Received: with ECARTIS (v1.0.0; list linux-mips); Fri, 10 Mar 2006 01:02:04 +0000 (GMT)
Received: from mxout.mainstreet.net ([199.245.73.25]:36849 "EHLO
	mxout.mainstreet.net") by ftp.linux-mips.org with ESMTP
	id S8133953AbWCJBBn (ORCPT <rfc822;linux-mips@linux-mips.org>);
	Fri, 10 Mar 2006 01:01:43 +0000
Received: from mail.idt.com (mail.idt.com [157.165.5.20])
	by mxout.mainstreet.net (8.13.4/8.13.4) with ESMTP id k2A19d1g027500;
	Thu, 9 Mar 2006 17:09:42 -0800 (PST)
Received: from corpml1.corp.idt.com (corpml1.corp.idt.com [157.165.140.20])
	by mail.idt.com (8.13.4/8.13.4) with ESMTP id k2A19CM2023759;
	Thu, 9 Mar 2006 17:09:12 -0800 (PST)
Received: from CORPBRIDGE.corp.idt.com (localhost [127.0.0.1])
	by corpml1.corp.idt.com (8.11.7p1+Sun/8.11.7) with ESMTP id k2A190l21351;
	Thu, 9 Mar 2006 17:09:00 -0800 (PST)
Received: by corpbridge.corp.idt.com with Internet Mail Service (5.5.2658.3)
	id <1X0B0LXS>; Thu, 9 Mar 2006 17:08:59 -0800
Message-ID: <73943A6B3BEAA1468EE1A4A090129F4316B15A73@corpbridge.corp.idt.com>
From:	"Tiwari, Rakesh" <Rakesh.Tiwari@idt.com>
To:	"'Ralf Baechle'" <ralf@linux-mips.org>
Cc:	linux-mips@linux-mips.org
Subject: [PATCH] IDT Interprise Processor Support for Linux  2.6.x
Date:	Thu, 9 Mar 2006 17:08:49 -0800 
MIME-Version: 1.0
X-Mailer: Internet Mail Service (5.5.2658.3)
Content-Type: multipart/mixed;
	boundary="----_=_NextPart_000_01C643DF.3058CF34"
X-Scanned-By: MIMEDefang 2.43
Return-Path: <Rakesh.Tiwari@idt.com>
X-Envelope-To: <"|/home/ecartis/ecartis -s linux-mips"> (uid 0)
X-Orcpt: rfc822;linux-mips@linux-mips.org
Original-Recipient: rfc822;linux-mips@linux-mips.org
X-archive-position: 10774
X-ecartis-version: Ecartis v1.0.0
Sender: linux-mips-bounce@linux-mips.org
Errors-to: linux-mips-bounce@linux-mips.org
X-original-sender: Rakesh.Tiwari@idt.com
Precedence: bulk
X-list: linux-mips

This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_000_01C643DF.3058CF34
Content-Type: multipart/alternative;
	boundary="----_=_NextPart_001_01C643DF.3058CF34"


------_=_NextPart_001_01C643DF.3058CF34
Content-Type: text/plain

Hi Ralf,

The attached patch adds support for the IDT Interprise series of processor 
based on the MIPS 4KC and Cronus (RC32300) core.

The patch is against the latest MIPS kernel linux-2.6.16-rc5. 

Look forward for your feedback/comments.

Regards
Rakesh

PS: Additional information regarding IDT's processor can be found at
http://www.idt.com/?catID=58532




------_=_NextPart_001_01C643DF.3058CF34
Content-Type: text/html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="Generator" CONTENT="MS Exchange Server version 5.5.2658.2">
<TITLE>[PATCH] IDT Interprise Processor Support for Linux  2.6.x</TITLE>
</HEAD>
<BODY>

<P><FONT SIZE=2>Hi Ralf,</FONT>
</P>

<P><FONT SIZE=2>The attached patch adds support for the IDT Interprise series of processor </FONT>
<BR><FONT SIZE=2>based on the MIPS 4KC and Cronus (RC32300) core.</FONT>
</P>

<P><FONT SIZE=2>The patch is against the latest MIPS kernel linux-2.6.16-rc5. </FONT>
</P>

<P><FONT SIZE=2>Look forward for your feedback/comments.</FONT>
</P>

<P><FONT SIZE=2>Regards</FONT>
<BR><FONT SIZE=2>Rakesh</FONT>
</P>

<P><FONT SIZE=2>PS: Additional information regarding IDT's processor can be found at</FONT>
<BR><FONT SIZE=2><A HREF="http://www.idt.com/?catID=58532" TARGET="_blank">http://www.idt.com/?catID=58532</A></FONT>
</P>
<BR>

<P><FONT FACE="Arial" SIZE=2 COLOR="#000000"></FONT>&nbsp;

</BODY>
</HTML>
------_=_NextPart_001_01C643DF.3058CF34--

------_=_NextPart_000_01C643DF.3058CF34
Content-Type: application/octet-stream;
	name="idt_processor.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="idt_processor.patch"

diff -uNr linux-2.6.16-rc5/arch/mips/configs/rc32334_defconfig =
idtlinux/arch/mips/configs/rc32334_defconfig=0A=
--- linux-2.6.16-rc5/arch/mips/configs/rc32334_defconfig	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/configs/rc32334_defconfig	2006-03-09 =
16:25:45.000000000 -0800=0A=
@@ -0,0 +1,969 @@=0A=
+#=0A=
+# Automatically generated make config: don't edit=0A=
+# Linux kernel version: 2.6.16-rc5=0A=
+# Thu Mar  9 15:47:19 2006=0A=
+#=0A=
+CONFIG_MIPS=3Dy=0A=
+=0A=
+#=0A=
+# Machine selection=0A=
+#=0A=
+# CONFIG_MIPS_MTX1 is not set=0A=
+# CONFIG_MIPS_BOSPORUS is not set=0A=
+# CONFIG_MIPS_PB1000 is not set=0A=
+# CONFIG_MIPS_PB1100 is not set=0A=
+# CONFIG_MIPS_PB1500 is not set=0A=
+# CONFIG_MIPS_PB1550 is not set=0A=
+# CONFIG_MIPS_PB1200 is not set=0A=
+# CONFIG_MIPS_DB1000 is not set=0A=
+# CONFIG_MIPS_DB1100 is not set=0A=
+# CONFIG_MIPS_DB1500 is not set=0A=
+# CONFIG_MIPS_DB1550 is not set=0A=
+# CONFIG_MIPS_DB1200 is not set=0A=
+# CONFIG_MIPS_MIRAGE is not set=0A=
+# CONFIG_MIPS_COBALT is not set=0A=
+# CONFIG_MACH_DECSTATION is not set=0A=
+# CONFIG_MIPS_EV64120 is not set=0A=
+# CONFIG_MIPS_EV96100 is not set=0A=
+# CONFIG_MIPS_IVR is not set=0A=
+CONFIG_IDT_BOARDS=3Dy=0A=
+# CONFIG_MIPS_ITE8172 is not set=0A=
+# CONFIG_MACH_JAZZ is not set=0A=
+# CONFIG_LASAT is not set=0A=
+# CONFIG_MIPS_ATLAS is not set=0A=
+# CONFIG_MIPS_MALTA is not set=0A=
+# CONFIG_MIPS_SEAD is not set=0A=
+# CONFIG_MIPS_SIM is not set=0A=
+# CONFIG_MOMENCO_JAGUAR_ATX is not set=0A=
+# CONFIG_MOMENCO_OCELOT is not set=0A=
+# CONFIG_MOMENCO_OCELOT_3 is not set=0A=
+# CONFIG_MOMENCO_OCELOT_C is not set=0A=
+# CONFIG_MOMENCO_OCELOT_G is not set=0A=
+# CONFIG_MIPS_XXS1500 is not set=0A=
+# CONFIG_PNX8550_V2PCI is not set=0A=
+# CONFIG_PNX8550_JBS is not set=0A=
+# CONFIG_DDB5074 is not set=0A=
+# CONFIG_DDB5476 is not set=0A=
+# CONFIG_DDB5477 is not set=0A=
+# CONFIG_MACH_VR41XX is not set=0A=
+# CONFIG_PMC_YOSEMITE is not set=0A=
+# CONFIG_QEMU is not set=0A=
+# CONFIG_SGI_IP22 is not set=0A=
+# CONFIG_SGI_IP27 is not set=0A=
+# CONFIG_SGI_IP32 is not set=0A=
+# CONFIG_SIBYTE_BIGSUR is not set=0A=
+# CONFIG_SIBYTE_SWARM is not set=0A=
+# CONFIG_SIBYTE_SENTOSA is not set=0A=
+# CONFIG_SIBYTE_RHONE is not set=0A=
+# CONFIG_SIBYTE_CARMEL is not set=0A=
+# CONFIG_SIBYTE_PTSWARM is not set=0A=
+# CONFIG_SIBYTE_LITTLESUR is not set=0A=
+# CONFIG_SIBYTE_CRHINE is not set=0A=
+# CONFIG_SIBYTE_CRHONE is not set=0A=
+# CONFIG_SNI_RM200_PCI is not set=0A=
+# CONFIG_TOSHIBA_JMR3927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4938 is not set=0A=
+# CONFIG_IDT_EB438 is not set=0A=
+# CONFIG_IDT_EB434 is not set=0A=
+# CONFIG_IDT_EB365 is not set=0A=
+# CONFIG_IDT_EB355 is not set=0A=
+CONFIG_IDT_S334=3Dy=0A=
+CONFIG_IDT_BOARD_FREQ=3D75000000=0A=
+CONFIG_IDT_ZIMAGE_ADDR=3D0x80800000=0A=
+CONFIG_IDT_BOOT_NVRAM=3Dy=0A=
+CONFIG_RWSEM_GENERIC_SPINLOCK=3Dy=0A=
+CONFIG_GENERIC_CALIBRATE_DELAY=3Dy=0A=
+CONFIG_DMA_NONCOHERENT=3Dy=0A=
+CONFIG_DMA_NEED_PCI_MAP_STATE=3Dy=0A=
+# CONFIG_CPU_BIG_ENDIAN is not set=0A=
+CONFIG_CPU_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_IRQ_CPU=3Dy=0A=
+CONFIG_SWAP_IO_SPACE=3Dy=0A=
+CONFIG_BOOT_ELF32=3Dy=0A=
+CONFIG_MIPS_L1_CACHE_SHIFT=3D5=0A=
+=0A=
+#=0A=
+# CPU selection=0A=
+#=0A=
+# CONFIG_CPU_MIPS32_R1 is not set=0A=
+# CONFIG_CPU_MIPS32_R2 is not set=0A=
+# CONFIG_CPU_MIPS64_R1 is not set=0A=
+# CONFIG_CPU_MIPS64_R2 is not set=0A=
+# CONFIG_CPU_R3000 is not set=0A=
+CONFIG_CPU_RC32300=3Dy=0A=
+# CONFIG_CPU_TX39XX is not set=0A=
+# CONFIG_CPU_VR41XX is not set=0A=
+# CONFIG_CPU_R4300 is not set=0A=
+# CONFIG_CPU_R4X00 is not set=0A=
+# CONFIG_CPU_TX49XX is not set=0A=
+# CONFIG_CPU_R5000 is not set=0A=
+# CONFIG_CPU_R5432 is not set=0A=
+# CONFIG_CPU_R6000 is not set=0A=
+# CONFIG_CPU_NEVADA is not set=0A=
+# CONFIG_CPU_R8000 is not set=0A=
+# CONFIG_CPU_R10000 is not set=0A=
+# CONFIG_CPU_RM7000 is not set=0A=
+# CONFIG_CPU_RM9000 is not set=0A=
+# CONFIG_CPU_SB1 is not set=0A=
+CONFIG_SYS_HAS_CPU_MIPS32_R1=3Dy=0A=
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+=0A=
+#=0A=
+# Kernel type=0A=
+#=0A=
+CONFIG_32BIT=3Dy=0A=
+# CONFIG_64BIT is not set=0A=
+CONFIG_PAGE_SIZE_4KB=3Dy=0A=
+# CONFIG_PAGE_SIZE_8KB is not set=0A=
+# CONFIG_PAGE_SIZE_16KB is not set=0A=
+# CONFIG_PAGE_SIZE_64KB is not set=0A=
+CONFIG_CPU_HAS_PREFETCH=3Dy=0A=
+# CONFIG_MIPS_MT is not set=0A=
+CONFIG_CPU_ADVANCED=3Dy=0A=
+CONFIG_CPU_HAS_LLSC=3Dy=0A=
+# CONFIG_CPU_HAS_WB is not set=0A=
+CONFIG_CPU_HAS_SYNC=3Dy=0A=
+CONFIG_GENERIC_HARDIRQS=3Dy=0A=
+CONFIG_GENERIC_IRQ_PROBE=3Dy=0A=
+CONFIG_ARCH_FLATMEM_ENABLE=3Dy=0A=
+CONFIG_SELECT_MEMORY_MODEL=3Dy=0A=
+CONFIG_FLATMEM_MANUAL=3Dy=0A=
+# CONFIG_DISCONTIGMEM_MANUAL is not set=0A=
+# CONFIG_SPARSEMEM_MANUAL is not set=0A=
+CONFIG_FLATMEM=3Dy=0A=
+CONFIG_FLAT_NODE_MEM_MAP=3Dy=0A=
+# CONFIG_SPARSEMEM_STATIC is not set=0A=
+CONFIG_SPLIT_PTLOCK_CPUS=3D4=0A=
+CONFIG_PREEMPT_NONE=3Dy=0A=
+# CONFIG_PREEMPT_VOLUNTARY is not set=0A=
+# CONFIG_PREEMPT is not set=0A=
+=0A=
+#=0A=
+# Code maturity level options=0A=
+#=0A=
+CONFIG_EXPERIMENTAL=3Dy=0A=
+CONFIG_BROKEN_ON_SMP=3Dy=0A=
+CONFIG_INIT_ENV_ARG_LIMIT=3D32=0A=
+=0A=
+#=0A=
+# General setup=0A=
+#=0A=
+CONFIG_LOCALVERSION=3D""=0A=
+CONFIG_LOCALVERSION_AUTO=3Dy=0A=
+# CONFIG_SWAP is not set=0A=
+CONFIG_SYSVIPC=3Dy=0A=
+# CONFIG_POSIX_MQUEUE is not set=0A=
+# CONFIG_BSD_PROCESS_ACCT is not set=0A=
+CONFIG_SYSCTL=3Dy=0A=
+# CONFIG_AUDIT is not set=0A=
+CONFIG_IKCONFIG=3Dy=0A=
+# CONFIG_IKCONFIG_PROC is not set=0A=
+CONFIG_INITRAMFS_SOURCE=3D""=0A=
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set=0A=
+CONFIG_EMBEDDED=3Dy=0A=
+# CONFIG_KALLSYMS is not set=0A=
+# CONFIG_HOTPLUG is not set=0A=
+CONFIG_PRINTK=3Dy=0A=
+CONFIG_BUG=3Dy=0A=
+CONFIG_ELF_CORE=3Dy=0A=
+# CONFIG_BASE_FULL is not set=0A=
+# CONFIG_FUTEX is not set=0A=
+# CONFIG_EPOLL is not set=0A=
+CONFIG_SHMEM=3Dy=0A=
+CONFIG_CC_ALIGN_FUNCTIONS=3D0=0A=
+CONFIG_CC_ALIGN_LABELS=3D0=0A=
+CONFIG_CC_ALIGN_LOOPS=3D0=0A=
+CONFIG_CC_ALIGN_JUMPS=3D0=0A=
+# CONFIG_SLAB is not set=0A=
+# CONFIG_TINY_SHMEM is not set=0A=
+CONFIG_BASE_SMALL=3D1=0A=
+CONFIG_SLOB=3Dy=0A=
+=0A=
+#=0A=
+# Loadable module support=0A=
+#=0A=
+CONFIG_MODULES=3Dy=0A=
+CONFIG_MODULE_UNLOAD=3Dy=0A=
+# CONFIG_MODULE_FORCE_UNLOAD is not set=0A=
+CONFIG_OBSOLETE_MODPARM=3Dy=0A=
+# CONFIG_MODVERSIONS is not set=0A=
+# CONFIG_MODULE_SRCVERSION_ALL is not set=0A=
+# CONFIG_KMOD is not set=0A=
+=0A=
+#=0A=
+# Block layer=0A=
+#=0A=
+# CONFIG_LBD is not set=0A=
+=0A=
+#=0A=
+# IO Schedulers=0A=
+#=0A=
+CONFIG_IOSCHED_NOOP=3Dy=0A=
+CONFIG_IOSCHED_AS=3Dy=0A=
+CONFIG_IOSCHED_DEADLINE=3Dy=0A=
+CONFIG_IOSCHED_CFQ=3Dy=0A=
+CONFIG_DEFAULT_AS=3Dy=0A=
+# CONFIG_DEFAULT_DEADLINE is not set=0A=
+# CONFIG_DEFAULT_CFQ is not set=0A=
+# CONFIG_DEFAULT_NOOP is not set=0A=
+CONFIG_DEFAULT_IOSCHED=3D"anticipatory"=0A=
+=0A=
+#=0A=
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)=0A=
+#=0A=
+CONFIG_HW_HAS_PCI=3Dy=0A=
+CONFIG_PCI=3Dy=0A=
+CONFIG_PCI_LEGACY_PROC=3Dy=0A=
+CONFIG_MMU=3Dy=0A=
+=0A=
+#=0A=
+# PCCARD (PCMCIA/CardBus) support=0A=
+#=0A=
+# CONFIG_PCCARD is not set=0A=
+=0A=
+#=0A=
+# PCI Hotplug Support=0A=
+#=0A=
+# CONFIG_HOTPLUG_PCI is not set=0A=
+=0A=
+#=0A=
+# Executable file formats=0A=
+#=0A=
+CONFIG_BINFMT_ELF=3Dy=0A=
+# CONFIG_BINFMT_MISC is not set=0A=
+CONFIG_TRAD_SIGNALS=3Dy=0A=
+=0A=
+#=0A=
+# Networking=0A=
+#=0A=
+CONFIG_NET=3Dy=0A=
+=0A=
+#=0A=
+# Networking options=0A=
+#=0A=
+# CONFIG_NETDEBUG is not set=0A=
+CONFIG_PACKET=3Dy=0A=
+CONFIG_PACKET_MMAP=3Dy=0A=
+CONFIG_UNIX=3Dy=0A=
+CONFIG_XFRM=3Dy=0A=
+# CONFIG_XFRM_USER is not set=0A=
+CONFIG_NET_KEY=3Dy=0A=
+CONFIG_INET=3Dy=0A=
+CONFIG_IP_MULTICAST=3Dy=0A=
+# CONFIG_IP_ADVANCED_ROUTER is not set=0A=
+CONFIG_IP_FIB_HASH=3Dy=0A=
+CONFIG_IP_PNP=3Dy=0A=
+# CONFIG_IP_PNP_DHCP is not set=0A=
+# CONFIG_IP_PNP_BOOTP is not set=0A=
+# CONFIG_IP_PNP_RARP is not set=0A=
+# CONFIG_NET_IPIP is not set=0A=
+# CONFIG_NET_IPGRE is not set=0A=
+# CONFIG_IP_MROUTE is not set=0A=
+# CONFIG_ARPD is not set=0A=
+# CONFIG_SYN_COOKIES is not set=0A=
+# CONFIG_INET_AH is not set=0A=
+# CONFIG_INET_ESP is not set=0A=
+# CONFIG_INET_IPCOMP is not set=0A=
+# CONFIG_INET_TUNNEL is not set=0A=
+# CONFIG_INET_DIAG is not set=0A=
+# CONFIG_TCP_CONG_ADVANCED is not set=0A=
+CONFIG_TCP_CONG_BIC=3Dy=0A=
+=0A=
+#=0A=
+# IP: Virtual Server Configuration=0A=
+#=0A=
+CONFIG_IP_VS=3Dm=0A=
+# CONFIG_IP_VS_DEBUG is not set=0A=
+CONFIG_IP_VS_TAB_BITS=3D12=0A=
+=0A=
+#=0A=
+# IPVS transport protocol load balancing support=0A=
+#=0A=
+CONFIG_IP_VS_PROTO_TCP=3Dy=0A=
+CONFIG_IP_VS_PROTO_UDP=3Dy=0A=
+CONFIG_IP_VS_PROTO_ESP=3Dy=0A=
+CONFIG_IP_VS_PROTO_AH=3Dy=0A=
+=0A=
+#=0A=
+# IPVS scheduler=0A=
+#=0A=
+CONFIG_IP_VS_RR=3Dm=0A=
+CONFIG_IP_VS_WRR=3Dm=0A=
+CONFIG_IP_VS_LC=3Dm=0A=
+CONFIG_IP_VS_WLC=3Dm=0A=
+CONFIG_IP_VS_LBLC=3Dm=0A=
+CONFIG_IP_VS_LBLCR=3Dm=0A=
+CONFIG_IP_VS_DH=3Dm=0A=
+CONFIG_IP_VS_SH=3Dm=0A=
+CONFIG_IP_VS_SED=3Dm=0A=
+CONFIG_IP_VS_NQ=3Dm=0A=
+=0A=
+#=0A=
+# IPVS application helper=0A=
+#=0A=
+CONFIG_IP_VS_FTP=3Dm=0A=
+# CONFIG_IPV6 is not set=0A=
+CONFIG_NETFILTER=3Dy=0A=
+# CONFIG_NETFILTER_DEBUG is not set=0A=
+=0A=
+#=0A=
+# Core Netfilter Configuration=0A=
+#=0A=
+CONFIG_NETFILTER_NETLINK=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_QUEUE=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_LOG=3Dm=0A=
+CONFIG_NETFILTER_XTABLES=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_COMMENT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_DCCP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_HELPER=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LENGTH=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LIMIT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MAC=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_REALM=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_SCTP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STATE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STRING=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=3Dm=0A=
+=0A=
+#=0A=
+# IP: Netfilter Configuration=0A=
+#=0A=
+CONFIG_IP_NF_CONNTRACK=3Dm=0A=
+CONFIG_IP_NF_CT_ACCT=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_MARK=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_EVENTS=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_NETLINK=3Dm=0A=
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set=0A=
+CONFIG_IP_NF_FTP=3Dm=0A=
+CONFIG_IP_NF_IRC=3Dm=0A=
+# CONFIG_IP_NF_NETBIOS_NS is not set=0A=
+CONFIG_IP_NF_TFTP=3Dm=0A=
+CONFIG_IP_NF_AMANDA=3Dm=0A=
+CONFIG_IP_NF_PPTP=3Dm=0A=
+CONFIG_IP_NF_QUEUE=3Dm=0A=
+CONFIG_IP_NF_IPTABLES=3Dm=0A=
+CONFIG_IP_NF_MATCH_IPRANGE=3Dm=0A=
+CONFIG_IP_NF_MATCH_MULTIPORT=3Dm=0A=
+CONFIG_IP_NF_MATCH_TOS=3Dm=0A=
+CONFIG_IP_NF_MATCH_RECENT=3Dm=0A=
+CONFIG_IP_NF_MATCH_ECN=3Dm=0A=
+CONFIG_IP_NF_MATCH_DSCP=3Dm=0A=
+CONFIG_IP_NF_MATCH_AH_ESP=3Dm=0A=
+CONFIG_IP_NF_MATCH_TTL=3Dm=0A=
+CONFIG_IP_NF_MATCH_OWNER=3Dm=0A=
+CONFIG_IP_NF_MATCH_ADDRTYPE=3Dm=0A=
+CONFIG_IP_NF_MATCH_HASHLIMIT=3Dm=0A=
+CONFIG_IP_NF_MATCH_POLICY=3Dm=0A=
+CONFIG_IP_NF_FILTER=3Dm=0A=
+CONFIG_IP_NF_TARGET_REJECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_LOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_ULOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_TCPMSS=3Dm=0A=
+CONFIG_IP_NF_NAT=3Dm=0A=
+CONFIG_IP_NF_NAT_NEEDED=3Dy=0A=
+CONFIG_IP_NF_TARGET_MASQUERADE=3Dm=0A=
+CONFIG_IP_NF_TARGET_REDIRECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_NETMAP=3Dm=0A=
+CONFIG_IP_NF_TARGET_SAME=3Dm=0A=
+CONFIG_IP_NF_NAT_SNMP_BASIC=3Dm=0A=
+CONFIG_IP_NF_NAT_IRC=3Dm=0A=
+CONFIG_IP_NF_NAT_FTP=3Dm=0A=
+CONFIG_IP_NF_NAT_TFTP=3Dm=0A=
+CONFIG_IP_NF_NAT_AMANDA=3Dm=0A=
+CONFIG_IP_NF_NAT_PPTP=3Dm=0A=
+CONFIG_IP_NF_MANGLE=3Dm=0A=
+CONFIG_IP_NF_TARGET_TOS=3Dm=0A=
+CONFIG_IP_NF_TARGET_ECN=3Dm=0A=
+CONFIG_IP_NF_TARGET_DSCP=3Dm=0A=
+CONFIG_IP_NF_TARGET_TTL=3Dm=0A=
+CONFIG_IP_NF_TARGET_CLUSTERIP=3Dm=0A=
+CONFIG_IP_NF_RAW=3Dm=0A=
+CONFIG_IP_NF_ARPTABLES=3Dm=0A=
+CONFIG_IP_NF_ARPFILTER=3Dm=0A=
+CONFIG_IP_NF_ARP_MANGLE=3Dm=0A=
+=0A=
+#=0A=
+# DCCP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_DCCP is not set=0A=
+=0A=
+#=0A=
+# SCTP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_SCTP is not set=0A=
+=0A=
+#=0A=
+# TIPC Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_TIPC is not set=0A=
+# CONFIG_ATM is not set=0A=
+# CONFIG_BRIDGE is not set=0A=
+# CONFIG_VLAN_8021Q is not set=0A=
+# CONFIG_DECNET is not set=0A=
+# CONFIG_LLC2 is not set=0A=
+# CONFIG_IPX is not set=0A=
+# CONFIG_ATALK is not set=0A=
+# CONFIG_X25 is not set=0A=
+# CONFIG_LAPB is not set=0A=
+# CONFIG_NET_DIVERT is not set=0A=
+# CONFIG_ECONET is not set=0A=
+# CONFIG_WAN_ROUTER is not set=0A=
+=0A=
+#=0A=
+# QoS and/or fair queueing=0A=
+#=0A=
+CONFIG_NET_SCHED=3Dy=0A=
+# CONFIG_NET_SCH_CLK_JIFFIES is not set=0A=
+CONFIG_NET_SCH_CLK_GETTIMEOFDAY=3Dy=0A=
+# CONFIG_NET_SCH_CLK_CPU is not set=0A=
+=0A=
+#=0A=
+# Queueing/Scheduling=0A=
+#=0A=
+CONFIG_NET_SCH_CBQ=3Dm=0A=
+CONFIG_NET_SCH_HTB=3Dm=0A=
+CONFIG_NET_SCH_HFSC=3Dm=0A=
+CONFIG_NET_SCH_PRIO=3Dm=0A=
+CONFIG_NET_SCH_RED=3Dm=0A=
+CONFIG_NET_SCH_SFQ=3Dm=0A=
+CONFIG_NET_SCH_TEQL=3Dm=0A=
+CONFIG_NET_SCH_TBF=3Dm=0A=
+CONFIG_NET_SCH_GRED=3Dm=0A=
+CONFIG_NET_SCH_DSMARK=3Dm=0A=
+CONFIG_NET_SCH_NETEM=3Dm=0A=
+CONFIG_NET_SCH_INGRESS=3Dm=0A=
+=0A=
+#=0A=
+# Classification=0A=
+#=0A=
+CONFIG_NET_CLS=3Dy=0A=
+CONFIG_NET_CLS_BASIC=3Dm=0A=
+CONFIG_NET_CLS_TCINDEX=3Dm=0A=
+CONFIG_NET_CLS_ROUTE4=3Dm=0A=
+CONFIG_NET_CLS_ROUTE=3Dy=0A=
+CONFIG_NET_CLS_FW=3Dm=0A=
+CONFIG_NET_CLS_U32=3Dm=0A=
+# CONFIG_CLS_U32_PERF is not set=0A=
+# CONFIG_CLS_U32_MARK is not set=0A=
+CONFIG_NET_CLS_RSVP=3Dm=0A=
+CONFIG_NET_CLS_RSVP6=3Dm=0A=
+# CONFIG_NET_EMATCH is not set=0A=
+# CONFIG_NET_CLS_ACT is not set=0A=
+CONFIG_NET_CLS_POLICE=3Dy=0A=
+# CONFIG_NET_CLS_IND is not set=0A=
+CONFIG_NET_ESTIMATOR=3Dy=0A=
+=0A=
+#=0A=
+# Network testing=0A=
+#=0A=
+# CONFIG_NET_PKTGEN is not set=0A=
+# CONFIG_HAMRADIO is not set=0A=
+# CONFIG_IRDA is not set=0A=
+# CONFIG_BT is not set=0A=
+# CONFIG_IEEE80211 is not set=0A=
+=0A=
+#=0A=
+# Device Drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Generic Driver Options=0A=
+#=0A=
+CONFIG_STANDALONE=3Dy=0A=
+CONFIG_PREVENT_FIRMWARE_BUILD=3Dy=0A=
+# CONFIG_FW_LOADER is not set=0A=
+=0A=
+#=0A=
+# Connector - unified userspace <-> kernelspace linker=0A=
+#=0A=
+# CONFIG_CONNECTOR is not set=0A=
+=0A=
+#=0A=
+# Memory Technology Devices (MTD)=0A=
+#=0A=
+# CONFIG_MTD is not set=0A=
+=0A=
+#=0A=
+# Parallel port support=0A=
+#=0A=
+# CONFIG_PARPORT is not set=0A=
+=0A=
+#=0A=
+# Plug and Play support=0A=
+#=0A=
+=0A=
+#=0A=
+# Block devices=0A=
+#=0A=
+# CONFIG_BLK_CPQ_DA is not set=0A=
+# CONFIG_BLK_CPQ_CISS_DA is not set=0A=
+# CONFIG_BLK_DEV_DAC960 is not set=0A=
+# CONFIG_BLK_DEV_UMEM is not set=0A=
+# CONFIG_BLK_DEV_COW_COMMON is not set=0A=
+# CONFIG_BLK_DEV_LOOP is not set=0A=
+# CONFIG_BLK_DEV_NBD is not set=0A=
+# CONFIG_BLK_DEV_SX8 is not set=0A=
+# CONFIG_BLK_DEV_RAM is not set=0A=
+CONFIG_BLK_DEV_RAM_COUNT=3D16=0A=
+# CONFIG_CDROM_PKTCDVD is not set=0A=
+# CONFIG_ATA_OVER_ETH is not set=0A=
+=0A=
+#=0A=
+# ATA/ATAPI/MFM/RLL support=0A=
+#=0A=
+# CONFIG_IDE is not set=0A=
+=0A=
+#=0A=
+# SCSI device support=0A=
+#=0A=
+# CONFIG_RAID_ATTRS is not set=0A=
+# CONFIG_SCSI is not set=0A=
+=0A=
+#=0A=
+# Multi-device support (RAID and LVM)=0A=
+#=0A=
+# CONFIG_MD is not set=0A=
+=0A=
+#=0A=
+# Fusion MPT device support=0A=
+#=0A=
+# CONFIG_FUSION is not set=0A=
+=0A=
+#=0A=
+# IEEE 1394 (FireWire) support=0A=
+#=0A=
+# CONFIG_IEEE1394 is not set=0A=
+=0A=
+#=0A=
+# I2O device support=0A=
+#=0A=
+# CONFIG_I2O is not set=0A=
+=0A=
+#=0A=
+# Network device support=0A=
+#=0A=
+CONFIG_NETDEVICES=3Dy=0A=
+# CONFIG_DUMMY is not set=0A=
+# CONFIG_BONDING is not set=0A=
+# CONFIG_EQUALIZER is not set=0A=
+# CONFIG_TUN is not set=0A=
+=0A=
+#=0A=
+# ARCnet devices=0A=
+#=0A=
+# CONFIG_ARCNET is not set=0A=
+=0A=
+#=0A=
+# PHY device support=0A=
+#=0A=
+# CONFIG_PHYLIB is not set=0A=
+=0A=
+#=0A=
+# Ethernet (10 or 100Mbit)=0A=
+#=0A=
+CONFIG_NET_ETHERNET=3Dy=0A=
+CONFIG_MII=3Dy=0A=
+# CONFIG_HAPPYMEAL is not set=0A=
+# CONFIG_SUNGEM is not set=0A=
+# CONFIG_CASSINI is not set=0A=
+# CONFIG_NET_VENDOR_3COM is not set=0A=
+# CONFIG_DM9000 is not set=0A=
+=0A=
+#=0A=
+# Tulip family network device support=0A=
+#=0A=
+# CONFIG_NET_TULIP is not set=0A=
+# CONFIG_HP100 is not set=0A=
+CONFIG_NET_PCI=3Dy=0A=
+# CONFIG_PCNET32 is not set=0A=
+# CONFIG_AMD8111_ETH is not set=0A=
+# CONFIG_ADAPTEC_STARFIRE is not set=0A=
+# CONFIG_B44 is not set=0A=
+# CONFIG_FORCEDETH is not set=0A=
+# CONFIG_DGRS is not set=0A=
+# CONFIG_EEPRO100 is not set=0A=
+CONFIG_E100=3Dy=0A=
+# CONFIG_FEALNX is not set=0A=
+# CONFIG_NATSEMI is not set=0A=
+# CONFIG_NE2K_PCI is not set=0A=
+# CONFIG_8139CP is not set=0A=
+# CONFIG_8139TOO is not set=0A=
+# CONFIG_SIS900 is not set=0A=
+# CONFIG_EPIC100 is not set=0A=
+# CONFIG_SUNDANCE is not set=0A=
+# CONFIG_TLAN is not set=0A=
+# CONFIG_VIA_RHINE is not set=0A=
+# CONFIG_LAN_SAA9730 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (1000 Mbit)=0A=
+#=0A=
+# CONFIG_ACENIC is not set=0A=
+# CONFIG_DL2K is not set=0A=
+# CONFIG_E1000 is not set=0A=
+# CONFIG_NS83820 is not set=0A=
+# CONFIG_HAMACHI is not set=0A=
+# CONFIG_YELLOWFIN is not set=0A=
+# CONFIG_R8169 is not set=0A=
+# CONFIG_SIS190 is not set=0A=
+# CONFIG_SKGE is not set=0A=
+# CONFIG_SKY2 is not set=0A=
+# CONFIG_SK98LIN is not set=0A=
+# CONFIG_VIA_VELOCITY is not set=0A=
+# CONFIG_TIGON3 is not set=0A=
+# CONFIG_BNX2 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (10000 Mbit)=0A=
+#=0A=
+# CONFIG_CHELSIO_T1 is not set=0A=
+# CONFIG_IXGB is not set=0A=
+# CONFIG_S2IO is not set=0A=
+=0A=
+#=0A=
+# Token Ring devices=0A=
+#=0A=
+# CONFIG_TR is not set=0A=
+=0A=
+#=0A=
+# Wireless LAN (non-hamradio)=0A=
+#=0A=
+# CONFIG_NET_RADIO is not set=0A=
+=0A=
+#=0A=
+# Wan interfaces=0A=
+#=0A=
+# CONFIG_WAN is not set=0A=
+# CONFIG_FDDI is not set=0A=
+# CONFIG_HIPPI is not set=0A=
+# CONFIG_PPP is not set=0A=
+# CONFIG_SLIP is not set=0A=
+# CONFIG_SHAPER is not set=0A=
+# CONFIG_NETCONSOLE is not set=0A=
+# CONFIG_NETPOLL is not set=0A=
+# CONFIG_NET_POLL_CONTROLLER is not set=0A=
+=0A=
+#=0A=
+# ISDN subsystem=0A=
+#=0A=
+# CONFIG_ISDN is not set=0A=
+=0A=
+#=0A=
+# Telephony Support=0A=
+#=0A=
+# CONFIG_PHONE is not set=0A=
+=0A=
+#=0A=
+# Input device support=0A=
+#=0A=
+CONFIG_INPUT=3Dy=0A=
+=0A=
+#=0A=
+# Userland interfaces=0A=
+#=0A=
+# CONFIG_INPUT_MOUSEDEV is not set=0A=
+# CONFIG_INPUT_JOYDEV is not set=0A=
+# CONFIG_INPUT_TSDEV is not set=0A=
+# CONFIG_INPUT_EVDEV is not set=0A=
+# CONFIG_INPUT_EVBUG is not set=0A=
+=0A=
+#=0A=
+# Input Device Drivers=0A=
+#=0A=
+# CONFIG_INPUT_KEYBOARD is not set=0A=
+# CONFIG_INPUT_MOUSE is not set=0A=
+# CONFIG_INPUT_JOYSTICK is not set=0A=
+# CONFIG_INPUT_TOUCHSCREEN is not set=0A=
+# CONFIG_INPUT_MISC is not set=0A=
+=0A=
+#=0A=
+# Hardware I/O ports=0A=
+#=0A=
+# CONFIG_SERIO is not set=0A=
+# CONFIG_GAMEPORT is not set=0A=
+=0A=
+#=0A=
+# Character devices=0A=
+#=0A=
+CONFIG_VT=3Dy=0A=
+CONFIG_VT_CONSOLE=3Dy=0A=
+CONFIG_HW_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_NONSTANDARD is not set=0A=
+=0A=
+#=0A=
+# Serial drivers=0A=
+#=0A=
+CONFIG_SERIAL_8250=3Dy=0A=
+CONFIG_SERIAL_8250_CONSOLE=3Dy=0A=
+CONFIG_SERIAL_8250_NR_UARTS=3D4=0A=
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3D4=0A=
+# CONFIG_SERIAL_8250_EXTENDED is not set=0A=
+=0A=
+#=0A=
+# Non-8250 serial port support=0A=
+#=0A=
+CONFIG_SERIAL_CORE=3Dy=0A=
+CONFIG_SERIAL_CORE_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_JSM is not set=0A=
+CONFIG_UNIX98_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTY_COUNT=3D256=0A=
+=0A=
+#=0A=
+# IPMI=0A=
+#=0A=
+# CONFIG_IPMI_HANDLER is not set=0A=
+=0A=
+#=0A=
+# Watchdog Cards=0A=
+#=0A=
+# CONFIG_WATCHDOG is not set=0A=
+# CONFIG_RTC is not set=0A=
+# CONFIG_GEN_RTC is not set=0A=
+# CONFIG_DTLK is not set=0A=
+# CONFIG_R3964 is not set=0A=
+# CONFIG_APPLICOM is not set=0A=
+=0A=
+#=0A=
+# Ftape, the floppy tape device driver=0A=
+#=0A=
+# CONFIG_DRM is not set=0A=
+# CONFIG_RAW_DRIVER is not set=0A=
+=0A=
+#=0A=
+# TPM devices=0A=
+#=0A=
+# CONFIG_TCG_TPM is not set=0A=
+# CONFIG_TELCLOCK is not set=0A=
+=0A=
+#=0A=
+# I2C support=0A=
+#=0A=
+# CONFIG_I2C is not set=0A=
+=0A=
+#=0A=
+# SPI support=0A=
+#=0A=
+# CONFIG_SPI is not set=0A=
+# CONFIG_SPI_MASTER is not set=0A=
+=0A=
+#=0A=
+# Dallas's 1-wire bus=0A=
+#=0A=
+# CONFIG_W1 is not set=0A=
+=0A=
+#=0A=
+# Hardware Monitoring support=0A=
+#=0A=
+# CONFIG_HWMON is not set=0A=
+# CONFIG_HWMON_VID is not set=0A=
+=0A=
+#=0A=
+# Misc devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia Capabilities Port drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia devices=0A=
+#=0A=
+# CONFIG_VIDEO_DEV is not set=0A=
+=0A=
+#=0A=
+# Digital Video Broadcasting Devices=0A=
+#=0A=
+# CONFIG_DVB is not set=0A=
+=0A=
+#=0A=
+# Graphics support=0A=
+#=0A=
+# CONFIG_FB is not set=0A=
+=0A=
+#=0A=
+# Console display driver support=0A=
+#=0A=
+# CONFIG_VGA_CONSOLE is not set=0A=
+CONFIG_DUMMY_CONSOLE=3Dy=0A=
+=0A=
+#=0A=
+# Sound=0A=
+#=0A=
+# CONFIG_SOUND is not set=0A=
+=0A=
+#=0A=
+# USB support=0A=
+#=0A=
+CONFIG_USB_ARCH_HAS_HCD=3Dy=0A=
+CONFIG_USB_ARCH_HAS_OHCI=3Dy=0A=
+# CONFIG_USB is not set=0A=
+=0A=
+#=0A=
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'=0A=
+#=0A=
+=0A=
+#=0A=
+# USB Gadget Support=0A=
+#=0A=
+# CONFIG_USB_GADGET is not set=0A=
+=0A=
+#=0A=
+# MMC/SD Card support=0A=
+#=0A=
+# CONFIG_MMC is not set=0A=
+=0A=
+#=0A=
+# InfiniBand support=0A=
+#=0A=
+# CONFIG_INFINIBAND is not set=0A=
+=0A=
+#=0A=
+# SN Devices=0A=
+#=0A=
+=0A=
+#=0A=
+# EDAC - error detection and reporting (RAS)=0A=
+#=0A=
+=0A=
+#=0A=
+# File systems=0A=
+#=0A=
+CONFIG_EXT2_FS=3Dy=0A=
+# CONFIG_EXT2_FS_XATTR is not set=0A=
+# CONFIG_EXT2_FS_XIP is not set=0A=
+# CONFIG_EXT3_FS is not set=0A=
+# CONFIG_REISERFS_FS is not set=0A=
+# CONFIG_JFS_FS is not set=0A=
+# CONFIG_FS_POSIX_ACL is not set=0A=
+# CONFIG_XFS_FS is not set=0A=
+# CONFIG_OCFS2_FS is not set=0A=
+# CONFIG_MINIX_FS is not set=0A=
+# CONFIG_ROMFS_FS is not set=0A=
+# CONFIG_INOTIFY is not set=0A=
+# CONFIG_QUOTA is not set=0A=
+# CONFIG_DNOTIFY is not set=0A=
+# CONFIG_AUTOFS_FS is not set=0A=
+# CONFIG_AUTOFS4_FS is not set=0A=
+# CONFIG_FUSE_FS is not set=0A=
+=0A=
+#=0A=
+# CD-ROM/DVD Filesystems=0A=
+#=0A=
+# CONFIG_ISO9660_FS is not set=0A=
+# CONFIG_UDF_FS is not set=0A=
+=0A=
+#=0A=
+# DOS/FAT/NT Filesystems=0A=
+#=0A=
+# CONFIG_MSDOS_FS is not set=0A=
+# CONFIG_VFAT_FS is not set=0A=
+# CONFIG_NTFS_FS is not set=0A=
+=0A=
+#=0A=
+# Pseudo filesystems=0A=
+#=0A=
+CONFIG_PROC_FS=3Dy=0A=
+CONFIG_PROC_KCORE=3Dy=0A=
+CONFIG_SYSFS=3Dy=0A=
+# CONFIG_TMPFS is not set=0A=
+# CONFIG_HUGETLB_PAGE is not set=0A=
+CONFIG_RAMFS=3Dy=0A=
+# CONFIG_RELAYFS_FS is not set=0A=
+# CONFIG_CONFIGFS_FS is not set=0A=
+=0A=
+#=0A=
+# Miscellaneous filesystems=0A=
+#=0A=
+# CONFIG_ADFS_FS is not set=0A=
+# CONFIG_AFFS_FS is not set=0A=
+# CONFIG_HFS_FS is not set=0A=
+# CONFIG_HFSPLUS_FS is not set=0A=
+# CONFIG_BEFS_FS is not set=0A=
+# CONFIG_BFS_FS is not set=0A=
+# CONFIG_EFS_FS is not set=0A=
+# CONFIG_CRAMFS is not set=0A=
+# CONFIG_VXFS_FS is not set=0A=
+# CONFIG_HPFS_FS is not set=0A=
+# CONFIG_QNX4FS_FS is not set=0A=
+# CONFIG_SYSV_FS is not set=0A=
+# CONFIG_UFS_FS is not set=0A=
+=0A=
+#=0A=
+# Network File Systems=0A=
+#=0A=
+# CONFIG_NFS_FS is not set=0A=
+# CONFIG_NFSD is not set=0A=
+# CONFIG_SMB_FS is not set=0A=
+# CONFIG_CIFS is not set=0A=
+# CONFIG_NCP_FS is not set=0A=
+# CONFIG_CODA_FS is not set=0A=
+# CONFIG_AFS_FS is not set=0A=
+# CONFIG_9P_FS is not set=0A=
+=0A=
+#=0A=
+# Partition Types=0A=
+#=0A=
+# CONFIG_PARTITION_ADVANCED is not set=0A=
+CONFIG_MSDOS_PARTITION=3Dy=0A=
+=0A=
+#=0A=
+# Native Language Support=0A=
+#=0A=
+# CONFIG_NLS is not set=0A=
+=0A=
+#=0A=
+# Profiling support=0A=
+#=0A=
+# CONFIG_PROFILING is not set=0A=
+=0A=
+#=0A=
+# Kernel hacking=0A=
+#=0A=
+# CONFIG_PRINTK_TIME is not set=0A=
+# CONFIG_MAGIC_SYSRQ is not set=0A=
+# CONFIG_DEBUG_KERNEL is not set=0A=
+CONFIG_LOG_BUF_SHIFT=3D14=0A=
+CONFIG_CROSSCOMPILE=3Dy=0A=
+CONFIG_CMDLINE=3D""=0A=
+=0A=
+#=0A=
+# Security options=0A=
+#=0A=
+# CONFIG_KEYS is not set=0A=
+# CONFIG_SECURITY is not set=0A=
+=0A=
+#=0A=
+# Cryptographic options=0A=
+#=0A=
+# CONFIG_CRYPTO is not set=0A=
+=0A=
+#=0A=
+# Hardware crypto devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Library routines=0A=
+#=0A=
+# CONFIG_CRC_CCITT is not set=0A=
+CONFIG_CRC16=3Dy=0A=
+CONFIG_CRC32=3Dy=0A=
+CONFIG_LIBCRC32C=3Dy=0A=
+CONFIG_TEXTSEARCH=3Dy=0A=
+CONFIG_TEXTSEARCH_KMP=3Dm=0A=
+CONFIG_TEXTSEARCH_BM=3Dm=0A=
+CONFIG_TEXTSEARCH_FSM=3Dm=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/configs/rc32355_defconfig =
idtlinux/arch/mips/configs/rc32355_defconfig=0A=
--- linux-2.6.16-rc5/arch/mips/configs/rc32355_defconfig	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/configs/rc32355_defconfig	2006-03-09 =
16:25:45.000000000 -0800=0A=
@@ -0,0 +1,940 @@=0A=
+#=0A=
+# Automatically generated make config: don't edit=0A=
+# Linux kernel version: 2.6.16-rc5=0A=
+# Thu Mar  9 16:01:25 2006=0A=
+#=0A=
+CONFIG_MIPS=3Dy=0A=
+=0A=
+#=0A=
+# Machine selection=0A=
+#=0A=
+# CONFIG_MIPS_MTX1 is not set=0A=
+# CONFIG_MIPS_BOSPORUS is not set=0A=
+# CONFIG_MIPS_PB1000 is not set=0A=
+# CONFIG_MIPS_PB1100 is not set=0A=
+# CONFIG_MIPS_PB1500 is not set=0A=
+# CONFIG_MIPS_PB1550 is not set=0A=
+# CONFIG_MIPS_PB1200 is not set=0A=
+# CONFIG_MIPS_DB1000 is not set=0A=
+# CONFIG_MIPS_DB1100 is not set=0A=
+# CONFIG_MIPS_DB1500 is not set=0A=
+# CONFIG_MIPS_DB1550 is not set=0A=
+# CONFIG_MIPS_DB1200 is not set=0A=
+# CONFIG_MIPS_MIRAGE is not set=0A=
+# CONFIG_MIPS_COBALT is not set=0A=
+# CONFIG_MACH_DECSTATION is not set=0A=
+# CONFIG_MIPS_EV64120 is not set=0A=
+# CONFIG_MIPS_EV96100 is not set=0A=
+# CONFIG_MIPS_IVR is not set=0A=
+CONFIG_IDT_BOARDS=3Dy=0A=
+# CONFIG_MIPS_ITE8172 is not set=0A=
+# CONFIG_MACH_JAZZ is not set=0A=
+# CONFIG_LASAT is not set=0A=
+# CONFIG_MIPS_ATLAS is not set=0A=
+# CONFIG_MIPS_MALTA is not set=0A=
+# CONFIG_MIPS_SEAD is not set=0A=
+# CONFIG_MIPS_SIM is not set=0A=
+# CONFIG_MOMENCO_JAGUAR_ATX is not set=0A=
+# CONFIG_MOMENCO_OCELOT is not set=0A=
+# CONFIG_MOMENCO_OCELOT_3 is not set=0A=
+# CONFIG_MOMENCO_OCELOT_C is not set=0A=
+# CONFIG_MOMENCO_OCELOT_G is not set=0A=
+# CONFIG_MIPS_XXS1500 is not set=0A=
+# CONFIG_PNX8550_V2PCI is not set=0A=
+# CONFIG_PNX8550_JBS is not set=0A=
+# CONFIG_DDB5074 is not set=0A=
+# CONFIG_DDB5476 is not set=0A=
+# CONFIG_DDB5477 is not set=0A=
+# CONFIG_MACH_VR41XX is not set=0A=
+# CONFIG_PMC_YOSEMITE is not set=0A=
+# CONFIG_QEMU is not set=0A=
+# CONFIG_SGI_IP22 is not set=0A=
+# CONFIG_SGI_IP27 is not set=0A=
+# CONFIG_SGI_IP32 is not set=0A=
+# CONFIG_SIBYTE_BIGSUR is not set=0A=
+# CONFIG_SIBYTE_SWARM is not set=0A=
+# CONFIG_SIBYTE_SENTOSA is not set=0A=
+# CONFIG_SIBYTE_RHONE is not set=0A=
+# CONFIG_SIBYTE_CARMEL is not set=0A=
+# CONFIG_SIBYTE_PTSWARM is not set=0A=
+# CONFIG_SIBYTE_LITTLESUR is not set=0A=
+# CONFIG_SIBYTE_CRHINE is not set=0A=
+# CONFIG_SIBYTE_CRHONE is not set=0A=
+# CONFIG_SNI_RM200_PCI is not set=0A=
+# CONFIG_TOSHIBA_JMR3927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4938 is not set=0A=
+# CONFIG_IDT_EB438 is not set=0A=
+# CONFIG_IDT_EB434 is not set=0A=
+# CONFIG_IDT_EB365 is not set=0A=
+CONFIG_IDT_EB355=3Dy=0A=
+# CONFIG_IDT_S334 is not set=0A=
+CONFIG_IDT_BOARD_FREQ=3D75000000=0A=
+CONFIG_IDT_ZIMAGE_ADDR=3D0x8c000000=0A=
+# CONFIG_IDT_BOOT_NVRAM is not set=0A=
+CONFIG_RWSEM_GENERIC_SPINLOCK=3Dy=0A=
+CONFIG_GENERIC_CALIBRATE_DELAY=3Dy=0A=
+CONFIG_DMA_NONCOHERENT=3Dy=0A=
+CONFIG_DMA_NEED_PCI_MAP_STATE=3Dy=0A=
+# CONFIG_CPU_BIG_ENDIAN is not set=0A=
+CONFIG_CPU_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_IRQ_CPU=3Dy=0A=
+CONFIG_SWAP_IO_SPACE=3Dy=0A=
+CONFIG_BOOT_ELF32=3Dy=0A=
+CONFIG_MIPS_L1_CACHE_SHIFT=3D5=0A=
+=0A=
+#=0A=
+# CPU selection=0A=
+#=0A=
+# CONFIG_CPU_MIPS32_R1 is not set=0A=
+# CONFIG_CPU_MIPS32_R2 is not set=0A=
+# CONFIG_CPU_MIPS64_R1 is not set=0A=
+# CONFIG_CPU_MIPS64_R2 is not set=0A=
+# CONFIG_CPU_R3000 is not set=0A=
+CONFIG_CPU_RC32300=3Dy=0A=
+# CONFIG_CPU_TX39XX is not set=0A=
+# CONFIG_CPU_VR41XX is not set=0A=
+# CONFIG_CPU_R4300 is not set=0A=
+# CONFIG_CPU_R4X00 is not set=0A=
+# CONFIG_CPU_TX49XX is not set=0A=
+# CONFIG_CPU_R5000 is not set=0A=
+# CONFIG_CPU_R5432 is not set=0A=
+# CONFIG_CPU_R6000 is not set=0A=
+# CONFIG_CPU_NEVADA is not set=0A=
+# CONFIG_CPU_R8000 is not set=0A=
+# CONFIG_CPU_R10000 is not set=0A=
+# CONFIG_CPU_RM7000 is not set=0A=
+# CONFIG_CPU_RM9000 is not set=0A=
+# CONFIG_CPU_SB1 is not set=0A=
+CONFIG_SYS_HAS_CPU_MIPS32_R1=3Dy=0A=
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+=0A=
+#=0A=
+# Kernel type=0A=
+#=0A=
+CONFIG_32BIT=3Dy=0A=
+# CONFIG_64BIT is not set=0A=
+CONFIG_PAGE_SIZE_4KB=3Dy=0A=
+# CONFIG_PAGE_SIZE_8KB is not set=0A=
+# CONFIG_PAGE_SIZE_16KB is not set=0A=
+# CONFIG_PAGE_SIZE_64KB is not set=0A=
+CONFIG_CPU_HAS_PREFETCH=3Dy=0A=
+# CONFIG_MIPS_MT is not set=0A=
+# CONFIG_CPU_ADVANCED is not set=0A=
+CONFIG_CPU_HAS_LLSC=3Dy=0A=
+CONFIG_CPU_HAS_SYNC=3Dy=0A=
+CONFIG_GENERIC_HARDIRQS=3Dy=0A=
+CONFIG_GENERIC_IRQ_PROBE=3Dy=0A=
+CONFIG_ARCH_FLATMEM_ENABLE=3Dy=0A=
+CONFIG_SELECT_MEMORY_MODEL=3Dy=0A=
+CONFIG_FLATMEM_MANUAL=3Dy=0A=
+# CONFIG_DISCONTIGMEM_MANUAL is not set=0A=
+# CONFIG_SPARSEMEM_MANUAL is not set=0A=
+CONFIG_FLATMEM=3Dy=0A=
+CONFIG_FLAT_NODE_MEM_MAP=3Dy=0A=
+# CONFIG_SPARSEMEM_STATIC is not set=0A=
+CONFIG_SPLIT_PTLOCK_CPUS=3D4=0A=
+CONFIG_PREEMPT_NONE=3Dy=0A=
+# CONFIG_PREEMPT_VOLUNTARY is not set=0A=
+# CONFIG_PREEMPT is not set=0A=
+=0A=
+#=0A=
+# Code maturity level options=0A=
+#=0A=
+CONFIG_EXPERIMENTAL=3Dy=0A=
+CONFIG_BROKEN_ON_SMP=3Dy=0A=
+CONFIG_INIT_ENV_ARG_LIMIT=3D32=0A=
+=0A=
+#=0A=
+# General setup=0A=
+#=0A=
+CONFIG_LOCALVERSION=3D""=0A=
+CONFIG_LOCALVERSION_AUTO=3Dy=0A=
+# CONFIG_SWAP is not set=0A=
+CONFIG_SYSVIPC=3Dy=0A=
+# CONFIG_POSIX_MQUEUE is not set=0A=
+# CONFIG_BSD_PROCESS_ACCT is not set=0A=
+CONFIG_SYSCTL=3Dy=0A=
+# CONFIG_AUDIT is not set=0A=
+CONFIG_IKCONFIG=3Dy=0A=
+# CONFIG_IKCONFIG_PROC is not set=0A=
+CONFIG_INITRAMFS_SOURCE=3D""=0A=
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set=0A=
+CONFIG_EMBEDDED=3Dy=0A=
+# CONFIG_KALLSYMS is not set=0A=
+# CONFIG_HOTPLUG is not set=0A=
+CONFIG_PRINTK=3Dy=0A=
+CONFIG_BUG=3Dy=0A=
+CONFIG_ELF_CORE=3Dy=0A=
+# CONFIG_BASE_FULL is not set=0A=
+# CONFIG_FUTEX is not set=0A=
+# CONFIG_EPOLL is not set=0A=
+CONFIG_SHMEM=3Dy=0A=
+CONFIG_CC_ALIGN_FUNCTIONS=3D0=0A=
+CONFIG_CC_ALIGN_LABELS=3D0=0A=
+CONFIG_CC_ALIGN_LOOPS=3D0=0A=
+CONFIG_CC_ALIGN_JUMPS=3D0=0A=
+# CONFIG_SLAB is not set=0A=
+# CONFIG_TINY_SHMEM is not set=0A=
+CONFIG_BASE_SMALL=3D1=0A=
+CONFIG_SLOB=3Dy=0A=
+=0A=
+#=0A=
+# Loadable module support=0A=
+#=0A=
+CONFIG_MODULES=3Dy=0A=
+CONFIG_MODULE_UNLOAD=3Dy=0A=
+# CONFIG_MODULE_FORCE_UNLOAD is not set=0A=
+CONFIG_OBSOLETE_MODPARM=3Dy=0A=
+# CONFIG_MODVERSIONS is not set=0A=
+# CONFIG_MODULE_SRCVERSION_ALL is not set=0A=
+# CONFIG_KMOD is not set=0A=
+=0A=
+#=0A=
+# Block layer=0A=
+#=0A=
+# CONFIG_LBD is not set=0A=
+=0A=
+#=0A=
+# IO Schedulers=0A=
+#=0A=
+CONFIG_IOSCHED_NOOP=3Dy=0A=
+CONFIG_IOSCHED_AS=3Dy=0A=
+CONFIG_IOSCHED_DEADLINE=3Dy=0A=
+CONFIG_IOSCHED_CFQ=3Dy=0A=
+CONFIG_DEFAULT_AS=3Dy=0A=
+# CONFIG_DEFAULT_DEADLINE is not set=0A=
+# CONFIG_DEFAULT_CFQ is not set=0A=
+# CONFIG_DEFAULT_NOOP is not set=0A=
+CONFIG_DEFAULT_IOSCHED=3D"anticipatory"=0A=
+=0A=
+#=0A=
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)=0A=
+#=0A=
+CONFIG_MMU=3Dy=0A=
+=0A=
+#=0A=
+# PCCARD (PCMCIA/CardBus) support=0A=
+#=0A=
+# CONFIG_PCCARD is not set=0A=
+=0A=
+#=0A=
+# PCI Hotplug Support=0A=
+#=0A=
+=0A=
+#=0A=
+# Executable file formats=0A=
+#=0A=
+CONFIG_BINFMT_ELF=3Dy=0A=
+# CONFIG_BINFMT_MISC is not set=0A=
+CONFIG_TRAD_SIGNALS=3Dy=0A=
+=0A=
+#=0A=
+# Networking=0A=
+#=0A=
+CONFIG_NET=3Dy=0A=
+=0A=
+#=0A=
+# Networking options=0A=
+#=0A=
+# CONFIG_NETDEBUG is not set=0A=
+CONFIG_PACKET=3Dy=0A=
+CONFIG_PACKET_MMAP=3Dy=0A=
+CONFIG_UNIX=3Dy=0A=
+CONFIG_XFRM=3Dy=0A=
+# CONFIG_XFRM_USER is not set=0A=
+CONFIG_NET_KEY=3Dy=0A=
+CONFIG_INET=3Dy=0A=
+CONFIG_IP_MULTICAST=3Dy=0A=
+# CONFIG_IP_ADVANCED_ROUTER is not set=0A=
+CONFIG_IP_FIB_HASH=3Dy=0A=
+CONFIG_IP_PNP=3Dy=0A=
+# CONFIG_IP_PNP_DHCP is not set=0A=
+# CONFIG_IP_PNP_BOOTP is not set=0A=
+# CONFIG_IP_PNP_RARP is not set=0A=
+# CONFIG_NET_IPIP is not set=0A=
+# CONFIG_NET_IPGRE is not set=0A=
+# CONFIG_IP_MROUTE is not set=0A=
+# CONFIG_ARPD is not set=0A=
+# CONFIG_SYN_COOKIES is not set=0A=
+# CONFIG_INET_AH is not set=0A=
+# CONFIG_INET_ESP is not set=0A=
+# CONFIG_INET_IPCOMP is not set=0A=
+# CONFIG_INET_TUNNEL is not set=0A=
+# CONFIG_INET_DIAG is not set=0A=
+# CONFIG_TCP_CONG_ADVANCED is not set=0A=
+CONFIG_TCP_CONG_BIC=3Dy=0A=
+=0A=
+#=0A=
+# IP: Virtual Server Configuration=0A=
+#=0A=
+CONFIG_IP_VS=3Dm=0A=
+# CONFIG_IP_VS_DEBUG is not set=0A=
+CONFIG_IP_VS_TAB_BITS=3D12=0A=
+=0A=
+#=0A=
+# IPVS transport protocol load balancing support=0A=
+#=0A=
+CONFIG_IP_VS_PROTO_TCP=3Dy=0A=
+CONFIG_IP_VS_PROTO_UDP=3Dy=0A=
+CONFIG_IP_VS_PROTO_ESP=3Dy=0A=
+CONFIG_IP_VS_PROTO_AH=3Dy=0A=
+=0A=
+#=0A=
+# IPVS scheduler=0A=
+#=0A=
+CONFIG_IP_VS_RR=3Dm=0A=
+CONFIG_IP_VS_WRR=3Dm=0A=
+CONFIG_IP_VS_LC=3Dm=0A=
+CONFIG_IP_VS_WLC=3Dm=0A=
+CONFIG_IP_VS_LBLC=3Dm=0A=
+CONFIG_IP_VS_LBLCR=3Dm=0A=
+CONFIG_IP_VS_DH=3Dm=0A=
+CONFIG_IP_VS_SH=3Dm=0A=
+CONFIG_IP_VS_SED=3Dm=0A=
+CONFIG_IP_VS_NQ=3Dm=0A=
+=0A=
+#=0A=
+# IPVS application helper=0A=
+#=0A=
+CONFIG_IP_VS_FTP=3Dm=0A=
+# CONFIG_IPV6 is not set=0A=
+CONFIG_NETFILTER=3Dy=0A=
+# CONFIG_NETFILTER_DEBUG is not set=0A=
+=0A=
+#=0A=
+# Core Netfilter Configuration=0A=
+#=0A=
+CONFIG_NETFILTER_NETLINK=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_QUEUE=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_LOG=3Dm=0A=
+CONFIG_NETFILTER_XTABLES=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_COMMENT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_DCCP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_HELPER=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LENGTH=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LIMIT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MAC=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_REALM=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_SCTP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STATE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STRING=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=3Dm=0A=
+=0A=
+#=0A=
+# IP: Netfilter Configuration=0A=
+#=0A=
+CONFIG_IP_NF_CONNTRACK=3Dm=0A=
+CONFIG_IP_NF_CT_ACCT=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_MARK=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_EVENTS=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_NETLINK=3Dm=0A=
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set=0A=
+CONFIG_IP_NF_FTP=3Dm=0A=
+CONFIG_IP_NF_IRC=3Dm=0A=
+# CONFIG_IP_NF_NETBIOS_NS is not set=0A=
+CONFIG_IP_NF_TFTP=3Dm=0A=
+CONFIG_IP_NF_AMANDA=3Dm=0A=
+CONFIG_IP_NF_PPTP=3Dm=0A=
+CONFIG_IP_NF_QUEUE=3Dm=0A=
+CONFIG_IP_NF_IPTABLES=3Dm=0A=
+CONFIG_IP_NF_MATCH_IPRANGE=3Dm=0A=
+CONFIG_IP_NF_MATCH_MULTIPORT=3Dm=0A=
+CONFIG_IP_NF_MATCH_TOS=3Dm=0A=
+CONFIG_IP_NF_MATCH_RECENT=3Dm=0A=
+CONFIG_IP_NF_MATCH_ECN=3Dm=0A=
+CONFIG_IP_NF_MATCH_DSCP=3Dm=0A=
+CONFIG_IP_NF_MATCH_AH_ESP=3Dm=0A=
+CONFIG_IP_NF_MATCH_TTL=3Dm=0A=
+CONFIG_IP_NF_MATCH_OWNER=3Dm=0A=
+CONFIG_IP_NF_MATCH_ADDRTYPE=3Dm=0A=
+CONFIG_IP_NF_MATCH_HASHLIMIT=3Dm=0A=
+CONFIG_IP_NF_MATCH_POLICY=3Dm=0A=
+CONFIG_IP_NF_FILTER=3Dm=0A=
+CONFIG_IP_NF_TARGET_REJECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_LOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_ULOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_TCPMSS=3Dm=0A=
+CONFIG_IP_NF_NAT=3Dm=0A=
+CONFIG_IP_NF_NAT_NEEDED=3Dy=0A=
+CONFIG_IP_NF_TARGET_MASQUERADE=3Dm=0A=
+CONFIG_IP_NF_TARGET_REDIRECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_NETMAP=3Dm=0A=
+CONFIG_IP_NF_TARGET_SAME=3Dm=0A=
+CONFIG_IP_NF_NAT_SNMP_BASIC=3Dm=0A=
+CONFIG_IP_NF_NAT_IRC=3Dm=0A=
+CONFIG_IP_NF_NAT_FTP=3Dm=0A=
+CONFIG_IP_NF_NAT_TFTP=3Dm=0A=
+CONFIG_IP_NF_NAT_AMANDA=3Dm=0A=
+CONFIG_IP_NF_NAT_PPTP=3Dm=0A=
+CONFIG_IP_NF_MANGLE=3Dm=0A=
+CONFIG_IP_NF_TARGET_TOS=3Dm=0A=
+CONFIG_IP_NF_TARGET_ECN=3Dm=0A=
+CONFIG_IP_NF_TARGET_DSCP=3Dm=0A=
+CONFIG_IP_NF_TARGET_TTL=3Dm=0A=
+CONFIG_IP_NF_TARGET_CLUSTERIP=3Dm=0A=
+CONFIG_IP_NF_RAW=3Dm=0A=
+CONFIG_IP_NF_ARPTABLES=3Dm=0A=
+CONFIG_IP_NF_ARPFILTER=3Dm=0A=
+CONFIG_IP_NF_ARP_MANGLE=3Dm=0A=
+=0A=
+#=0A=
+# DCCP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_DCCP is not set=0A=
+=0A=
+#=0A=
+# SCTP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_SCTP is not set=0A=
+=0A=
+#=0A=
+# TIPC Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_TIPC is not set=0A=
+# CONFIG_ATM is not set=0A=
+# CONFIG_BRIDGE is not set=0A=
+# CONFIG_VLAN_8021Q is not set=0A=
+# CONFIG_DECNET is not set=0A=
+# CONFIG_LLC2 is not set=0A=
+# CONFIG_IPX is not set=0A=
+# CONFIG_ATALK is not set=0A=
+# CONFIG_X25 is not set=0A=
+# CONFIG_LAPB is not set=0A=
+# CONFIG_NET_DIVERT is not set=0A=
+# CONFIG_ECONET is not set=0A=
+# CONFIG_WAN_ROUTER is not set=0A=
+=0A=
+#=0A=
+# QoS and/or fair queueing=0A=
+#=0A=
+CONFIG_NET_SCHED=3Dy=0A=
+# CONFIG_NET_SCH_CLK_JIFFIES is not set=0A=
+CONFIG_NET_SCH_CLK_GETTIMEOFDAY=3Dy=0A=
+# CONFIG_NET_SCH_CLK_CPU is not set=0A=
+=0A=
+#=0A=
+# Queueing/Scheduling=0A=
+#=0A=
+CONFIG_NET_SCH_CBQ=3Dm=0A=
+CONFIG_NET_SCH_HTB=3Dm=0A=
+CONFIG_NET_SCH_HFSC=3Dm=0A=
+CONFIG_NET_SCH_PRIO=3Dm=0A=
+CONFIG_NET_SCH_RED=3Dm=0A=
+CONFIG_NET_SCH_SFQ=3Dm=0A=
+CONFIG_NET_SCH_TEQL=3Dm=0A=
+CONFIG_NET_SCH_TBF=3Dm=0A=
+CONFIG_NET_SCH_GRED=3Dm=0A=
+CONFIG_NET_SCH_DSMARK=3Dm=0A=
+CONFIG_NET_SCH_NETEM=3Dm=0A=
+CONFIG_NET_SCH_INGRESS=3Dm=0A=
+=0A=
+#=0A=
+# Classification=0A=
+#=0A=
+CONFIG_NET_CLS=3Dy=0A=
+CONFIG_NET_CLS_BASIC=3Dm=0A=
+CONFIG_NET_CLS_TCINDEX=3Dm=0A=
+CONFIG_NET_CLS_ROUTE4=3Dm=0A=
+CONFIG_NET_CLS_ROUTE=3Dy=0A=
+CONFIG_NET_CLS_FW=3Dm=0A=
+CONFIG_NET_CLS_U32=3Dm=0A=
+# CONFIG_CLS_U32_PERF is not set=0A=
+# CONFIG_CLS_U32_MARK is not set=0A=
+CONFIG_NET_CLS_RSVP=3Dm=0A=
+CONFIG_NET_CLS_RSVP6=3Dm=0A=
+# CONFIG_NET_EMATCH is not set=0A=
+# CONFIG_NET_CLS_ACT is not set=0A=
+CONFIG_NET_CLS_POLICE=3Dy=0A=
+# CONFIG_NET_CLS_IND is not set=0A=
+CONFIG_NET_ESTIMATOR=3Dy=0A=
+=0A=
+#=0A=
+# Network testing=0A=
+#=0A=
+# CONFIG_NET_PKTGEN is not set=0A=
+# CONFIG_HAMRADIO is not set=0A=
+# CONFIG_IRDA is not set=0A=
+# CONFIG_BT is not set=0A=
+# CONFIG_IEEE80211 is not set=0A=
+=0A=
+#=0A=
+# Device Drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Generic Driver Options=0A=
+#=0A=
+CONFIG_STANDALONE=3Dy=0A=
+CONFIG_PREVENT_FIRMWARE_BUILD=3Dy=0A=
+# CONFIG_FW_LOADER is not set=0A=
+=0A=
+#=0A=
+# Connector - unified userspace <-> kernelspace linker=0A=
+#=0A=
+# CONFIG_CONNECTOR is not set=0A=
+=0A=
+#=0A=
+# Memory Technology Devices (MTD)=0A=
+#=0A=
+# CONFIG_MTD is not set=0A=
+=0A=
+#=0A=
+# Parallel port support=0A=
+#=0A=
+# CONFIG_PARPORT is not set=0A=
+=0A=
+#=0A=
+# Plug and Play support=0A=
+#=0A=
+=0A=
+#=0A=
+# Block devices=0A=
+#=0A=
+# CONFIG_BLK_DEV_COW_COMMON is not set=0A=
+# CONFIG_BLK_DEV_LOOP is not set=0A=
+# CONFIG_BLK_DEV_NBD is not set=0A=
+# CONFIG_BLK_DEV_RAM is not set=0A=
+CONFIG_BLK_DEV_RAM_COUNT=3D16=0A=
+# CONFIG_CDROM_PKTCDVD is not set=0A=
+# CONFIG_ATA_OVER_ETH is not set=0A=
+=0A=
+#=0A=
+# ATA/ATAPI/MFM/RLL support=0A=
+#=0A=
+# CONFIG_IDE is not set=0A=
+=0A=
+#=0A=
+# SCSI device support=0A=
+#=0A=
+# CONFIG_RAID_ATTRS is not set=0A=
+# CONFIG_SCSI is not set=0A=
+=0A=
+#=0A=
+# Multi-device support (RAID and LVM)=0A=
+#=0A=
+# CONFIG_MD is not set=0A=
+=0A=
+#=0A=
+# Fusion MPT device support=0A=
+#=0A=
+# CONFIG_FUSION is not set=0A=
+=0A=
+#=0A=
+# IEEE 1394 (FireWire) support=0A=
+#=0A=
+=0A=
+#=0A=
+# I2O device support=0A=
+#=0A=
+=0A=
+#=0A=
+# Network device support=0A=
+#=0A=
+CONFIG_NETDEVICES=3Dy=0A=
+# CONFIG_DUMMY is not set=0A=
+# CONFIG_BONDING is not set=0A=
+# CONFIG_EQUALIZER is not set=0A=
+# CONFIG_TUN is not set=0A=
+=0A=
+#=0A=
+# PHY device support=0A=
+#=0A=
+CONFIG_PHYLIB=3Dm=0A=
+=0A=
+#=0A=
+# MII PHY device drivers=0A=
+#=0A=
+CONFIG_MARVELL_PHY=3Dm=0A=
+CONFIG_DAVICOM_PHY=3Dm=0A=
+CONFIG_QSEMI_PHY=3Dm=0A=
+CONFIG_LXT_PHY=3Dm=0A=
+CONFIG_CICADA_PHY=3Dm=0A=
+=0A=
+#=0A=
+# Ethernet (10 or 100Mbit)=0A=
+#=0A=
+CONFIG_NET_ETHERNET=3Dy=0A=
+CONFIG_MII=3Dy=0A=
+CONFIG_IDT_RC32355_ETH=3Dy=0A=
+# CONFIG_DM9000 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (1000 Mbit)=0A=
+#=0A=
+=0A=
+#=0A=
+# Ethernet (10000 Mbit)=0A=
+#=0A=
+=0A=
+#=0A=
+# Token Ring devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Wireless LAN (non-hamradio)=0A=
+#=0A=
+# CONFIG_NET_RADIO is not set=0A=
+=0A=
+#=0A=
+# Wan interfaces=0A=
+#=0A=
+# CONFIG_WAN is not set=0A=
+# CONFIG_PPP is not set=0A=
+# CONFIG_SLIP is not set=0A=
+# CONFIG_SHAPER is not set=0A=
+# CONFIG_NETCONSOLE is not set=0A=
+# CONFIG_NETPOLL is not set=0A=
+# CONFIG_NET_POLL_CONTROLLER is not set=0A=
+=0A=
+#=0A=
+# ISDN subsystem=0A=
+#=0A=
+# CONFIG_ISDN is not set=0A=
+=0A=
+#=0A=
+# Telephony Support=0A=
+#=0A=
+# CONFIG_PHONE is not set=0A=
+=0A=
+#=0A=
+# Input device support=0A=
+#=0A=
+CONFIG_INPUT=3Dy=0A=
+=0A=
+#=0A=
+# Userland interfaces=0A=
+#=0A=
+# CONFIG_INPUT_MOUSEDEV is not set=0A=
+# CONFIG_INPUT_JOYDEV is not set=0A=
+# CONFIG_INPUT_TSDEV is not set=0A=
+# CONFIG_INPUT_EVDEV is not set=0A=
+# CONFIG_INPUT_EVBUG is not set=0A=
+=0A=
+#=0A=
+# Input Device Drivers=0A=
+#=0A=
+# CONFIG_INPUT_KEYBOARD is not set=0A=
+# CONFIG_INPUT_MOUSE is not set=0A=
+# CONFIG_INPUT_JOYSTICK is not set=0A=
+# CONFIG_INPUT_TOUCHSCREEN is not set=0A=
+# CONFIG_INPUT_MISC is not set=0A=
+=0A=
+#=0A=
+# Hardware I/O ports=0A=
+#=0A=
+# CONFIG_SERIO is not set=0A=
+# CONFIG_GAMEPORT is not set=0A=
+=0A=
+#=0A=
+# Character devices=0A=
+#=0A=
+CONFIG_VT=3Dy=0A=
+CONFIG_VT_CONSOLE=3Dy=0A=
+CONFIG_HW_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_NONSTANDARD is not set=0A=
+=0A=
+#=0A=
+# Serial drivers=0A=
+#=0A=
+CONFIG_SERIAL_8250=3Dy=0A=
+CONFIG_SERIAL_8250_CONSOLE=3Dy=0A=
+CONFIG_SERIAL_8250_NR_UARTS=3D4=0A=
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3D4=0A=
+# CONFIG_SERIAL_8250_EXTENDED is not set=0A=
+=0A=
+#=0A=
+# Non-8250 serial port support=0A=
+#=0A=
+CONFIG_SERIAL_CORE=3Dy=0A=
+CONFIG_SERIAL_CORE_CONSOLE=3Dy=0A=
+CONFIG_UNIX98_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTY_COUNT=3D256=0A=
+=0A=
+#=0A=
+# IPMI=0A=
+#=0A=
+# CONFIG_IPMI_HANDLER is not set=0A=
+=0A=
+#=0A=
+# Watchdog Cards=0A=
+#=0A=
+# CONFIG_WATCHDOG is not set=0A=
+# CONFIG_RTC is not set=0A=
+# CONFIG_GEN_RTC is not set=0A=
+# CONFIG_DTLK is not set=0A=
+# CONFIG_R3964 is not set=0A=
+=0A=
+#=0A=
+# Ftape, the floppy tape device driver=0A=
+#=0A=
+# CONFIG_RAW_DRIVER is not set=0A=
+=0A=
+#=0A=
+# TPM devices=0A=
+#=0A=
+# CONFIG_TCG_TPM is not set=0A=
+# CONFIG_TELCLOCK is not set=0A=
+=0A=
+#=0A=
+# I2C support=0A=
+#=0A=
+CONFIG_I2C=3Dy=0A=
+CONFIG_I2C_CHARDEV=3Dy=0A=
+=0A=
+#=0A=
+# I2C Algorithms=0A=
+#=0A=
+# CONFIG_I2C_ALGOBIT is not set=0A=
+# CONFIG_I2C_ALGOPCF is not set=0A=
+# CONFIG_I2C_ALGOPCA is not set=0A=
+=0A=
+#=0A=
+# I2C Hardware Bus support=0A=
+#=0A=
+# CONFIG_I2C_PARPORT_LIGHT is not set=0A=
+# CONFIG_I2C_STUB is not set=0A=
+# CONFIG_I2C_PCA_ISA is not set=0A=
+CONFIG_I2C_RC32355=3Dy=0A=
+=0A=
+#=0A=
+# Miscellaneous I2C Chip support=0A=
+#=0A=
+# CONFIG_SENSORS_DS1337 is not set=0A=
+# CONFIG_SENSORS_DS1374 is not set=0A=
+# CONFIG_SENSORS_EEPROM is not set=0A=
+# CONFIG_SENSORS_PCF8574 is not set=0A=
+# CONFIG_SENSORS_PCA9539 is not set=0A=
+# CONFIG_SENSORS_PCF8591 is not set=0A=
+# CONFIG_SENSORS_RTC8564 is not set=0A=
+# CONFIG_SENSORS_MAX6875 is not set=0A=
+# CONFIG_RTC_X1205_I2C is not set=0A=
+# CONFIG_I2C_DEBUG_CORE is not set=0A=
+# CONFIG_I2C_DEBUG_ALGO is not set=0A=
+# CONFIG_I2C_DEBUG_BUS is not set=0A=
+# CONFIG_I2C_DEBUG_CHIP is not set=0A=
+=0A=
+#=0A=
+# SPI support=0A=
+#=0A=
+# CONFIG_SPI is not set=0A=
+# CONFIG_SPI_MASTER is not set=0A=
+=0A=
+#=0A=
+# Dallas's 1-wire bus=0A=
+#=0A=
+# CONFIG_W1 is not set=0A=
+=0A=
+#=0A=
+# Hardware Monitoring support=0A=
+#=0A=
+# CONFIG_HWMON is not set=0A=
+# CONFIG_HWMON_VID is not set=0A=
+=0A=
+#=0A=
+# Misc devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia Capabilities Port drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia devices=0A=
+#=0A=
+# CONFIG_VIDEO_DEV is not set=0A=
+=0A=
+#=0A=
+# Digital Video Broadcasting Devices=0A=
+#=0A=
+# CONFIG_DVB is not set=0A=
+=0A=
+#=0A=
+# Graphics support=0A=
+#=0A=
+# CONFIG_FB is not set=0A=
+=0A=
+#=0A=
+# Console display driver support=0A=
+#=0A=
+# CONFIG_VGA_CONSOLE is not set=0A=
+CONFIG_DUMMY_CONSOLE=3Dy=0A=
+=0A=
+#=0A=
+# Sound=0A=
+#=0A=
+# CONFIG_SOUND is not set=0A=
+=0A=
+#=0A=
+# USB support=0A=
+#=0A=
+# CONFIG_USB_ARCH_HAS_HCD is not set=0A=
+# CONFIG_USB_ARCH_HAS_OHCI is not set=0A=
+=0A=
+#=0A=
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'=0A=
+#=0A=
+=0A=
+#=0A=
+# USB Gadget Support=0A=
+#=0A=
+# CONFIG_USB_GADGET is not set=0A=
+=0A=
+#=0A=
+# MMC/SD Card support=0A=
+#=0A=
+# CONFIG_MMC is not set=0A=
+=0A=
+#=0A=
+# InfiniBand support=0A=
+#=0A=
+=0A=
+#=0A=
+# SN Devices=0A=
+#=0A=
+=0A=
+#=0A=
+# EDAC - error detection and reporting (RAS)=0A=
+#=0A=
+=0A=
+#=0A=
+# File systems=0A=
+#=0A=
+CONFIG_EXT2_FS=3Dy=0A=
+# CONFIG_EXT2_FS_XATTR is not set=0A=
+# CONFIG_EXT2_FS_XIP is not set=0A=
+# CONFIG_EXT3_FS is not set=0A=
+# CONFIG_REISERFS_FS is not set=0A=
+# CONFIG_JFS_FS is not set=0A=
+# CONFIG_FS_POSIX_ACL is not set=0A=
+# CONFIG_XFS_FS is not set=0A=
+# CONFIG_OCFS2_FS is not set=0A=
+# CONFIG_MINIX_FS is not set=0A=
+# CONFIG_ROMFS_FS is not set=0A=
+# CONFIG_INOTIFY is not set=0A=
+# CONFIG_QUOTA is not set=0A=
+# CONFIG_DNOTIFY is not set=0A=
+# CONFIG_AUTOFS_FS is not set=0A=
+# CONFIG_AUTOFS4_FS is not set=0A=
+# CONFIG_FUSE_FS is not set=0A=
+=0A=
+#=0A=
+# CD-ROM/DVD Filesystems=0A=
+#=0A=
+# CONFIG_ISO9660_FS is not set=0A=
+# CONFIG_UDF_FS is not set=0A=
+=0A=
+#=0A=
+# DOS/FAT/NT Filesystems=0A=
+#=0A=
+# CONFIG_MSDOS_FS is not set=0A=
+# CONFIG_VFAT_FS is not set=0A=
+# CONFIG_NTFS_FS is not set=0A=
+=0A=
+#=0A=
+# Pseudo filesystems=0A=
+#=0A=
+CONFIG_PROC_FS=3Dy=0A=
+CONFIG_PROC_KCORE=3Dy=0A=
+CONFIG_SYSFS=3Dy=0A=
+# CONFIG_TMPFS is not set=0A=
+# CONFIG_HUGETLB_PAGE is not set=0A=
+CONFIG_RAMFS=3Dy=0A=
+# CONFIG_RELAYFS_FS is not set=0A=
+# CONFIG_CONFIGFS_FS is not set=0A=
+=0A=
+#=0A=
+# Miscellaneous filesystems=0A=
+#=0A=
+# CONFIG_ADFS_FS is not set=0A=
+# CONFIG_AFFS_FS is not set=0A=
+# CONFIG_HFS_FS is not set=0A=
+# CONFIG_HFSPLUS_FS is not set=0A=
+# CONFIG_BEFS_FS is not set=0A=
+# CONFIG_BFS_FS is not set=0A=
+# CONFIG_EFS_FS is not set=0A=
+# CONFIG_CRAMFS is not set=0A=
+# CONFIG_VXFS_FS is not set=0A=
+# CONFIG_HPFS_FS is not set=0A=
+# CONFIG_QNX4FS_FS is not set=0A=
+# CONFIG_SYSV_FS is not set=0A=
+# CONFIG_UFS_FS is not set=0A=
+=0A=
+#=0A=
+# Network File Systems=0A=
+#=0A=
+# CONFIG_NFS_FS is not set=0A=
+# CONFIG_NFSD is not set=0A=
+# CONFIG_SMB_FS is not set=0A=
+# CONFIG_CIFS is not set=0A=
+# CONFIG_NCP_FS is not set=0A=
+# CONFIG_CODA_FS is not set=0A=
+# CONFIG_AFS_FS is not set=0A=
+# CONFIG_9P_FS is not set=0A=
+=0A=
+#=0A=
+# Partition Types=0A=
+#=0A=
+# CONFIG_PARTITION_ADVANCED is not set=0A=
+CONFIG_MSDOS_PARTITION=3Dy=0A=
+=0A=
+#=0A=
+# Native Language Support=0A=
+#=0A=
+# CONFIG_NLS is not set=0A=
+=0A=
+#=0A=
+# Profiling support=0A=
+#=0A=
+# CONFIG_PROFILING is not set=0A=
+=0A=
+#=0A=
+# Kernel hacking=0A=
+#=0A=
+# CONFIG_PRINTK_TIME is not set=0A=
+# CONFIG_MAGIC_SYSRQ is not set=0A=
+# CONFIG_DEBUG_KERNEL is not set=0A=
+CONFIG_LOG_BUF_SHIFT=3D14=0A=
+CONFIG_CROSSCOMPILE=3Dy=0A=
+CONFIG_CMDLINE=3D""=0A=
+=0A=
+#=0A=
+# Security options=0A=
+#=0A=
+# CONFIG_KEYS is not set=0A=
+# CONFIG_SECURITY is not set=0A=
+=0A=
+#=0A=
+# Cryptographic options=0A=
+#=0A=
+# CONFIG_CRYPTO is not set=0A=
+=0A=
+#=0A=
+# Hardware crypto devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Library routines=0A=
+#=0A=
+CONFIG_CRC_CCITT=3Dy=0A=
+CONFIG_CRC16=3Dm=0A=
+CONFIG_CRC32=3Dy=0A=
+# CONFIG_LIBCRC32C is not set=0A=
+CONFIG_TEXTSEARCH=3Dy=0A=
+CONFIG_TEXTSEARCH_KMP=3Dm=0A=
+CONFIG_TEXTSEARCH_BM=3Dm=0A=
+CONFIG_TEXTSEARCH_FSM=3Dm=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/configs/rc32365_defconfig =
idtlinux/arch/mips/configs/rc32365_defconfig=0A=
--- linux-2.6.16-rc5/arch/mips/configs/rc32365_defconfig	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/configs/rc32365_defconfig	2006-03-09 =
16:25:45.000000000 -0800=0A=
@@ -0,0 +1,1029 @@=0A=
+#=0A=
+# Automatically generated make config: don't edit=0A=
+# Linux kernel version: 2.6.16-rc5=0A=
+# Thu Mar  9 16:13:13 2006=0A=
+#=0A=
+CONFIG_MIPS=3Dy=0A=
+=0A=
+#=0A=
+# Machine selection=0A=
+#=0A=
+# CONFIG_MIPS_MTX1 is not set=0A=
+# CONFIG_MIPS_BOSPORUS is not set=0A=
+# CONFIG_MIPS_PB1000 is not set=0A=
+# CONFIG_MIPS_PB1100 is not set=0A=
+# CONFIG_MIPS_PB1500 is not set=0A=
+# CONFIG_MIPS_PB1550 is not set=0A=
+# CONFIG_MIPS_PB1200 is not set=0A=
+# CONFIG_MIPS_DB1000 is not set=0A=
+# CONFIG_MIPS_DB1100 is not set=0A=
+# CONFIG_MIPS_DB1500 is not set=0A=
+# CONFIG_MIPS_DB1550 is not set=0A=
+# CONFIG_MIPS_DB1200 is not set=0A=
+# CONFIG_MIPS_MIRAGE is not set=0A=
+# CONFIG_MIPS_COBALT is not set=0A=
+# CONFIG_MACH_DECSTATION is not set=0A=
+# CONFIG_MIPS_EV64120 is not set=0A=
+# CONFIG_MIPS_EV96100 is not set=0A=
+# CONFIG_MIPS_IVR is not set=0A=
+CONFIG_IDT_BOARDS=3Dy=0A=
+# CONFIG_MIPS_ITE8172 is not set=0A=
+# CONFIG_MACH_JAZZ is not set=0A=
+# CONFIG_LASAT is not set=0A=
+# CONFIG_MIPS_ATLAS is not set=0A=
+# CONFIG_MIPS_MALTA is not set=0A=
+# CONFIG_MIPS_SEAD is not set=0A=
+# CONFIG_MIPS_SIM is not set=0A=
+# CONFIG_MOMENCO_JAGUAR_ATX is not set=0A=
+# CONFIG_MOMENCO_OCELOT is not set=0A=
+# CONFIG_MOMENCO_OCELOT_3 is not set=0A=
+# CONFIG_MOMENCO_OCELOT_C is not set=0A=
+# CONFIG_MOMENCO_OCELOT_G is not set=0A=
+# CONFIG_MIPS_XXS1500 is not set=0A=
+# CONFIG_PNX8550_V2PCI is not set=0A=
+# CONFIG_PNX8550_JBS is not set=0A=
+# CONFIG_DDB5074 is not set=0A=
+# CONFIG_DDB5476 is not set=0A=
+# CONFIG_DDB5477 is not set=0A=
+# CONFIG_MACH_VR41XX is not set=0A=
+# CONFIG_PMC_YOSEMITE is not set=0A=
+# CONFIG_QEMU is not set=0A=
+# CONFIG_SGI_IP22 is not set=0A=
+# CONFIG_SGI_IP27 is not set=0A=
+# CONFIG_SGI_IP32 is not set=0A=
+# CONFIG_SIBYTE_BIGSUR is not set=0A=
+# CONFIG_SIBYTE_SWARM is not set=0A=
+# CONFIG_SIBYTE_SENTOSA is not set=0A=
+# CONFIG_SIBYTE_RHONE is not set=0A=
+# CONFIG_SIBYTE_CARMEL is not set=0A=
+# CONFIG_SIBYTE_PTSWARM is not set=0A=
+# CONFIG_SIBYTE_LITTLESUR is not set=0A=
+# CONFIG_SIBYTE_CRHINE is not set=0A=
+# CONFIG_SIBYTE_CRHONE is not set=0A=
+# CONFIG_SNI_RM200_PCI is not set=0A=
+# CONFIG_TOSHIBA_JMR3927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4938 is not set=0A=
+# CONFIG_IDT_EB438 is not set=0A=
+# CONFIG_IDT_EB434 is not set=0A=
+CONFIG_IDT_EB365=3Dy=0A=
+# CONFIG_IDT_EB355 is not set=0A=
+# CONFIG_IDT_S334 is not set=0A=
+CONFIG_IDT_BOARD_FREQ=3D90000000=0A=
+CONFIG_IDT_ZIMAGE_ADDR=3D0x88000000=0A=
+# CONFIG_IDT_BOOT_NVRAM is not set=0A=
+CONFIG_RWSEM_GENERIC_SPINLOCK=3Dy=0A=
+CONFIG_GENERIC_CALIBRATE_DELAY=3Dy=0A=
+CONFIG_DMA_NONCOHERENT=3Dy=0A=
+CONFIG_DMA_NEED_PCI_MAP_STATE=3Dy=0A=
+# CONFIG_CPU_BIG_ENDIAN is not set=0A=
+CONFIG_CPU_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_IRQ_CPU=3Dy=0A=
+CONFIG_SWAP_IO_SPACE=3Dy=0A=
+CONFIG_BOOT_ELF32=3Dy=0A=
+CONFIG_MIPS_L1_CACHE_SHIFT=3D5=0A=
+=0A=
+#=0A=
+# CPU selection=0A=
+#=0A=
+# CONFIG_CPU_MIPS32_R1 is not set=0A=
+# CONFIG_CPU_MIPS32_R2 is not set=0A=
+# CONFIG_CPU_MIPS64_R1 is not set=0A=
+# CONFIG_CPU_MIPS64_R2 is not set=0A=
+# CONFIG_CPU_R3000 is not set=0A=
+CONFIG_CPU_RC32300=3Dy=0A=
+# CONFIG_CPU_TX39XX is not set=0A=
+# CONFIG_CPU_VR41XX is not set=0A=
+# CONFIG_CPU_R4300 is not set=0A=
+# CONFIG_CPU_R4X00 is not set=0A=
+# CONFIG_CPU_TX49XX is not set=0A=
+# CONFIG_CPU_R5000 is not set=0A=
+# CONFIG_CPU_R5432 is not set=0A=
+# CONFIG_CPU_R6000 is not set=0A=
+# CONFIG_CPU_NEVADA is not set=0A=
+# CONFIG_CPU_R8000 is not set=0A=
+# CONFIG_CPU_R10000 is not set=0A=
+# CONFIG_CPU_RM7000 is not set=0A=
+# CONFIG_CPU_RM9000 is not set=0A=
+# CONFIG_CPU_SB1 is not set=0A=
+CONFIG_SYS_HAS_CPU_MIPS32_R1=3Dy=0A=
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+=0A=
+#=0A=
+# Kernel type=0A=
+#=0A=
+CONFIG_32BIT=3Dy=0A=
+# CONFIG_64BIT is not set=0A=
+CONFIG_PAGE_SIZE_4KB=3Dy=0A=
+# CONFIG_PAGE_SIZE_8KB is not set=0A=
+# CONFIG_PAGE_SIZE_16KB is not set=0A=
+# CONFIG_PAGE_SIZE_64KB is not set=0A=
+CONFIG_CPU_HAS_PREFETCH=3Dy=0A=
+# CONFIG_MIPS_MT is not set=0A=
+CONFIG_CPU_ADVANCED=3Dy=0A=
+CONFIG_CPU_HAS_LLSC=3Dy=0A=
+# CONFIG_CPU_HAS_WB is not set=0A=
+CONFIG_CPU_HAS_SYNC=3Dy=0A=
+CONFIG_GENERIC_HARDIRQS=3Dy=0A=
+CONFIG_GENERIC_IRQ_PROBE=3Dy=0A=
+CONFIG_ARCH_FLATMEM_ENABLE=3Dy=0A=
+CONFIG_SELECT_MEMORY_MODEL=3Dy=0A=
+CONFIG_FLATMEM_MANUAL=3Dy=0A=
+# CONFIG_DISCONTIGMEM_MANUAL is not set=0A=
+# CONFIG_SPARSEMEM_MANUAL is not set=0A=
+CONFIG_FLATMEM=3Dy=0A=
+CONFIG_FLAT_NODE_MEM_MAP=3Dy=0A=
+# CONFIG_SPARSEMEM_STATIC is not set=0A=
+CONFIG_SPLIT_PTLOCK_CPUS=3D4=0A=
+CONFIG_PREEMPT_NONE=3Dy=0A=
+# CONFIG_PREEMPT_VOLUNTARY is not set=0A=
+# CONFIG_PREEMPT is not set=0A=
+=0A=
+#=0A=
+# Code maturity level options=0A=
+#=0A=
+CONFIG_EXPERIMENTAL=3Dy=0A=
+CONFIG_BROKEN_ON_SMP=3Dy=0A=
+CONFIG_INIT_ENV_ARG_LIMIT=3D32=0A=
+=0A=
+#=0A=
+# General setup=0A=
+#=0A=
+CONFIG_LOCALVERSION=3D""=0A=
+CONFIG_LOCALVERSION_AUTO=3Dy=0A=
+# CONFIG_SWAP is not set=0A=
+CONFIG_SYSVIPC=3Dy=0A=
+# CONFIG_POSIX_MQUEUE is not set=0A=
+# CONFIG_BSD_PROCESS_ACCT is not set=0A=
+CONFIG_SYSCTL=3Dy=0A=
+# CONFIG_AUDIT is not set=0A=
+CONFIG_IKCONFIG=3Dy=0A=
+# CONFIG_IKCONFIG_PROC is not set=0A=
+CONFIG_INITRAMFS_SOURCE=3D""=0A=
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set=0A=
+CONFIG_EMBEDDED=3Dy=0A=
+# CONFIG_KALLSYMS is not set=0A=
+# CONFIG_HOTPLUG is not set=0A=
+CONFIG_PRINTK=3Dy=0A=
+CONFIG_BUG=3Dy=0A=
+CONFIG_ELF_CORE=3Dy=0A=
+# CONFIG_BASE_FULL is not set=0A=
+# CONFIG_FUTEX is not set=0A=
+# CONFIG_EPOLL is not set=0A=
+CONFIG_SHMEM=3Dy=0A=
+CONFIG_CC_ALIGN_FUNCTIONS=3D0=0A=
+CONFIG_CC_ALIGN_LABELS=3D0=0A=
+CONFIG_CC_ALIGN_LOOPS=3D0=0A=
+CONFIG_CC_ALIGN_JUMPS=3D0=0A=
+# CONFIG_SLAB is not set=0A=
+# CONFIG_TINY_SHMEM is not set=0A=
+CONFIG_BASE_SMALL=3D1=0A=
+CONFIG_SLOB=3Dy=0A=
+=0A=
+#=0A=
+# Loadable module support=0A=
+#=0A=
+CONFIG_MODULES=3Dy=0A=
+CONFIG_MODULE_UNLOAD=3Dy=0A=
+# CONFIG_MODULE_FORCE_UNLOAD is not set=0A=
+CONFIG_OBSOLETE_MODPARM=3Dy=0A=
+# CONFIG_MODVERSIONS is not set=0A=
+# CONFIG_MODULE_SRCVERSION_ALL is not set=0A=
+# CONFIG_KMOD is not set=0A=
+=0A=
+#=0A=
+# Block layer=0A=
+#=0A=
+# CONFIG_LBD is not set=0A=
+=0A=
+#=0A=
+# IO Schedulers=0A=
+#=0A=
+CONFIG_IOSCHED_NOOP=3Dy=0A=
+CONFIG_IOSCHED_AS=3Dy=0A=
+CONFIG_IOSCHED_DEADLINE=3Dy=0A=
+CONFIG_IOSCHED_CFQ=3Dy=0A=
+CONFIG_DEFAULT_AS=3Dy=0A=
+# CONFIG_DEFAULT_DEADLINE is not set=0A=
+# CONFIG_DEFAULT_CFQ is not set=0A=
+# CONFIG_DEFAULT_NOOP is not set=0A=
+CONFIG_DEFAULT_IOSCHED=3D"anticipatory"=0A=
+=0A=
+#=0A=
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)=0A=
+#=0A=
+CONFIG_HW_HAS_PCI=3Dy=0A=
+CONFIG_PCI=3Dy=0A=
+CONFIG_PCI_LEGACY_PROC=3Dy=0A=
+CONFIG_MMU=3Dy=0A=
+=0A=
+#=0A=
+# PCCARD (PCMCIA/CardBus) support=0A=
+#=0A=
+# CONFIG_PCCARD is not set=0A=
+=0A=
+#=0A=
+# PCI Hotplug Support=0A=
+#=0A=
+# CONFIG_HOTPLUG_PCI is not set=0A=
+=0A=
+#=0A=
+# Executable file formats=0A=
+#=0A=
+CONFIG_BINFMT_ELF=3Dy=0A=
+# CONFIG_BINFMT_MISC is not set=0A=
+CONFIG_TRAD_SIGNALS=3Dy=0A=
+=0A=
+#=0A=
+# Networking=0A=
+#=0A=
+CONFIG_NET=3Dy=0A=
+=0A=
+#=0A=
+# Networking options=0A=
+#=0A=
+# CONFIG_NETDEBUG is not set=0A=
+CONFIG_PACKET=3Dy=0A=
+CONFIG_PACKET_MMAP=3Dy=0A=
+CONFIG_UNIX=3Dy=0A=
+CONFIG_XFRM=3Dy=0A=
+# CONFIG_XFRM_USER is not set=0A=
+CONFIG_NET_KEY=3Dy=0A=
+CONFIG_INET=3Dy=0A=
+CONFIG_IP_MULTICAST=3Dy=0A=
+# CONFIG_IP_ADVANCED_ROUTER is not set=0A=
+CONFIG_IP_FIB_HASH=3Dy=0A=
+CONFIG_IP_PNP=3Dy=0A=
+# CONFIG_IP_PNP_DHCP is not set=0A=
+# CONFIG_IP_PNP_BOOTP is not set=0A=
+# CONFIG_IP_PNP_RARP is not set=0A=
+# CONFIG_NET_IPIP is not set=0A=
+# CONFIG_NET_IPGRE is not set=0A=
+# CONFIG_IP_MROUTE is not set=0A=
+# CONFIG_ARPD is not set=0A=
+# CONFIG_SYN_COOKIES is not set=0A=
+# CONFIG_INET_AH is not set=0A=
+# CONFIG_INET_ESP is not set=0A=
+# CONFIG_INET_IPCOMP is not set=0A=
+# CONFIG_INET_TUNNEL is not set=0A=
+# CONFIG_INET_DIAG is not set=0A=
+# CONFIG_TCP_CONG_ADVANCED is not set=0A=
+CONFIG_TCP_CONG_BIC=3Dy=0A=
+=0A=
+#=0A=
+# IP: Virtual Server Configuration=0A=
+#=0A=
+CONFIG_IP_VS=3Dm=0A=
+# CONFIG_IP_VS_DEBUG is not set=0A=
+CONFIG_IP_VS_TAB_BITS=3D12=0A=
+=0A=
+#=0A=
+# IPVS transport protocol load balancing support=0A=
+#=0A=
+CONFIG_IP_VS_PROTO_TCP=3Dy=0A=
+CONFIG_IP_VS_PROTO_UDP=3Dy=0A=
+CONFIG_IP_VS_PROTO_ESP=3Dy=0A=
+CONFIG_IP_VS_PROTO_AH=3Dy=0A=
+=0A=
+#=0A=
+# IPVS scheduler=0A=
+#=0A=
+CONFIG_IP_VS_RR=3Dm=0A=
+CONFIG_IP_VS_WRR=3Dm=0A=
+CONFIG_IP_VS_LC=3Dm=0A=
+CONFIG_IP_VS_WLC=3Dm=0A=
+CONFIG_IP_VS_LBLC=3Dm=0A=
+CONFIG_IP_VS_LBLCR=3Dm=0A=
+CONFIG_IP_VS_DH=3Dm=0A=
+CONFIG_IP_VS_SH=3Dm=0A=
+CONFIG_IP_VS_SED=3Dm=0A=
+CONFIG_IP_VS_NQ=3Dm=0A=
+=0A=
+#=0A=
+# IPVS application helper=0A=
+#=0A=
+CONFIG_IP_VS_FTP=3Dm=0A=
+# CONFIG_IPV6 is not set=0A=
+CONFIG_NETFILTER=3Dy=0A=
+# CONFIG_NETFILTER_DEBUG is not set=0A=
+=0A=
+#=0A=
+# Core Netfilter Configuration=0A=
+#=0A=
+CONFIG_NETFILTER_NETLINK=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_QUEUE=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_LOG=3Dm=0A=
+CONFIG_NETFILTER_XTABLES=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_COMMENT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_DCCP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_HELPER=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LENGTH=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LIMIT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MAC=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_REALM=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_SCTP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STATE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STRING=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=3Dm=0A=
+=0A=
+#=0A=
+# IP: Netfilter Configuration=0A=
+#=0A=
+CONFIG_IP_NF_CONNTRACK=3Dm=0A=
+CONFIG_IP_NF_CT_ACCT=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_MARK=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_EVENTS=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_NETLINK=3Dm=0A=
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set=0A=
+CONFIG_IP_NF_FTP=3Dm=0A=
+CONFIG_IP_NF_IRC=3Dm=0A=
+# CONFIG_IP_NF_NETBIOS_NS is not set=0A=
+CONFIG_IP_NF_TFTP=3Dm=0A=
+CONFIG_IP_NF_AMANDA=3Dm=0A=
+CONFIG_IP_NF_PPTP=3Dm=0A=
+CONFIG_IP_NF_QUEUE=3Dm=0A=
+CONFIG_IP_NF_IPTABLES=3Dm=0A=
+CONFIG_IP_NF_MATCH_IPRANGE=3Dm=0A=
+CONFIG_IP_NF_MATCH_MULTIPORT=3Dm=0A=
+CONFIG_IP_NF_MATCH_TOS=3Dm=0A=
+CONFIG_IP_NF_MATCH_RECENT=3Dm=0A=
+CONFIG_IP_NF_MATCH_ECN=3Dm=0A=
+CONFIG_IP_NF_MATCH_DSCP=3Dm=0A=
+CONFIG_IP_NF_MATCH_AH_ESP=3Dm=0A=
+CONFIG_IP_NF_MATCH_TTL=3Dm=0A=
+CONFIG_IP_NF_MATCH_OWNER=3Dm=0A=
+CONFIG_IP_NF_MATCH_ADDRTYPE=3Dm=0A=
+CONFIG_IP_NF_MATCH_HASHLIMIT=3Dm=0A=
+CONFIG_IP_NF_MATCH_POLICY=3Dm=0A=
+CONFIG_IP_NF_FILTER=3Dm=0A=
+CONFIG_IP_NF_TARGET_REJECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_LOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_ULOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_TCPMSS=3Dm=0A=
+CONFIG_IP_NF_NAT=3Dm=0A=
+CONFIG_IP_NF_NAT_NEEDED=3Dy=0A=
+CONFIG_IP_NF_TARGET_MASQUERADE=3Dm=0A=
+CONFIG_IP_NF_TARGET_REDIRECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_NETMAP=3Dm=0A=
+CONFIG_IP_NF_TARGET_SAME=3Dm=0A=
+CONFIG_IP_NF_NAT_SNMP_BASIC=3Dm=0A=
+CONFIG_IP_NF_NAT_IRC=3Dm=0A=
+CONFIG_IP_NF_NAT_FTP=3Dm=0A=
+CONFIG_IP_NF_NAT_TFTP=3Dm=0A=
+CONFIG_IP_NF_NAT_AMANDA=3Dm=0A=
+CONFIG_IP_NF_NAT_PPTP=3Dm=0A=
+CONFIG_IP_NF_MANGLE=3Dm=0A=
+CONFIG_IP_NF_TARGET_TOS=3Dm=0A=
+CONFIG_IP_NF_TARGET_ECN=3Dm=0A=
+CONFIG_IP_NF_TARGET_DSCP=3Dm=0A=
+CONFIG_IP_NF_TARGET_TTL=3Dm=0A=
+CONFIG_IP_NF_TARGET_CLUSTERIP=3Dm=0A=
+CONFIG_IP_NF_RAW=3Dm=0A=
+CONFIG_IP_NF_ARPTABLES=3Dm=0A=
+CONFIG_IP_NF_ARPFILTER=3Dm=0A=
+CONFIG_IP_NF_ARP_MANGLE=3Dm=0A=
+=0A=
+#=0A=
+# DCCP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_DCCP is not set=0A=
+=0A=
+#=0A=
+# SCTP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_SCTP is not set=0A=
+=0A=
+#=0A=
+# TIPC Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_TIPC is not set=0A=
+# CONFIG_ATM is not set=0A=
+# CONFIG_BRIDGE is not set=0A=
+# CONFIG_VLAN_8021Q is not set=0A=
+# CONFIG_DECNET is not set=0A=
+# CONFIG_LLC2 is not set=0A=
+# CONFIG_IPX is not set=0A=
+# CONFIG_ATALK is not set=0A=
+# CONFIG_X25 is not set=0A=
+# CONFIG_LAPB is not set=0A=
+# CONFIG_NET_DIVERT is not set=0A=
+# CONFIG_ECONET is not set=0A=
+# CONFIG_WAN_ROUTER is not set=0A=
+=0A=
+#=0A=
+# QoS and/or fair queueing=0A=
+#=0A=
+CONFIG_NET_SCHED=3Dy=0A=
+# CONFIG_NET_SCH_CLK_JIFFIES is not set=0A=
+CONFIG_NET_SCH_CLK_GETTIMEOFDAY=3Dy=0A=
+# CONFIG_NET_SCH_CLK_CPU is not set=0A=
+=0A=
+#=0A=
+# Queueing/Scheduling=0A=
+#=0A=
+CONFIG_NET_SCH_CBQ=3Dm=0A=
+CONFIG_NET_SCH_HTB=3Dm=0A=
+CONFIG_NET_SCH_HFSC=3Dm=0A=
+CONFIG_NET_SCH_PRIO=3Dm=0A=
+CONFIG_NET_SCH_RED=3Dm=0A=
+CONFIG_NET_SCH_SFQ=3Dm=0A=
+CONFIG_NET_SCH_TEQL=3Dm=0A=
+CONFIG_NET_SCH_TBF=3Dm=0A=
+CONFIG_NET_SCH_GRED=3Dm=0A=
+CONFIG_NET_SCH_DSMARK=3Dm=0A=
+CONFIG_NET_SCH_NETEM=3Dm=0A=
+CONFIG_NET_SCH_INGRESS=3Dm=0A=
+=0A=
+#=0A=
+# Classification=0A=
+#=0A=
+CONFIG_NET_CLS=3Dy=0A=
+CONFIG_NET_CLS_BASIC=3Dm=0A=
+CONFIG_NET_CLS_TCINDEX=3Dm=0A=
+CONFIG_NET_CLS_ROUTE4=3Dm=0A=
+CONFIG_NET_CLS_ROUTE=3Dy=0A=
+CONFIG_NET_CLS_FW=3Dm=0A=
+CONFIG_NET_CLS_U32=3Dm=0A=
+# CONFIG_CLS_U32_PERF is not set=0A=
+# CONFIG_CLS_U32_MARK is not set=0A=
+CONFIG_NET_CLS_RSVP=3Dm=0A=
+CONFIG_NET_CLS_RSVP6=3Dm=0A=
+# CONFIG_NET_EMATCH is not set=0A=
+# CONFIG_NET_CLS_ACT is not set=0A=
+CONFIG_NET_CLS_POLICE=3Dy=0A=
+# CONFIG_NET_CLS_IND is not set=0A=
+CONFIG_NET_ESTIMATOR=3Dy=0A=
+=0A=
+#=0A=
+# Network testing=0A=
+#=0A=
+# CONFIG_NET_PKTGEN is not set=0A=
+# CONFIG_HAMRADIO is not set=0A=
+# CONFIG_IRDA is not set=0A=
+# CONFIG_BT is not set=0A=
+# CONFIG_IEEE80211 is not set=0A=
+=0A=
+#=0A=
+# Device Drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Generic Driver Options=0A=
+#=0A=
+CONFIG_STANDALONE=3Dy=0A=
+CONFIG_PREVENT_FIRMWARE_BUILD=3Dy=0A=
+# CONFIG_FW_LOADER is not set=0A=
+=0A=
+#=0A=
+# Connector - unified userspace <-> kernelspace linker=0A=
+#=0A=
+# CONFIG_CONNECTOR is not set=0A=
+=0A=
+#=0A=
+# Memory Technology Devices (MTD)=0A=
+#=0A=
+# CONFIG_MTD is not set=0A=
+=0A=
+#=0A=
+# Parallel port support=0A=
+#=0A=
+# CONFIG_PARPORT is not set=0A=
+=0A=
+#=0A=
+# Plug and Play support=0A=
+#=0A=
+=0A=
+#=0A=
+# Block devices=0A=
+#=0A=
+# CONFIG_BLK_CPQ_DA is not set=0A=
+# CONFIG_BLK_CPQ_CISS_DA is not set=0A=
+# CONFIG_BLK_DEV_DAC960 is not set=0A=
+# CONFIG_BLK_DEV_UMEM is not set=0A=
+# CONFIG_BLK_DEV_COW_COMMON is not set=0A=
+# CONFIG_BLK_DEV_LOOP is not set=0A=
+# CONFIG_BLK_DEV_NBD is not set=0A=
+# CONFIG_BLK_DEV_SX8 is not set=0A=
+# CONFIG_BLK_DEV_RAM is not set=0A=
+CONFIG_BLK_DEV_RAM_COUNT=3D16=0A=
+# CONFIG_CDROM_PKTCDVD is not set=0A=
+# CONFIG_ATA_OVER_ETH is not set=0A=
+=0A=
+#=0A=
+# ATA/ATAPI/MFM/RLL support=0A=
+#=0A=
+# CONFIG_IDE is not set=0A=
+=0A=
+#=0A=
+# SCSI device support=0A=
+#=0A=
+# CONFIG_RAID_ATTRS is not set=0A=
+# CONFIG_SCSI is not set=0A=
+=0A=
+#=0A=
+# Multi-device support (RAID and LVM)=0A=
+#=0A=
+# CONFIG_MD is not set=0A=
+=0A=
+#=0A=
+# Fusion MPT device support=0A=
+#=0A=
+# CONFIG_FUSION is not set=0A=
+=0A=
+#=0A=
+# IEEE 1394 (FireWire) support=0A=
+#=0A=
+# CONFIG_IEEE1394 is not set=0A=
+=0A=
+#=0A=
+# I2O device support=0A=
+#=0A=
+# CONFIG_I2O is not set=0A=
+=0A=
+#=0A=
+# Network device support=0A=
+#=0A=
+CONFIG_NETDEVICES=3Dy=0A=
+# CONFIG_DUMMY is not set=0A=
+# CONFIG_BONDING is not set=0A=
+# CONFIG_EQUALIZER is not set=0A=
+# CONFIG_TUN is not set=0A=
+=0A=
+#=0A=
+# ARCnet devices=0A=
+#=0A=
+# CONFIG_ARCNET is not set=0A=
+=0A=
+#=0A=
+# PHY device support=0A=
+#=0A=
+CONFIG_PHYLIB=3Dm=0A=
+=0A=
+#=0A=
+# MII PHY device drivers=0A=
+#=0A=
+CONFIG_MARVELL_PHY=3Dm=0A=
+CONFIG_DAVICOM_PHY=3Dm=0A=
+CONFIG_QSEMI_PHY=3Dm=0A=
+CONFIG_LXT_PHY=3Dm=0A=
+CONFIG_CICADA_PHY=3Dm=0A=
+=0A=
+#=0A=
+# Ethernet (10 or 100Mbit)=0A=
+#=0A=
+CONFIG_NET_ETHERNET=3Dy=0A=
+CONFIG_MII=3Dy=0A=
+CONFIG_IDT_RC32365_ETH=3Dy=0A=
+# CONFIG_HAPPYMEAL is not set=0A=
+# CONFIG_SUNGEM is not set=0A=
+# CONFIG_CASSINI is not set=0A=
+# CONFIG_NET_VENDOR_3COM is not set=0A=
+# CONFIG_DM9000 is not set=0A=
+=0A=
+#=0A=
+# Tulip family network device support=0A=
+#=0A=
+# CONFIG_NET_TULIP is not set=0A=
+# CONFIG_HP100 is not set=0A=
+CONFIG_NET_PCI=3Dy=0A=
+# CONFIG_PCNET32 is not set=0A=
+# CONFIG_AMD8111_ETH is not set=0A=
+# CONFIG_ADAPTEC_STARFIRE is not set=0A=
+# CONFIG_B44 is not set=0A=
+# CONFIG_FORCEDETH is not set=0A=
+# CONFIG_DGRS is not set=0A=
+# CONFIG_EEPRO100 is not set=0A=
+CONFIG_E100=3Dy=0A=
+# CONFIG_FEALNX is not set=0A=
+# CONFIG_NATSEMI is not set=0A=
+# CONFIG_NE2K_PCI is not set=0A=
+# CONFIG_8139CP is not set=0A=
+# CONFIG_8139TOO is not set=0A=
+# CONFIG_SIS900 is not set=0A=
+# CONFIG_EPIC100 is not set=0A=
+# CONFIG_SUNDANCE is not set=0A=
+# CONFIG_TLAN is not set=0A=
+# CONFIG_VIA_RHINE is not set=0A=
+# CONFIG_LAN_SAA9730 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (1000 Mbit)=0A=
+#=0A=
+# CONFIG_ACENIC is not set=0A=
+# CONFIG_DL2K is not set=0A=
+# CONFIG_E1000 is not set=0A=
+# CONFIG_NS83820 is not set=0A=
+# CONFIG_HAMACHI is not set=0A=
+# CONFIG_YELLOWFIN is not set=0A=
+# CONFIG_R8169 is not set=0A=
+# CONFIG_SIS190 is not set=0A=
+# CONFIG_SKGE is not set=0A=
+# CONFIG_SKY2 is not set=0A=
+# CONFIG_SK98LIN is not set=0A=
+# CONFIG_VIA_VELOCITY is not set=0A=
+# CONFIG_TIGON3 is not set=0A=
+# CONFIG_BNX2 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (10000 Mbit)=0A=
+#=0A=
+# CONFIG_CHELSIO_T1 is not set=0A=
+# CONFIG_IXGB is not set=0A=
+# CONFIG_S2IO is not set=0A=
+=0A=
+#=0A=
+# Token Ring devices=0A=
+#=0A=
+# CONFIG_TR is not set=0A=
+=0A=
+#=0A=
+# Wireless LAN (non-hamradio)=0A=
+#=0A=
+# CONFIG_NET_RADIO is not set=0A=
+=0A=
+#=0A=
+# Wan interfaces=0A=
+#=0A=
+# CONFIG_WAN is not set=0A=
+# CONFIG_FDDI is not set=0A=
+# CONFIG_HIPPI is not set=0A=
+# CONFIG_PPP is not set=0A=
+# CONFIG_SLIP is not set=0A=
+# CONFIG_SHAPER is not set=0A=
+# CONFIG_NETCONSOLE is not set=0A=
+# CONFIG_NETPOLL is not set=0A=
+# CONFIG_NET_POLL_CONTROLLER is not set=0A=
+=0A=
+#=0A=
+# ISDN subsystem=0A=
+#=0A=
+# CONFIG_ISDN is not set=0A=
+=0A=
+#=0A=
+# Telephony Support=0A=
+#=0A=
+# CONFIG_PHONE is not set=0A=
+=0A=
+#=0A=
+# Input device support=0A=
+#=0A=
+CONFIG_INPUT=3Dy=0A=
+=0A=
+#=0A=
+# Userland interfaces=0A=
+#=0A=
+# CONFIG_INPUT_MOUSEDEV is not set=0A=
+# CONFIG_INPUT_JOYDEV is not set=0A=
+# CONFIG_INPUT_TSDEV is not set=0A=
+# CONFIG_INPUT_EVDEV is not set=0A=
+# CONFIG_INPUT_EVBUG is not set=0A=
+=0A=
+#=0A=
+# Input Device Drivers=0A=
+#=0A=
+# CONFIG_INPUT_KEYBOARD is not set=0A=
+# CONFIG_INPUT_MOUSE is not set=0A=
+# CONFIG_INPUT_JOYSTICK is not set=0A=
+# CONFIG_INPUT_TOUCHSCREEN is not set=0A=
+# CONFIG_INPUT_MISC is not set=0A=
+=0A=
+#=0A=
+# Hardware I/O ports=0A=
+#=0A=
+# CONFIG_SERIO is not set=0A=
+# CONFIG_GAMEPORT is not set=0A=
+=0A=
+#=0A=
+# Character devices=0A=
+#=0A=
+CONFIG_VT=3Dy=0A=
+CONFIG_VT_CONSOLE=3Dy=0A=
+CONFIG_HW_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_NONSTANDARD is not set=0A=
+=0A=
+#=0A=
+# Serial drivers=0A=
+#=0A=
+CONFIG_SERIAL_8250=3Dy=0A=
+CONFIG_SERIAL_8250_CONSOLE=3Dy=0A=
+CONFIG_SERIAL_8250_NR_UARTS=3D4=0A=
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3D4=0A=
+# CONFIG_SERIAL_8250_EXTENDED is not set=0A=
+=0A=
+#=0A=
+# Non-8250 serial port support=0A=
+#=0A=
+CONFIG_SERIAL_CORE=3Dy=0A=
+CONFIG_SERIAL_CORE_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_JSM is not set=0A=
+CONFIG_UNIX98_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTY_COUNT=3D256=0A=
+=0A=
+#=0A=
+# IPMI=0A=
+#=0A=
+# CONFIG_IPMI_HANDLER is not set=0A=
+=0A=
+#=0A=
+# Watchdog Cards=0A=
+#=0A=
+# CONFIG_WATCHDOG is not set=0A=
+# CONFIG_RTC is not set=0A=
+# CONFIG_GEN_RTC is not set=0A=
+# CONFIG_DTLK is not set=0A=
+# CONFIG_R3964 is not set=0A=
+# CONFIG_APPLICOM is not set=0A=
+=0A=
+#=0A=
+# Ftape, the floppy tape device driver=0A=
+#=0A=
+# CONFIG_DRM is not set=0A=
+# CONFIG_RAW_DRIVER is not set=0A=
+=0A=
+#=0A=
+# TPM devices=0A=
+#=0A=
+# CONFIG_TCG_TPM is not set=0A=
+# CONFIG_TELCLOCK is not set=0A=
+=0A=
+#=0A=
+# I2C support=0A=
+#=0A=
+CONFIG_I2C=3Dy=0A=
+CONFIG_I2C_CHARDEV=3Dy=0A=
+=0A=
+#=0A=
+# I2C Algorithms=0A=
+#=0A=
+# CONFIG_I2C_ALGOBIT is not set=0A=
+# CONFIG_I2C_ALGOPCF is not set=0A=
+# CONFIG_I2C_ALGOPCA is not set=0A=
+=0A=
+#=0A=
+# I2C Hardware Bus support=0A=
+#=0A=
+# CONFIG_I2C_ALI1535 is not set=0A=
+# CONFIG_I2C_ALI1563 is not set=0A=
+# CONFIG_I2C_ALI15X3 is not set=0A=
+# CONFIG_I2C_AMD756 is not set=0A=
+# CONFIG_I2C_AMD8111 is not set=0A=
+# CONFIG_I2C_I801 is not set=0A=
+# CONFIG_I2C_I810 is not set=0A=
+# CONFIG_I2C_PIIX4 is not set=0A=
+# CONFIG_I2C_NFORCE2 is not set=0A=
+# CONFIG_I2C_PARPORT_LIGHT is not set=0A=
+# CONFIG_I2C_PROSAVAGE is not set=0A=
+# CONFIG_I2C_SAVAGE4 is not set=0A=
+# CONFIG_SCx200_ACB is not set=0A=
+# CONFIG_I2C_SIS5595 is not set=0A=
+# CONFIG_I2C_SIS630 is not set=0A=
+# CONFIG_I2C_SIS96X is not set=0A=
+# CONFIG_I2C_STUB is not set=0A=
+# CONFIG_I2C_VIA is not set=0A=
+# CONFIG_I2C_VIAPRO is not set=0A=
+# CONFIG_I2C_VOODOO3 is not set=0A=
+# CONFIG_I2C_PCA_ISA is not set=0A=
+=0A=
+#=0A=
+# Miscellaneous I2C Chip support=0A=
+#=0A=
+# CONFIG_SENSORS_DS1337 is not set=0A=
+# CONFIG_SENSORS_DS1374 is not set=0A=
+# CONFIG_SENSORS_EEPROM is not set=0A=
+# CONFIG_SENSORS_PCF8574 is not set=0A=
+# CONFIG_SENSORS_PCA9539 is not set=0A=
+# CONFIG_SENSORS_PCF8591 is not set=0A=
+# CONFIG_SENSORS_RTC8564 is not set=0A=
+# CONFIG_SENSORS_MAX6875 is not set=0A=
+# CONFIG_RTC_X1205_I2C is not set=0A=
+# CONFIG_I2C_DEBUG_CORE is not set=0A=
+# CONFIG_I2C_DEBUG_ALGO is not set=0A=
+# CONFIG_I2C_DEBUG_BUS is not set=0A=
+# CONFIG_I2C_DEBUG_CHIP is not set=0A=
+=0A=
+#=0A=
+# SPI support=0A=
+#=0A=
+# CONFIG_SPI is not set=0A=
+# CONFIG_SPI_MASTER is not set=0A=
+=0A=
+#=0A=
+# Dallas's 1-wire bus=0A=
+#=0A=
+# CONFIG_W1 is not set=0A=
+=0A=
+#=0A=
+# Hardware Monitoring support=0A=
+#=0A=
+# CONFIG_HWMON is not set=0A=
+# CONFIG_HWMON_VID is not set=0A=
+=0A=
+#=0A=
+# Misc devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia Capabilities Port drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia devices=0A=
+#=0A=
+# CONFIG_VIDEO_DEV is not set=0A=
+=0A=
+#=0A=
+# Digital Video Broadcasting Devices=0A=
+#=0A=
+# CONFIG_DVB is not set=0A=
+=0A=
+#=0A=
+# Graphics support=0A=
+#=0A=
+# CONFIG_FB is not set=0A=
+=0A=
+#=0A=
+# Console display driver support=0A=
+#=0A=
+# CONFIG_VGA_CONSOLE is not set=0A=
+CONFIG_DUMMY_CONSOLE=3Dy=0A=
+=0A=
+#=0A=
+# Sound=0A=
+#=0A=
+# CONFIG_SOUND is not set=0A=
+=0A=
+#=0A=
+# USB support=0A=
+#=0A=
+CONFIG_USB_ARCH_HAS_HCD=3Dy=0A=
+CONFIG_USB_ARCH_HAS_OHCI=3Dy=0A=
+# CONFIG_USB is not set=0A=
+=0A=
+#=0A=
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'=0A=
+#=0A=
+=0A=
+#=0A=
+# USB Gadget Support=0A=
+#=0A=
+# CONFIG_USB_GADGET is not set=0A=
+=0A=
+#=0A=
+# MMC/SD Card support=0A=
+#=0A=
+# CONFIG_MMC is not set=0A=
+=0A=
+#=0A=
+# InfiniBand support=0A=
+#=0A=
+# CONFIG_INFINIBAND is not set=0A=
+=0A=
+#=0A=
+# SN Devices=0A=
+#=0A=
+=0A=
+#=0A=
+# EDAC - error detection and reporting (RAS)=0A=
+#=0A=
+=0A=
+#=0A=
+# File systems=0A=
+#=0A=
+CONFIG_EXT2_FS=3Dy=0A=
+# CONFIG_EXT2_FS_XATTR is not set=0A=
+# CONFIG_EXT2_FS_XIP is not set=0A=
+# CONFIG_EXT3_FS is not set=0A=
+# CONFIG_REISERFS_FS is not set=0A=
+# CONFIG_JFS_FS is not set=0A=
+# CONFIG_FS_POSIX_ACL is not set=0A=
+# CONFIG_XFS_FS is not set=0A=
+# CONFIG_OCFS2_FS is not set=0A=
+# CONFIG_MINIX_FS is not set=0A=
+# CONFIG_ROMFS_FS is not set=0A=
+# CONFIG_INOTIFY is not set=0A=
+# CONFIG_QUOTA is not set=0A=
+# CONFIG_DNOTIFY is not set=0A=
+# CONFIG_AUTOFS_FS is not set=0A=
+# CONFIG_AUTOFS4_FS is not set=0A=
+# CONFIG_FUSE_FS is not set=0A=
+=0A=
+#=0A=
+# CD-ROM/DVD Filesystems=0A=
+#=0A=
+# CONFIG_ISO9660_FS is not set=0A=
+# CONFIG_UDF_FS is not set=0A=
+=0A=
+#=0A=
+# DOS/FAT/NT Filesystems=0A=
+#=0A=
+# CONFIG_MSDOS_FS is not set=0A=
+# CONFIG_VFAT_FS is not set=0A=
+# CONFIG_NTFS_FS is not set=0A=
+=0A=
+#=0A=
+# Pseudo filesystems=0A=
+#=0A=
+CONFIG_PROC_FS=3Dy=0A=
+CONFIG_PROC_KCORE=3Dy=0A=
+CONFIG_SYSFS=3Dy=0A=
+# CONFIG_TMPFS is not set=0A=
+# CONFIG_HUGETLB_PAGE is not set=0A=
+CONFIG_RAMFS=3Dy=0A=
+# CONFIG_RELAYFS_FS is not set=0A=
+# CONFIG_CONFIGFS_FS is not set=0A=
+=0A=
+#=0A=
+# Miscellaneous filesystems=0A=
+#=0A=
+# CONFIG_ADFS_FS is not set=0A=
+# CONFIG_AFFS_FS is not set=0A=
+# CONFIG_HFS_FS is not set=0A=
+# CONFIG_HFSPLUS_FS is not set=0A=
+# CONFIG_BEFS_FS is not set=0A=
+# CONFIG_BFS_FS is not set=0A=
+# CONFIG_EFS_FS is not set=0A=
+# CONFIG_CRAMFS is not set=0A=
+# CONFIG_VXFS_FS is not set=0A=
+# CONFIG_HPFS_FS is not set=0A=
+# CONFIG_QNX4FS_FS is not set=0A=
+# CONFIG_SYSV_FS is not set=0A=
+# CONFIG_UFS_FS is not set=0A=
+=0A=
+#=0A=
+# Network File Systems=0A=
+#=0A=
+# CONFIG_NFS_FS is not set=0A=
+# CONFIG_NFSD is not set=0A=
+# CONFIG_SMB_FS is not set=0A=
+# CONFIG_CIFS is not set=0A=
+# CONFIG_NCP_FS is not set=0A=
+# CONFIG_CODA_FS is not set=0A=
+# CONFIG_AFS_FS is not set=0A=
+# CONFIG_9P_FS is not set=0A=
+=0A=
+#=0A=
+# Partition Types=0A=
+#=0A=
+# CONFIG_PARTITION_ADVANCED is not set=0A=
+CONFIG_MSDOS_PARTITION=3Dy=0A=
+=0A=
+#=0A=
+# Native Language Support=0A=
+#=0A=
+# CONFIG_NLS is not set=0A=
+=0A=
+#=0A=
+# Profiling support=0A=
+#=0A=
+# CONFIG_PROFILING is not set=0A=
+=0A=
+#=0A=
+# Kernel hacking=0A=
+#=0A=
+# CONFIG_PRINTK_TIME is not set=0A=
+# CONFIG_MAGIC_SYSRQ is not set=0A=
+# CONFIG_DEBUG_KERNEL is not set=0A=
+CONFIG_LOG_BUF_SHIFT=3D14=0A=
+CONFIG_CROSSCOMPILE=3Dy=0A=
+CONFIG_CMDLINE=3D""=0A=
+=0A=
+#=0A=
+# Security options=0A=
+#=0A=
+# CONFIG_KEYS is not set=0A=
+# CONFIG_SECURITY is not set=0A=
+=0A=
+#=0A=
+# Cryptographic options=0A=
+#=0A=
+# CONFIG_CRYPTO is not set=0A=
+=0A=
+#=0A=
+# Hardware crypto devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Library routines=0A=
+#=0A=
+CONFIG_CRC_CCITT=3Dy=0A=
+CONFIG_CRC16=3Dm=0A=
+CONFIG_CRC32=3Dy=0A=
+# CONFIG_LIBCRC32C is not set=0A=
+CONFIG_TEXTSEARCH=3Dy=0A=
+CONFIG_TEXTSEARCH_KMP=3Dm=0A=
+CONFIG_TEXTSEARCH_BM=3Dm=0A=
+CONFIG_TEXTSEARCH_FSM=3Dm=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/configs/rc32434_defconfig =
idtlinux/arch/mips/configs/rc32434_defconfig=0A=
--- linux-2.6.16-rc5/arch/mips/configs/rc32434_defconfig	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/configs/rc32434_defconfig	2006-03-09 =
16:25:45.000000000 -0800=0A=
@@ -0,0 +1,1032 @@=0A=
+#=0A=
+# Automatically generated make config: don't edit=0A=
+# Linux kernel version: 2.6.16-rc5=0A=
+# Thu Mar  9 11:35:54 2006=0A=
+#=0A=
+CONFIG_MIPS=3Dy=0A=
+=0A=
+#=0A=
+# Machine selection=0A=
+#=0A=
+# CONFIG_MIPS_MTX1 is not set=0A=
+# CONFIG_MIPS_BOSPORUS is not set=0A=
+# CONFIG_MIPS_PB1000 is not set=0A=
+# CONFIG_MIPS_PB1100 is not set=0A=
+# CONFIG_MIPS_PB1500 is not set=0A=
+# CONFIG_MIPS_PB1550 is not set=0A=
+# CONFIG_MIPS_PB1200 is not set=0A=
+# CONFIG_MIPS_DB1000 is not set=0A=
+# CONFIG_MIPS_DB1100 is not set=0A=
+# CONFIG_MIPS_DB1500 is not set=0A=
+# CONFIG_MIPS_DB1550 is not set=0A=
+# CONFIG_MIPS_DB1200 is not set=0A=
+# CONFIG_MIPS_MIRAGE is not set=0A=
+# CONFIG_MIPS_COBALT is not set=0A=
+# CONFIG_MACH_DECSTATION is not set=0A=
+# CONFIG_MIPS_EV64120 is not set=0A=
+# CONFIG_MIPS_EV96100 is not set=0A=
+# CONFIG_MIPS_IVR is not set=0A=
+CONFIG_IDT_BOARDS=3Dy=0A=
+# CONFIG_MIPS_ITE8172 is not set=0A=
+# CONFIG_MACH_JAZZ is not set=0A=
+# CONFIG_LASAT is not set=0A=
+# CONFIG_MIPS_ATLAS is not set=0A=
+# CONFIG_MIPS_MALTA is not set=0A=
+# CONFIG_MIPS_SEAD is not set=0A=
+# CONFIG_MIPS_SIM is not set=0A=
+# CONFIG_MOMENCO_JAGUAR_ATX is not set=0A=
+# CONFIG_MOMENCO_OCELOT is not set=0A=
+# CONFIG_MOMENCO_OCELOT_3 is not set=0A=
+# CONFIG_MOMENCO_OCELOT_C is not set=0A=
+# CONFIG_MOMENCO_OCELOT_G is not set=0A=
+# CONFIG_MIPS_XXS1500 is not set=0A=
+# CONFIG_PNX8550_V2PCI is not set=0A=
+# CONFIG_PNX8550_JBS is not set=0A=
+# CONFIG_DDB5074 is not set=0A=
+# CONFIG_DDB5476 is not set=0A=
+# CONFIG_DDB5477 is not set=0A=
+# CONFIG_MACH_VR41XX is not set=0A=
+# CONFIG_PMC_YOSEMITE is not set=0A=
+# CONFIG_QEMU is not set=0A=
+# CONFIG_SGI_IP22 is not set=0A=
+# CONFIG_SGI_IP27 is not set=0A=
+# CONFIG_SGI_IP32 is not set=0A=
+# CONFIG_SIBYTE_BIGSUR is not set=0A=
+# CONFIG_SIBYTE_SWARM is not set=0A=
+# CONFIG_SIBYTE_SENTOSA is not set=0A=
+# CONFIG_SIBYTE_RHONE is not set=0A=
+# CONFIG_SIBYTE_CARMEL is not set=0A=
+# CONFIG_SIBYTE_PTSWARM is not set=0A=
+# CONFIG_SIBYTE_LITTLESUR is not set=0A=
+# CONFIG_SIBYTE_CRHINE is not set=0A=
+# CONFIG_SIBYTE_CRHONE is not set=0A=
+# CONFIG_SNI_RM200_PCI is not set=0A=
+# CONFIG_TOSHIBA_JMR3927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4938 is not set=0A=
+# CONFIG_IDT_EB438 is not set=0A=
+CONFIG_IDT_EB434=3Dy=0A=
+# CONFIG_IDT_EB365 is not set=0A=
+# CONFIG_IDT_EB355 is not set=0A=
+# CONFIG_IDT_S334 is not set=0A=
+CONFIG_IDT_BOARD_FREQ=3D200000000=0A=
+CONFIG_IDT_ZIMAGE_ADDR=3D0x9b000000=0A=
+# CONFIG_IDT_BOOT_NVRAM is not set=0A=
+CONFIG_RWSEM_GENERIC_SPINLOCK=3Dy=0A=
+CONFIG_GENERIC_CALIBRATE_DELAY=3Dy=0A=
+CONFIG_DMA_NONCOHERENT=3Dy=0A=
+CONFIG_DMA_NEED_PCI_MAP_STATE=3Dy=0A=
+# CONFIG_CPU_BIG_ENDIAN is not set=0A=
+CONFIG_CPU_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_IRQ_CPU=3Dy=0A=
+CONFIG_SWAP_IO_SPACE=3Dy=0A=
+CONFIG_BOOT_ELF32=3Dy=0A=
+CONFIG_MIPS_L1_CACHE_SHIFT=3D5=0A=
+=0A=
+#=0A=
+# CPU selection=0A=
+#=0A=
+CONFIG_CPU_MIPS32_R1=3Dy=0A=
+# CONFIG_CPU_MIPS32_R2 is not set=0A=
+# CONFIG_CPU_MIPS64_R1 is not set=0A=
+# CONFIG_CPU_MIPS64_R2 is not set=0A=
+# CONFIG_CPU_R3000 is not set=0A=
+# CONFIG_CPU_TX39XX is not set=0A=
+# CONFIG_CPU_VR41XX is not set=0A=
+# CONFIG_CPU_R4300 is not set=0A=
+# CONFIG_CPU_R4X00 is not set=0A=
+# CONFIG_CPU_TX49XX is not set=0A=
+# CONFIG_CPU_R5000 is not set=0A=
+# CONFIG_CPU_R5432 is not set=0A=
+# CONFIG_CPU_R6000 is not set=0A=
+# CONFIG_CPU_NEVADA is not set=0A=
+# CONFIG_CPU_R8000 is not set=0A=
+# CONFIG_CPU_R10000 is not set=0A=
+# CONFIG_CPU_RM7000 is not set=0A=
+# CONFIG_CPU_RM9000 is not set=0A=
+# CONFIG_CPU_SB1 is not set=0A=
+CONFIG_SYS_HAS_CPU_MIPS32_R1=3Dy=0A=
+CONFIG_CPU_MIPS32=3Dy=0A=
+CONFIG_CPU_MIPSR1=3Dy=0A=
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+=0A=
+#=0A=
+# Kernel type=0A=
+#=0A=
+CONFIG_32BIT=3Dy=0A=
+# CONFIG_64BIT is not set=0A=
+CONFIG_PAGE_SIZE_4KB=3Dy=0A=
+# CONFIG_PAGE_SIZE_8KB is not set=0A=
+# CONFIG_PAGE_SIZE_16KB is not set=0A=
+# CONFIG_PAGE_SIZE_64KB is not set=0A=
+CONFIG_CPU_HAS_PREFETCH=3Dy=0A=
+# CONFIG_MIPS_MT is not set=0A=
+# CONFIG_64BIT_PHYS_ADDR is not set=0A=
+CONFIG_CPU_ADVANCED=3Dy=0A=
+CONFIG_CPU_HAS_LLSC=3Dy=0A=
+# CONFIG_CPU_HAS_WB is not set=0A=
+CONFIG_CPU_HAS_SYNC=3Dy=0A=
+CONFIG_GENERIC_HARDIRQS=3Dy=0A=
+CONFIG_GENERIC_IRQ_PROBE=3Dy=0A=
+CONFIG_ARCH_FLATMEM_ENABLE=3Dy=0A=
+CONFIG_SELECT_MEMORY_MODEL=3Dy=0A=
+CONFIG_FLATMEM_MANUAL=3Dy=0A=
+# CONFIG_DISCONTIGMEM_MANUAL is not set=0A=
+# CONFIG_SPARSEMEM_MANUAL is not set=0A=
+CONFIG_FLATMEM=3Dy=0A=
+CONFIG_FLAT_NODE_MEM_MAP=3Dy=0A=
+# CONFIG_SPARSEMEM_STATIC is not set=0A=
+CONFIG_SPLIT_PTLOCK_CPUS=3D4=0A=
+CONFIG_PREEMPT_NONE=3Dy=0A=
+# CONFIG_PREEMPT_VOLUNTARY is not set=0A=
+# CONFIG_PREEMPT is not set=0A=
+=0A=
+#=0A=
+# Code maturity level options=0A=
+#=0A=
+CONFIG_EXPERIMENTAL=3Dy=0A=
+CONFIG_BROKEN_ON_SMP=3Dy=0A=
+CONFIG_INIT_ENV_ARG_LIMIT=3D32=0A=
+=0A=
+#=0A=
+# General setup=0A=
+#=0A=
+CONFIG_LOCALVERSION=3D""=0A=
+CONFIG_LOCALVERSION_AUTO=3Dy=0A=
+# CONFIG_SWAP is not set=0A=
+CONFIG_SYSVIPC=3Dy=0A=
+# CONFIG_POSIX_MQUEUE is not set=0A=
+# CONFIG_BSD_PROCESS_ACCT is not set=0A=
+CONFIG_SYSCTL=3Dy=0A=
+# CONFIG_AUDIT is not set=0A=
+CONFIG_IKCONFIG=3Dy=0A=
+# CONFIG_IKCONFIG_PROC is not set=0A=
+CONFIG_INITRAMFS_SOURCE=3D""=0A=
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set=0A=
+CONFIG_EMBEDDED=3Dy=0A=
+# CONFIG_KALLSYMS is not set=0A=
+# CONFIG_HOTPLUG is not set=0A=
+CONFIG_PRINTK=3Dy=0A=
+CONFIG_BUG=3Dy=0A=
+CONFIG_ELF_CORE=3Dy=0A=
+# CONFIG_BASE_FULL is not set=0A=
+# CONFIG_FUTEX is not set=0A=
+# CONFIG_EPOLL is not set=0A=
+CONFIG_SHMEM=3Dy=0A=
+CONFIG_CC_ALIGN_FUNCTIONS=3D0=0A=
+CONFIG_CC_ALIGN_LABELS=3D0=0A=
+CONFIG_CC_ALIGN_LOOPS=3D0=0A=
+CONFIG_CC_ALIGN_JUMPS=3D0=0A=
+# CONFIG_SLAB is not set=0A=
+# CONFIG_TINY_SHMEM is not set=0A=
+CONFIG_BASE_SMALL=3D1=0A=
+CONFIG_SLOB=3Dy=0A=
+=0A=
+#=0A=
+# Loadable module support=0A=
+#=0A=
+CONFIG_MODULES=3Dy=0A=
+CONFIG_MODULE_UNLOAD=3Dy=0A=
+# CONFIG_MODULE_FORCE_UNLOAD is not set=0A=
+CONFIG_OBSOLETE_MODPARM=3Dy=0A=
+# CONFIG_MODVERSIONS is not set=0A=
+# CONFIG_MODULE_SRCVERSION_ALL is not set=0A=
+# CONFIG_KMOD is not set=0A=
+=0A=
+#=0A=
+# Block layer=0A=
+#=0A=
+# CONFIG_LBD is not set=0A=
+=0A=
+#=0A=
+# IO Schedulers=0A=
+#=0A=
+CONFIG_IOSCHED_NOOP=3Dy=0A=
+CONFIG_IOSCHED_AS=3Dy=0A=
+CONFIG_IOSCHED_DEADLINE=3Dy=0A=
+CONFIG_IOSCHED_CFQ=3Dy=0A=
+CONFIG_DEFAULT_AS=3Dy=0A=
+# CONFIG_DEFAULT_DEADLINE is not set=0A=
+# CONFIG_DEFAULT_CFQ is not set=0A=
+# CONFIG_DEFAULT_NOOP is not set=0A=
+CONFIG_DEFAULT_IOSCHED=3D"anticipatory"=0A=
+=0A=
+#=0A=
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)=0A=
+#=0A=
+CONFIG_HW_HAS_PCI=3Dy=0A=
+CONFIG_PCI=3Dy=0A=
+CONFIG_PCI_LEGACY_PROC=3Dy=0A=
+CONFIG_MMU=3Dy=0A=
+=0A=
+#=0A=
+# PCCARD (PCMCIA/CardBus) support=0A=
+#=0A=
+# CONFIG_PCCARD is not set=0A=
+=0A=
+#=0A=
+# PCI Hotplug Support=0A=
+#=0A=
+# CONFIG_HOTPLUG_PCI is not set=0A=
+=0A=
+#=0A=
+# Executable file formats=0A=
+#=0A=
+CONFIG_BINFMT_ELF=3Dy=0A=
+# CONFIG_BINFMT_MISC is not set=0A=
+CONFIG_TRAD_SIGNALS=3Dy=0A=
+=0A=
+#=0A=
+# Networking=0A=
+#=0A=
+CONFIG_NET=3Dy=0A=
+=0A=
+#=0A=
+# Networking options=0A=
+#=0A=
+# CONFIG_NETDEBUG is not set=0A=
+CONFIG_PACKET=3Dy=0A=
+CONFIG_PACKET_MMAP=3Dy=0A=
+CONFIG_UNIX=3Dy=0A=
+CONFIG_XFRM=3Dy=0A=
+# CONFIG_XFRM_USER is not set=0A=
+CONFIG_NET_KEY=3Dy=0A=
+CONFIG_INET=3Dy=0A=
+CONFIG_IP_MULTICAST=3Dy=0A=
+# CONFIG_IP_ADVANCED_ROUTER is not set=0A=
+CONFIG_IP_FIB_HASH=3Dy=0A=
+CONFIG_IP_PNP=3Dy=0A=
+# CONFIG_IP_PNP_DHCP is not set=0A=
+# CONFIG_IP_PNP_BOOTP is not set=0A=
+# CONFIG_IP_PNP_RARP is not set=0A=
+# CONFIG_NET_IPIP is not set=0A=
+# CONFIG_NET_IPGRE is not set=0A=
+# CONFIG_IP_MROUTE is not set=0A=
+# CONFIG_ARPD is not set=0A=
+# CONFIG_SYN_COOKIES is not set=0A=
+# CONFIG_INET_AH is not set=0A=
+# CONFIG_INET_ESP is not set=0A=
+# CONFIG_INET_IPCOMP is not set=0A=
+# CONFIG_INET_TUNNEL is not set=0A=
+# CONFIG_INET_DIAG is not set=0A=
+# CONFIG_TCP_CONG_ADVANCED is not set=0A=
+CONFIG_TCP_CONG_BIC=3Dy=0A=
+=0A=
+#=0A=
+# IP: Virtual Server Configuration=0A=
+#=0A=
+CONFIG_IP_VS=3Dm=0A=
+# CONFIG_IP_VS_DEBUG is not set=0A=
+CONFIG_IP_VS_TAB_BITS=3D12=0A=
+=0A=
+#=0A=
+# IPVS transport protocol load balancing support=0A=
+#=0A=
+CONFIG_IP_VS_PROTO_TCP=3Dy=0A=
+CONFIG_IP_VS_PROTO_UDP=3Dy=0A=
+CONFIG_IP_VS_PROTO_ESP=3Dy=0A=
+CONFIG_IP_VS_PROTO_AH=3Dy=0A=
+=0A=
+#=0A=
+# IPVS scheduler=0A=
+#=0A=
+CONFIG_IP_VS_RR=3Dm=0A=
+CONFIG_IP_VS_WRR=3Dm=0A=
+CONFIG_IP_VS_LC=3Dm=0A=
+CONFIG_IP_VS_WLC=3Dm=0A=
+CONFIG_IP_VS_LBLC=3Dm=0A=
+CONFIG_IP_VS_LBLCR=3Dm=0A=
+CONFIG_IP_VS_DH=3Dm=0A=
+CONFIG_IP_VS_SH=3Dm=0A=
+CONFIG_IP_VS_SED=3Dm=0A=
+CONFIG_IP_VS_NQ=3Dm=0A=
+=0A=
+#=0A=
+# IPVS application helper=0A=
+#=0A=
+CONFIG_IP_VS_FTP=3Dm=0A=
+# CONFIG_IPV6 is not set=0A=
+CONFIG_NETFILTER=3Dy=0A=
+# CONFIG_NETFILTER_DEBUG is not set=0A=
+=0A=
+#=0A=
+# Core Netfilter Configuration=0A=
+#=0A=
+CONFIG_NETFILTER_NETLINK=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_QUEUE=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_LOG=3Dm=0A=
+CONFIG_NETFILTER_XTABLES=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_COMMENT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_DCCP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_HELPER=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LENGTH=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LIMIT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MAC=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_REALM=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_SCTP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STATE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STRING=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=3Dm=0A=
+=0A=
+#=0A=
+# IP: Netfilter Configuration=0A=
+#=0A=
+CONFIG_IP_NF_CONNTRACK=3Dm=0A=
+CONFIG_IP_NF_CT_ACCT=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_MARK=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_EVENTS=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_NETLINK=3Dm=0A=
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set=0A=
+CONFIG_IP_NF_FTP=3Dm=0A=
+CONFIG_IP_NF_IRC=3Dm=0A=
+# CONFIG_IP_NF_NETBIOS_NS is not set=0A=
+CONFIG_IP_NF_TFTP=3Dm=0A=
+CONFIG_IP_NF_AMANDA=3Dm=0A=
+CONFIG_IP_NF_PPTP=3Dm=0A=
+CONFIG_IP_NF_QUEUE=3Dm=0A=
+CONFIG_IP_NF_IPTABLES=3Dm=0A=
+CONFIG_IP_NF_MATCH_IPRANGE=3Dm=0A=
+CONFIG_IP_NF_MATCH_MULTIPORT=3Dm=0A=
+CONFIG_IP_NF_MATCH_TOS=3Dm=0A=
+CONFIG_IP_NF_MATCH_RECENT=3Dm=0A=
+CONFIG_IP_NF_MATCH_ECN=3Dm=0A=
+CONFIG_IP_NF_MATCH_DSCP=3Dm=0A=
+CONFIG_IP_NF_MATCH_AH_ESP=3Dm=0A=
+CONFIG_IP_NF_MATCH_TTL=3Dm=0A=
+CONFIG_IP_NF_MATCH_OWNER=3Dm=0A=
+CONFIG_IP_NF_MATCH_ADDRTYPE=3Dm=0A=
+CONFIG_IP_NF_MATCH_HASHLIMIT=3Dm=0A=
+CONFIG_IP_NF_MATCH_POLICY=3Dm=0A=
+CONFIG_IP_NF_FILTER=3Dm=0A=
+CONFIG_IP_NF_TARGET_REJECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_LOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_ULOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_TCPMSS=3Dm=0A=
+CONFIG_IP_NF_NAT=3Dm=0A=
+CONFIG_IP_NF_NAT_NEEDED=3Dy=0A=
+CONFIG_IP_NF_TARGET_MASQUERADE=3Dm=0A=
+CONFIG_IP_NF_TARGET_REDIRECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_NETMAP=3Dm=0A=
+CONFIG_IP_NF_TARGET_SAME=3Dm=0A=
+CONFIG_IP_NF_NAT_SNMP_BASIC=3Dm=0A=
+CONFIG_IP_NF_NAT_IRC=3Dm=0A=
+CONFIG_IP_NF_NAT_FTP=3Dm=0A=
+CONFIG_IP_NF_NAT_TFTP=3Dm=0A=
+CONFIG_IP_NF_NAT_AMANDA=3Dm=0A=
+CONFIG_IP_NF_NAT_PPTP=3Dm=0A=
+CONFIG_IP_NF_MANGLE=3Dm=0A=
+CONFIG_IP_NF_TARGET_TOS=3Dm=0A=
+CONFIG_IP_NF_TARGET_ECN=3Dm=0A=
+CONFIG_IP_NF_TARGET_DSCP=3Dm=0A=
+CONFIG_IP_NF_TARGET_TTL=3Dm=0A=
+CONFIG_IP_NF_TARGET_CLUSTERIP=3Dm=0A=
+CONFIG_IP_NF_RAW=3Dm=0A=
+CONFIG_IP_NF_ARPTABLES=3Dm=0A=
+CONFIG_IP_NF_ARPFILTER=3Dm=0A=
+CONFIG_IP_NF_ARP_MANGLE=3Dm=0A=
+=0A=
+#=0A=
+# DCCP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_DCCP is not set=0A=
+=0A=
+#=0A=
+# SCTP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_SCTP is not set=0A=
+=0A=
+#=0A=
+# TIPC Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_TIPC is not set=0A=
+# CONFIG_ATM is not set=0A=
+# CONFIG_BRIDGE is not set=0A=
+# CONFIG_VLAN_8021Q is not set=0A=
+# CONFIG_DECNET is not set=0A=
+# CONFIG_LLC2 is not set=0A=
+# CONFIG_IPX is not set=0A=
+# CONFIG_ATALK is not set=0A=
+# CONFIG_X25 is not set=0A=
+# CONFIG_LAPB is not set=0A=
+# CONFIG_NET_DIVERT is not set=0A=
+# CONFIG_ECONET is not set=0A=
+# CONFIG_WAN_ROUTER is not set=0A=
+=0A=
+#=0A=
+# QoS and/or fair queueing=0A=
+#=0A=
+CONFIG_NET_SCHED=3Dy=0A=
+# CONFIG_NET_SCH_CLK_JIFFIES is not set=0A=
+CONFIG_NET_SCH_CLK_GETTIMEOFDAY=3Dy=0A=
+# CONFIG_NET_SCH_CLK_CPU is not set=0A=
+=0A=
+#=0A=
+# Queueing/Scheduling=0A=
+#=0A=
+CONFIG_NET_SCH_CBQ=3Dm=0A=
+CONFIG_NET_SCH_HTB=3Dm=0A=
+CONFIG_NET_SCH_HFSC=3Dm=0A=
+CONFIG_NET_SCH_PRIO=3Dm=0A=
+CONFIG_NET_SCH_RED=3Dm=0A=
+CONFIG_NET_SCH_SFQ=3Dm=0A=
+CONFIG_NET_SCH_TEQL=3Dm=0A=
+CONFIG_NET_SCH_TBF=3Dm=0A=
+CONFIG_NET_SCH_GRED=3Dm=0A=
+CONFIG_NET_SCH_DSMARK=3Dm=0A=
+CONFIG_NET_SCH_NETEM=3Dm=0A=
+CONFIG_NET_SCH_INGRESS=3Dm=0A=
+=0A=
+#=0A=
+# Classification=0A=
+#=0A=
+CONFIG_NET_CLS=3Dy=0A=
+CONFIG_NET_CLS_BASIC=3Dm=0A=
+CONFIG_NET_CLS_TCINDEX=3Dm=0A=
+CONFIG_NET_CLS_ROUTE4=3Dm=0A=
+CONFIG_NET_CLS_ROUTE=3Dy=0A=
+CONFIG_NET_CLS_FW=3Dm=0A=
+CONFIG_NET_CLS_U32=3Dm=0A=
+# CONFIG_CLS_U32_PERF is not set=0A=
+# CONFIG_CLS_U32_MARK is not set=0A=
+CONFIG_NET_CLS_RSVP=3Dm=0A=
+CONFIG_NET_CLS_RSVP6=3Dm=0A=
+# CONFIG_NET_EMATCH is not set=0A=
+# CONFIG_NET_CLS_ACT is not set=0A=
+CONFIG_NET_CLS_POLICE=3Dy=0A=
+# CONFIG_NET_CLS_IND is not set=0A=
+CONFIG_NET_ESTIMATOR=3Dy=0A=
+=0A=
+#=0A=
+# Network testing=0A=
+#=0A=
+# CONFIG_NET_PKTGEN is not set=0A=
+# CONFIG_HAMRADIO is not set=0A=
+# CONFIG_IRDA is not set=0A=
+# CONFIG_BT is not set=0A=
+# CONFIG_IEEE80211 is not set=0A=
+=0A=
+#=0A=
+# Device Drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Generic Driver Options=0A=
+#=0A=
+CONFIG_STANDALONE=3Dy=0A=
+CONFIG_PREVENT_FIRMWARE_BUILD=3Dy=0A=
+# CONFIG_FW_LOADER is not set=0A=
+=0A=
+#=0A=
+# Connector - unified userspace <-> kernelspace linker=0A=
+#=0A=
+# CONFIG_CONNECTOR is not set=0A=
+=0A=
+#=0A=
+# Memory Technology Devices (MTD)=0A=
+#=0A=
+# CONFIG_MTD is not set=0A=
+=0A=
+#=0A=
+# Parallel port support=0A=
+#=0A=
+# CONFIG_PARPORT is not set=0A=
+=0A=
+#=0A=
+# Plug and Play support=0A=
+#=0A=
+=0A=
+#=0A=
+# Block devices=0A=
+#=0A=
+# CONFIG_BLK_CPQ_DA is not set=0A=
+# CONFIG_BLK_CPQ_CISS_DA is not set=0A=
+# CONFIG_BLK_DEV_DAC960 is not set=0A=
+# CONFIG_BLK_DEV_UMEM is not set=0A=
+# CONFIG_BLK_DEV_COW_COMMON is not set=0A=
+# CONFIG_BLK_DEV_LOOP is not set=0A=
+# CONFIG_BLK_DEV_NBD is not set=0A=
+# CONFIG_BLK_DEV_SX8 is not set=0A=
+# CONFIG_BLK_DEV_RAM is not set=0A=
+CONFIG_BLK_DEV_RAM_COUNT=3D16=0A=
+# CONFIG_CDROM_PKTCDVD is not set=0A=
+# CONFIG_ATA_OVER_ETH is not set=0A=
+=0A=
+#=0A=
+# ATA/ATAPI/MFM/RLL support=0A=
+#=0A=
+# CONFIG_IDE is not set=0A=
+=0A=
+#=0A=
+# SCSI device support=0A=
+#=0A=
+# CONFIG_RAID_ATTRS is not set=0A=
+# CONFIG_SCSI is not set=0A=
+=0A=
+#=0A=
+# Multi-device support (RAID and LVM)=0A=
+#=0A=
+# CONFIG_MD is not set=0A=
+=0A=
+#=0A=
+# Fusion MPT device support=0A=
+#=0A=
+# CONFIG_FUSION is not set=0A=
+=0A=
+#=0A=
+# IEEE 1394 (FireWire) support=0A=
+#=0A=
+# CONFIG_IEEE1394 is not set=0A=
+=0A=
+#=0A=
+# I2O device support=0A=
+#=0A=
+# CONFIG_I2O is not set=0A=
+=0A=
+#=0A=
+# Network device support=0A=
+#=0A=
+CONFIG_NETDEVICES=3Dy=0A=
+# CONFIG_DUMMY is not set=0A=
+# CONFIG_BONDING is not set=0A=
+# CONFIG_EQUALIZER is not set=0A=
+# CONFIG_TUN is not set=0A=
+=0A=
+#=0A=
+# ARCnet devices=0A=
+#=0A=
+# CONFIG_ARCNET is not set=0A=
+=0A=
+#=0A=
+# PHY device support=0A=
+#=0A=
+CONFIG_PHYLIB=3Dm=0A=
+=0A=
+#=0A=
+# MII PHY device drivers=0A=
+#=0A=
+CONFIG_MARVELL_PHY=3Dm=0A=
+CONFIG_DAVICOM_PHY=3Dm=0A=
+CONFIG_QSEMI_PHY=3Dm=0A=
+CONFIG_LXT_PHY=3Dm=0A=
+CONFIG_CICADA_PHY=3Dm=0A=
+=0A=
+#=0A=
+# Ethernet (10 or 100Mbit)=0A=
+#=0A=
+CONFIG_NET_ETHERNET=3Dy=0A=
+CONFIG_MII=3Dy=0A=
+CONFIG_IDT_RC32434_ETH=3Dy=0A=
+# CONFIG_HAPPYMEAL is not set=0A=
+# CONFIG_SUNGEM is not set=0A=
+# CONFIG_CASSINI is not set=0A=
+# CONFIG_NET_VENDOR_3COM is not set=0A=
+# CONFIG_DM9000 is not set=0A=
+=0A=
+#=0A=
+# Tulip family network device support=0A=
+#=0A=
+# CONFIG_NET_TULIP is not set=0A=
+# CONFIG_HP100 is not set=0A=
+CONFIG_NET_PCI=3Dy=0A=
+# CONFIG_PCNET32 is not set=0A=
+# CONFIG_AMD8111_ETH is not set=0A=
+# CONFIG_ADAPTEC_STARFIRE is not set=0A=
+# CONFIG_B44 is not set=0A=
+# CONFIG_FORCEDETH is not set=0A=
+# CONFIG_DGRS is not set=0A=
+# CONFIG_EEPRO100 is not set=0A=
+CONFIG_E100=3Dy=0A=
+# CONFIG_FEALNX is not set=0A=
+# CONFIG_NATSEMI is not set=0A=
+# CONFIG_NE2K_PCI is not set=0A=
+# CONFIG_8139CP is not set=0A=
+# CONFIG_8139TOO is not set=0A=
+# CONFIG_SIS900 is not set=0A=
+# CONFIG_EPIC100 is not set=0A=
+# CONFIG_SUNDANCE is not set=0A=
+# CONFIG_TLAN is not set=0A=
+# CONFIG_VIA_RHINE is not set=0A=
+# CONFIG_LAN_SAA9730 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (1000 Mbit)=0A=
+#=0A=
+# CONFIG_ACENIC is not set=0A=
+# CONFIG_DL2K is not set=0A=
+# CONFIG_E1000 is not set=0A=
+# CONFIG_NS83820 is not set=0A=
+# CONFIG_HAMACHI is not set=0A=
+# CONFIG_YELLOWFIN is not set=0A=
+# CONFIG_R8169 is not set=0A=
+# CONFIG_SIS190 is not set=0A=
+# CONFIG_SKGE is not set=0A=
+# CONFIG_SKY2 is not set=0A=
+# CONFIG_SK98LIN is not set=0A=
+# CONFIG_VIA_VELOCITY is not set=0A=
+# CONFIG_TIGON3 is not set=0A=
+# CONFIG_BNX2 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (10000 Mbit)=0A=
+#=0A=
+# CONFIG_CHELSIO_T1 is not set=0A=
+# CONFIG_IXGB is not set=0A=
+# CONFIG_S2IO is not set=0A=
+=0A=
+#=0A=
+# Token Ring devices=0A=
+#=0A=
+# CONFIG_TR is not set=0A=
+=0A=
+#=0A=
+# Wireless LAN (non-hamradio)=0A=
+#=0A=
+# CONFIG_NET_RADIO is not set=0A=
+=0A=
+#=0A=
+# Wan interfaces=0A=
+#=0A=
+# CONFIG_WAN is not set=0A=
+# CONFIG_FDDI is not set=0A=
+# CONFIG_HIPPI is not set=0A=
+# CONFIG_PPP is not set=0A=
+# CONFIG_SLIP is not set=0A=
+# CONFIG_SHAPER is not set=0A=
+# CONFIG_NETCONSOLE is not set=0A=
+# CONFIG_NETPOLL is not set=0A=
+# CONFIG_NET_POLL_CONTROLLER is not set=0A=
+=0A=
+#=0A=
+# ISDN subsystem=0A=
+#=0A=
+# CONFIG_ISDN is not set=0A=
+=0A=
+#=0A=
+# Telephony Support=0A=
+#=0A=
+# CONFIG_PHONE is not set=0A=
+=0A=
+#=0A=
+# Input device support=0A=
+#=0A=
+CONFIG_INPUT=3Dy=0A=
+=0A=
+#=0A=
+# Userland interfaces=0A=
+#=0A=
+# CONFIG_INPUT_MOUSEDEV is not set=0A=
+# CONFIG_INPUT_JOYDEV is not set=0A=
+# CONFIG_INPUT_TSDEV is not set=0A=
+# CONFIG_INPUT_EVDEV is not set=0A=
+# CONFIG_INPUT_EVBUG is not set=0A=
+=0A=
+#=0A=
+# Input Device Drivers=0A=
+#=0A=
+# CONFIG_INPUT_KEYBOARD is not set=0A=
+# CONFIG_INPUT_MOUSE is not set=0A=
+# CONFIG_INPUT_JOYSTICK is not set=0A=
+# CONFIG_INPUT_TOUCHSCREEN is not set=0A=
+# CONFIG_INPUT_MISC is not set=0A=
+=0A=
+#=0A=
+# Hardware I/O ports=0A=
+#=0A=
+# CONFIG_SERIO is not set=0A=
+# CONFIG_GAMEPORT is not set=0A=
+=0A=
+#=0A=
+# Character devices=0A=
+#=0A=
+CONFIG_VT=3Dy=0A=
+CONFIG_VT_CONSOLE=3Dy=0A=
+CONFIG_HW_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_NONSTANDARD is not set=0A=
+=0A=
+#=0A=
+# Serial drivers=0A=
+#=0A=
+CONFIG_SERIAL_8250=3Dy=0A=
+CONFIG_SERIAL_8250_CONSOLE=3Dy=0A=
+CONFIG_SERIAL_8250_NR_UARTS=3D4=0A=
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3D4=0A=
+# CONFIG_SERIAL_8250_EXTENDED is not set=0A=
+=0A=
+#=0A=
+# Non-8250 serial port support=0A=
+#=0A=
+CONFIG_SERIAL_CORE=3Dy=0A=
+CONFIG_SERIAL_CORE_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_JSM is not set=0A=
+CONFIG_UNIX98_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTY_COUNT=3D256=0A=
+=0A=
+#=0A=
+# IPMI=0A=
+#=0A=
+# CONFIG_IPMI_HANDLER is not set=0A=
+=0A=
+#=0A=
+# Watchdog Cards=0A=
+#=0A=
+# CONFIG_WATCHDOG is not set=0A=
+# CONFIG_RTC is not set=0A=
+# CONFIG_GEN_RTC is not set=0A=
+# CONFIG_DTLK is not set=0A=
+# CONFIG_R3964 is not set=0A=
+# CONFIG_APPLICOM is not set=0A=
+=0A=
+#=0A=
+# Ftape, the floppy tape device driver=0A=
+#=0A=
+# CONFIG_DRM is not set=0A=
+# CONFIG_RAW_DRIVER is not set=0A=
+=0A=
+#=0A=
+# TPM devices=0A=
+#=0A=
+# CONFIG_TCG_TPM is not set=0A=
+# CONFIG_TELCLOCK is not set=0A=
+=0A=
+#=0A=
+# I2C support=0A=
+#=0A=
+CONFIG_I2C=3Dy=0A=
+CONFIG_I2C_CHARDEV=3Dy=0A=
+=0A=
+#=0A=
+# I2C Algorithms=0A=
+#=0A=
+# CONFIG_I2C_ALGOBIT is not set=0A=
+# CONFIG_I2C_ALGOPCF is not set=0A=
+# CONFIG_I2C_ALGOPCA is not set=0A=
+=0A=
+#=0A=
+# I2C Hardware Bus support=0A=
+#=0A=
+# CONFIG_I2C_ALI1535 is not set=0A=
+# CONFIG_I2C_ALI1563 is not set=0A=
+# CONFIG_I2C_ALI15X3 is not set=0A=
+# CONFIG_I2C_AMD756 is not set=0A=
+# CONFIG_I2C_AMD8111 is not set=0A=
+# CONFIG_I2C_I801 is not set=0A=
+# CONFIG_I2C_I810 is not set=0A=
+# CONFIG_I2C_PIIX4 is not set=0A=
+# CONFIG_I2C_NFORCE2 is not set=0A=
+# CONFIG_I2C_PARPORT_LIGHT is not set=0A=
+# CONFIG_I2C_PROSAVAGE is not set=0A=
+# CONFIG_I2C_SAVAGE4 is not set=0A=
+# CONFIG_SCx200_ACB is not set=0A=
+# CONFIG_I2C_SIS5595 is not set=0A=
+# CONFIG_I2C_SIS630 is not set=0A=
+# CONFIG_I2C_SIS96X is not set=0A=
+# CONFIG_I2C_STUB is not set=0A=
+# CONFIG_I2C_VIA is not set=0A=
+# CONFIG_I2C_VIAPRO is not set=0A=
+# CONFIG_I2C_VOODOO3 is not set=0A=
+# CONFIG_I2C_PCA_ISA is not set=0A=
+CONFIG_I2C_RC32434=3Dy=0A=
+=0A=
+#=0A=
+# Miscellaneous I2C Chip support=0A=
+#=0A=
+# CONFIG_SENSORS_DS1337 is not set=0A=
+# CONFIG_SENSORS_DS1374 is not set=0A=
+# CONFIG_SENSORS_EEPROM is not set=0A=
+# CONFIG_SENSORS_PCF8574 is not set=0A=
+# CONFIG_SENSORS_PCA9539 is not set=0A=
+# CONFIG_SENSORS_PCF8591 is not set=0A=
+# CONFIG_SENSORS_RTC8564 is not set=0A=
+# CONFIG_SENSORS_MAX6875 is not set=0A=
+# CONFIG_RTC_X1205_I2C is not set=0A=
+# CONFIG_I2C_DEBUG_CORE is not set=0A=
+# CONFIG_I2C_DEBUG_ALGO is not set=0A=
+# CONFIG_I2C_DEBUG_BUS is not set=0A=
+# CONFIG_I2C_DEBUG_CHIP is not set=0A=
+=0A=
+#=0A=
+# SPI support=0A=
+#=0A=
+# CONFIG_SPI is not set=0A=
+# CONFIG_SPI_MASTER is not set=0A=
+=0A=
+#=0A=
+# Dallas's 1-wire bus=0A=
+#=0A=
+# CONFIG_W1 is not set=0A=
+=0A=
+#=0A=
+# Hardware Monitoring support=0A=
+#=0A=
+# CONFIG_HWMON is not set=0A=
+# CONFIG_HWMON_VID is not set=0A=
+=0A=
+#=0A=
+# Misc devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia Capabilities Port drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia devices=0A=
+#=0A=
+# CONFIG_VIDEO_DEV is not set=0A=
+=0A=
+#=0A=
+# Digital Video Broadcasting Devices=0A=
+#=0A=
+# CONFIG_DVB is not set=0A=
+=0A=
+#=0A=
+# Graphics support=0A=
+#=0A=
+# CONFIG_FB is not set=0A=
+=0A=
+#=0A=
+# Console display driver support=0A=
+#=0A=
+# CONFIG_VGA_CONSOLE is not set=0A=
+CONFIG_DUMMY_CONSOLE=3Dy=0A=
+=0A=
+#=0A=
+# Sound=0A=
+#=0A=
+# CONFIG_SOUND is not set=0A=
+=0A=
+#=0A=
+# USB support=0A=
+#=0A=
+CONFIG_USB_ARCH_HAS_HCD=3Dy=0A=
+CONFIG_USB_ARCH_HAS_OHCI=3Dy=0A=
+# CONFIG_USB is not set=0A=
+=0A=
+#=0A=
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'=0A=
+#=0A=
+=0A=
+#=0A=
+# USB Gadget Support=0A=
+#=0A=
+# CONFIG_USB_GADGET is not set=0A=
+=0A=
+#=0A=
+# MMC/SD Card support=0A=
+#=0A=
+# CONFIG_MMC is not set=0A=
+=0A=
+#=0A=
+# InfiniBand support=0A=
+#=0A=
+# CONFIG_INFINIBAND is not set=0A=
+=0A=
+#=0A=
+# SN Devices=0A=
+#=0A=
+=0A=
+#=0A=
+# EDAC - error detection and reporting (RAS)=0A=
+#=0A=
+=0A=
+#=0A=
+# File systems=0A=
+#=0A=
+CONFIG_EXT2_FS=3Dy=0A=
+# CONFIG_EXT2_FS_XATTR is not set=0A=
+# CONFIG_EXT2_FS_XIP is not set=0A=
+# CONFIG_EXT3_FS is not set=0A=
+# CONFIG_REISERFS_FS is not set=0A=
+# CONFIG_JFS_FS is not set=0A=
+# CONFIG_FS_POSIX_ACL is not set=0A=
+# CONFIG_XFS_FS is not set=0A=
+# CONFIG_OCFS2_FS is not set=0A=
+# CONFIG_MINIX_FS is not set=0A=
+# CONFIG_ROMFS_FS is not set=0A=
+# CONFIG_INOTIFY is not set=0A=
+# CONFIG_QUOTA is not set=0A=
+# CONFIG_DNOTIFY is not set=0A=
+# CONFIG_AUTOFS_FS is not set=0A=
+# CONFIG_AUTOFS4_FS is not set=0A=
+# CONFIG_FUSE_FS is not set=0A=
+=0A=
+#=0A=
+# CD-ROM/DVD Filesystems=0A=
+#=0A=
+# CONFIG_ISO9660_FS is not set=0A=
+# CONFIG_UDF_FS is not set=0A=
+=0A=
+#=0A=
+# DOS/FAT/NT Filesystems=0A=
+#=0A=
+# CONFIG_MSDOS_FS is not set=0A=
+# CONFIG_VFAT_FS is not set=0A=
+# CONFIG_NTFS_FS is not set=0A=
+=0A=
+#=0A=
+# Pseudo filesystems=0A=
+#=0A=
+CONFIG_PROC_FS=3Dy=0A=
+CONFIG_PROC_KCORE=3Dy=0A=
+CONFIG_SYSFS=3Dy=0A=
+# CONFIG_TMPFS is not set=0A=
+# CONFIG_HUGETLB_PAGE is not set=0A=
+CONFIG_RAMFS=3Dy=0A=
+# CONFIG_RELAYFS_FS is not set=0A=
+# CONFIG_CONFIGFS_FS is not set=0A=
+=0A=
+#=0A=
+# Miscellaneous filesystems=0A=
+#=0A=
+# CONFIG_ADFS_FS is not set=0A=
+# CONFIG_AFFS_FS is not set=0A=
+# CONFIG_HFS_FS is not set=0A=
+# CONFIG_HFSPLUS_FS is not set=0A=
+# CONFIG_BEFS_FS is not set=0A=
+# CONFIG_BFS_FS is not set=0A=
+# CONFIG_EFS_FS is not set=0A=
+# CONFIG_CRAMFS is not set=0A=
+# CONFIG_VXFS_FS is not set=0A=
+# CONFIG_HPFS_FS is not set=0A=
+# CONFIG_QNX4FS_FS is not set=0A=
+# CONFIG_SYSV_FS is not set=0A=
+# CONFIG_UFS_FS is not set=0A=
+=0A=
+#=0A=
+# Network File Systems=0A=
+#=0A=
+# CONFIG_NFS_FS is not set=0A=
+# CONFIG_NFSD is not set=0A=
+# CONFIG_SMB_FS is not set=0A=
+# CONFIG_CIFS is not set=0A=
+# CONFIG_NCP_FS is not set=0A=
+# CONFIG_CODA_FS is not set=0A=
+# CONFIG_AFS_FS is not set=0A=
+# CONFIG_9P_FS is not set=0A=
+=0A=
+#=0A=
+# Partition Types=0A=
+#=0A=
+# CONFIG_PARTITION_ADVANCED is not set=0A=
+CONFIG_MSDOS_PARTITION=3Dy=0A=
+=0A=
+#=0A=
+# Native Language Support=0A=
+#=0A=
+# CONFIG_NLS is not set=0A=
+=0A=
+#=0A=
+# Profiling support=0A=
+#=0A=
+# CONFIG_PROFILING is not set=0A=
+=0A=
+#=0A=
+# Kernel hacking=0A=
+#=0A=
+# CONFIG_PRINTK_TIME is not set=0A=
+# CONFIG_MAGIC_SYSRQ is not set=0A=
+# CONFIG_DEBUG_KERNEL is not set=0A=
+CONFIG_LOG_BUF_SHIFT=3D14=0A=
+CONFIG_CROSSCOMPILE=3Dy=0A=
+CONFIG_CMDLINE=3D""=0A=
+=0A=
+#=0A=
+# Security options=0A=
+#=0A=
+# CONFIG_KEYS is not set=0A=
+# CONFIG_SECURITY is not set=0A=
+=0A=
+#=0A=
+# Cryptographic options=0A=
+#=0A=
+# CONFIG_CRYPTO is not set=0A=
+=0A=
+#=0A=
+# Hardware crypto devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Library routines=0A=
+#=0A=
+CONFIG_CRC_CCITT=3Dy=0A=
+CONFIG_CRC16=3Dm=0A=
+CONFIG_CRC32=3Dy=0A=
+# CONFIG_LIBCRC32C is not set=0A=
+CONFIG_TEXTSEARCH=3Dy=0A=
+CONFIG_TEXTSEARCH_KMP=3Dm=0A=
+CONFIG_TEXTSEARCH_BM=3Dm=0A=
+CONFIG_TEXTSEARCH_FSM=3Dm=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/configs/rc32438_defconfig =
idtlinux/arch/mips/configs/rc32438_defconfig=0A=
--- linux-2.6.16-rc5/arch/mips/configs/rc32438_defconfig	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/configs/rc32438_defconfig	2006-03-09 =
16:25:45.000000000 -0800=0A=
@@ -0,0 +1,982 @@=0A=
+#=0A=
+# Automatically generated make config: don't edit=0A=
+# Linux kernel version: 2.6.16-rc5=0A=
+# Thu Mar  9 10:57:39 2006=0A=
+#=0A=
+CONFIG_MIPS=3Dy=0A=
+=0A=
+#=0A=
+# Machine selection=0A=
+#=0A=
+# CONFIG_MIPS_MTX1 is not set=0A=
+# CONFIG_MIPS_BOSPORUS is not set=0A=
+# CONFIG_MIPS_PB1000 is not set=0A=
+# CONFIG_MIPS_PB1100 is not set=0A=
+# CONFIG_MIPS_PB1500 is not set=0A=
+# CONFIG_MIPS_PB1550 is not set=0A=
+# CONFIG_MIPS_PB1200 is not set=0A=
+# CONFIG_MIPS_DB1000 is not set=0A=
+# CONFIG_MIPS_DB1100 is not set=0A=
+# CONFIG_MIPS_DB1500 is not set=0A=
+# CONFIG_MIPS_DB1550 is not set=0A=
+# CONFIG_MIPS_DB1200 is not set=0A=
+# CONFIG_MIPS_MIRAGE is not set=0A=
+# CONFIG_MIPS_COBALT is not set=0A=
+# CONFIG_MACH_DECSTATION is not set=0A=
+# CONFIG_MIPS_EV64120 is not set=0A=
+# CONFIG_MIPS_EV96100 is not set=0A=
+# CONFIG_MIPS_IVR is not set=0A=
+CONFIG_IDT_BOARDS=3Dy=0A=
+# CONFIG_MIPS_ITE8172 is not set=0A=
+# CONFIG_MACH_JAZZ is not set=0A=
+# CONFIG_LASAT is not set=0A=
+# CONFIG_MIPS_ATLAS is not set=0A=
+# CONFIG_MIPS_MALTA is not set=0A=
+# CONFIG_MIPS_SEAD is not set=0A=
+# CONFIG_MIPS_SIM is not set=0A=
+# CONFIG_MOMENCO_JAGUAR_ATX is not set=0A=
+# CONFIG_MOMENCO_OCELOT is not set=0A=
+# CONFIG_MOMENCO_OCELOT_3 is not set=0A=
+# CONFIG_MOMENCO_OCELOT_C is not set=0A=
+# CONFIG_MOMENCO_OCELOT_G is not set=0A=
+# CONFIG_MIPS_XXS1500 is not set=0A=
+# CONFIG_PNX8550_V2PCI is not set=0A=
+# CONFIG_PNX8550_JBS is not set=0A=
+# CONFIG_DDB5074 is not set=0A=
+# CONFIG_DDB5476 is not set=0A=
+# CONFIG_DDB5477 is not set=0A=
+# CONFIG_MACH_VR41XX is not set=0A=
+# CONFIG_PMC_YOSEMITE is not set=0A=
+# CONFIG_QEMU is not set=0A=
+# CONFIG_SGI_IP22 is not set=0A=
+# CONFIG_SGI_IP27 is not set=0A=
+# CONFIG_SGI_IP32 is not set=0A=
+# CONFIG_SIBYTE_BIGSUR is not set=0A=
+# CONFIG_SIBYTE_SWARM is not set=0A=
+# CONFIG_SIBYTE_SENTOSA is not set=0A=
+# CONFIG_SIBYTE_RHONE is not set=0A=
+# CONFIG_SIBYTE_CARMEL is not set=0A=
+# CONFIG_SIBYTE_PTSWARM is not set=0A=
+# CONFIG_SIBYTE_LITTLESUR is not set=0A=
+# CONFIG_SIBYTE_CRHINE is not set=0A=
+# CONFIG_SIBYTE_CRHONE is not set=0A=
+# CONFIG_SNI_RM200_PCI is not set=0A=
+# CONFIG_TOSHIBA_JMR3927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4938 is not set=0A=
+CONFIG_IDT_EB438=3Dy=0A=
+# CONFIG_RC32438_REVISION_ZA is not set=0A=
+# CONFIG_IDT_EB434 is not set=0A=
+# CONFIG_IDT_EB365 is not set=0A=
+# CONFIG_IDT_EB355 is not set=0A=
+# CONFIG_IDT_S334 is not set=0A=
+CONFIG_IDT_BOARD_FREQ=3D150000000=0A=
+CONFIG_IDT_ZIMAGE_ADDR=3D0x91000000=0A=
+# CONFIG_IDT_BOOT_NVRAM is not set=0A=
+CONFIG_RWSEM_GENERIC_SPINLOCK=3Dy=0A=
+CONFIG_GENERIC_CALIBRATE_DELAY=3Dy=0A=
+CONFIG_DMA_NONCOHERENT=3Dy=0A=
+CONFIG_DMA_NEED_PCI_MAP_STATE=3Dy=0A=
+# CONFIG_CPU_BIG_ENDIAN is not set=0A=
+CONFIG_CPU_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_IRQ_CPU=3Dy=0A=
+CONFIG_SWAP_IO_SPACE=3Dy=0A=
+CONFIG_BOOT_ELF32=3Dy=0A=
+CONFIG_MIPS_L1_CACHE_SHIFT=3D5=0A=
+=0A=
+#=0A=
+# CPU selection=0A=
+#=0A=
+CONFIG_CPU_MIPS32_R1=3Dy=0A=
+# CONFIG_CPU_MIPS32_R2 is not set=0A=
+# CONFIG_CPU_MIPS64_R1 is not set=0A=
+# CONFIG_CPU_MIPS64_R2 is not set=0A=
+# CONFIG_CPU_R3000 is not set=0A=
+# CONFIG_CPU_TX39XX is not set=0A=
+# CONFIG_CPU_VR41XX is not set=0A=
+# CONFIG_CPU_R4300 is not set=0A=
+# CONFIG_CPU_R4X00 is not set=0A=
+# CONFIG_CPU_TX49XX is not set=0A=
+# CONFIG_CPU_R5000 is not set=0A=
+# CONFIG_CPU_R5432 is not set=0A=
+# CONFIG_CPU_R6000 is not set=0A=
+# CONFIG_CPU_NEVADA is not set=0A=
+# CONFIG_CPU_R8000 is not set=0A=
+# CONFIG_CPU_R10000 is not set=0A=
+# CONFIG_CPU_RM7000 is not set=0A=
+# CONFIG_CPU_RM9000 is not set=0A=
+# CONFIG_CPU_SB1 is not set=0A=
+CONFIG_SYS_HAS_CPU_MIPS32_R1=3Dy=0A=
+CONFIG_CPU_MIPS32=3Dy=0A=
+CONFIG_CPU_MIPSR1=3Dy=0A=
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+=0A=
+#=0A=
+# Kernel type=0A=
+#=0A=
+CONFIG_32BIT=3Dy=0A=
+# CONFIG_64BIT is not set=0A=
+CONFIG_PAGE_SIZE_4KB=3Dy=0A=
+# CONFIG_PAGE_SIZE_8KB is not set=0A=
+# CONFIG_PAGE_SIZE_16KB is not set=0A=
+# CONFIG_PAGE_SIZE_64KB is not set=0A=
+CONFIG_CPU_HAS_PREFETCH=3Dy=0A=
+# CONFIG_MIPS_MT is not set=0A=
+# CONFIG_64BIT_PHYS_ADDR is not set=0A=
+CONFIG_CPU_ADVANCED=3Dy=0A=
+CONFIG_CPU_HAS_LLSC=3Dy=0A=
+# CONFIG_CPU_HAS_WB is not set=0A=
+CONFIG_CPU_HAS_SYNC=3Dy=0A=
+CONFIG_GENERIC_HARDIRQS=3Dy=0A=
+CONFIG_GENERIC_IRQ_PROBE=3Dy=0A=
+CONFIG_ARCH_FLATMEM_ENABLE=3Dy=0A=
+CONFIG_SELECT_MEMORY_MODEL=3Dy=0A=
+CONFIG_FLATMEM_MANUAL=3Dy=0A=
+# CONFIG_DISCONTIGMEM_MANUAL is not set=0A=
+# CONFIG_SPARSEMEM_MANUAL is not set=0A=
+CONFIG_FLATMEM=3Dy=0A=
+CONFIG_FLAT_NODE_MEM_MAP=3Dy=0A=
+# CONFIG_SPARSEMEM_STATIC is not set=0A=
+CONFIG_SPLIT_PTLOCK_CPUS=3D4=0A=
+CONFIG_PREEMPT_NONE=3Dy=0A=
+# CONFIG_PREEMPT_VOLUNTARY is not set=0A=
+# CONFIG_PREEMPT is not set=0A=
+=0A=
+#=0A=
+# Code maturity level options=0A=
+#=0A=
+CONFIG_EXPERIMENTAL=3Dy=0A=
+CONFIG_BROKEN_ON_SMP=3Dy=0A=
+CONFIG_INIT_ENV_ARG_LIMIT=3D32=0A=
+=0A=
+#=0A=
+# General setup=0A=
+#=0A=
+CONFIG_LOCALVERSION=3D""=0A=
+CONFIG_LOCALVERSION_AUTO=3Dy=0A=
+# CONFIG_SWAP is not set=0A=
+CONFIG_SYSVIPC=3Dy=0A=
+# CONFIG_POSIX_MQUEUE is not set=0A=
+# CONFIG_BSD_PROCESS_ACCT is not set=0A=
+CONFIG_SYSCTL=3Dy=0A=
+# CONFIG_AUDIT is not set=0A=
+CONFIG_IKCONFIG=3Dy=0A=
+# CONFIG_IKCONFIG_PROC is not set=0A=
+CONFIG_INITRAMFS_SOURCE=3D""=0A=
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set=0A=
+CONFIG_EMBEDDED=3Dy=0A=
+# CONFIG_KALLSYMS is not set=0A=
+# CONFIG_HOTPLUG is not set=0A=
+CONFIG_PRINTK=3Dy=0A=
+CONFIG_BUG=3Dy=0A=
+CONFIG_ELF_CORE=3Dy=0A=
+# CONFIG_BASE_FULL is not set=0A=
+# CONFIG_FUTEX is not set=0A=
+# CONFIG_EPOLL is not set=0A=
+CONFIG_SHMEM=3Dy=0A=
+CONFIG_CC_ALIGN_FUNCTIONS=3D0=0A=
+CONFIG_CC_ALIGN_LABELS=3D0=0A=
+CONFIG_CC_ALIGN_LOOPS=3D0=0A=
+CONFIG_CC_ALIGN_JUMPS=3D0=0A=
+# CONFIG_SLAB is not set=0A=
+# CONFIG_TINY_SHMEM is not set=0A=
+CONFIG_BASE_SMALL=3D1=0A=
+CONFIG_SLOB=3Dy=0A=
+=0A=
+#=0A=
+# Loadable module support=0A=
+#=0A=
+CONFIG_MODULES=3Dy=0A=
+CONFIG_MODULE_UNLOAD=3Dy=0A=
+# CONFIG_MODULE_FORCE_UNLOAD is not set=0A=
+CONFIG_OBSOLETE_MODPARM=3Dy=0A=
+# CONFIG_MODVERSIONS is not set=0A=
+# CONFIG_MODULE_SRCVERSION_ALL is not set=0A=
+# CONFIG_KMOD is not set=0A=
+=0A=
+#=0A=
+# Block layer=0A=
+#=0A=
+# CONFIG_LBD is not set=0A=
+=0A=
+#=0A=
+# IO Schedulers=0A=
+#=0A=
+CONFIG_IOSCHED_NOOP=3Dy=0A=
+CONFIG_IOSCHED_AS=3Dy=0A=
+CONFIG_IOSCHED_DEADLINE=3Dy=0A=
+CONFIG_IOSCHED_CFQ=3Dy=0A=
+CONFIG_DEFAULT_AS=3Dy=0A=
+# CONFIG_DEFAULT_DEADLINE is not set=0A=
+# CONFIG_DEFAULT_CFQ is not set=0A=
+# CONFIG_DEFAULT_NOOP is not set=0A=
+CONFIG_DEFAULT_IOSCHED=3D"anticipatory"=0A=
+=0A=
+#=0A=
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)=0A=
+#=0A=
+CONFIG_HW_HAS_PCI=3Dy=0A=
+CONFIG_PCI=3Dy=0A=
+CONFIG_PCI_LEGACY_PROC=3Dy=0A=
+CONFIG_MMU=3Dy=0A=
+=0A=
+#=0A=
+# PCCARD (PCMCIA/CardBus) support=0A=
+#=0A=
+# CONFIG_PCCARD is not set=0A=
+=0A=
+#=0A=
+# PCI Hotplug Support=0A=
+#=0A=
+# CONFIG_HOTPLUG_PCI is not set=0A=
+=0A=
+#=0A=
+# Executable file formats=0A=
+#=0A=
+CONFIG_BINFMT_ELF=3Dy=0A=
+# CONFIG_BINFMT_MISC is not set=0A=
+CONFIG_TRAD_SIGNALS=3Dy=0A=
+=0A=
+#=0A=
+# Networking=0A=
+#=0A=
+CONFIG_NET=3Dy=0A=
+=0A=
+#=0A=
+# Networking options=0A=
+#=0A=
+# CONFIG_NETDEBUG is not set=0A=
+CONFIG_PACKET=3Dy=0A=
+CONFIG_PACKET_MMAP=3Dy=0A=
+CONFIG_UNIX=3Dy=0A=
+CONFIG_XFRM=3Dy=0A=
+# CONFIG_XFRM_USER is not set=0A=
+CONFIG_NET_KEY=3Dy=0A=
+CONFIG_INET=3Dy=0A=
+CONFIG_IP_MULTICAST=3Dy=0A=
+# CONFIG_IP_ADVANCED_ROUTER is not set=0A=
+CONFIG_IP_FIB_HASH=3Dy=0A=
+CONFIG_IP_PNP=3Dy=0A=
+# CONFIG_IP_PNP_DHCP is not set=0A=
+# CONFIG_IP_PNP_BOOTP is not set=0A=
+# CONFIG_IP_PNP_RARP is not set=0A=
+# CONFIG_NET_IPIP is not set=0A=
+# CONFIG_NET_IPGRE is not set=0A=
+# CONFIG_IP_MROUTE is not set=0A=
+# CONFIG_ARPD is not set=0A=
+# CONFIG_SYN_COOKIES is not set=0A=
+# CONFIG_INET_AH is not set=0A=
+# CONFIG_INET_ESP is not set=0A=
+# CONFIG_INET_IPCOMP is not set=0A=
+# CONFIG_INET_TUNNEL is not set=0A=
+# CONFIG_INET_DIAG is not set=0A=
+# CONFIG_TCP_CONG_ADVANCED is not set=0A=
+CONFIG_TCP_CONG_BIC=3Dy=0A=
+=0A=
+#=0A=
+# IP: Virtual Server Configuration=0A=
+#=0A=
+CONFIG_IP_VS=3Dm=0A=
+# CONFIG_IP_VS_DEBUG is not set=0A=
+CONFIG_IP_VS_TAB_BITS=3D12=0A=
+=0A=
+#=0A=
+# IPVS transport protocol load balancing support=0A=
+#=0A=
+CONFIG_IP_VS_PROTO_TCP=3Dy=0A=
+CONFIG_IP_VS_PROTO_UDP=3Dy=0A=
+CONFIG_IP_VS_PROTO_ESP=3Dy=0A=
+CONFIG_IP_VS_PROTO_AH=3Dy=0A=
+=0A=
+#=0A=
+# IPVS scheduler=0A=
+#=0A=
+CONFIG_IP_VS_RR=3Dm=0A=
+CONFIG_IP_VS_WRR=3Dm=0A=
+CONFIG_IP_VS_LC=3Dm=0A=
+CONFIG_IP_VS_WLC=3Dm=0A=
+CONFIG_IP_VS_LBLC=3Dm=0A=
+CONFIG_IP_VS_LBLCR=3Dm=0A=
+CONFIG_IP_VS_DH=3Dm=0A=
+CONFIG_IP_VS_SH=3Dm=0A=
+CONFIG_IP_VS_SED=3Dm=0A=
+CONFIG_IP_VS_NQ=3Dm=0A=
+=0A=
+#=0A=
+# IPVS application helper=0A=
+#=0A=
+CONFIG_IP_VS_FTP=3Dm=0A=
+# CONFIG_IPV6 is not set=0A=
+CONFIG_NETFILTER=3Dy=0A=
+# CONFIG_NETFILTER_DEBUG is not set=0A=
+=0A=
+#=0A=
+# Core Netfilter Configuration=0A=
+#=0A=
+CONFIG_NETFILTER_NETLINK=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_QUEUE=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_LOG=3Dm=0A=
+CONFIG_NETFILTER_XTABLES=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=3Dm=0A=
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_COMMENT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_DCCP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_HELPER=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LENGTH=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_LIMIT=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MAC=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_MARK=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_REALM=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_SCTP=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STATE=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_STRING=3Dm=0A=
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=3Dm=0A=
+=0A=
+#=0A=
+# IP: Netfilter Configuration=0A=
+#=0A=
+CONFIG_IP_NF_CONNTRACK=3Dm=0A=
+CONFIG_IP_NF_CT_ACCT=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_MARK=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_EVENTS=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_NETLINK=3Dm=0A=
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set=0A=
+CONFIG_IP_NF_FTP=3Dm=0A=
+CONFIG_IP_NF_IRC=3Dm=0A=
+# CONFIG_IP_NF_NETBIOS_NS is not set=0A=
+CONFIG_IP_NF_TFTP=3Dm=0A=
+CONFIG_IP_NF_AMANDA=3Dm=0A=
+CONFIG_IP_NF_PPTP=3Dm=0A=
+CONFIG_IP_NF_QUEUE=3Dm=0A=
+CONFIG_IP_NF_IPTABLES=3Dm=0A=
+CONFIG_IP_NF_MATCH_IPRANGE=3Dm=0A=
+CONFIG_IP_NF_MATCH_MULTIPORT=3Dm=0A=
+CONFIG_IP_NF_MATCH_TOS=3Dm=0A=
+CONFIG_IP_NF_MATCH_RECENT=3Dm=0A=
+CONFIG_IP_NF_MATCH_ECN=3Dm=0A=
+CONFIG_IP_NF_MATCH_DSCP=3Dm=0A=
+CONFIG_IP_NF_MATCH_AH_ESP=3Dm=0A=
+CONFIG_IP_NF_MATCH_TTL=3Dm=0A=
+CONFIG_IP_NF_MATCH_OWNER=3Dm=0A=
+CONFIG_IP_NF_MATCH_ADDRTYPE=3Dm=0A=
+CONFIG_IP_NF_MATCH_HASHLIMIT=3Dm=0A=
+CONFIG_IP_NF_MATCH_POLICY=3Dm=0A=
+CONFIG_IP_NF_FILTER=3Dm=0A=
+CONFIG_IP_NF_TARGET_REJECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_LOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_ULOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_TCPMSS=3Dm=0A=
+CONFIG_IP_NF_NAT=3Dm=0A=
+CONFIG_IP_NF_NAT_NEEDED=3Dy=0A=
+CONFIG_IP_NF_TARGET_MASQUERADE=3Dm=0A=
+CONFIG_IP_NF_TARGET_REDIRECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_NETMAP=3Dm=0A=
+CONFIG_IP_NF_TARGET_SAME=3Dm=0A=
+CONFIG_IP_NF_NAT_SNMP_BASIC=3Dm=0A=
+CONFIG_IP_NF_NAT_IRC=3Dm=0A=
+CONFIG_IP_NF_NAT_FTP=3Dm=0A=
+CONFIG_IP_NF_NAT_TFTP=3Dm=0A=
+CONFIG_IP_NF_NAT_AMANDA=3Dm=0A=
+CONFIG_IP_NF_NAT_PPTP=3Dm=0A=
+CONFIG_IP_NF_MANGLE=3Dm=0A=
+CONFIG_IP_NF_TARGET_TOS=3Dm=0A=
+CONFIG_IP_NF_TARGET_ECN=3Dm=0A=
+CONFIG_IP_NF_TARGET_DSCP=3Dm=0A=
+CONFIG_IP_NF_TARGET_TTL=3Dm=0A=
+CONFIG_IP_NF_TARGET_CLUSTERIP=3Dm=0A=
+CONFIG_IP_NF_RAW=3Dm=0A=
+CONFIG_IP_NF_ARPTABLES=3Dm=0A=
+CONFIG_IP_NF_ARPFILTER=3Dm=0A=
+CONFIG_IP_NF_ARP_MANGLE=3Dm=0A=
+=0A=
+#=0A=
+# DCCP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_DCCP is not set=0A=
+=0A=
+#=0A=
+# SCTP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_SCTP is not set=0A=
+=0A=
+#=0A=
+# TIPC Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_TIPC is not set=0A=
+# CONFIG_ATM is not set=0A=
+# CONFIG_BRIDGE is not set=0A=
+# CONFIG_VLAN_8021Q is not set=0A=
+# CONFIG_DECNET is not set=0A=
+# CONFIG_LLC2 is not set=0A=
+# CONFIG_IPX is not set=0A=
+# CONFIG_ATALK is not set=0A=
+# CONFIG_X25 is not set=0A=
+# CONFIG_LAPB is not set=0A=
+# CONFIG_NET_DIVERT is not set=0A=
+# CONFIG_ECONET is not set=0A=
+# CONFIG_WAN_ROUTER is not set=0A=
+=0A=
+#=0A=
+# QoS and/or fair queueing=0A=
+#=0A=
+CONFIG_NET_SCHED=3Dy=0A=
+# CONFIG_NET_SCH_CLK_JIFFIES is not set=0A=
+CONFIG_NET_SCH_CLK_GETTIMEOFDAY=3Dy=0A=
+# CONFIG_NET_SCH_CLK_CPU is not set=0A=
+=0A=
+#=0A=
+# Queueing/Scheduling=0A=
+#=0A=
+CONFIG_NET_SCH_CBQ=3Dm=0A=
+CONFIG_NET_SCH_HTB=3Dm=0A=
+CONFIG_NET_SCH_HFSC=3Dm=0A=
+CONFIG_NET_SCH_PRIO=3Dm=0A=
+CONFIG_NET_SCH_RED=3Dm=0A=
+CONFIG_NET_SCH_SFQ=3Dm=0A=
+CONFIG_NET_SCH_TEQL=3Dm=0A=
+CONFIG_NET_SCH_TBF=3Dm=0A=
+CONFIG_NET_SCH_GRED=3Dm=0A=
+CONFIG_NET_SCH_DSMARK=3Dm=0A=
+CONFIG_NET_SCH_NETEM=3Dm=0A=
+CONFIG_NET_SCH_INGRESS=3Dm=0A=
+=0A=
+#=0A=
+# Classification=0A=
+#=0A=
+CONFIG_NET_CLS=3Dy=0A=
+CONFIG_NET_CLS_BASIC=3Dm=0A=
+CONFIG_NET_CLS_TCINDEX=3Dm=0A=
+CONFIG_NET_CLS_ROUTE4=3Dm=0A=
+CONFIG_NET_CLS_ROUTE=3Dy=0A=
+CONFIG_NET_CLS_FW=3Dm=0A=
+CONFIG_NET_CLS_U32=3Dm=0A=
+# CONFIG_CLS_U32_PERF is not set=0A=
+# CONFIG_CLS_U32_MARK is not set=0A=
+CONFIG_NET_CLS_RSVP=3Dm=0A=
+CONFIG_NET_CLS_RSVP6=3Dm=0A=
+# CONFIG_NET_EMATCH is not set=0A=
+# CONFIG_NET_CLS_ACT is not set=0A=
+CONFIG_NET_CLS_POLICE=3Dy=0A=
+# CONFIG_NET_CLS_IND is not set=0A=
+CONFIG_NET_ESTIMATOR=3Dy=0A=
+=0A=
+#=0A=
+# Network testing=0A=
+#=0A=
+# CONFIG_NET_PKTGEN is not set=0A=
+# CONFIG_HAMRADIO is not set=0A=
+# CONFIG_IRDA is not set=0A=
+# CONFIG_BT is not set=0A=
+# CONFIG_IEEE80211 is not set=0A=
+=0A=
+#=0A=
+# Device Drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Generic Driver Options=0A=
+#=0A=
+CONFIG_STANDALONE=3Dy=0A=
+CONFIG_PREVENT_FIRMWARE_BUILD=3Dy=0A=
+# CONFIG_FW_LOADER is not set=0A=
+=0A=
+#=0A=
+# Connector - unified userspace <-> kernelspace linker=0A=
+#=0A=
+# CONFIG_CONNECTOR is not set=0A=
+=0A=
+#=0A=
+# Memory Technology Devices (MTD)=0A=
+#=0A=
+# CONFIG_MTD is not set=0A=
+=0A=
+#=0A=
+# Parallel port support=0A=
+#=0A=
+# CONFIG_PARPORT is not set=0A=
+=0A=
+#=0A=
+# Plug and Play support=0A=
+#=0A=
+=0A=
+#=0A=
+# Block devices=0A=
+#=0A=
+# CONFIG_BLK_CPQ_DA is not set=0A=
+# CONFIG_BLK_CPQ_CISS_DA is not set=0A=
+# CONFIG_BLK_DEV_DAC960 is not set=0A=
+# CONFIG_BLK_DEV_UMEM is not set=0A=
+# CONFIG_BLK_DEV_COW_COMMON is not set=0A=
+# CONFIG_BLK_DEV_LOOP is not set=0A=
+# CONFIG_BLK_DEV_NBD is not set=0A=
+# CONFIG_BLK_DEV_SX8 is not set=0A=
+# CONFIG_BLK_DEV_RAM is not set=0A=
+CONFIG_BLK_DEV_RAM_COUNT=3D16=0A=
+# CONFIG_CDROM_PKTCDVD is not set=0A=
+# CONFIG_ATA_OVER_ETH is not set=0A=
+=0A=
+#=0A=
+# ATA/ATAPI/MFM/RLL support=0A=
+#=0A=
+# CONFIG_IDE is not set=0A=
+=0A=
+#=0A=
+# SCSI device support=0A=
+#=0A=
+# CONFIG_RAID_ATTRS is not set=0A=
+# CONFIG_SCSI is not set=0A=
+=0A=
+#=0A=
+# Multi-device support (RAID and LVM)=0A=
+#=0A=
+# CONFIG_MD is not set=0A=
+=0A=
+#=0A=
+# Fusion MPT device support=0A=
+#=0A=
+# CONFIG_FUSION is not set=0A=
+=0A=
+#=0A=
+# IEEE 1394 (FireWire) support=0A=
+#=0A=
+# CONFIG_IEEE1394 is not set=0A=
+=0A=
+#=0A=
+# I2O device support=0A=
+#=0A=
+# CONFIG_I2O is not set=0A=
+=0A=
+#=0A=
+# Network device support=0A=
+#=0A=
+CONFIG_NETDEVICES=3Dy=0A=
+# CONFIG_DUMMY is not set=0A=
+# CONFIG_BONDING is not set=0A=
+# CONFIG_EQUALIZER is not set=0A=
+# CONFIG_TUN is not set=0A=
+=0A=
+#=0A=
+# ARCnet devices=0A=
+#=0A=
+# CONFIG_ARCNET is not set=0A=
+=0A=
+#=0A=
+# PHY device support=0A=
+#=0A=
+CONFIG_PHYLIB=3Dm=0A=
+=0A=
+#=0A=
+# MII PHY device drivers=0A=
+#=0A=
+CONFIG_MARVELL_PHY=3Dm=0A=
+CONFIG_DAVICOM_PHY=3Dm=0A=
+CONFIG_QSEMI_PHY=3Dm=0A=
+CONFIG_LXT_PHY=3Dm=0A=
+CONFIG_CICADA_PHY=3Dm=0A=
+=0A=
+#=0A=
+# Ethernet (10 or 100Mbit)=0A=
+#=0A=
+CONFIG_NET_ETHERNET=3Dy=0A=
+CONFIG_MII=3Dy=0A=
+CONFIG_IDT_RC32438_ETH=3Dy=0A=
+# CONFIG_HAPPYMEAL is not set=0A=
+# CONFIG_SUNGEM is not set=0A=
+# CONFIG_CASSINI is not set=0A=
+# CONFIG_NET_VENDOR_3COM is not set=0A=
+# CONFIG_DM9000 is not set=0A=
+=0A=
+#=0A=
+# Tulip family network device support=0A=
+#=0A=
+# CONFIG_NET_TULIP is not set=0A=
+# CONFIG_HP100 is not set=0A=
+CONFIG_NET_PCI=3Dy=0A=
+# CONFIG_PCNET32 is not set=0A=
+# CONFIG_AMD8111_ETH is not set=0A=
+# CONFIG_ADAPTEC_STARFIRE is not set=0A=
+# CONFIG_B44 is not set=0A=
+# CONFIG_FORCEDETH is not set=0A=
+# CONFIG_DGRS is not set=0A=
+# CONFIG_EEPRO100 is not set=0A=
+CONFIG_E100=3Dy=0A=
+# CONFIG_FEALNX is not set=0A=
+# CONFIG_NATSEMI is not set=0A=
+# CONFIG_NE2K_PCI is not set=0A=
+# CONFIG_8139CP is not set=0A=
+# CONFIG_8139TOO is not set=0A=
+# CONFIG_SIS900 is not set=0A=
+# CONFIG_EPIC100 is not set=0A=
+# CONFIG_SUNDANCE is not set=0A=
+# CONFIG_TLAN is not set=0A=
+# CONFIG_VIA_RHINE is not set=0A=
+# CONFIG_LAN_SAA9730 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (1000 Mbit)=0A=
+#=0A=
+# CONFIG_ACENIC is not set=0A=
+# CONFIG_DL2K is not set=0A=
+# CONFIG_E1000 is not set=0A=
+# CONFIG_NS83820 is not set=0A=
+# CONFIG_HAMACHI is not set=0A=
+# CONFIG_YELLOWFIN is not set=0A=
+# CONFIG_R8169 is not set=0A=
+# CONFIG_SIS190 is not set=0A=
+# CONFIG_SKGE is not set=0A=
+# CONFIG_SKY2 is not set=0A=
+# CONFIG_SK98LIN is not set=0A=
+# CONFIG_VIA_VELOCITY is not set=0A=
+# CONFIG_TIGON3 is not set=0A=
+# CONFIG_BNX2 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (10000 Mbit)=0A=
+#=0A=
+# CONFIG_CHELSIO_T1 is not set=0A=
+# CONFIG_IXGB is not set=0A=
+# CONFIG_S2IO is not set=0A=
+=0A=
+#=0A=
+# Token Ring devices=0A=
+#=0A=
+# CONFIG_TR is not set=0A=
+=0A=
+#=0A=
+# Wireless LAN (non-hamradio)=0A=
+#=0A=
+# CONFIG_NET_RADIO is not set=0A=
+=0A=
+#=0A=
+# Wan interfaces=0A=
+#=0A=
+# CONFIG_WAN is not set=0A=
+# CONFIG_FDDI is not set=0A=
+# CONFIG_HIPPI is not set=0A=
+# CONFIG_PPP is not set=0A=
+# CONFIG_SLIP is not set=0A=
+# CONFIG_SHAPER is not set=0A=
+# CONFIG_NETCONSOLE is not set=0A=
+# CONFIG_NETPOLL is not set=0A=
+# CONFIG_NET_POLL_CONTROLLER is not set=0A=
+=0A=
+#=0A=
+# ISDN subsystem=0A=
+#=0A=
+# CONFIG_ISDN is not set=0A=
+=0A=
+#=0A=
+# Telephony Support=0A=
+#=0A=
+# CONFIG_PHONE is not set=0A=
+=0A=
+#=0A=
+# Input device support=0A=
+#=0A=
+CONFIG_INPUT=3Dy=0A=
+=0A=
+#=0A=
+# Userland interfaces=0A=
+#=0A=
+# CONFIG_INPUT_MOUSEDEV is not set=0A=
+# CONFIG_INPUT_JOYDEV is not set=0A=
+# CONFIG_INPUT_TSDEV is not set=0A=
+# CONFIG_INPUT_EVDEV is not set=0A=
+# CONFIG_INPUT_EVBUG is not set=0A=
+=0A=
+#=0A=
+# Input Device Drivers=0A=
+#=0A=
+# CONFIG_INPUT_KEYBOARD is not set=0A=
+# CONFIG_INPUT_MOUSE is not set=0A=
+# CONFIG_INPUT_JOYSTICK is not set=0A=
+# CONFIG_INPUT_TOUCHSCREEN is not set=0A=
+# CONFIG_INPUT_MISC is not set=0A=
+=0A=
+#=0A=
+# Hardware I/O ports=0A=
+#=0A=
+# CONFIG_SERIO is not set=0A=
+# CONFIG_GAMEPORT is not set=0A=
+=0A=
+#=0A=
+# Character devices=0A=
+#=0A=
+CONFIG_VT=3Dy=0A=
+CONFIG_VT_CONSOLE=3Dy=0A=
+CONFIG_HW_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_NONSTANDARD is not set=0A=
+=0A=
+#=0A=
+# Serial drivers=0A=
+#=0A=
+CONFIG_SERIAL_8250=3Dy=0A=
+CONFIG_SERIAL_8250_CONSOLE=3Dy=0A=
+CONFIG_SERIAL_8250_NR_UARTS=3D4=0A=
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3D4=0A=
+# CONFIG_SERIAL_8250_EXTENDED is not set=0A=
+=0A=
+#=0A=
+# Non-8250 serial port support=0A=
+#=0A=
+CONFIG_SERIAL_CORE=3Dy=0A=
+CONFIG_SERIAL_CORE_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_JSM is not set=0A=
+CONFIG_UNIX98_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTY_COUNT=3D256=0A=
+=0A=
+#=0A=
+# IPMI=0A=
+#=0A=
+# CONFIG_IPMI_HANDLER is not set=0A=
+=0A=
+#=0A=
+# Watchdog Cards=0A=
+#=0A=
+# CONFIG_WATCHDOG is not set=0A=
+# CONFIG_RTC is not set=0A=
+# CONFIG_GEN_RTC is not set=0A=
+# CONFIG_DTLK is not set=0A=
+# CONFIG_R3964 is not set=0A=
+# CONFIG_APPLICOM is not set=0A=
+=0A=
+#=0A=
+# Ftape, the floppy tape device driver=0A=
+#=0A=
+# CONFIG_DRM is not set=0A=
+# CONFIG_RAW_DRIVER is not set=0A=
+=0A=
+#=0A=
+# TPM devices=0A=
+#=0A=
+# CONFIG_TCG_TPM is not set=0A=
+# CONFIG_TELCLOCK is not set=0A=
+=0A=
+#=0A=
+# I2C support=0A=
+#=0A=
+# CONFIG_I2C is not set=0A=
+=0A=
+#=0A=
+# SPI support=0A=
+#=0A=
+# CONFIG_SPI is not set=0A=
+# CONFIG_SPI_MASTER is not set=0A=
+=0A=
+#=0A=
+# Dallas's 1-wire bus=0A=
+#=0A=
+# CONFIG_W1 is not set=0A=
+=0A=
+#=0A=
+# Hardware Monitoring support=0A=
+#=0A=
+# CONFIG_HWMON is not set=0A=
+# CONFIG_HWMON_VID is not set=0A=
+=0A=
+#=0A=
+# Misc devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia Capabilities Port drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia devices=0A=
+#=0A=
+# CONFIG_VIDEO_DEV is not set=0A=
+=0A=
+#=0A=
+# Digital Video Broadcasting Devices=0A=
+#=0A=
+# CONFIG_DVB is not set=0A=
+=0A=
+#=0A=
+# Graphics support=0A=
+#=0A=
+# CONFIG_FB is not set=0A=
+=0A=
+#=0A=
+# Console display driver support=0A=
+#=0A=
+# CONFIG_VGA_CONSOLE is not set=0A=
+CONFIG_DUMMY_CONSOLE=3Dy=0A=
+=0A=
+#=0A=
+# Sound=0A=
+#=0A=
+# CONFIG_SOUND is not set=0A=
+=0A=
+#=0A=
+# USB support=0A=
+#=0A=
+CONFIG_USB_ARCH_HAS_HCD=3Dy=0A=
+CONFIG_USB_ARCH_HAS_OHCI=3Dy=0A=
+# CONFIG_USB is not set=0A=
+=0A=
+#=0A=
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'=0A=
+#=0A=
+=0A=
+#=0A=
+# USB Gadget Support=0A=
+#=0A=
+# CONFIG_USB_GADGET is not set=0A=
+=0A=
+#=0A=
+# MMC/SD Card support=0A=
+#=0A=
+# CONFIG_MMC is not set=0A=
+=0A=
+#=0A=
+# InfiniBand support=0A=
+#=0A=
+# CONFIG_INFINIBAND is not set=0A=
+=0A=
+#=0A=
+# SN Devices=0A=
+#=0A=
+=0A=
+#=0A=
+# EDAC - error detection and reporting (RAS)=0A=
+#=0A=
+=0A=
+#=0A=
+# File systems=0A=
+#=0A=
+CONFIG_EXT2_FS=3Dy=0A=
+# CONFIG_EXT2_FS_XATTR is not set=0A=
+# CONFIG_EXT2_FS_XIP is not set=0A=
+# CONFIG_EXT3_FS is not set=0A=
+# CONFIG_REISERFS_FS is not set=0A=
+# CONFIG_JFS_FS is not set=0A=
+# CONFIG_FS_POSIX_ACL is not set=0A=
+# CONFIG_XFS_FS is not set=0A=
+# CONFIG_OCFS2_FS is not set=0A=
+# CONFIG_MINIX_FS is not set=0A=
+# CONFIG_ROMFS_FS is not set=0A=
+# CONFIG_INOTIFY is not set=0A=
+# CONFIG_QUOTA is not set=0A=
+# CONFIG_DNOTIFY is not set=0A=
+# CONFIG_AUTOFS_FS is not set=0A=
+# CONFIG_AUTOFS4_FS is not set=0A=
+# CONFIG_FUSE_FS is not set=0A=
+=0A=
+#=0A=
+# CD-ROM/DVD Filesystems=0A=
+#=0A=
+# CONFIG_ISO9660_FS is not set=0A=
+# CONFIG_UDF_FS is not set=0A=
+=0A=
+#=0A=
+# DOS/FAT/NT Filesystems=0A=
+#=0A=
+# CONFIG_MSDOS_FS is not set=0A=
+# CONFIG_VFAT_FS is not set=0A=
+# CONFIG_NTFS_FS is not set=0A=
+=0A=
+#=0A=
+# Pseudo filesystems=0A=
+#=0A=
+CONFIG_PROC_FS=3Dy=0A=
+CONFIG_PROC_KCORE=3Dy=0A=
+CONFIG_SYSFS=3Dy=0A=
+# CONFIG_TMPFS is not set=0A=
+# CONFIG_HUGETLB_PAGE is not set=0A=
+CONFIG_RAMFS=3Dy=0A=
+# CONFIG_RELAYFS_FS is not set=0A=
+# CONFIG_CONFIGFS_FS is not set=0A=
+=0A=
+#=0A=
+# Miscellaneous filesystems=0A=
+#=0A=
+# CONFIG_ADFS_FS is not set=0A=
+# CONFIG_AFFS_FS is not set=0A=
+# CONFIG_HFS_FS is not set=0A=
+# CONFIG_HFSPLUS_FS is not set=0A=
+# CONFIG_BEFS_FS is not set=0A=
+# CONFIG_BFS_FS is not set=0A=
+# CONFIG_EFS_FS is not set=0A=
+# CONFIG_CRAMFS is not set=0A=
+# CONFIG_VXFS_FS is not set=0A=
+# CONFIG_HPFS_FS is not set=0A=
+# CONFIG_QNX4FS_FS is not set=0A=
+# CONFIG_SYSV_FS is not set=0A=
+# CONFIG_UFS_FS is not set=0A=
+=0A=
+#=0A=
+# Network File Systems=0A=
+#=0A=
+# CONFIG_NFS_FS is not set=0A=
+# CONFIG_NFSD is not set=0A=
+# CONFIG_SMB_FS is not set=0A=
+# CONFIG_CIFS is not set=0A=
+# CONFIG_NCP_FS is not set=0A=
+# CONFIG_CODA_FS is not set=0A=
+# CONFIG_AFS_FS is not set=0A=
+# CONFIG_9P_FS is not set=0A=
+=0A=
+#=0A=
+# Partition Types=0A=
+#=0A=
+# CONFIG_PARTITION_ADVANCED is not set=0A=
+CONFIG_MSDOS_PARTITION=3Dy=0A=
+=0A=
+#=0A=
+# Native Language Support=0A=
+#=0A=
+# CONFIG_NLS is not set=0A=
+=0A=
+#=0A=
+# Profiling support=0A=
+#=0A=
+# CONFIG_PROFILING is not set=0A=
+=0A=
+#=0A=
+# Kernel hacking=0A=
+#=0A=
+# CONFIG_PRINTK_TIME is not set=0A=
+# CONFIG_MAGIC_SYSRQ is not set=0A=
+# CONFIG_DEBUG_KERNEL is not set=0A=
+CONFIG_LOG_BUF_SHIFT=3D14=0A=
+CONFIG_CROSSCOMPILE=3Dy=0A=
+CONFIG_CMDLINE=3D""=0A=
+=0A=
+#=0A=
+# Security options=0A=
+#=0A=
+# CONFIG_KEYS is not set=0A=
+# CONFIG_SECURITY is not set=0A=
+=0A=
+#=0A=
+# Cryptographic options=0A=
+#=0A=
+# CONFIG_CRYPTO is not set=0A=
+=0A=
+#=0A=
+# Hardware crypto devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Library routines=0A=
+#=0A=
+CONFIG_CRC_CCITT=3Dy=0A=
+CONFIG_CRC16=3Dm=0A=
+CONFIG_CRC32=3Dy=0A=
+# CONFIG_LIBCRC32C is not set=0A=
+CONFIG_TEXTSEARCH=3Dy=0A=
+CONFIG_TEXTSEARCH_KMP=3Dm=0A=
+CONFIG_TEXTSEARCH_BM=3Dm=0A=
+CONFIG_TEXTSEARCH_FSM=3Dm=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/Kconfig =
idtlinux/arch/mips/idt-boards/Kconfig=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/Kconfig	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/Kconfig	2006-03-09 16:25:51.000000000 =
-0800=0A=
@@ -0,0 +1,107 @@=0A=
+config IDT_EB438=0A=
+	bool " Support for the IDT 79EB438 evaluation board"=0A=
+	depends on IDT_BOARDS=0A=
+	select DMA_NONCOHERENT=0A=
+	select IRQ_CPU=0A=
+	select HW_HAS_PCI=0A=
+	select SWAP_IO_SPACE=0A=
+	select SYS_HAS_CPU_MIPS32_R1=0A=
+	select SYS_SUPPORTS_LITTLE_ENDIAN=0A=
+	select BOOT_ELF32=0A=
+	select SYS_SUPPORTS_32BIT_KERNEL=0A=
+	select SYS_SUPPORTS_BIG_ENDIAN=0A=
+	help=0A=
+	 IDT evaluation board based on RC32438 Interprise Processor=0A=
+=0A=
+config RC32438_REVISION_ZA=0A=
+	bool " Support for ZA version"=0A=
+	depends on IDT_EB438=0A=
+	help=0A=
+	 Enable this option for enabling the workaround for the bugs=0A=
+	 in the ZA part.=0A=
+=0A=
+config IDT_EB434=0A=
+        bool " Support for the IDT 79EB434/435 evaluation board"=0A=
+        depends on IDT_BOARDS=0A=
+        select DMA_NONCOHERENT=0A=
+        select IRQ_CPU=0A=
+        select HW_HAS_PCI=0A=
+        select SWAP_IO_SPACE=0A=
+        select SYS_HAS_CPU_MIPS32_R1=0A=
+        select SYS_SUPPORTS_LITTLE_ENDIAN=0A=
+        select BOOT_ELF32=0A=
+        select SYS_SUPPORTS_32BIT_KERNEL=0A=
+        select SYS_SUPPORTS_BIG_ENDIAN=0A=
+        help=0A=
+         IDT evaluation board based on RC32434/435 Interprise =
Processor=0A=
+=0A=
+config IDT_EB365=0A=
+        bool " Support for the IDT 79EB365/336 based evaluation =
boards"=0A=
+        depends on IDT_BOARDS=0A=
+        select DMA_NONCOHERENT=0A=
+        select IRQ_CPU=0A=
+        select HW_HAS_PCI=0A=
+	select SYS_HAS_CPU_MIPS32_R1=0A=
+        select SYS_SUPPORTS_LITTLE_ENDIAN=0A=
+        select BOOT_ELF32=0A=
+        select SYS_SUPPORTS_32BIT_KERNEL=0A=
+        select SYS_SUPPORTS_BIG_ENDIAN=0A=
+        select SWAP_IO_SPACE=0A=
+        help=0A=
+         IDT evaluation boards based RC32300 core.=0A=
+=0A=
+config IDT_EB355=0A=
+        bool " Support for the IDT 79EB355 based evaluation boards"=0A=
+        depends on IDT_BOARDS=0A=
+        select DMA_NONCOHERENT=0A=
+        select IRQ_CPU=0A=
+        select SYS_HAS_CPU_MIPS32_R1=0A=
+        select SYS_SUPPORTS_LITTLE_ENDIAN=0A=
+        select BOOT_ELF32=0A=
+        select SYS_SUPPORTS_32BIT_KERNEL=0A=
+        select SYS_SUPPORTS_BIG_ENDIAN=0A=
+        select SWAP_IO_SPACE=0A=
+        help=0A=
+         IDT evaluation boards based RC32300 core.=0A=
+=0A=
+config IDT_S334=0A=
+        bool " Support for the IDT 79EB334 based evaluation boards"=0A=
+        depends on IDT_BOARDS=0A=
+        select DMA_NONCOHERENT=0A=
+        select IRQ_CPU=0A=
+        select HW_HAS_PCI=0A=
+        select SYS_SUPPORTS_LITTLE_ENDIAN=0A=
+	select SYS_HAS_CPU_MIPS32_R1=0A=
+        select BOOT_ELF32=0A=
+        select SYS_SUPPORTS_32BIT_KERNEL=0A=
+        select SYS_SUPPORTS_BIG_ENDIAN=0A=
+        select SWAP_IO_SPACE=0A=
+        help=0A=
+         IDT evaluation boards based RC32300 core.=0A=
+=0A=
+=0A=
+config  IDT_BOARD_FREQ=0A=
+        int "  Board Frequency (HZ)"=0A=
+        depends on IDT_EB438 || IDT_EB365 || IDT_EB434 || IDT_S334 || =
IDT_EB355=0A=
+        default 100000000 if IDT_EB434 || IDT_EB438=0A=
+        default 75000000 if IDT_EB355 || IDT_S334=0A=
+        default 90000000 if IDT_EB365=0A=
+        help=0A=
+         Specify the board frequency in Hz.=0A=
+=0A=
+config  IDT_ZIMAGE_ADDR=0A=
+        hex "  zImage Address"=0A=
+        depends on IDT_EB438 || IDT_EB355 || IDT_EB365 || IDT_EB434 || =
IDT_S334=0A=
+        default "0x88000000" if IDT_EB365 || IDT_EB438=0A=
+        default "0x9b000000" if IDT_EB434=0A=
+        default "0x8c000000" if IDT_EB355=0A=
+        default "0x80800000" if IDT_S334=0A=
+        help=0A=
+         You may create a compressed image by running 'make zImage' =
that can=0A=
+         either be loaded using the bootloader, or can be burned into =
the flash.=0A=
+         Specify the address where zImage will be loaded. The default =
address=0A=
+         is that of flash.=0A=
+=0A=
+config  IDT_BOOT_NVRAM=0A=
+        depends on IDT_EB438 || IDT_EB365 || IDT_EB434 || IDT_S334 || =
IDT_EB355=0A=
+        bool "  Enable reading environment variables from NVRAM"=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/csu_idt.S =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/csu_idt.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/csu_idt.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/csu_idt.S	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,285 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialization code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+		=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+#include "iregdef.h"=0A=
+#include "idtcpu.h"=0A=
+#include "idthdr.h"=0A=
+	=0A=
+#define  MHZ CONFIG_IDT_BOARD_FREQ=0A=
+=0A=
+#include "s364.h"		=0A=
+#include "s355ram.h"=0A=
+=0A=
+#define IndexInvalidate_I       0x00=0A=
+		=0A=
+/*--------------------------------------------------------------=0A=
+* prom entry point table=0A=
+*-------------------------------------------------------------*/=0A=
+=0A=
+FRAME(start,sp,0,ra)=0A=
+=0A=
+	j idtstart  /* begin monitor from start |00| */=0A=
+	=0A=
+idtstart:=0A=
+=0A=
+	.set noreorder=0A=
+	=0A=
+	mtc0  zero, C0_CAUSE=0A=
+	li    v0, 0x0=0A=
+	or    v0, (SR_CU0 | SR_BEV | SR_DE)=0A=
+	mtc0  v0, C0_SR=0A=
+=0A=
+	mfc0  v1, C0_CONFIG=0A=
+	li    v0, CFG_C_NCHRNT_WB  /* CFG_C_NCHRNT_WB  CFG_C_NCHRNT_WT_NWA =
CFG_C_UNCACHED */=0A=
+	and   v1, ~(0x7)=0A=
+	or    v1, v1, v0=0A=
+	mtc0  v1, C0_CONFIG=0A=
+	nop=0A=
+	nop=0A=
+	li    t0, ERR_CNTL_STATUS=0A=
+	lw    t1, 0(t0) =0A=
+	li    t2, ERR_CNTL_VALUE=0A=
+	and   t1, t2  =0A=
+	sw    t1, 0(t0)  =0A=
+=0A=
+/* ------------------- Setup Device Controller =
-------------------------------*/=0A=
+	li    t0, DEV_CTL_BASE    /* load 2 base address registers' base =
*/=0A=
+=0A=
+	lw    t2, 0x8(t0)=0A=
+	andi  t2, t2, 0x3=0A=
+	li    t1, MCR_CS0_BS      /* device0 control parameter */=0A=
+	or    t1, t1, t2=0A=
+	sw    t1, 0x8(t0)         /* set the control register for CS 1 - SRAM =
*/=0A=
+	li    t1, MCR_CS0_TC      /* device0 timing config. parameter */=0A=
+	sw    t1, 0xC(t0)=0A=
+=0A=
+	li    t1, 0x0=0A=
+	sw    t1, 0x14(t0)=0A=
+	sw    t1, 0x24(t0)=0A=
+	sw    t1, 0x34(t0)=0A=
+	sw    t1, 0x44(t0)=0A=
+	sw    t1, 0x54(t0)=0A=
+=0A=
+	li    t1, MBA_REG1=0A=
+	sw    t1, 0x10(t0)=0A=
+	li    t1, MCR_CS1_BS=0A=
+	sw    t1, 0x18(t0)=0A=
+	li    t1, MCR_CS1_TC=0A=
+	sw    t1, 0x1C(t0)=0A=
+	li    t1, MBM_REG1=0A=
+	sw    t1, 0x14(t0)=0A=
+=0A=
+	li    t1, MBA_REG2=0A=
+	sw    t1, 0x20(t0)=0A=
+	li    t1, MCR_CS2_BS=0A=
+	sw    t1, 0x28(t0)=0A=
+	li    t1, MCR_CS2_TC=0A=
+	sw    t1, 0x2C(t0)=0A=
+	li    t1, MBM_REG2=0A=
+	sw    t1, 0x24(t0)=0A=
+=0A=
+	li    t1, MBA_REG3=0A=
+	sw    t1, 0x30(t0)=0A=
+	li    t1, MCR_CS3_BS=0A=
+	sw    t1, 0x38(t0)=0A=
+	li    t1, MCR_CS3_TC=0A=
+	sw    t1, 0x3C(t0)=0A=
+	li    t1, MBM_REG3=0A=
+	sw    t1, 0x34(t0)=0A=
+=0A=
+	li    t1, MBA_REG4=0A=
+	sw    t1, 0x40(t0)=0A=
+	li    t1, MCR_CS4_BS=0A=
+	sw    t1, 0x48(t0)=0A=
+	li    t1, MCR_CS4_TC=0A=
+	sw    t1, 0x4C(t0)=0A=
+	li    t1, MBM_REG4=0A=
+	sw    t1, 0x44(t0)=0A=
+=0A=
+	li    t1, MBA_REG5=0A=
+	sw    t1, 0x50(t0)=0A=
+	li    t1, MCR_CS5_BS=0A=
+	sw    t1, 0x58(t0)=0A=
+	li    t1, MCR_CS5_TC=0A=
+	sw    t1, 0x5C(t0)=0A=
+	li    t1, MBM_REG5=0A=
+	sw    t1, 0x54(t0)=0A=
+=0A=
+/* USB fix for RP355 - set GPIO_26 as GPIO output low */=0A=
+	li    t0, GPIO_BASE=0A=
+	li    t1, 0xf9ffffff      /* All alternate functions for GPIO pins =
except GPIO_26*/=0A=
+	sw    t1, 0x0(t0)=0A=
+=0A=
+	lw    t1, 0x8(t0)         /* Reset GPIOD bit */=0A=
+	and   t1, ~0x04000000=0A=
+	sw    t1, 0x8(t0)=0A=
+=0A=
+	lw    t2, 0x4(t0)         /* Set as output */=0A=
+	or    t2, 0x04000000=0A=
+	sw    t2, 0x4(t0)=0A=
+=0A=
+	sw    t1, 0x8(t0)         /* Once again reset output */=0A=
+=0A=
+/*------------ load all R32355 internal registers' base address =
----------*/=0A=
+	li    t0, TIMER_BASE  =0A=
+=0A=
+/* ------------------- Disable WatchDog Timer =
--------------------------------- */=0A=
+	li    t1, DISABLE_TIMER=0A=
+	sw    t1, 0x40(t0)=0A=
+=0A=
+/* ------------------- Reduce Bus Timeout Count =
-----------------------------*/=0A=
+	li    t1, TIMEOUT_COUNT=0A=
+	sw    t1, 0x34(t0)=0A=
+=0A=
+/*-------------- Initialize SDRAM  Base and Mask Registers =
----------*/=0A=
+=0A=
+	li    t0, SDRAM_CTL_BASE=0A=
+	li    t1, SDRAM_CR_BS=0A=
+	li    t2, 0x7FFFFFFF=0A=
+	and   t1, t1, t2=0A=
+	sw    t1, 0x10(t0)        /* disable SDRAM refresh */=0A=
+=0A=
+	li    t1, 0x0             /* Disable Bank0 */=0A=
+	sw    t1, 0x4(t0)=0A=
+	li    t1, 0x0             /* Disable Bank1 */=0A=
+	sw    t1, 0xC(t0)         /* set DRAM bank 1 mask */=0A=
+=0A=
+	li    t1, DRAM_BNK0_BASE  /* load DRAM bank 0 physical address in t1 =
*/=0A=
+	sw    t1, 0x0(t0)         /* set DRAM bank 0 base */=0A=
+	li    t1, DRAM_BNK0_MASK  /* load DRAM bank 0 size in t1 */=0A=
+	sw    t1, 0x4(t0)         /* set DRAM bank 0 mask */=0A=
+=0A=
+/*-------------- Enable SDRAM Controller =
---------------------------*/=0A=
+	li    t0, SDRAM_CTL_BASE=0A=
+=0A=
+/*-------------- Setup Precharge Command =
---------------------------*/=0A=
+	li    t2, 2=0A=
+	li    t3, 0=0A=
+1:  =0A=
+	li    t1, SDRAM_PC_VAL=0A=
+	sw    t1, 0x10(t0)=0A=
+	nop=0A=
+	nop=0A=
+	lw    t7, 0x10(t0)=0A=
+	nop=0A=
+	li    t4, APATTERN=0A=
+	li    t5, 0xA0000000 | DRAM_BNK0_BASE=0A=
+	sw    t4, 0x0(t5)=0A=
+	addu  t3, 1=0A=
+	bne   t3, t2, 1b=0A=
+	nop=0A=
+/*--------------- Setup Refresh Command =
----------------------------*/=0A=
+	li    t2, 8=0A=
+	li    t3, 0=0A=
+1:      =0A=
+	li    t1, SDRAM_RFRSH_CMD=0A=
+	sw    t1, 0x10(t0)=0A=
+	sw    t4, 0x0(t5)=0A=
+	addu  t3, 1=0A=
+	bne   t3, t2, 1b=0A=
+	nop=0A=
+/*-------------- Setup up to write to Mode Register =
----------------*/=0A=
+	li    t1, SDRAM_MODE_REG=0A=
+	sw    t1, 0x10(t0)=0A=
+	addu  t5, 0x80            /* Kasi addu  t5,0xC0 (CL=3D3)*/=0A=
+	sw    t4, 0x0(t5)         /* note: same old t5 */=0A=
+=0A=
+/*-------------- Setup and Enable Refresh Timer =
--------------------*/=0A=
+=0A=
+	li    t0, TIMER_BASE      /* load timer register set base */=0A=
+=0A=
+	li    t1, DISABLE_TIMER   /* load diable timer bit settings into t1 =
*/=0A=
+	sw    t1, 0x2c(t0)        /* disable timer */=0A=
+=0A=
+	li    t1, 0               /* load DRAM refresh timer count register =
bit settings in t1 */=0A=
+	sw    t1, 0x24(t0)        /* set DRAM refresh timer count register =
bit settings */=0A=
+	li    t1, DRAM_RF_CMPR_SE_BS  /* load refresh timer compare value for =
slower expiration */=0A=
+	sw    t1, 0x28(t0)        /* set compare register again */=0A=
+=0A=
+	li    t1, ENABLE_TIMER    /* load timer enable bit */=0A=
+	sw    t1, 0x2c(t0)        /* enable refresh timer */=0A=
+=0A=
+	li    t0, SDRAM_CTL_BASE=0A=
+	li    t1, SDRAM_CR_BS=0A=
+	sw    t1, 0x10(t0)=0A=
+/* the memory system may need up to 120us to start up... */=0A=
+	li    v0, 128             /* ~256us */=0A=
+1:  =0A=
+	bne   v0, zero, 1b=0A=
+	subu  v0, 1               /* BDSLOT  */=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+/**********************************************************************=
**=0A=
+** before doing anything=0A=
+** initialize the section of memory used by cache initialization=0A=
+** whenever you boot out of ROM or reset-vector=0A=
+** This assumed to be 1MB.=0A=
+** --Sugan (11-22-96)=0A=
+***********************************************************************=
*/=0A=
+	=0A=
+	li    t0, 0xa0000000=0A=
+	li    t1, 0xa0100000=0A=
+1:=0A=
+	sw    zero, 0x00(t0)=0A=
+	sw    zero, 0x04(t0)=0A=
+	sw    zero, 0x08(t0)=0A=
+	sw    zero, 0x0c(t0)=0A=
+	addiu t0, 16=0A=
+	nop=0A=
+	blt   t0, t1, 1b=0A=
+	nop=0A=
+	nop=0A=
+	nop=0A=
+3:=0A=
+	mfc0  t0, C0_SR=0A=
+	nop=0A=
+	nop=0A=
+	and   t0, ~SR_BEV=0A=
+	mtc0  t0, C0_SR=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+	la      k0, zstartup=0A=
+	j      k0=0A=
+	nop=0A=
+	nop=0A=
+			=0A=
+ENDFRAME(start)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/head.S =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/head.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/head.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/head.S	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,138 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialisation code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+		=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/cacheops.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+#include <asm/regdef.h>=0A=
+=0A=
+#define IndexInvalidate_I       0x00=0A=
+=0A=
+	.set noreorder=0A=
+	.cprestore=0A=
+	LEAF(zstartup)=0A=
+zstartup:=0A=
+=0A=
+        la      sp, .stack=0A=
+	move	s0, a0=0A=
+	move	s1, a1=0A=
+	move	s2, a2=0A=
+	move	s3, a3=0A=
+=0A=
+	/* Clear BSS */=0A=
+	/* Note: when zImage is in ROM, _edata and _bss point to=0A=
+	 * ROM space even when using -Tbss on the linker command line;=0A=
+	 * maybe ld.script needs to be corrected.=0A=
+	 */=0A=
+	la	a0, .stack=0A=
+	la	a2, _end=0A=
+1:	sw	zero, 0(a0)=0A=
+	bne	a2, a0, 1b=0A=
+	addu	a0, 4=0A=
+=0A=
+#if 1=0A=
+	/* flush the I-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80002000  # end address (8KB I-Cache)=0A=
+	subu	k1, 128=0A=
+2:=0A=
+	.set mips3=0A=
+	cache	IndexInvalidate_I, 0(k0)=0A=
+	cache	IndexInvalidate_I, 16(k0)=0A=
+	cache	IndexInvalidate_I, 32(k0)=0A=
+	cache	IndexInvalidate_I, 48(k0)=0A=
+	cache	IndexInvalidate_I, 64(k0)=0A=
+	cache	IndexInvalidate_I, 80(k0)=0A=
+	cache	IndexInvalidate_I, 96(k0)=0A=
+	cache	IndexInvalidate_I, 112(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 2b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+#endif=0A=
+#if 1=0A=
+	/* flush the D-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80000400  # end address (2KB I-Cache)=0A=
+	subu	k1, 128=0A=
+3:	=0A=
+	.set mips3=0A=
+	/* First way */=0A=
+	cache	Index_Writeback_Inv_D, 0(k0)=0A=
+	cache	Index_Writeback_Inv_D, 16(k0)=0A=
+	cache	Index_Writeback_Inv_D, 32(k0)=0A=
+	cache	Index_Writeback_Inv_D, 48(k0)=0A=
+	cache	Index_Writeback_Inv_D, 64(k0)=0A=
+	cache	Index_Writeback_Inv_D, 80(k0)=0A=
+	cache	Index_Writeback_Inv_D, 96(k0)=0A=
+	cache	Index_Writeback_Inv_D, 112(k0)=0A=
+	/* Second way */=0A=
+	cache	Index_Writeback_Inv_D, 1024(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1040(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1056(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1072(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1088(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1104(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1120(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1136(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 3b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+#endif=0A=
+=0A=
+	la	ra, 3f=0A=
+	la	k0, decompress_kernel=0A=
+	jr	k0=0A=
+	nop=0A=
+3:=0A=
+=0A=
+	move	a0, s0=0A=
+	move	a1, s1=0A=
+	move	a2, s2=0A=
+	move	a3, s3=0A=
+	li	k0, KERNEL_ENTRY=0A=
+	jr	k0=0A=
+	nop=0A=
+4:=0A=
+	b 4b=0A=
+	END(zstartup)=0A=
+=0A=
+	.bss=0A=
+	.fill 0x2000=0A=
+	EXPORT(.stack)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/idtcpu.h =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/idtcpu.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/idtcpu.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/idtcpu.h	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,614 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#if defined(__IDTCPU_H__)=0A=
+#else=0A=
+#define __IDTCPU_H__=0A=
+=0A=
+=0A=
+/*=0A=
+** memory configuration and mapping=0A=
+*/=0A=
+#define K0BASE	0x80000000=0A=
+#define K0SIZE	0x20000000=0A=
+#define K1BASE	0xa0000000=0A=
+#define K1SIZE	0x20000000=0A=
+#define K2BASE	0xc0000000=0A=
+#if defined(S364)=0A=
+#define K2SIZE	0x3e000000=0A=
+#define ICEBASE	0xff000000=0A=
+#define ICESIZE	0x01000000=0A=
+#else=0A=
+#define K2SIZE	0x20000000=0A=
+#endif=0A=
+#if defined(CPU_R4000)=0A=
+#define KSBASE	0xe0000000=0A=
+#define KSSIZE	0x20000000=0A=
+#endif=0A=
+=0A=
+#define KUBASE	0=0A=
+#define KUSIZE	0x80000000=0A=
+=0A=
+/*=0A=
+** Exception Vectors=0A=
+*/=0A=
+#if defined(CPU_R3000)=0A=
+#define	UT_VEC	K0BASE			/* utlbmiss vector */=0A=
+#define E_VEC	(K0BASE+0x80)		/* exception vevtor */=0A=
+#endif=0A=
+#if defined(CPU_R4000) || defined S364  /*(CPU_R32364)      */=0A=
+#define	T_VEC	(K0BASE+0x000)		/* tlbmiss vector */=0A=
+#define X_VEC	(K0BASE+0x080)		/* xtlbmiss vector */=0A=
+#define C_VEC	(K1BASE+0x100)		/* cache error vector */=0A=
+#define E_VEC	(K0BASE+0x180)		/* exception vector */=0A=
+#define I_VEC	(K0BASE+0X200)		/* interrupt vector */=0A=
+#endif=0A=
+#define	R_VEC	(K1BASE+0x1fc00000)	/* reset vector */=0A=
+=0A=
+/*=0A=
+** Address conversion macros=0A=
+*/=0A=
+#ifdef CLANGUAGE=0A=
+#define	CAST(as) (as)=0A=
+#else=0A=
+#define	CAST(as)=0A=
+#endif=0A=
+#define	K0_TO_K1(x)	(CAST(unsigned)(x)|0xA0000000)	/* kseg0 to kseg1 =
*/=0A=
+#define	K1_TO_K0(x)	(CAST(unsigned)(x)&0x9FFFFFFF)	/* kseg1 to kseg0 =
*/=0A=
+#define	K0_TO_PHYS(x)	(CAST(unsigned)(x)&0x1FFFFFFF)	/* kseg0 to =
physical */=0A=
+#define	K1_TO_PHYS(x)	(CAST(unsigned)(x)&0x1FFFFFFF)	/* kseg1 to =
physical */=0A=
+#define	PHYS_TO_K0(x)	(CAST(unsigned)(x)|0x80000000)	/* physical to =
kseg0 */=0A=
+#define	PHYS_TO_K1(x)	(CAST(unsigned)(x)|0xA0000000)	/* physical to =
kseg1 */=0A=
+=0A=
+/*=0A=
+**	Cache size constants=0A=
+*/=0A=
+/* Sugan changed so that MINCACHE is 0x200 instead of 0x800 */=0A=
+#define	MINCACHE	0x200		/* 512 bytes  */=0A=
+#define	MAXCACHE	0x40000		/* 256*1024   256k */	=0A=
+=0A=
+#if defined CPU_R32364                  /* Includes RC32364, RC32332, =
RC32334 */=0A=
+#define	CFG_ICE		0x80000000	/* ICE detect */=0A=
+#define	CFG_ECMASK	0x70000000	/* System Clock Ratio */=0A=
+#define	CFG_ECBY2	0x00000000 	/* divide by 2 */=0A=
+#define	CFG_ECBY3	0x10000000 	/* divide by 3 */=0A=
+#define	CFG_ECBY4	0x20000000 	/* divide by 4 */=0A=
+#define	CFG_NBL		0x00800000	/* Non-Blocking load pending */=0A=
+#define	CFG_BE		0x00008000	/* Big Endian */=0A=
+#define	CFG_ICMASK	0x00000e00	/* Instruction cache size */=0A=
+#define	CFG_ICSHIFT	9=0A=
+#define	CFG_DCMASK	0x000001c0	/* Data cache size */=0A=
+#define	CFG_DCSHIFT	6=0A=
+#define	CFG_IB		0x00000020	/* Instruction cache line size */=0A=
+#define	CFG_DB		0x00000010	/* Data cache line size */=0A=
+#define	CFG_K0MASK	0x00000007	/* KSEG0 coherency algorithm */=0A=
+=0A=
+/*=0A=
+ * R32364 primary cache mode=0A=
+ */=0A=
+#define CFG_C_NCHRNT_WT_NWA	0=0A=
+#define CFG_C_NCHRNT_WT		1=0A=
+#define CFG_C_UNCACHED		2=0A=
+#define CFG_C_NCHRNT_WB		3=0A=
+=0A=
+/* Cache Operations */=0A=
+#define Index_Invalidate_I               0x0         /* 0       0 =
*/=0A=
+#define Index_Writeback_Inv_D            0x1         /* 0       1 =
*/=0A=
+#define Index_Invalidate_SI              0x2         /* 0       2 =
*/=0A=
+#define Index_Writeback_Inv_SD           0x3         /* 0       3 =
*/=0A=
+#define Index_Load_Tag_I                 0x4         /* 1       0 =
*/=0A=
+#define Index_Load_Tag_D                 0x5         /* 1       1 =
*/=0A=
+#define Index_Load_Tag_SI                0x6         /* 1       2 =
*/=0A=
+#define Index_Load_Tag_SD                0x7         /* 1       3 =
*/=0A=
+#define Index_Store_Tag_I                0x8         /* 2       0 =
*/=0A=
+#define Index_Store_Tag_D                0x9         /* 2       1 =
*/=0A=
+#define Index_Store_Tag_SI               0xA         /* 2       2 =
*/=0A=
+#define Index_Store_Tag_SD               0xB         /* 2       3 =
*/=0A=
+#define Create_Dirty_Exc_D               0xD         /* 3       1 =
*/=0A=
+#define Create_Dirty_Exc_SD              0xF         /* 3       3 =
*/=0A=
+#define Hit_Invalidate_I                 0x10        /* 4       0 =
*/=0A=
+#define Hit_Invalidate_D                 0x11        /* 4       1 =
*/=0A=
+#define Hit_Invalidate_SI                0x12        /* 4       2 =
*/=0A=
+#define Hit_Invalidate_SD                0x13        /* 4       3 =
*/=0A=
+#define Hit_Writeback_Inv_D              0x15        /* 5       1 =
*/=0A=
+#define Hit_Writeback_Inv_SD             0x17        /* 5       3 =
*/=0A=
+#define Fill_I                           0x14        /* 5       0 =
*/=0A=
+#define Hit_Writeback_D                  0x19        /* 6       1 =
*/=0A=
+#define Hit_Writeback_SD                 0x1B        /* 6       3 =
*/=0A=
+#define Hit_Writeback_I                  0x18        /* 6       0 =
*/=0A=
+#define Hit_Set_Virtual_SI               0x1E        /* 7       2 =
*/=0A=
+#define Hit_Set_Virtual_SD               0x1F        /* 7       3 =
*/=0A=
+#define CFG_EW32        0x00040000      /* 32 bit */=0A=
+#endif /* CPU_R32364 */=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+/* R4000 configuration register definitions */=0A=
+#define CFG_CM		0x80000000	/* Master-Checker mode */=0A=
+#define CFG_ECMASK	0x70000000	/* System Clock Ratio */=0A=
+#define CFG_ECBY2	0x00000000 	/* divide by 2 */=0A=
+#define CFG_ECBY3	0x10000000 	/* divide by 3 */=0A=
+#define CFG_ECBY4	0x20000000 	/* divide by 4 */=0A=
+#define CFG_EPMASK	0x0f000000	/* Transmit data pattern */=0A=
+#define CFG_EPD		0x00000000	/* D */=0A=
+#define CFG_EPDDX	0x01000000	/* DDX */=0A=
+#define CFG_EPDDXX	0x02000000	/* DDXX */=0A=
+#define CFG_EPDXDX	0x03000000	/* DXDX */=0A=
+#define CFG_EPDDXXX	0x04000000	/* DDXXX */=0A=
+#define CFG_EPDDXXXX	0x05000000	/* DDXXXX */=0A=
+#define CFG_EPDXXDXX	0x06000000	/* DXXDXX */=0A=
+#define CFG_EPDDXXXXX	0x07000000	/* DDXXXXX */=0A=
+#define CFG_EPDXXXDXXX	0x08000000	/* DXXXDXXX */=0A=
+#define CFG_SBMASK	0x00c00000	/* Secondary cache block size */=0A=
+#define CFG_SBSHIFT	22=0A=
+#define CFG_SB4		0x00000000	/* 4 words */=0A=
+#define CFG_SB8		0x00400000	/* 8 words */=0A=
+#define CFG_SB16	0x00800000	/* 16 words */=0A=
+#define CFG_SB32	0x00c00000	/* 32 words */=0A=
+#define CFG_SS		0x00200000	/* Split secondary cache */=0A=
+#define CFG_SW		0x00100000	/* Secondary cache port width */=0A=
+#define CFG_EWMASK	0x000c0000	/* System port width */=0A=
+#define CFG_EWSHIFT	18=0A=
+#define CFG_EW64	0x00000000	/* 64 bit */=0A=
+#define CFG_EW32	0x00040000	/* 32 bit */=0A=
+/* #if defined(CPU_R5000) */=0A=
+/* Sugan added for R5000 L2 cache 07-17-96 */=0A=
+#define L2_PAGESIZE	0x1000=0A=
+#define SIZE256K	0x00040000 /* 256KB in Hex */=0A=
+#define CFG_HARDL2	0x00020000 /* Hardware bit that enables/disables=0A=
+				      L2 cache */=0A=
+#define CFG_SE		0x1000=0A=
+#define CFG_SIZE512K	0x00000000 /* size of Scache is 512k */=0A=
+#define CFG_SIZE1MB 	0x00100000 /* size of Scache is 1MB */=0A=
+#define CFG_SIZE2MB 	0x00200000 /* size of Scache is 2MB */=0A=
+#define CFG_SIZEMASK	0x00300000 /* size mask */=0A=
+/* #endif */=0A=
+#define CFG_SC		0x00020000	/* Secondary cache absent */=0A=
+#define CFG_SM		0x00010000	/* Dirty Shared mode disabled */=0A=
+#define CFG_BE		0x00008000	/* Big Endian */=0A=
+#define CFG_EM		0x00004000	/* ECC mode enable */=0A=
+#define CFG_EB		0x00002000	/* Block ordering */=0A=
+#define CFG_ICMASK	0x00000e00	/* Instruction cache size */=0A=
+#define CFG_ICSHIFT	9=0A=
+#define CFG_DCMASK	0x000001c0	/* Data cache size */=0A=
+#define CFG_DCSHIFT	6=0A=
+#define CFG_IB		0x00000020	/* Instruction cache block size */=0A=
+#define CFG_DB		0x00000010	/* Data cache block size */=0A=
+#define CFG_CU		0x00000008	/* Update on Store Conditional */=0A=
+#define CFG_K0MASK	0x00000007	/* KSEG0 coherency algorithm */=0A=
+=0A=
+/*=0A=
+ * R4000 primary cache mode=0A=
+ */=0A=
+#define CFG_C_WRITETHROUGH_CACHE		0=0A=
+#define CFG_C_UNCACHED		2=0A=
+#define CFG_C_NONCOHERENT	3=0A=
+#define CFG_C_COHERENTXCL	4=0A=
+#define CFG_C_COHERENTXCLW	5=0A=
+#define CFG_C_COHERENTUPD	6=0A=
+=0A=
+/*=0A=
+ * R4000 cache operations (should be in assembler...?)=0A=
+ */=0A=
+#if defined(CPU_R5000)=0A=
+#define InvAllScache			 0x03	     /* 0	3 */=0A=
+#define IndexLoadTagScache		 0x07	     /* 1	3 */=0A=
+#define IndexStoreTagScache		 0x0b	     /* 2	3 */=0A=
+#define PageInvScache			 0x17	     /* 5	3 */=0A=
+#endif=0A=
+#define Index_Invalidate_I               0x0         /* 0       0 =
*/=0A=
+#define Index_Writeback_Inv_D            0x1         /* 0       1 =
*/=0A=
+#define Index_Invalidate_SI              0x2         /* 0       2 =
*/=0A=
+#define Index_Writeback_Inv_SD           0x3         /* 0       3 =
*/=0A=
+#define Index_Load_Tag_I                 0x4         /* 1       0 =
*/=0A=
+#define Index_Load_Tag_D                 0x5         /* 1       1 =
*/=0A=
+#define Index_Load_Tag_SI                0x6         /* 1       2 =
*/=0A=
+#define Index_Load_Tag_SD                0x7         /* 1       3 =
*/=0A=
+#define Index_Store_Tag_I                0x8         /* 2       0 =
*/=0A=
+#define Index_Store_Tag_D                0x9         /* 2       1 =
*/=0A=
+#define Index_Store_Tag_SI               0xA         /* 2       2 =
*/=0A=
+#define Index_Store_Tag_SD               0xB         /* 2       3 =
*/=0A=
+#define Create_Dirty_Exc_D               0xD         /* 3       1 =
*/=0A=
+#define Create_Dirty_Exc_SD              0xF         /* 3       3 =
*/=0A=
+#define Hit_Invalidate_I                 0x10        /* 4       0 =
*/=0A=
+#define Hit_Invalidate_D                 0x11        /* 4       1 =
*/=0A=
+#define Hit_Invalidate_SI                0x12        /* 4       2 =
*/=0A=
+#define Hit_Invalidate_SD                0x13        /* 4       3 =
*/=0A=
+#define Hit_Writeback_Inv_D              0x15        /* 5       1 =
*/=0A=
+#define Hit_Writeback_Inv_SD             0x17        /* 5       3 =
*/=0A=
+#define Fill_I                           0x14        /* 5       0 =
*/=0A=
+#define Hit_Writeback_D                  0x19        /* 6       1 =
*/=0A=
+#define Hit_Writeback_SD                 0x1B        /* 6       3 =
*/=0A=
+#define Hit_Writeback_I                  0x18        /* 6       0 =
*/=0A=
+#define Hit_Set_Virtual_SI               0x1E        /* 7       2 =
*/=0A=
+#define Hit_Set_Virtual_SD               0x1F        /* 7       3 =
*/=0A=
+=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** TLB resource defines=0A=
+*/=0A=
+=0A=
+#if defined(CPU_R32364)  =0A=
+#define	N_TLB_ENTRIES	16=0A=
+#endif =0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+#define N_TLB_ENTRIES  48=0A=
+#endif=0A=
+=0A=
+#if defined (CPU_R32364)=0A=
+#define	TLBHI_VPN2MASK	0xffffe000=0A=
+#define	TLBHI_PIDMASK	0x000000ff=0A=
+#define	TLBHI_NPID	256=0A=
+=0A=
+#define	TLBLO_PFNMASK	0x03ffffc0=0A=
+#define	TLBLO_PFNSHIFT	6=0A=
+#define	TLBLO_D		0x00000004	/* writeable */=0A=
+#define	TLBLO_V		0x00000002	/* valid bit */=0A=
+#define	TLBLO_G		0x00000001	/* global access bit */=0A=
+#define	TLBLO_CMASK	0x00000038	/* cache algorithm mask */=0A=
+#define	TLBLO_CSHIFT	3=0A=
+=0A=
+#define	TLBLO_UNCACHED		(CFG_C_UNCACHED<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WT_NWA	(CFG_C_NCHRNT_WT_NWA<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WT		(CFG_C_NCHRNT_WT<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WB		(CFG_C_NCHRNT_WB<<TLBLO_CSHIFT)=0A=
+=0A=
+#elif defined(CPU_R4000)=0A=
+#define	TLBHI_VPN2MASK	0xffffe000=0A=
+#define	TLBHI_PIDMASK	0x000000ff=0A=
+#define	TLBHI_NPID	256=0A=
+=0A=
+#define	TLBLO_PFNMASK	0x3fffffc0=0A=
+#define	TLBLO_PFNSHIFT	6=0A=
+#define	TLBLO_D		0x00000004	/* writeable */=0A=
+#define	TLBLO_V		0x00000002	/* valid bit */=0A=
+#define	TLBLO_G		0x00000001	/* global access bit */=0A=
+#define	TLBLO_CMASK	0x00000038	/* cache algorithm mask */=0A=
+#define	TLBLO_CSHIFT	3=0A=
+=0A=
+#define	TLBLO_UNCACHED		(CFG_C_UNCACHED<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NONCOHERENT	(CFG_C_NONCOHERENT<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTXCL	(CFG_C_COHERENTXCL<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTXCLW	(CFG_C_COHERENTXCLW<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTUPD	(CFG_C_COHERENTUPD<<TLBLO_CSHIFT)=0A=
+#endif=0A=
+#if defined(CPU_R4000)||defined(S364)=0A=
+#define	TLBINX_PROBE	0x80000000=0A=
+#define	TLBINX_INXMASK	0x0000003f=0A=
+=0A=
+#define	TLBRAND_RANDMASK	0x0000003f=0A=
+=0A=
+#define	TLBCTXT_BASEMASK	0xff800000=0A=
+#define	TLBCTXT_BASESHIFT	23=0A=
+=0A=
+#define	TLBCTXT_VPN2MASK	0x007ffff0=0A=
+#define	TLBCTXT_VPN2SHIFT	4=0A=
+=0A=
+#define	TLBPGMASK_MASK		0x01ffe000=0A=
+#endif=0A=
+=0A=
+#define	SR_PE		0x00100000	/* cache parity error */=0A=
+#if defined(CPU_R3000)=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* use boot exception vectors */=0A=
+=0A=
+/* Cache control bits */=0A=
+#define	SR_TS		0x00200000	/* TLB shutdown */=0A=
+#define	SR_CM		0x00080000	/* cache miss */=0A=
+#define	SR_PZ		0x00040000	/* cache parity zero */=0A=
+#define	SR_SWC		0x00020000	/* swap cache */=0A=
+#define	SR_ISC		0x00010000	/* Isolate data cache */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KUO		0x00000020	/* old kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEO		0x00000010	/* old interrupt enable, 1 =3D> enable =
*/=0A=
+#define	SR_KUP		0x00000008	/* prev kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEP		0x00000004	/* prev interrupt enable, 1 =3D> enable =
*/=0A=
+#define	SR_KUC		0x00000002	/* cur kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEC		0x00000001	/* cur interrupt enable, 1 =3D> enable =
*/=0A=
+#endif=0A=
+=0A=
+#if defined S364                        /* (CPU_R32364)        */=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+/* defines for R32364 processor */=0A=
+#define	SR_NBL		0x08000000	/* Non Blocking Load */=0A=
+#define	SR_RE		0X02000000	/* Reverse Endianness */=0A=
+#define	SR_DL		0x01000000	/* Data Cache Locking */=0A=
+#define	SR_IL		0x00800000	/* Instruction Cache Locking */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_SR		0x00100000	/* Soft reset */=0A=
+#define	SR_CH		0x00040000	/* Cache hit */=0A=
+#define	SR_CE		0x00020000	/* Use cache ECC  */=0A=
+#define	SR_DE		0x00010000	/* Disable cache exceptions */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KSMASK	0x00000016	/* Kernel mode mask */=0A=
+#define	SR_KSUSER	0x00000000	/* User Mode */=0A=
+#define	SR_KSKERNEL	0x00000016	/* Kernel Mode */=0A=
+=0A=
+#define	SR_ERL		0x00000004	/* Error level */=0A=
+#define	SR_EXL		0x00000002	/* Exception level */=0A=
+#define	SR_IE		0x00000001	/* Interrupts enabled */=0A=
+#define	NOT_SR_IEC      0xfffffffe      /* assembler problem with =
li=0A=
+~SR_IEC */=0A=
+=0A=
+/* R32364 Cache locking bits */=0A=
+#define SR_ICACHELOCK 0x00800000=0A=
+#define SR_DCACHELOCK 0x01000000=0A=
+=0A=
+#endif /* CPU_R32364 */=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+#define	SR_RP		0x08000000      /* Reduced power operation */=0A=
+#define	SR_FR		0x04000000	/* Additional floating pt registers */=0A=
+#define	SR_RE		0x02000000	/* Reverse endian in user mode */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_TS		0x00200000	/* TLB shutdown */=0A=
+#define	SR_SR		0x00100000	/* Soft reset */=0A=
+#define	SR_CH		0x00040000	/* Cache hit */=0A=
+#define	SR_CE		0x00020000	/* Use cache ECC  */=0A=
+#define	SR_DE		0x00010000	/* Disable cache exceptions */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KSMASK	0x00000018	/* Kernel mode mask */=0A=
+#define	SR_KSUSER	0x00000010	/* User mode */=0A=
+#define	SR_KSSUPER	0x00000008	/* Supervisor mode */=0A=
+#define	SR_KSKERNEL	0x00000000	/* Kernel mode */=0A=
+#define	SR_ERL		0x00000004	/* Error level */=0A=
+#define	SR_EXL		0x00000002	/* Exception level */=0A=
+#define	SR_IE		0x00000001	/* Interrupts enabled */=0A=
+=0A=
+/* R4650 Cache locking bits */=0A=
+#define	SR_ICACHELOCK 0x00800000=0A=
+#define	SR_DCACHELOCK 0x01000000=0A=
+=0A=
+=0A=
+#endif=0A=
+#if defined(CPU_R3000)=0A=
+#define	SR_FR		0x04000000	/* Additional floating point registers */=0A=
+#endif=0A=
+=0A=
+=0A=
+=0A=
+/*=0A=
+ * Cause Register=0A=
+ */=0A=
+#define	CAUSE_BD	0x80000000	/* Branch delay slot */=0A=
+#define	CAUSE_CEMASK	0x30000000	/* coprocessor error */=0A=
+#define	CAUSE_CESHIFT	28=0A=
+#define	CAUSE_IW	0x01000000	/* Instruction watch */=0A=
+#define	CAUSE_DW	0x02000000	/* Data watch */=0A=
+#define	CAUSE_IPE	0x04000000	/* Imprecise exception */=0A=
+=0A=
+=0A=
+#define	CAUSE_IPMASK	0x0000FF00	/* Pending interrupt mask */=0A=
+#define	CAUSE_IPSHIFT	8=0A=
+=0A=
+/* Notice: Watch Exception if Exc. Code is 23 is not included in the =
mask=0A=
+ *	   for R32364.=0A=
+ */=0A=
+#define	CAUSE_EXCMASK	0x0000003C	/* Cause code bits */=0A=
+#define	CAUSE_EXCSHIFT	2=0A=
+=0A=
+#ifndef XDS=0A=
+/*=0A=
+**  Coprocessor 0 registers=0A=
+*/=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3 	*/=0A=
+#define C0_IBASE        $0		/* I base */=0A=
+#define C0_IBOUND       $1		/* I bound */=0A=
+=0A=
+#define	C0_INX			$0		/* tlb index */=0A=
+#define	C0_RAND			$1		/* tlb random */=0A=
+#if defined(CPU_R3000)=0A=
+#define	C0_TLBLO	$2				/* tlb entry low */=0A=
+#define	C0_BUSCTRL		$2		/* bus control R3041 specific */=0A=
+#define	C0_CONFIG		$3		/* cache config */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* count R3041 specific */=0A=
+#define	C0_PORTSIZE		$10	/* port size R3041 specific */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* compare R3041 specific */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#endif=0A=
+=0A=
+#if defined(S364)					/*(CPU_R32364)      */=0A=
+#define	C0_RANDOM		$1=0A=
+#define	C0_TLBLO0		$2		/* tlb entry low 0 */=0A=
+#define	C0_TLBLO1		$3		/* tlb entry low 1 */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_PAGEMASK		$5		/* tlb page mask */=0A=
+#define	C0_WIRED			$6		/* number of wired tlb entries */=0A=
+=0A=
+#define	C0_INX			$0		/* tlb index */=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* timer count */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* timer comparator  */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#define	C0_CONFIG		$16	/* configuration register */=0A=
+=0A=
+#define	C0_IWATCH		$18	/* Instr brk pt Virtual add. */=0A=
+#define	C0_DWATCH		$19	/* Data brk pt Virtual add. */=0A=
+=0A=
+#define	C0_IEPC			$22	/* Imprecise Exception pc */=0A=
+#define	C0_DEPC			$23	/* Debug Exception pc */=0A=
+#define	C0_DEBUG			$24	/* Debug control/status reg */=0A=
+=0A=
+#define	C0_ECC			$26	/* primary cache Parity control */=0A=
+#define	C0_CACHEERR		$27	/* cache error status */=0A=
+#define	C0_TAGLO			$28	/* cache tag lo */=0A=
+#define	C0_TAGHI			$29=0A=
+#define	C0_ERRPC			$30	/* cache error pc */=0A=
+#endif /* CPU_R32364 			*/=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3 	*/=0A=
+#define	C0_DBASE			$2		/* D base */=0A=
+#define	C0_DBOUND		$3		/* D bound */=0A=
+=0A=
+#define	C0_TLBLO0		$2		/* tlb entry low 0 */=0A=
+#define	C0_TLBLO1		$3		/* tlb entry low 1 */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_PAGEMASK		$5		/* tlb page mask */=0A=
+#define	C0_WIRED			$6		/* number of wired tlb entries */=0A=
+=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* cycle count */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* cyccle count comparator  */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#define	C0_CONFIG		$16	/* configuration register */=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3   */=0A=
+#define	C0_CALG			$17	/* Calg rigister */=0A=
+#define	C0_IWATCH		$18	/* IWatch register */=0A=
+#define	C0_DWATCH		$19	/* DWatch register */=0A=
+=0A=
+#define	C0_LLADDR		$17	/* linked load address */=0A=
+#define	C0_WATCHLO		$18	/* watchpoint trap register */=0A=
+#define	C0_WATCHHI		$19	/* watchpoint trap register */=0A=
+#define	C0_XCTXT			$20 	/* extended tlb context */=0A=
+#define	C0_ECC			$26	/* secondary cache ECC control */=0A=
+#define	C0_CACHEERR		$27	/* cache error status */=0A=
+#define	C0_TAGLO			$28	/* cache tag lo */=0A=
+#define	C0_TAGHI			$29	/* cache tag hi */=0A=
+#define	C0_ERRPC			$30	/* cache error pc */=0A=
+#endif=0A=
+#endif =0A=
+#endif /* defined(__IDTCPU_H__) */=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/idthdr.h =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/idthdr.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/idthdr.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/idthdr.h	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,53 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Some macros. Though they are already defined else where in the =
linux=0A=
+ *   tree, they are once again declared here for the ease of syncing =
up with=0A=
+ *    IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef XDS=0A=
+=0A=
+#define	FRAME(name,frm_reg,offset,ret_reg)	\=0A=
+	.globl	name;				\=0A=
+	.ent	name;				\=0A=
+name:;						\=0A=
+	.frame	frm_reg,offset,ret_reg=0A=
+=0A=
+#define ENDFRAME(name) 	.end name=0A=
+=0A=
+#else=0A=
+=0A=
+#define FRAME(name,frm_reg,offset,ret_reg)      \=0A=
+name:=0A=
+=0A=
+#define ENDFRAME(name)=0A=
+=0A=
+#endif=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/image.lds.in =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/image.lds.in=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/image.lds.in	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/image.lds.in	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D IMSTART;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/EB355/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D BSS_START;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/iregdef.h =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/iregdef.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/iregdef.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/iregdef.h	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,284 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#define r0	$0=0A=
+#define r1	$1 /*at assembler temp */=0A=
+#define r2	$2 /*v0 return value */=0A=
+#define r3	$3 /*v1 return value */=0A=
+#define r4	$4 /*a0 argument 0 */=0A=
+#define r5	$5 /*a1 argument 1 */=0A=
+#define r6	$6=0A=
+#define r7	$7=0A=
+#define r8	$8=0A=
+#define r9	$9=0A=
+#define r10	$10=0A=
+#define r11	$11=0A=
+#define r12	$12=0A=
+#define r13	$13=0A=
+=0A=
+#define r14	$14=0A=
+#define r15	$15=0A=
+#define r16	$16 /*s0 called saved */=0A=
+#define r17	$17=0A=
+#define r18	$18=0A=
+#define r19	$19=0A=
+#define r20	$20=0A=
+#define r21	$21=0A=
+#define r22	$22=0A=
+#define r23	$23 /*s7 called saved */=0A=
+#define r24	$24=0A=
+#define r25	$25=0A=
+#define r26	$26 /*k0 kernel temp. */=0A=
+#define r27	$27 /*k1   ""    ""   */=0A=
+#define r28	$28 /*gp global pointer */=0A=
+#define r29	$29 /*sp stack pointer */=0A=
+#define r30	$30 /*fp frame pointer */=0A=
+#define r31	$31 /*ra return address */=0A=
+=0A=
+#define fp0	$f0=0A=
+#define fp1	$f1=0A=
+#define fp2	$f2=0A=
+#define fp3	$f3=0A=
+#define fp4	$f4=0A=
+#define fp5	$f5=0A=
+#define fp6	$f6=0A=
+#define fp7	$f7=0A=
+#define fp8	$f8=0A=
+#define fp9	$f9=0A=
+#define fp10	$f10=0A=
+#define fp11	$f11=0A=
+#define fp12	$f12=0A=
+#define fp13	$f13=0A=
+#define fp14	$f14=0A=
+#define fp15	$f15=0A=
+#define fp16	$f16=0A=
+#define fp17	$f17=0A=
+#define fp18	$f18=0A=
+#define fp19	$f19=0A=
+#define fp20	$f20=0A=
+#define fp21	$f21=0A=
+#define fp22	$f22=0A=
+#define fp23	$f23=0A=
+#define fp24	$f24=0A=
+#define fp25	$f25=0A=
+#define fp26	$f26=0A=
+#define fp27	$f27=0A=
+#define fp28	$f28=0A=
+#define fp29	$f29=0A=
+#define fp30	$f30=0A=
+#define fp31	$f31=0A=
+=0A=
+#define fcr0	$0=0A=
+#define fcr30	$30=0A=
+#define fcr31	$31=0A=
+=0A=
+#define zero	$0	/* wired zero */=0A=
+#define AT	$at	/* assembler temp */=0A=
+#define v0	$2	/* return value */=0A=
+#define v1	$3=0A=
+#define a0	$4	/* argument registers */=0A=
+#define a1	$5=0A=
+#define a2	$6=0A=
+#define a3	$7=0A=
+#define t0	$8	/* caller saved */=0A=
+#define t1	$9=0A=
+#define t2	$10=0A=
+#define t3	$11=0A=
+#define t4	$12=0A=
+#define t5	$13=0A=
+#define t6	$14=0A=
+#define t7	$15=0A=
+#define s0	$16	/* callee saved */=0A=
+#define s1	$17=0A=
+#define s2	$18=0A=
+#define s3	$19=0A=
+#define s4	$20=0A=
+#define s5	$21=0A=
+#define s6	$22=0A=
+#define s7	$23=0A=
+#define t8	$24	/* code generator */=0A=
+#define t9	$25=0A=
+#define k0	$26	/* kernel temporary */=0A=
+#define k1	$27=0A=
+#define gp	$28	/* global pointer */=0A=
+#define sp	$29	/* stack pointer */=0A=
+#define s8	$30	/* yet another saved reg for the callee */=0A=
+#define fp	$30	/* frame pointer - this is being phased out by MIPS =
*/=0A=
+#define ra	$31	/* return address */=0A=
+=0A=
+=0A=
+/*=0A=
+ * register names=0A=
+ */=0A=
+#define	R_R0		0=0A=
+#define	R_R1		1=0A=
+#define	R_R2		2=0A=
+#define	R_R3		3=0A=
+#define	R_R4		4=0A=
+#define	R_R5		5=0A=
+#define	R_R6		6=0A=
+#define	R_R7		7=0A=
+#define	R_R8		8=0A=
+#define	R_R9		9=0A=
+#define	R_R10		10=0A=
+#define	R_R11		11=0A=
+#define	R_R12		12=0A=
+#define	R_R13		13=0A=
+#define	R_R14		14=0A=
+#define	R_R15		15=0A=
+#define	R_R16		16=0A=
+#define	R_R17		17=0A=
+#define	R_R18		18=0A=
+#define	R_R19		19=0A=
+#define	R_R20		20=0A=
+#define	R_R21		21=0A=
+#define	R_R22		22=0A=
+#define	R_R23		23=0A=
+#define	R_R24		24=0A=
+#define	R_R25		25=0A=
+#define	R_R26		26=0A=
+#define	R_R27		27=0A=
+#define	R_R28		28=0A=
+#define	R_R29		29=0A=
+#define	R_R30		30=0A=
+#define	R_R31		31=0A=
+#define	R_F0		32=0A=
+#define	R_F1		33=0A=
+#define	R_F2		34=0A=
+#define	R_F3		35=0A=
+#define	R_F4		36=0A=
+#define	R_F5		37=0A=
+#define	R_F6		38=0A=
+#define	R_F7		39=0A=
+#define	R_F8		40=0A=
+#define	R_F9		41=0A=
+#define	R_F10		42=0A=
+#define	R_F11		43=0A=
+#define	R_F12		44=0A=
+#define	R_F13		45=0A=
+#define	R_F14		46=0A=
+#define	R_F15		47=0A=
+#define	R_F16		48=0A=
+#define	R_F17		49=0A=
+#define	R_F18		50=0A=
+#define	R_F19		51=0A=
+#define	R_F20		52=0A=
+#define	R_F21		53=0A=
+#define	R_F22		54=0A=
+#define	R_F23		55=0A=
+#define	R_F24		56=0A=
+#define	R_F25		57=0A=
+#define	R_F26		58=0A=
+#define	R_F27		59=0A=
+#define	R_F28		60=0A=
+#define	R_F29		61=0A=
+#define	R_F30		62=0A=
+#define	R_F31		63=0A=
+#define NCLIENTREGS	64=0A=
+#define	R_EPC		64=0A=
+#define	R_MDHI		65=0A=
+#define	R_MDLO		66=0A=
+#define	R_SR		67=0A=
+#define	R_CAUSE		68=0A=
+#define	R_TLBHI		69=0A=
+#ifdef CPU_R4000=0A=
+#define	R_TLBLO0	70=0A=
+#else=0A=
+#define	R_TLBLO		70=0A=
+#endif=0A=
+#define	R_BADVADDR	71=0A=
+#define	R_INX		72=0A=
+#define	R_RAND		73=0A=
+#define	R_CTXT		74=0A=
+#define	R_EXCTYPE	75=0A=
+#define R_MODE		76=0A=
+#define	R_PRID		77=0A=
+#define R_FCSR		78=0A=
+#define R_FEIR		79=0A=
+#ifdef CPU_R4000=0A=
+#define	R_TLBLO1	80=0A=
+#define R_PAGEMASK	81=0A=
+#define R_WIRED		82=0A=
+#define R_COUNT		83=0A=
+#define R_COMPARE	84=0A=
+#define R_CONFIG	85=0A=
+#define R_LLADDR	86=0A=
+#define R_WATCHLO	87=0A=
+#define R_WATCHHI	88=0A=
+#define R_ECC		89=0A=
+#define R_CACHEERR	90=0A=
+#define R_TAGLO		91=0A=
+#define R_TAGHI		92=0A=
+#define R_ERRPC		93=0A=
+#endif=0A=
+=0A=
+#ifdef CPU_R4000=0A=
+#define	NREGS		94=0A=
+#else=0A=
+#define NREGS		80=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * compiler defined bindings=0A=
+ */=0A=
+#define	R_ZERO		R_R0=0A=
+#define	R_AT		R_R1=0A=
+#define	R_V0		R_R2=0A=
+#define	R_V1		R_R3=0A=
+#define	R_A0		R_R4=0A=
+#define	R_A1		R_R5=0A=
+#define	R_A2		R_R6=0A=
+#define	R_A3		R_R7=0A=
+#define	R_T0		R_R8=0A=
+#define	R_T1		R_R9=0A=
+#define	R_T2		R_R10=0A=
+#define	R_T3		R_R11=0A=
+#define	R_T4		R_R12=0A=
+#define	R_T5		R_R13=0A=
+#define	R_T6		R_R14=0A=
+#define	R_T7		R_R15=0A=
+#define	R_S0		R_R16=0A=
+#define	R_S1		R_R17=0A=
+#define	R_S2		R_R18=0A=
+#define	R_S3		R_R19=0A=
+#define	R_S4		R_R20=0A=
+#define	R_S5		R_R21=0A=
+#define	R_S6		R_R22=0A=
+#define	R_S7		R_R23=0A=
+#define	R_T8		R_R24=0A=
+#define	R_T9		R_R25=0A=
+#define	R_K0		R_R26=0A=
+#define	R_K1		R_R27=0A=
+#define	R_GP		R_R28=0A=
+#define	R_SP		R_R29=0A=
+#define	R_FP		R_R30=0A=
+#define	R_RA		R_R31=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/Makefile	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,134 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile create a compressed zImage or Rommable rImage=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+#######################################################################=
########=0A=
+# The following is taken from IDT/Sim Makefile=0A=
+#######################################################################=
######=0A=
+TARGET=3D355=0A=
+=0A=
+# following refers to size of the DRAM space.=0A=
+# These are values for the switch DRAMSZ.=0A=
+SRAM_ONLY=3D1=0A=
+SDRAM_ONLY=3D2=0A=
+SRAM_N_SDRAM=3D3=0A=
+SDRAM_N_SRAM=3D4=0A=
+=0A=
+MB16=3D1=0A=
+MB32=3D2=0A=
+MB64=3D3=0A=
+MB128=3D4=0A=
+MB32SO=3D5=0A=
+=0A=
+FLASH_2M=3D0=0A=
+FLASH_4M=3D1=0A=
+FLASH_8M=3D2=0A=
+=0A=
+MACH=3D -DS$(TARGET) -DEB355 -DS364 -DCPU_R32364 =
-DMEMCFG=3D$(SDRAM_ONLY) -DDRAMSZ=3D$(MB32SO) =
-DFLASHSZ=3D$(FLASH_8M)=0A=
+COMMSWITCHES =3D $(INCDIRS) $(MACH)=0A=
+#***************** END IDT/Sim Makefile =
#####################################=0A=
+ZDEBUG=3D0=0A=
+export ZDEBUG=0A=
+=0A=
+# working space for gunzip:=0A=
+FREE_RAM      :=3D 0x80C00000=0A=
+END_RAM       :=3D 0x80E00000=0A=
+=0A=
+KERNELCONFIG  :=3D $(TOPDIR)/.config=0A=
+include $(KERNELCONFIG)=0A=
+=0A=
+SIZE =3D $(CROSS_COMPILE)size=0A=
+=0A=
+O_FORMAT =3D $(shell $(OBJDUMP) -i | head -2 | grep elf32)=0A=
+=0A=
+SYSTEM	      :=3D $(TOPDIR)/vmlinux=0A=
+ZBSS          :=3D 0x800A0000=0A=
+=0A=
+ZIMSTART      :=3D $(CONFIG_IDT_ZIMAGE_ADDR)=0A=
+RIMSTART      :=3D 0x9FC00000=0A=
+=0A=
+LOADADDR      :=3D 0x$(shell $(NM) $(SYSTEM) | grep "A _text" |cut -f1 =
-d' ')=0A=
+KERNEL_ENTRY  :=3D $(shell $(OBJDUMP) -f $(SYSTEM) | sed -n -e =
's/^start address //p')=0A=
+=0A=
+#######################################################################=
#############=0A=
+ZIMFLAGS        =3D s/IMSTART/$(ZIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+RIMFLAGS        =3D s/IMSTART/$(RIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+CFLAGS	:=3D -fno-pic -nostdinc -G 0 -mno-abicalls -fno-pic -pipe =
-I$(TOPDIR)/include=0A=
+AFLAGS	:=3D -D__ASSEMBLY__ $(CFLAGS)=0A=
+=0A=
+#######################################################################=
#############=0A=
+OBJECTS=3D $(obj)/piggy.o $(obj)/head.o $(obj)/misc.o=0A=
+ifneq ($(ZDEBUG),0)=0A=
+OBJECTS +=3D $(obj)/uart16550.o=0A=
+endif=0A=
+=0A=
+$(obj)/zImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(ZIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/rImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(RIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/piggy.o: $(SYSTEM) $(obj)/Makefile=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(SYSTEM) =
$(SYSTEM).bin=0A=
+	gzip -f -9 < $(SYSTEM).bin > $(SYSTEM).gz=0A=
+	echo "O_FORMAT:  " $(O_FORMAT); =0A=
+	$(LD) -r -b binary --oformat $(O_FORMAT) -o $(obj)/piggy.o =
$(SYSTEM).gz=0A=
+	rm -f $(SYSTEM).bin $(SYSTEM).gz=0A=
+=0A=
+$(obj)/head.o: $(obj)/head.S $(SYSTEM) $(obj)/Makefile=0A=
+	$(CC) $(AFLAGS) -DKERNEL_ENTRY=3D$(KERNEL_ENTRY) -c $(obj)/head.S -o =
$(obj)/head.o=0A=
+=0A=
+$(obj)/misc.o: $(obj)/misc.c $(obj)/Makefile=0A=
+	$(CC) $(CFLAGS) -DLOADADDR=3D$(LOADADDR) -DFREE_RAM=3D$(FREE_RAM) =
-DEND_RAM=3D$(END_RAM) \=0A=
+		-c $< -DZDEBUG=3D$(ZDEBUG) -o $(obj)/misc.o=0A=
+=0A=
+$(obj)/uart16550.o: $(obj)/uart16550.c $(KERNELCONFIG)=0A=
+	$(CC) $(CFLAGS) -c $< -o $(obj)/uart16550.o=0A=
+=0A=
+$(obj)/csu_idt.o: $(obj)/csu_idt.S Makefile $(SYSTEM)=0A=
+	$(CC) $(AFLAGS) $(COMMSWITCHES) -c $< -o $(obj)/csu_idt.o=0A=
+=0A=
+zImage: $(obj)/zImage.lds $(SYSTEM) $(OBJECTS)=0A=
+	$(LD) -T$(obj)/zImage.lds -o $(TOPDIR)/zImage $(OBJECTS)=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/zImage =
$(TOPDIR)/zImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/zImage.bin $(TOPDIR)/zImage.prm=0A=
+	$(SIZE) $(TOPDIR)/zImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/zImage.size=0A=
+	rm -f *.o=0A=
+=0A=
+rImage: $(obj)/rImage.lds $(OBJECTS) $(obj)/csu_idt.o $(SYSTEM)=0A=
+	@rm -f $(TOPDIR)/*.prm=0A=
+	$(LD) -T$(obj)/rImage.lds -o $(TOPDIR)/rImage $(obj)/csu_idt.o =
$(OBJECTS) =0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/rImage =
$(TOPDIR)/rImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/rImage.bin $(TOPDIR)/rImage.prm=0A=
+	$(SIZE) $(TOPDIR)/rImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/rImage.size=0A=
+	rm -f *.o=0A=
+clean:=0A=
+	rm -f *.o $(TOPDIR)/zImage $(TOPDIR)/rImage $(TOPDIR)/*.prm =
$(TOPDIR)/rImage.size $(TOPDIR)/zImage.size=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/misc.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/misc.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/misc.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/misc.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,341 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Code to un-compress linux image=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/types.h>=0A=
+=0A=
+/*=0A=
+ * gzip declarations=0A=
+ */=0A=
+#define OF(args)  args=0A=
+#define STATIC static=0A=
+#define memzero(s, n)     memset ((s), 0, (n))=0A=
+typedef unsigned char uch;=0A=
+typedef unsigned short ush;=0A=
+typedef unsigned long ulg;=0A=
+#define WSIZE 0x8000		/* Window size must be at least 32k, */=0A=
+				/* and a power of two */=0A=
+static uch *inbuf;		/* input buffer */=0A=
+static uch window[WSIZE];	/* Sliding window buffer */=0A=
+=0A=
+/* gzip flag byte */=0A=
+#define ASCII_FLAG   0x01	/* bit 0 set: file probably ASCII text */=0A=
+#define CONTINUATION 0x02	/* bit 1 set: continuation of multi-part =
gzip file */=0A=
+#define EXTRA_FIELD  0x04	/* bit 2 set: extra field present */=0A=
+#define ORIG_NAME    0x08	/* bit 3 set: original file name present =
*/=0A=
+#define COMMENT      0x10	/* bit 4 set: file comment present */=0A=
+#define ENCRYPTED    0x20	/* bit 5 set: file is encrypted */=0A=
+#define RESERVED     0xC0	/* bit 6,7:   reserved */=0A=
+=0A=
+=0A=
+static unsigned insize;	/* valid bytes in inbuf */=0A=
+static unsigned inptr;	/* index of next byte to be processed in inbuf =
*/=0A=
+static unsigned outcnt;	/* bytes in output buffer */=0A=
+=0A=
+void variable_init(void);=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *);=0A=
+extern void putc_init(void);=0A=
+extern void putc(unsigned char c);=0A=
+#endif=0A=
+static int fill_inbuf(void);=0A=
+static void flush_window(void);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+extern char input_data[];=0A=
+//extern int input_len;=0A=
+extern char input_data_end[];=0A=
+=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void int2hex(unsigned long val)=0A=
+{=0A=
+        unsigned char buf[10];=0A=
+        int i;=0A=
+        for (i =3D 7;  i >=3D 0;  i--)=0A=
+        {=0A=
+                buf[i] =3D "0123456789ABCDEF"[val & 0x0F];=0A=
+                val >>=3D 4;=0A=
+        }=0A=
+        buf[8] =3D '\0';=0A=
+        puts(buf);=0A=
+}=0A=
+#endif=0A=
+=0A=
+static unsigned long byte_count;=0A=
+=0A=
+int get_byte(void)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	static int printCnt;=0A=
+#endif=0A=
+	unsigned char c =3D (inptr < insize ? inbuf[inptr++] : =
fill_inbuf());=0A=
+	byte_count++;=0A=
+=0A=
+#if ZDEBUG > 1=0A=
+	if (printCnt++ < 32)=0A=
+	{=0A=
+	  puts("byte count =3D ");=0A=
+	  int2hex(byte_count);=0A=
+	  puts(" byte val =3D ");=0A=
+	  int2hex(c);=0A=
+	  puts("\n");=0A=
+	}=0A=
+#endif=0A=
+	return c;=0A=
+}=0A=
+=0A=
+/* Diagnostic functions */=0A=
+#ifdef DEBUG=0A=
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}=0A=
+#  define Trace(x) fprintf x=0A=
+#  define Tracev(x) {if (verbose) fprintf x ;}=0A=
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}=0A=
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}=0A=
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}=0A=
+#else=0A=
+#  define Assert(cond,msg)=0A=
+#  define Trace(x)=0A=
+#  define Tracev(x)=0A=
+#  define Tracevv(x)=0A=
+#  define Tracec(c,x)=0A=
+#  define Tracecv(c,x)=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * This is set up by the setup-routine at boot-time=0A=
+ */=0A=
+=0A=
+static long bytes_out;=0A=
+static uch *output_data;=0A=
+static unsigned long output_ptr;=0A=
+=0A=
+=0A=
+static void *malloc(int size);=0A=
+static void free(void *where);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+static unsigned long free_mem_ptr;=0A=
+static unsigned long free_mem_end_ptr;=0A=
+=0A=
+#include "../../../../../../lib/inflate.c"=0A=
+=0A=
+static void *malloc(int size)=0A=
+{=0A=
+	void *p;=0A=
+=0A=
+	if (size < 0)=0A=
+		error("Malloc error\n");=0A=
+	if (free_mem_ptr <=3D 0) error("Memory error\n");=0A=
+=0A=
+	free_mem_ptr =3D (free_mem_ptr + 3) & ~3;	/* Align */=0A=
+=0A=
+	p =3D (void *) free_mem_ptr;=0A=
+	free_mem_ptr +=3D size;=0A=
+=0A=
+	if (free_mem_ptr >=3D free_mem_end_ptr)=0A=
+		error("\nOut of memory\n");=0A=
+=0A=
+	return p;=0A=
+}=0A=
+=0A=
+static void free(void *where)=0A=
+{				/* Don't care */=0A=
+}=0A=
+=0A=
+static void gzip_mark(void **ptr)=0A=
+{=0A=
+	*ptr =3D (void *) free_mem_ptr;=0A=
+}=0A=
+=0A=
+static void gzip_release(void **ptr)=0A=
+{=0A=
+	free_mem_ptr =3D (long) *ptr;=0A=
+}=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *s)=0A=
+{=0A=
+	while (*s) {=0A=
+		if (*s =3D=3D 10)=0A=
+			putc(13);=0A=
+		putc(*s++);=0A=
+	}=0A=
+}=0A=
+#endif=0A=
+void *memset(void *s, int c, size_t n)=0A=
+{=0A=
+	int i;=0A=
+	char *ss =3D (char *) s;=0A=
+=0A=
+	for (i =3D 0; i < n; i++)=0A=
+		ss[i] =3D c;=0A=
+	return s;=0A=
+}=0A=
+=0A=
+void *memcpy(void *__dest, __const void *__src, size_t __n)=0A=
+{=0A=
+	int i;=0A=
+	char *d =3D (char *) __dest, *s =3D (char *) __src;=0A=
+=0A=
+	for (i =3D 0; i < __n; i++)=0A=
+		d[i] =3D s[i];=0A=
+	return __dest;=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Fill the input buffer. This is called only when the buffer is =
empty=0A=
+ * and at least one byte is really needed.=0A=
+ */=0A=
+static int fill_inbuf(void)=0A=
+{=0A=
+	if (insize !=3D 0) {=0A=
+		error("ran out of input data\n");=0A=
+	}=0A=
+=0A=
+	inbuf =3D input_data;=0A=
+	//	insize =3D input_len;=0A=
+	insize =3D &input_data_end[0] - &input_data[0];	=0A=
+	inptr =3D 1;=0A=
+	return inbuf[0];=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Write the output window window[0..outcnt-1] and update crc and =
bytes_out.=0A=
+ * (Used for the decompressed data only.)=0A=
+ */=0A=
+static void flush_window(void)=0A=
+{=0A=
+	ulg c =3D crc;		/* temporary variable */=0A=
+	unsigned n;=0A=
+	uch *in, *out, ch;=0A=
+=0A=
+	in =3D window;=0A=
+	out =3D &output_data[output_ptr];=0A=
+	for (n =3D 0; n < outcnt; n++) {=0A=
+		ch =3D *out++ =3D *in++;=0A=
+		c =3D crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);=0A=
+	}=0A=
+	crc =3D c;=0A=
+	bytes_out +=3D (ulg) outcnt;=0A=
+	output_ptr +=3D (ulg) outcnt;=0A=
+	outcnt =3D 0;=0A=
+}=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void check_mem(void)=0A=
+{=0A=
+	int i;=0A=
+=0A=
+	puts("\ncplens =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplens[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\ncplext =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplext[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\nborder =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(border[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\n");=0A=
+}=0A=
+#endif=0A=
+static void error(char *x)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	check_mem();=0A=
+	puts("\n\n");=0A=
+	puts(x);=0A=
+	puts("byte_count =3D ");=0A=
+	int2hex(byte_count);=0A=
+	puts("\n");=0A=
+	puts("\n\n -- Error. System halted");=0A=
+#endif=0A=
+	while (1);		/* Halt */=0A=
+}=0A=
+=0A=
+void variable_init(void)=0A=
+{=0A=
+	byte_count =3D 0;=0A=
+	//	output_data =3D (char *) LOADADDR;=0A=
+	free_mem_ptr =3D FREE_RAM;=0A=
+	free_mem_end_ptr =3D END_RAM;=0A=
+#if ZDEBUG > 1=0A=
+	puts("output_data      0x");=0A=
+	int2hex((unsigned long)output_data); puts("\n");=0A=
+	puts("free_mem_ptr     0x");=0A=
+	int2hex(free_mem_ptr); puts("\n");=0A=
+	puts("free_mem_end_ptr 0x");=0A=
+	int2hex(free_mem_end_ptr); puts("\n");=0A=
+	puts("input_data       0x");=0A=
+	int2hex((unsigned long)input_data); puts("\n");=0A=
+#endif=0A=
+}=0A=
+=0A=
+int decompress_kernel(void)=0A=
+{=0A=
+#if ZDEBUG > 0=0A=
+  putc_init();=0A=
+#if ZDEBUG > 2=0A=
+  check_mem();=0A=
+#endif=0A=
+#endif=0A=
+=0A=
+  variable_init();=0A=
+=0A=
+  makecrc();=0A=
+#if ZDEBUG > 0=0A=
+  puts("\n");=0A=
+  puts("Uncompressing Linux... \n");=0A=
+#endif=0A=
+  gunzip();		// ...see inflate.c=0A=
+#if ZDEBUG > 0=0A=
+  puts("Ok, booting the kernel.\n");=0A=
+#endif=0A=
+=0A=
+#if ZDEBUG > 1=0A=
+ {=0A=
+  unsigned long *p =3D (unsigned long *)LOADADDR;=0A=
+  int2hex(p[0]); puts("\n");=0A=
+  int2hex(p[1]); puts("\n");=0A=
+  int2hex(p[2]); puts("\n");=0A=
+  int2hex(p[3]); puts("\n");=0A=
+ }=0A=
+#endif=0A=
+=0A=
+  return 0;=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/rImage.lds =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/rImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/rImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/rImage.lds	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x9FC00000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/EB355/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/s355ram.h =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/s355ram.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/s355ram.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/s355ram.h	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,613 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT EB355 SDRAM setup values.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#ifndef __S355RAM__=0A=
+#define __S355RAM__=0A=
+=0A=
+#define SRAM_ONLY     1=0A=
+#define SDRAM_ONLY    2=0A=
+#define SRAM_N_SDRAM  3=0A=
+#define SDRAM_N_SRAM  4=0A=
+ =0A=
+#define MB16	1=0A=
+#define MB32	2=0A=
+#define MB64	3=0A=
+#define MB128	4=0A=
+#define MB32SO	5=0A=
+=0A=
+=0A=
+#define EXTU  1=0A=
+#define INTU  2=0A=
+=0A=
+#define RST_CTL_BASE      PHYS_TO_K1(0x18008000)  /* base address of =
reset controller register */=0A=
+#define DEV_CTL_BASE      PHYS_TO_K1(0x18010000)  /* base address of =
device controller Registers */=0A=
+#define SDRAM_CTL_BASE    PHYS_TO_K1(0x18018000)  /* base address of =
SDRAM controller Registers */=0A=
+#define BANYAN_IREG_BASE  PHYS_TO_K1(0x18000000)  /* all Banyan =
internal registers' base address */=0A=
+#define GPIO_BASE         PHYS_TO_K1(0x18040000)=0A=
+#define ERR_CNTL_STATUS   0xb8028030=0A=
+#define ERR_CNTL_VALUE    0x000000bf=0A=
+=0A=
+/*=0A=
+** b14:13=3D>01=3DPROM;b12=3D>1=3D do not assert CS during writes; =
b11:10=3D>00=3D8 bit port=0A=
+** b09:05=3D>0A=3D10 wait states; b04:00=3D>0A=3D 10 wait states=0A=
+*/=0A=
+=0A=
+=0A=
+/********  Chip Select 0 Control Register settings ***********/=0A=
+#if defined(EB355)=0A=
+#define MCR_CS0_BS    0x028A2204=0A=
+#define MCR_CS0_TC    0x00000A44=0A=
+#else=0A=
+#define MCR_CS0_BS    0x01CA333C=0A=
+#define MCR_CS0_TC    0x00001FFF=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** b14:13=3D>00=3DSRAM;b12=3D>0=3D assert CS during writes; =
b11:10=3D>10=3D32 bit port=0A=
+** b09:05=3D>FF=3D31 wait states; b04:00=3D>FF=3D 31 wait states.=0A=
+** NOTE: wait states should be tuned.=0A=
+*/=0A=
+=0A=
+=0A=
+/*#define MCR_CS1_BS    0x28e728e7*/=0A=
+#if defined(EB355)=0A=
+#define MCR_CS1_BS    0x01C73336=0A=
+#define MCR_CS1_TC    0x00000A44=0A=
+#else=0A=
+#define MCR_CS1_BS    0x01C73336=0A=
+#define MCR_CS1_TC    0x00001fff=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** b14:13=3D>01=3DI Type;b12=3D>0=3D assert CS during writes; =
b11:10=3D>00=3D8 bit port=0A=
+** b09:05=3D>FF=3D31 wait states; b04:00=3D>FF=3D 31 wait states=0A=
+*/=0A=
+#if defined(EB355)=0A=
+#define MCR_CS2_BS    0x028A2204=0A=
+#ifdef FLASHSZ=0A=
+#define MCR_CS2_TC    (0x00000A44 | FLASHSZ)=0A=
+#else=0A=
+#define MCR_CS2_TC    0x00000A46=0A=
+#endif=0A=
+#else=0A=
+#define MCR_CS2_BS    0x0ffffff4=0A=
+#define MCR_CS2_TC    0x00001fff=0A=
+#endif=0A=
+=0A=
+#if defined(EB355)=0A=
+#define MCR_CS3_BS    0x0ffffff4=0A=
+#define MCR_CS3_TC    0x00001fff=0A=
+#endif=0A=
+=0A=
+#define MCR_CS4_BS    0x0ffffff4=0A=
+#define MCR_CS4_TC    0x00001fff=0A=
+=0A=
+#define MCR_CS5_BS    0x0ffffff4=0A=
+#define MCR_CS5_TC    0x00001fff=0A=
+=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 0 - =
EPROM=0A=
+** NOTE: for starters see if you can just set the default value: =
0x1FC00000 Banyan=0A=
+*/=0A=
+#define MBA_REG0    0x1FC00000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 0 - EPROM - 4MB =
Banyan=0A=
+*/=0A=
+#define MBM_REG0    0xFFC00000=0A=
+=0A=
+#ifdef EB355=0A=
+#define MBA_REG2    0x0C000000=0A=
+#ifdef FLASHSZ=0A=
+#define MBM_REG2    (~(0x200000 * FLASHSZ - 1))=0A=
+#else=0A=
+#define MBM_REG2    0xFFC00000=0A=
+#endif=0A=
+#else=0A=
+#define MBA_REG2    0x0C000000=0A=
+#define MBM_REG2    0xFC000000=0A=
+#endif=0A=
+=0A=
+#ifdef EB355=0A=
+#define MBA_REG3    0x1A000000=0A=
+#define MBM_REG3    0xFFFF0000=0A=
+#endif=0A=
+=0A=
+#define MBA_REG4    0x14000000=0A=
+#define MBM_REG4    0xFC000000=0A=
+=0A=
+#define MBA_REG5    0x00000000=0A=
+#ifdef EB355=0A=
+#define MBM_REG5    0x00000000=0A=
+#else=0A=
+#define MBM_REG5    0xFC000000=0A=
+#endif=0A=
+=0A=
+#define CPU_BERR_BS   0xFF=0A=
+#define IP_BERR_BS    0xFF=0A=
+=0A=
+=0A=
+=0A=
+#if MEMCFG =3D=3D SRAM_ONLY=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1    0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1    0xFFF00000=0A=
+=0A=
+#elif MEMCFG =3D=3D SDRAM_ONLY || MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/*=0A=
+*************************************=0A=
+** SDRAM_ONLY or SDRAM_N_SRAM section=0A=
+*************************************=0A=
+*/=0A=
+=0A=
+#define APATTERN 0xa5a5a5a5=0A=
+=0A=
+#if DRAMSZ =3D=3D MB64=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 128MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 0MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE    0x00000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 64MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE    0x04000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK    0xFFF00000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK    DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS   0xb95500FF  /* old: 0x9EFBOOFF */=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS   0x2AF800FF=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL    0xb95501a0=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+#define SDRAM_RFRSH_CMD   0xb9550090=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG    0xAAF80080=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+** at 128MB:=0A=
+*/=0A=
+#define MBA_REG1    0x08000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1    0xFFF00000=0A=
+=0A=
+#endif /* #if MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 32MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 0MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE    0x00000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 8MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE    0x00800000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK    0xFF800000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK    DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS   0xB95500FF  /* 11:18:99 0xBAF800FF */=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS   0x395500FF  /* 11:18:99 0x3AF800FF */=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL    0xB95501A0  /* 11:18:99 0xBAF801A0 */=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+#define SDRAM_RFRSH_CMD   0xB9550090  /* 11:18:99 0xBAF80090 */=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG    0xB9550080  /* 11:18:99 0xBAF80080 */=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS    0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS   0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS  0x000002A0=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+** at 32MB:=0A=
+*/=0A=
+#define MBA_REG1    0x04000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1    0xFFF00000=0A=
+#endif /* MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+#elif DRAMSZ =3D=3D MB32SO=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 32MB SODIMM section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 0MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE    0x00000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 8MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE    0x02000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK    0xFE000000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK          0xFE000000=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+/* for other boards such as S355, EB355=0A=
+*/=0A=
+#define SDRAM_CR_BS             0x9a281080=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS   0x1a681080=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL    0x1a6810c3=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+=0A=
+#define SDRAM_RFRSH_CMD         0x1a681093=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG          0x1a681083=0A=
+=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS    0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS   0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS  0x00000271=0A=
+=0A=
+//#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+** at 32MB:=0A=
+*/=0A=
+#define MBA_REG1    0x02000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1    0xFFF00000=0A=
+#endif /* MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+//#endif /* DRAMSZ =3D=3D MB32SO */=0A=
+=0A=
+#elif MEMCFG =3D=3D SRAM_N_SDRAM=0A=
+=0A=
+#define APATTERN 0xa5a5a5a5=0A=
+=0A=
+/*=0A=
+*******************************=0A=
+** SRAM and SDRAM section=0A=
+*******************************=0A=
+*/=0A=
+#if DRAMSZ =3D=3D MB128=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 128MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1    0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1    0xFFF00000=0A=
+=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 32MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE    0x02000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 64MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE    0x04000000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 96MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE    0x06000000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 128MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE    0x08000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK    0xFE000000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK    DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK    DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK    DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS   0xAAF800FF  /* old: 0x9EFBOOFF */=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS   0x2AF800FF=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL    0xAAF801A0=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+#define SDRAM_RFRSH_CMD   0xAAF80090=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG    0xAAF80080=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS    0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS   0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS  0x000000A0=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 32MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1    0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1    0xFFF00000=0A=
+=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 8MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE    0x00800000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 16MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE    0x01000000=0A=
+=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK    0xFF800000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK    DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS   0xB95500FF  /* 11:18:99 0xBAF800FF */=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS   0x395500FF  /* 11:18:99 0x3AF800FF */=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL    0xB95501A0  /* 11:18:99 0xBAF801A0 */=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+#define SDRAM_RFRSH_CMD   0xB9550090  /* 11:18:99 0xBAF80090 */=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG    0xB9550080  /* 11:18:99 0xBAF80080 */=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS    0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS   0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS  0x000002A0  /* 11:18:99 0x000000A0 */=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32SO=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 32MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1    0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1    0xFFF00000=0A=
+=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 32MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE    0x02000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 16MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE    0x02100000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK    0xFE000000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK    0xFE000000=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS   0x9a281080=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS   0x1a681080=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL    0x1a6810c3=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+=0A=
+#define SDRAM_RFRSH_CMD         0x1a681093=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+=0A=
+#define SDRAM_MODE_REG          0x1a681083=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS    0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS   0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS  0x00000271  /* 11:18:99 0x000000A0 */=0A=
+=0A=
+=0A=
+#else=0A=
+#error "unrecognized dram size"=0A=
+#endif /* DRAMSZ */=0A=
+=0A=
+#else=0A=
+#error "unrecogized memory configuration parameter"=0A=
+#endif /* error */=0A=
+=0A=
+#endif /* __S355RAM__ */=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/s364.h =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/s364.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/s364.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/s364.h	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,156 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   LCD Display routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S364134__=0A=
+#define __S364134__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+#ifndef GPIO_BASE=0A=
+#ifdef S355=0A=
+#define GPIO_BASE PHYS_TO_K1(0x18040000)=0A=
+#else=0A=
+#define GPIO_BASE PHYS_TO_K1(0x18000600)=0A=
+#endif=0A=
+#endif=0A=
+/*=0A=
+** following defines simple and uniform to save and restore context=0A=
+** when enrtering and leaving as assemblu language program when =
memory=0A=
+** and registers are both premiunm.=0A=
+*/=0A=
+#define SAVE_CNTXT    \=0A=
+  subu  sp,64;    \=0A=
+  sw  t0,60(sp);  \=0A=
+  sw  t1,56(sp);  \=0A=
+  sw  t2,52(sp);  \=0A=
+  sw  t3,48(sp);  \=0A=
+  sw  t4,44(sp);  \=0A=
+  sw  t5,40(sp);  \=0A=
+  sw  t6,36(sp);  \=0A=
+  sw  t7,32(sp);  \=0A=
+  sw  t8,28(sp);  \=0A=
+  sw  t9,24(sp);  \=0A=
+  sw  a0,20(sp);  \=0A=
+  sw  a1,16(sp);  \=0A=
+  sw  a2,12(sp);  \=0A=
+  sw  a3,8(sp); \=0A=
+  sw  ra,4(sp)=0A=
+=0A=
+#define RSTR_CNTXT    \=0A=
+  lw  t0,60(sp);  \=0A=
+  lw  t1,56(sp);  \=0A=
+  lw  t2,52(sp);  \=0A=
+  lw  t3,48(sp);  \=0A=
+  lw  t4,44(sp);  \=0A=
+  lw  t5,40(sp);  \=0A=
+  lw  t6,36(sp);  \=0A=
+  lw  t7,32(sp);  \=0A=
+  lw  t8,28(sp);  \=0A=
+  lw  t9,24(sp);  \=0A=
+  lw  a0,20(sp);  \=0A=
+  lw  a1,16(sp);  \=0A=
+  lw  a2,12(sp);  \=0A=
+  lw  a3,8(sp); \=0A=
+  lw  ra,4(sp); \=0A=
+  add sp,64=0A=
+=0A=
+/*=0A=
+** Following define is to specify a maximum value for a software=0A=
+** busy wait counter.=0A=
+*/=0A=
+=0A=
+#define LP_CNT_100NS  1000      /* set this based on processor speed =
*/=0A=
+#define LP_CNT_3S     1000000   /* set this based on processor speed =
*/=0A=
+=0A=
+/*=0A=
+** Following are other common timer definitions.=0A=
+*/=0A=
+#ifdef S355=0A=
+#define TIMER_BASE    PHYS_TO_K1(0x18028000)  =0A=
+#define TIMEOUT_COUNT 0x00000FFF=0A=
+#else=0A=
+#define TIMER_BASE    PHYS_TO_K1(0x18000700)  =0A=
+#endif=0A=
+#define ENABLE_TIMER  0x1=0A=
+#define DISABLE_TIMER 0x0=0A=
+#define BIG_VALUE     0xFFFFFFFF=0A=
+=0A=
+#ifdef S355=0A=
+/* There is no DISPLAY on 355 boards*/=0A=
+#elif defined(S334)=0A=
+/*=0A=
+** following few lines define a macro DISPLAY=0A=
+** which is used to write a set of 4 characters=0A=
+** onto the S334 LED.=0A=
+*/=0A=
+=0A=
+#if defined(EB332)=0A=
+#define LED_BASE      PHYS_TO_K1(0x10000000)=0A=
+#define LED_DIGIT0    0xc=0A=
+#define LED_DIGIT1    0x8=0A=
+#define LED_DIGIT2    0x4=0A=
+#define LED_DIGIT3    0x0=0A=
+=0A=
+#define LED_CLEAR     0x400=0A=
+=0A=
+#else=0A=
+#define LED_BASE      PHYS_TO_K1(0x14000000)=0A=
+#define LED_DIGIT0    0xf=0A=
+#define LED_DIGIT1    0xb=0A=
+#define LED_DIGIT2    0x7=0A=
+#define LED_DIGIT3    0x3=0A=
+=0A=
+#define LED_CLEAR     0x400=0A=
+=0A=
+#endif=0A=
+=0A=
+#define DISPLAY(d0, d1, d2, d3)     \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        lb    t7, LED_CLEAR(t6)               ;\=0A=
+              nop                             ;\=0A=
+        li    t7, (d0) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT0(t6)              ;\=0A=
+        li    t7, (d1) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT1(t6)              ;\=0A=
+        li    t7, (d2) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT2(t6)              ;\=0A=
+        li    t7, (d3) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT3(t6)=0A=
+=0A=
+#define LEDCLEAR()              \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        lb    t7, LED_CLEAR(t6)               ;\=0A=
+              nop=0A=
+=0A=
+#endif=0A=
+=0A=
+#define DESTRUCTIVE     1=0A=
+#define NONDESTRUCTIVE  0=0A=
+=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/uart16550.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/uart16550.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/uart16550.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/uart16550.c	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,180 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   UART code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+=0A=
+#define RC32355_REG_BASE   0xb8000000=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32300_UART0_BASE (RC32355_REG_BASE + 0x50003)=0A=
+#define RC32300_UART1_BASE (RC32355_REG_BASE + 0x50023)=0A=
+#else=0A=
+#define RC32300_UART0_BASE (RC32355_REG_BASE + 0x50000)=0A=
+#define RC32300_UART1_BASE (RC32355_REG_BASE + 0x50020)=0A=
+#endif=0A=
+=0A=
+#define BASE		   RC32300_UART0_BASE=0A=
+=0A=
+#define MAX_BAUD		(CONFIG_IDT_BOARD_FREQ / 16)=0A=
+#define REG_OFFSET		0x4=0A=
+=0A=
+/* =3D=3D=3D CONFIG =3D=3D=3D */=0A=
+=0A=
+/*=0A=
+ * #define BASE			0xb2001000=0A=
+ * #define MAX_BAUD		1152000=0A=
+ * #define REG_OFFSET		0x10=0A=
+ */=0A=
+#if (!defined(BASE) || !defined(MAX_BAUD) || !defined(REG_OFFSET))=0A=
+#error You must define BASE, MAX_BAUD and REG_OFFSET in the =
Makefile.=0A=
+#endif=0A=
+=0A=
+#ifndef INIT_SERIAL_PORT=0A=
+#define INIT_SERIAL_PORT	1=0A=
+#endif=0A=
+=0A=
+#ifndef DEFAULT_BAUD=0A=
+//#define DEFAULT_BAUD		UART16550_BAUD_115200=0A=
+#define DEFAULT_BAUD		UART16550_BAUD_9600=0A=
+#endif=0A=
+#ifndef DEFAULT_PARITY=0A=
+#define DEFAULT_PARITY		UART16550_PARITY_NONE=0A=
+#endif=0A=
+#ifndef DEFAULT_DATA=0A=
+#define DEFAULT_DATA		UART16550_DATA_8BIT=0A=
+#endif=0A=
+#ifndef DEFAULT_STOP=0A=
+#define DEFAULT_STOP		UART16550_STOP_1BIT=0A=
+#endif=0A=
+=0A=
+/* =3D=3D=3D END OF CONFIG =3D=3D=3D */=0A=
+=0A=
+typedef         unsigned char uint8;=0A=
+typedef         unsigned int  uint32;=0A=
+=0A=
+#define         UART16550_BAUD_2400             2400=0A=
+#define         UART16550_BAUD_4800             4800=0A=
+#define         UART16550_BAUD_9600             9600=0A=
+#define         UART16550_BAUD_19200            19200=0A=
+#define         UART16550_BAUD_38400            38400=0A=
+#define         UART16550_BAUD_57600            57600=0A=
+#define         UART16550_BAUD_115200           115200=0A=
+=0A=
+#define         UART16550_PARITY_NONE           0=0A=
+#define         UART16550_PARITY_ODD            0x08=0A=
+#define         UART16550_PARITY_EVEN           0x18=0A=
+#define         UART16550_PARITY_MARK           0x28=0A=
+#define         UART16550_PARITY_SPACE          0x38=0A=
+=0A=
+#define         UART16550_DATA_5BIT             0x0=0A=
+#define         UART16550_DATA_6BIT             0x1=0A=
+#define         UART16550_DATA_7BIT             0x2=0A=
+#define         UART16550_DATA_8BIT             0x3=0A=
+=0A=
+#define         UART16550_STOP_1BIT             0x0=0A=
+#define         UART16550_STOP_2BIT             0x4=0A=
+=0A=
+/* register offset */=0A=
+#define		OFS_RCV_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_TRANS_HOLD		(0*REG_OFFSET)=0A=
+#define		OFS_SEND_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_INTR_ENABLE		(1*REG_OFFSET)=0A=
+#define		OFS_INTR_ID		(2*REG_OFFSET)=0A=
+#define		OFS_DATA_FORMAT		(3*REG_OFFSET)=0A=
+#define		OFS_LINE_CONTROL	(3*REG_OFFSET)=0A=
+#define		OFS_MODEM_CONTROL	(4*REG_OFFSET)=0A=
+#define		OFS_RS232_OUTPUT	(4*REG_OFFSET)=0A=
+#define		OFS_LINE_STATUS		(5*REG_OFFSET)=0A=
+#define		OFS_MODEM_STATUS	(6*REG_OFFSET)=0A=
+#define		OFS_RS232_INPUT		(6*REG_OFFSET)=0A=
+#define		OFS_SCRATCH_PAD		(7*REG_OFFSET)=0A=
+=0A=
+#define		OFS_DIVISOR_LSB		(0*REG_OFFSET)=0A=
+#define		OFS_DIVISOR_MSB		(1*REG_OFFSET)=0A=
+=0A=
+#define		UART16550_READ(y)    (*((volatile uint8*)(BASE + y)))=0A=
+#define		UART16550_WRITE(y, z)  ((*((volatile uint8*)(BASE + y))) =3D =
z)=0A=
+=0A=
+static void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 =
stop)=0A=
+{=0A=
+	/* disable interrupts */=0A=
+	UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	UART16550_WRITE(OFS_INTR_ENABLE, 0);=0A=
+=0A=
+	/* set up baud rate */=0A=
+	{=0A=
+		uint32 divisor;=0A=
+=0A=
+		/* set DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x80);=0A=
+=0A=
+		/* set divisor */=0A=
+		divisor =3D MAX_BAUD / baud;=0A=
+		UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);=0A=
+		UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);=0A=
+=0A=
+		/* clear DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	}=0A=
+=0A=
+	/* set data format */=0A=
+	UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);=0A=
+}=0A=
+=0A=
+=0A=
+void=0A=
+putc_init(void)=0A=
+{=0A=
+#if INIT_SERIAL_PORT=0A=
+	Uart16550Init(DEFAULT_BAUD, DEFAULT_DATA, DEFAULT_PARITY, =
DEFAULT_STOP);=0A=
+#endif=0A=
+}=0A=
+=0A=
+void=0A=
+putc(unsigned char c)=0A=
+{=0A=
+	while ((UART16550_READ(OFS_LINE_STATUS) &0x20) =3D=3D 0);=0A=
+	UART16550_WRITE(OFS_SEND_BUFFER, c);=0A=
+}=0A=
+=0A=
+#if 0=0A=
+unsigned char=0A=
+getc(void)=0A=
+{=0A=
+	while((UART16550_READ(OFS_LINE_STATUS) & 0x1) =3D=3D 0);=0A=
+	return UART16550_READ(OFS_RCV_BUFFER);=0A=
+}=0A=
+=0A=
+int=0A=
+tstc(void)=0A=
+{=0A=
+	return((UART16550_READ(OFS_LINE_STATUS) & 0x01) !=3D 0);=0A=
+}=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/zImage.lds =
idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/zImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/boot/zImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/boot/zImage.lds	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x8c000000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/EB355/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/idtIRQ.S =
idtlinux/arch/mips/idt-boards/rc32300/EB355/idtIRQ.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/idtIRQ.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/idtIRQ.S	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,75 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Interrupt dispatcher for IDT EB355 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+	=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/regdef.h>=0A=
+#include <asm/stackframe.h>=0A=
+=0A=
+	.text=0A=
+	.set	noreorder=0A=
+	.set	noat=0A=
+	.align	5=0A=
+	NESTED(rc32300_IRQ, PT_SIZE, sp)=0A=
+	SAVE_ALL=0A=
+	CLI=0A=
+=0A=
+	.set	at=0A=
+	.set	noreorder=0A=
+=0A=
+	/* Get the pending interrupts */=0A=
+	mfc0    t0, CP0_CAUSE=0A=
+	nop=0A=
+			 =0A=
+	/* Isolate the allowed ones by anding the irq mask */=0A=
+	mfc0    t2, CP0_STATUS =0A=
+	move	a1, sp		/* need a nop here, hence we anticipate */=0A=
+	andi	t0, CAUSEF_IP =0A=
+	and     t0, t2=0A=
+								  =0A=
+	/* check for r4k counter/timer IRQ. */=0A=
+	=0A=
+	andi    t1, t0, CAUSEF_IP7=0A=
+	beqz    t1, 1f=0A=
+	nop=0A=
+=0A=
+	jal     idt_timer_interrupt	/* bypass rc32300_irqdispatch */=0A=
+	li	a0, 7=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+1:=0A=
+	jal	rc32300_irqdispatch=0A=
+	move	a0, t0=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+=0A=
+	END(rc32300_IRQ)=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/irq.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/irq.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/irq.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/irq.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,287 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     RC32355 interrupt routines.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#include <linux/errno.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/signal.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/timex.h>=0A=
+#include <linux/slab.h>=0A=
+#include <linux/random.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+#undef DEBUG_IRQ=0A=
+#ifdef DEBUG_IRQ=0A=
+/* note: prints function name for you */=0A=
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## =
args)=0A=
+#else=0A=
+#define DPRINTK(fmt, args...)=0A=
+#endif=0A=
+=0A=
+extern asmlinkage void rc32300_IRQ(void);=0A=
+extern irq_cpustat_t irq_stat [NR_CPUS];=0A=
+unsigned int local_bh_count[NR_CPUS];=0A=
+unsigned int local_irq_count[NR_CPUS];=0A=
+=0A=
+static unsigned int startup_irq(unsigned int irq);=0A=
+static void end_irq(unsigned int irq_nr);=0A=
+static void mask_and_ack_irq(unsigned int irq_nr);=0A=
+static void rc32355_enable_irq(unsigned int irq_nr);=0A=
+static void rc32355_disable_irq(unsigned int irq_nr);=0A=
+=0A=
+extern void __init init_generic_irq(void);=0A=
+=0A=
+#ifdef CONFIG_PM=0A=
+extern void counter0_irq(int irq, void *dev_id, struct pt_regs =
*regs);=0A=
+#endif=0A=
+=0A=
+typedef struct {=0A=
+	u32 mask;       /* mask of valid bits in pending/mask registers */=0A=
+	volatile u32 *base_addr;=0A=
+} intr_group_t;=0A=
+=0A=
+static const intr_group_t intr_group[NUM_INTR_GROUPS] =3D {=0A=
+	{ 0x0000003f, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 0 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x0000ffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 1 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x000003ff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 2 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x00ffffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 3 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0xffffffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 4 * IC_GROUP_OFFSET) =
}=0A=
+};=0A=
+=0A=
+#define READ_PEND(base) (*(base))=0A=
+#define READ_MASK(base) (*(base + 1))=0A=
+#define WRITE_MASK(base, val) (*(base + 1) =3D (val))=0A=
+=0A=
+static inline int irq_to_group(unsigned int irq_nr)=0A=
+{=0A=
+	return ((irq_nr - GROUP0_IRQ_BASE) >> 5);=0A=
+}=0A=
+=0A=
+static inline int group_to_ip(unsigned int group)=0A=
+{=0A=
+	return group + 2;=0A=
+}=0A=
+=0A=
+static inline void enable_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	clear_c0_cause(ipnum);=0A=
+	set_c0_status(ipnum);=0A=
+}=0A=
+=0A=
+static inline void disable_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	clear_c0_status(ipnum);=0A=
+}=0A=
+=0A=
+static inline void ack_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	clear_c0_cause(ipnum);=0A=
+}=0A=
+=0A=
+static void rc32355_enable_irq(unsigned int irq_nr)=0A=
+{=0A=
+	unsigned long flags;=0A=
+	int           ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int  group, intr_bit;=0A=
+	volatile unsigned int  *addr;=0A=
+	=0A=
+	local_irq_save(flags);=0A=
+	if (ip < 0)=0A=
+		enable_local_irq(irq_nr);=0A=
+	else {=0A=
+		// calculate group=0A=
+		group =3D ip >> 5;=0A=
+		=0A=
+		// calc interrupt bit within group=0A=
+		ip -=3D (group << 5);=0A=
+		intr_bit =3D 1 << ip;=0A=
+		=0A=
+		// first enable the IP mapped to this IRQ=0A=
+		enable_local_irq(group_to_ip(group));=0A=
+		=0A=
+		addr =3D intr_group[group].base_addr;=0A=
+		// unmask intr within group=0A=
+		WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);=0A=
+	}=0A=
+	=0A=
+	local_irq_restore(flags);=0A=
+}=0A=
+=0A=
+static void rc32355_disable_irq(unsigned int irq_nr)=0A=
+{=0A=
+	unsigned long flags;=0A=
+	int           ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int  group, intr_bit, mask;=0A=
+	volatile unsigned int  *addr;=0A=
+	=0A=
+	local_irq_save(flags);=0A=
+	if (ip < 0)=0A=
+		disable_local_irq(irq_nr);=0A=
+	else {=0A=
+		// calculate group=0A=
+		group =3D ip >> 5;=0A=
+		=0A=
+		// calc interrupt bit within group=0A=
+		ip -=3D group << 5;=0A=
+		intr_bit =3D 1 << ip;=0A=
+		=0A=
+		addr =3D intr_group[group].base_addr;=0A=
+		// mask intr within group=0A=
+		mask =3D READ_MASK(addr);=0A=
+		mask |=3D intr_bit;=0A=
+		WRITE_MASK(addr, mask);=0A=
+		=0A=
+		/*=0A=
+		  if there are no more interrupts enabled in this=0A=
+		  group, disable corresponding IP=0A=
+		*/=0A=
+		if (mask =3D=3D intr_group[group].mask)=0A=
+			disable_local_irq(group_to_ip(group));=0A=
+	}=0A=
+	=0A=
+	local_irq_restore(flags);=0A=
+}=0A=
+=0A=
+static unsigned int startup_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32355_enable_irq(irq_nr);=0A=
+	return 0; =0A=
+}=0A=
+=0A=
+static void shutdown_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32355_disable_irq(irq_nr);=0A=
+	return;=0A=
+}=0A=
+=0A=
+static void mask_and_ack_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32355_disable_irq(irq_nr);=0A=
+	ack_local_irq(group_to_ip(irq_to_group(irq_nr)));=0A=
+}=0A=
+=0A=
+static void end_irq(unsigned int irq_nr)=0A=
+{=0A=
+	int ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int intr_bit, group;=0A=
+	volatile unsigned int *addr;=0A=
+	=0A=
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED | IRQ_INPROGRESS))) =
{=0A=
+		if (ip < 0)=0A=
+			enable_local_irq(irq_nr);=0A=
+		else {=0A=
+			=0A=
+			group =3D ip >> 5;=0A=
+			=0A=
+			// calc interrupt bit within group=0A=
+			ip -=3D (group << 5);=0A=
+			intr_bit =3D 1 << ip;=0A=
+			=0A=
+			// first enable the IP mapped to this IRQ=0A=
+			enable_local_irq(group_to_ip(group));=0A=
+			=0A=
+			addr =3D intr_group[group].base_addr;=0A=
+			// unmask intr within group=0A=
+			WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);=0A=
+		}=0A=
+	} =0A=
+	else {=0A=
+		printk("warning: end_irq %d did not enable (%x)\n", =0A=
+		       irq_nr, irq_desc[irq_nr].status);=0A=
+	}=0A=
+}=0A=
+=0A=
+static struct hw_interrupt_type rc32355_irq_type =3D {=0A=
+	"RC32355",=0A=
+	startup_irq,=0A=
+	shutdown_irq,=0A=
+	rc32355_enable_irq,=0A=
+	rc32355_disable_irq,=0A=
+	mask_and_ack_irq,=0A=
+	end_irq,=0A=
+	NULL=0A=
+};=0A=
+=0A=
+=0A=
+void __init arch_init_irq(void)=0A=
+{=0A=
+	int i;=0A=
+	=0A=
+	printk("Initializing IRQ's: %d\n", RC32355_NR_IRQS);=0A=
+	memset(irq_desc, 0, sizeof(irq_desc));=0A=
+	set_except_vector(0, rc32300_IRQ);=0A=
+	=0A=
+	for (i =3D 0; i < RC32355_NR_IRQS; i++) {=0A=
+		irq_desc[i].status =3D IRQ_DISABLED;=0A=
+		irq_desc[i].action =3D NULL;=0A=
+		irq_desc[i].depth =3D 1;=0A=
+		irq_desc[i].handler =3D &rc32355_irq_type;=0A=
+                spin_lock_init(&irq_desc[i].lock);=0A=
+	}=0A=
+}=0A=
+=0A=
+/* Main Interrupt dispatcher */=0A=
+void rc32300_irqdispatch(unsigned long cp0_cause, struct pt_regs =
*regs)=0A=
+{=0A=
+	unsigned int ip, pend, group;=0A=
+	volatile unsigned int *addr;=0A=
+	=0A=
+	if ((ip =3D (cp0_cause & 0x7c00))) {=0A=
+		group =3D 21 - rc32300_clz(ip);=0A=
+		=0A=
+		addr =3D intr_group[group].base_addr;=0A=
+		=0A=
+		pend =3D READ_PEND(addr);=0A=
+		pend &=3D ~READ_MASK(addr); // only unmasked interrupts=0A=
+		pend =3D 39 - rc32300_clz(pend);=0A=
+		do_IRQ((group << 5) + pend, regs);=0A=
+		return;=0A=
+	} =0A=
+	else =0A=
+		return; //spurious interrupt, do nothing....=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/lcd.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/lcd.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/lcd.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/lcd.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,144 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     IDT 79EB355 lcd support.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/init.h>=0A=
+#include <linux/irq.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32355.h>=0A=
+=0A=
+#define LCD_FUNC_SET    	0x38=0A=
+#define	LCD_ENT_MODE    	0x06=0A=
+#define	LCD_DISP_ON_CURS_OFF 	0x0C =0A=
+#define	LCD_DISP_ON_CURS_ON 	0x0E =0A=
+#define	LCD_DISP_CLEAR  	0x01=0A=
+#define	LCD_DDRAM_ADR_SET_0	0x80=0A=
+#define	LCD_DDRAM_ADR_SET_1	0xC0=0A=
+=0A=
+#define	LCD_MAX_CHAR_PER_LINE 	16=0A=
+#define	LCD_MAX_LINES	 	2=0A=
+=0A=
+=0A=
+static void delay_lcd_long(void)=0A=
+{=0A=
+	int ii ;=0A=
+	for (ii =3D 0 ; ii < 0x5FFFF ; ii++)=0A=
+		;=0A=
+}=0A=
+=0A=
+=0A=
+static void delay_lcd_short(void)=0A=
+{=0A=
+	int ii ;=0A=
+	for (ii =3D 0 ; ii < 0x1FFFF ; ii++)=0A=
+		;=0A=
+}=0A=
+=0A=
+=0A=
+int init_lcd(void)=0A=
+{=0A=
+	u8* chLcdBase =3D (u8*)KSEG1ADDR(LCD_BASE);=0A=
+	=0A=
+	/*-------------- Reset LCD ---------------------------*/=0A=
+	=0A=
+	delay_lcd_long() ;=0A=
+	=0A=
+	/* send function select 4 times */=0A=
+	rc32300_writeb(LCD_FUNC_SET, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+	rc32300_writeb(LCD_FUNC_SET, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+	rc32300_writeb(LCD_FUNC_SET, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+	rc32300_writeb(LCD_FUNC_SET, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;  	=0A=
+	=0A=
+	=0A=
+	rc32300_writeb(LCD_ENT_MODE, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+=0A=
+	rc32300_writeb(LCD_DISP_ON_CURS_OFF, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+	=0A=
+	rc32300_writeb(LCD_DISP_CLEAR, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+	=0A=
+	/* set it to row-0, column-0 */=0A=
+	rc32300_writeb(LCD_DDRAM_ADR_SET_0, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+int idtprintf(const char *fmt, ...)=0A=
+{=0A=
+	va_list args;=0A=
+	u8* chLcdData =3D (u8*)KSEG1ADDR((LCD_BASE+1));=0A=
+	u8* chLcdBase =3D (u8*)KSEG1ADDR(LCD_BASE);=0A=
+	char str[LCD_MAX_CHAR_PER_LINE * LCD_MAX_LINES];=0A=
+	int iNumChars, iCharsSent;=0A=
+	=0A=
+	va_start(args, fmt);=0A=
+	vsprintf(str, fmt, args);=0A=
+	va_end(args);=0A=
+	=0A=
+	iNumChars =3D strlen(str);=0A=
+	=0A=
+	/* Can't have more characters than what will fit on the display */=0A=
+	if (iNumChars > (LCD_MAX_CHAR_PER_LINE * LCD_MAX_LINES))=0A=
+		iNumChars =3D (LCD_MAX_CHAR_PER_LINE * LCD_MAX_LINES) ;=0A=
+	=0A=
+	/* first blank out the whole display */=0A=
+	rc32300_writeb(LCD_DISP_CLEAR, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+	=0A=
+	/* set it to row-0, column-0 */=0A=
+	rc32300_writeb(LCD_DDRAM_ADR_SET_0, (unsigned long)chLcdBase);=0A=
+	delay_lcd_long() ;=0A=
+	=0A=
+	/* Now display characters one by one*/=0A=
+	for(iCharsSent =3D 0 ; iCharsSent < iNumChars ; iCharsSent++) {=0A=
+		if (iCharsSent =3D=3D LCD_MAX_CHAR_PER_LINE ) {=0A=
+			/* move over to the next line */=0A=
+			rc32300_writeb(LCD_DDRAM_ADR_SET_1, (unsigned long)chLcdBase); =0A=
+			delay_lcd_long() ;=0A=
+		}=0A=
+		rc32300_writeb(str[iCharsSent], (unsigned long)chLcdData);=0A=
+		delay_lcd_short() ;=0A=
+	}=0A=
+=0A=
+	return iNumChars;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/EB355/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/Makefile	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,41 @@=0A=
+#**********************************************************************=
****=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for EB355 BSP=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#         =0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR =
TORT=0A=
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#  You should have received a copy of the  GNU General Public License =
along=0A=
+#  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+#=0A=
+#**********************************************************************=
****=0A=
+#=0A=
+=0A=
+.S.s:=0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:=0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+obj-y	 :=3D irq.o lcd.o setup.o idtIRQ.o reset.o prom.o time.o=0A=
+obj-$(CONFIG_KGDB)			+=3D serial_gdb.o=0A=
+obj-$(CONFIG_SERIAL_8250)		+=3D serial.o=0A=
+subdir-$(CONFIG_IDT_BOOT_NVRAM)		+=3D nvram=0A=
+obj-$(CONFIG_IDT_BOOT_NVRAM)		+=3D nvram/built-in.o=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/nvram/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/EB355/nvram/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/nvram/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/nvram/Makefile	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,40 @@=0A=
+#**********************************************************************=
****=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for nvram driver=0A=
+#=0A=
+#  Copyright 2006 IDT Inc.=0A=
+#  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+#=0A=
+#         =0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR =
TORT=0A=
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#  You should have received a copy of the  GNU General Public License =
along=0A=
+#  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+#=0A=
+#=0A=
+#**********************************************************************=
***=0A=
+#/=0A=
+=0A=
+.S.s:   =0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:   =0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+=0A=
+obj-y   :=3D nvram355.o=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/nvram/nvram355.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/nvram/nvram355.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/nvram/nvram355.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/nvram/nvram355.c	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,423 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram API=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/string.h>=0A=
+#include "nvram355.h"=0A=
+=0A=
+void setenv (char *e, char *v, int rewrite);=0A=
+char *getenv (char *e);=0A=
+void unsetenv (char *e);=0A=
+void mapenv (int (*func)(char *, char *));=0A=
+void purgeenv(void);=0A=
+extern char *getenv (char *s);=0A=
+unsigned int  is_valid =3D 0;=0A=
+static void nvram_initenv(void);=0A=
+=0A=
+/*=0A=
+ * The *env routines provide wrappers to the nvram_*env=0A=
+ * routines to allow any special processing of the environment=0A=
+ * to be carried out=0A=
+ * Yes this is a bit naff=0A=
+ */=0A=
+#define WAIT(x) { int i=3D0; while (++i < (x)) ; }=0A=
+=0A=
+static unsigned char=0A=
+nvram_getbyte(int offs)=0A=
+{=0A=
+	int i =3D 0;=0A=
+=0A=
+	unsigned char* nvramAddrPointer =3D (unsigned char*)(NVRAM_BASE + =
0x10);=0A=
+	unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE + =
0x13);=0A=
+	=0A=
+	*nvramAddrPointer =3D (unsigned char) offs;=0A=
+	=0A=
+	while (++i < 0x100);=0A=
+	=0A=
+	return ((unsigned int)(*nvramDataPointer));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setbyte(int offs, unsigned char val)=0A=
+{=0A=
+	int i =3D 0;=0A=
+	unsigned char* nvramAddrPointer=3D(unsigned char*)(NVRAM_BASE + =
0x10);=0A=
+	unsigned char* nvramDataPointer=3D(unsigned char*)(NVRAM_BASE + =
0x13);=0A=
+	=0A=
+	*nvramAddrPointer=3D(unsigned char)offs;=0A=
+	=0A=
+	while(++i < 0x100);=0A=
+	=0A=
+	*nvramDataPointer =3D val;=0A=
+	=0A=
+	i =3D 0;=0A=
+	while(++i < 0x100);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * BigEndian!=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_getshort(int offs)=0A=
+{=0A=
+	return((nvram_getbyte(offs) << 8) | nvram_getbyte(offs + 1));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setshort(int offs, unsigned short val)=0A=
+{=0A=
+	nvram_setbyte(offs, (unsigned char)((val >> 8) & 0xff));=0A=
+	nvram_setbyte(offs + 1, (unsigned char)(val & 0xff));=0A=
+}=0A=
+=0A=
+#if 0=0A=
+static unsigned int=0A=
+nvram_getint(int offs)=0A=
+{=0A=
+	unsigned int val;=0A=
+	val =3D nvram_getbyte(offs) << 24;=0A=
+	val |=3D nvram_getbyte(offs + 1) << 16;=0A=
+	val |=3D nvram_getbyte(offs + 2) << 8;=0A=
+	val |=3D nvram_getbyte(offs + 3);=0A=
+	return(val);=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setint(int offs, unsigned int val)=0A=
+{=0A=
+	nvram_setbyte(offs, val >> 24);=0A=
+	nvram_setbyte(offs + 1, val >> 16);=0A=
+	nvram_setbyte(offs + 2, val >> 8);=0A=
+	nvram_setbyte(offs + 3, val);=0A=
+}=0A=
+#endif=0A=
+/*=0A=
+ * calculate NVRAM checksum=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_calcsum(void)=0A=
+{=0A=
+	unsigned short sum =3D NV_MAGIC;=0A=
+	int i;=0A=
+	=0A=
+	for (i =3D ENV_BASE; i < ENV_TOP; i +=3D 2)=0A=
+		sum +=3D nvram_getshort(i);=0A=
+	return(sum);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * update the nvram checksum=0A=
+ */=0A=
+static void=0A=
+nvram_updatesum(void)=0A=
+{=0A=
+	nvram_setshort(NVOFF_CSUM, nvram_calcsum());=0A=
+}=0A=
+=0A=
+/*=0A=
+ * test validity of nvram by checksumming it=0A=
+ */=0A=
+static int=0A=
+nvram_isvalid(void)=0A=
+{=0A=
+#if defined(PRETEND_NVRAM) || defined(NO_NVRAM)=0A=
+	is_valid =3D 1;=0A=
+	return(1);=0A=
+#else=0A=
+	=0A=
+	if (is_valid)=0A=
+		return(1);=0A=
+	=0A=
+	if (nvram_getshort(NVOFF_MAGIC) !=3D NV_MAGIC) {=0A=
+		nvram_initenv();=0A=
+		return(0);=0A=
+	}=0A=
+	=0A=
+	is_valid =3D 1;=0A=
+	return(1);=0A=
+#endif=0A=
+}=0A=
+=0A=
+/* return nvram address of environment string */=0A=
+static int=0A=
+nvram_matchenv(char *s)=0A=
+{=0A=
+	int envsize, envp, n, i, varsize;=0A=
+	char *var;=0A=
+	=0A=
+	envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+	if (envsize > ENV_AVAIL)=0A=
+		return(0);     /* sanity */=0A=
+	envp =3D ENV_BASE;=0A=
+	=0A=
+	if ((n =3D strlen (s)) > 255)=0A=
+		return(0);=0A=
+	=0A=
+	while (envsize > 0) {=0A=
+		varsize =3D nvram_getbyte(envp);=0A=
+		if (varsize =3D=3D 0 || (envp + varsize) > ENV_TOP)=0A=
+			return(0);   /* sanity */=0A=
+		for (i =3D envp + 1, var =3D s; i <=3D envp + n; i++, var++) {=0A=
+			char c1 =3D nvram_getbyte(i);=0A=
+			char c2 =3D *var;=0A=
+			if (islower(c1))=0A=
+				c1 =3D toupper(c1);=0A=
+			if (islower(c2))=0A=
+				c2 =3D toupper(c2);=0A=
+			if (c1 !=3D c2)=0A=
+				break;=0A=
+		}=0A=
+		if (i > envp + n) {   /* match so far */=0A=
+			if (n =3D=3D varsize - 1) /* match on boolean */=0A=
+				return(envp);=0A=
+			if (nvram_getbyte(i) =3D=3D '=3D')  /* exact match on variable =
*/=0A=
+				return(envp);=0A=
+		}=0A=
+		envsize -=3D varsize;=0A=
+		envp +=3D varsize;=0A=
+	}=0A=
+	return(0);=0A=
+}=0A=
+=0A=
+static void nvram_initenv(void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_delenv(char *s)=0A=
+{=0A=
+	int nenvp, envp, envsize, nbytes;=0A=
+	=0A=
+	envp =3D nvram_matchenv(s);=0A=
+	if (envp =3D=3D 0)=0A=
+		return;=0A=
+	=0A=
+	nenvp =3D envp + nvram_getbyte(envp);=0A=
+	envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+	nbytes =3D envsize - (nenvp - ENV_BASE);=0A=
+	nvram_setshort(NVOFF_ENVSIZE, envsize - (nenvp - envp));=0A=
+	while (nbytes--) {=0A=
+		nvram_setbyte(envp, nvram_getbyte(nenvp));=0A=
+		envp++;=0A=
+		nenvp++;=0A=
+	}=0A=
+	nvram_updatesum();=0A=
+}=0A=
+=0A=
+static int=0A=
+nvram_setenv(char *s, char *v)=0A=
+{=0A=
+	int ns, nv, total;=0A=
+	int envp;=0A=
+	=0A=
+	if (!nvram_isvalid())=0A=
+		return(-1);=0A=
+	=0A=
+	nvram_delenv(s);=0A=
+	ns =3D strlen(s);=0A=
+	if (ns =3D=3D 0)=0A=
+		return (-1);=0A=
+	if (v && *v) {=0A=
+		nv =3D strlen(v);=0A=
+		total =3D ns + nv + 2;=0A=
+	}=0A=
+	else {=0A=
+		nv =3D 0;=0A=
+		total =3D ns + 1;=0A=
+	}=0A=
+	if (total > 255 || total > ENV_AVAIL - =
nvram_getshort(NVOFF_ENVSIZE))=0A=
+		return(-1);=0A=
+	=0A=
+	envp =3D ENV_BASE + nvram_getshort(NVOFF_ENVSIZE);=0A=
+	=0A=
+	nvram_setbyte(envp, (unsigned char)total);=0A=
+	envp++;=0A=
+	=0A=
+	while (ns--) {=0A=
+		nvram_setbyte(envp, *s);=0A=
+		envp++;=0A=
+		s++;=0A=
+	}=0A=
+	=0A=
+	if (nv) {=0A=
+		nvram_setbyte(envp, '=3D');=0A=
+		envp++;=0A=
+		while (nv--) {=0A=
+			nvram_setbyte(envp, *v);=0A=
+			envp++;=0A=
+			v++;=0A=
+		}=0A=
+	}=0A=
+	nvram_setshort(NVOFF_ENVSIZE, envp - ENV_BASE);=0A=
+	nvram_updatesum();=0A=
+	return(0);=0A=
+}=0A=
+=0A=
+static char *=0A=
+nvram_getenv(char *s)=0A=
+{=0A=
+	static char buf[256];=0A=
+	int envp, ns, nbytes, i;=0A=
+	=0A=
+	if (!nvram_isvalid())=0A=
+		return((char *)0);=0A=
+	=0A=
+	envp =3D nvram_matchenv(s);=0A=
+	if (envp =3D=3D 0)=0A=
+		return((char *)0);=0A=
+	ns =3D strlen(s);=0A=
+	if (nvram_getbyte(envp) =3D=3D ns + 1)  /* boolean */=0A=
+		buf[0] =3D '\0';=0A=
+	else {=0A=
+		nbytes =3D nvram_getbyte(envp) - (ns + 2);=0A=
+		envp +=3D ns + 2;=0A=
+		for (i =3D 0; i < nbytes; i++)=0A=
+			buf[i] =3D nvram_getbyte(envp++);=0A=
+		buf[i] =3D '\0';=0A=
+	}=0A=
+	return(buf);=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_unsetenv(char *s)=0A=
+{=0A=
+	if (!nvram_isvalid())=0A=
+		return;=0A=
+	=0A=
+	nvram_delenv(s);=0A=
+}=0A=
+=0A=
+void=0A=
+purgeenv()=0A=
+{=0A=
+	int i;=0A=
+	unsigned char temp;=0A=
+	=0A=
+	unsigned char* nvramAddrPointer =3D (unsigned char*)(NVRAM_BASE + =
0x10);=0A=
+	unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE + =
0x13);=0A=
+	=0A=
+	/* enable burst mode for DS1511*/=0A=
+	unsigned char* controlB =3D (unsigned char*)(NVRAM_BASE + 0x0F);=0A=
+	temp =3D *controlB;=0A=
+	*controlB =3D temp | 0x20;=0A=
+	*nvramAddrPointer =3D (unsigned char)ENV_BASE;=0A=
+	for (i =3D ENV_BASE; i < ENV_TOP; i++)=0A=
+		*nvramDataPointer=3D 0;=0A=
+	*controlB =3D temp;=0A=
+	nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+	nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+	nvram_setshort(NVOFF_CSUM, NV_MAGIC);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * apply func to each string in environment=0A=
+ */=0A=
+static void=0A=
+nvram_mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+	int envsize, envp, n, i, seeneql;=0A=
+	char name[256], value[256];=0A=
+	char c, *s;=0A=
+	=0A=
+	if (!nvram_isvalid())=0A=
+		return;=0A=
+	=0A=
+	envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+	envp =3D ENV_BASE;=0A=
+	=0A=
+	while (envsize > 0) {=0A=
+		value[0] =3D '\0';=0A=
+		seeneql =3D 0;=0A=
+		s =3D name;=0A=
+		n =3D nvram_getbyte(envp);=0A=
+		for (i =3D envp + 1; i < envp + n; i++) {=0A=
+			c =3D nvram_getbyte(i);=0A=
+			if ((c =3D=3D '=3D') && !seeneql) {=0A=
+				*s =3D '\0';=0A=
+				s =3D value;=0A=
+				seeneql =3D 1;=0A=
+				continue;=0A=
+			}=0A=
+			*s++ =3D c;=0A=
+		}=0A=
+		*s =3D '\0';=0A=
+		(*func)(name, value);=0A=
+		envsize -=3D n;=0A=
+		envp +=3D n;=0A=
+	}=0A=
+}=0A=
+#if 0=0A=
+static unsigned int=0A=
+digit(char c)=0A=
+{=0A=
+	if ('0' <=3D c && c <=3D '9')=0A=
+		return(c - '0');=0A=
+	if ('A' <=3D c && c <=3D 'Z')=0A=
+		return(10 + c - 'A');=0A=
+	if ('a' <=3D c && c <=3D 'z')=0A=
+		return(10 + c - 'a');=0A=
+	return(~0);=0A=
+}=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * Wrappers to allow 'special' environment variables to get =
processed=0A=
+ */=0A=
+void=0A=
+setenv(char *e, char *v, int rewrite)=0A=
+{=0A=
+	if (nvram_getenv(e) && !rewrite)=0A=
+		return;=0A=
+	nvram_setenv(e, v);=0A=
+}=0A=
+=0A=
+char *=0A=
+getenv(char *e)=0A=
+{=0A=
+	return(nvram_getenv(e));=0A=
+}=0A=
+=0A=
+void=0A=
+unsetenv(char *e)=0A=
+{=0A=
+	nvram_unsetenv(e);=0A=
+}=0A=
+=0A=
+void=0A=
+mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+	nvram_mapenv(func);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/nvram/nvram355.h =
idtlinux/arch/mips/idt-boards/rc32300/EB355/nvram/nvram355.h=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/nvram/nvram355.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/nvram/nvram355.h	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,72 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram.h: NVRAM layout definitions=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#ifndef _NVRAM_=0A=
+#define _NVRAM_=0A=
+/*=0A=
+ * defining ALGCOMPAT provides backward compatibility=0A=
+ * with Algorithmics derived PROM monitors=0A=
+ */=0A=
+#define ALGCOMPAT=0A=
+#ifdef ALGCOMPAT=0A=
+#define NVOFFSET  0   /* use all of NVRAM */=0A=
+#else=0A=
+#define NVOFFSET  128   /* first 1Kb reserved for DECelx */=0A=
+#endif=0A=
+=0A=
+/* Offsets to reserved locations */=0A=
+/* size description */=0A=
+#define NVOFF_MAGIC   (NVOFFSET + 0)  /* 2 magic value */=0A=
+#define NVOFF_CSUM    (NVOFFSET + 2)  /* 2 NVRAM environment checksum =
*/=0A=
+#define NVOFF_ENVSIZE (NVOFFSET + 4)  /* 2 size of 'environment' */=0A=
+#define NVOFF_TEST    (NVOFFSET + 5)  /* 1 cold start test byte */=0A=
+#define NVOFF_ETHADDR (NVOFFSET + 6)  /* 6 decoded ethernet address =
*/=0A=
+#define NVOFF_UNUSED  (NVOFFSET + 12) /* 0 current end of table */=0A=
+=0A=
+#define NV_MAGIC      0xdeaf          /* nvram magic number */=0A=
+#define NV_RESERVED   32              /* number of reserved bytes =
*/=0A=
+=0A=
+#ifdef ALGCOMPAT=0A=
+/* ho hum... */=0A=
+#undef NVOFF_ETHADDR=0A=
+#define NVOFF_ETHADDR (NVOFFSET + NV_RESERVED - 6)=0A=
+#endif=0A=
+=0A=
+/* number of bytes available for environment */=0A=
+#define ENV_BASE      (NVOFFSET + NV_RESERVED)=0A=
+#define ENV_TOP       TD_NVRAM_SIZE=0A=
+#define ENV_AVAIL     (ENV_TOP - ENV_BASE)=0A=
+#endif /* _NVRAM_ */=0A=
+=0A=
+#define NVRAM_BASE 0xba004000=0A=
+#define TD_NVRAM_SIZE 0x100=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/nvram/nvramproc.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/nvram/nvramproc.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/nvram/nvramproc.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/nvram/nvramproc.c	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,219 @@=0A=
+/**********************************************************************=
********=0A=
+  We provide a /proc interface to the nvram. We make an entry=0A=
+  for 'nvram' and under which 'boot'. 'boot' is a deivce that=0A=
+  is read/write. Together with nvram365.c, we provide an interface =
for=0A=
+  the user to set and modify the environment variables stored in =
NVRAM.=0A=
+ =
************************************************************************=
*******=0A=
+  Examples=0A=
+  =0A=
+  #cat /proc/nvram/boot=0A=
+     will display the boot environment variables, like =
netaddr0,bootaddr etc.=0A=
+  #echo "netaddr0 192.168.1.3" >/proc/nvram/boot=0A=
+     will modify the boot environment variable netaddr0.=0A=
+  #echo "netaddr0" >/proc/nvram/boot=0A=
+     will erase the "netaddr0" environment variable=0A=
+  #echo >/proc/nvram/boot=0A=
+     will erase all environment variables stored in nvram=0A=
+=0A=
+***********************************************************************=
*******/=0A=
+	=0A=
+#include <linux/module.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/proc_fs.h>=0A=
+#include <linux/sched.h>=0A=
+#include <asm/uaccess.h>=0A=
+#include <linux/string.h>=0A=
+=0A=
+//#define DEBUG 1=0A=
+#define MODULE_VERSION "1.0"=0A=
+#define MODULE_NAME "nvram"=0A=
+#define BOOT_MAJOR 240=0A=
+#define BUF_LEN 8192=0A=
+=0A=
+extern void setenv (char *e, char *v, int rewrite);=0A=
+extern char *getenv (char *e);=0A=
+extern void unsetenv (char *e);=0A=
+extern void mapenv (int (*func)(char *, char *));=0A=
+extern void purgeenv(void);=0A=
+extern char *getenv (char *s);=0A=
+=0A=
+static struct proc_dir_entry *nvram, *boot;=0A=
+=0A=
+static int boot_open(struct inode *, struct file *);=0A=
+static int boot_release(struct inode *, struct file *);=0A=
+static ssize_t boot_read(struct file *, char *, size_t, loff_t *);=0A=
+static ssize_t boot_write(struct file *, const char *, size_t, loff_t =
*);=0A=
+=0A=
+static struct file_operations boot_fops =3D {=0A=
+	.read =3D boot_read, =0A=
+	.write =3D boot_write,=0A=
+	.open =3D boot_open,=0A=
+	.release =3D boot_release=0A=
+};=0A=
+=0A=
+static char msg[BUF_LEN];=0A=
+static char *msg_Ptr;=0A=
+const char delimiters[] =3D " \n";=0A=
+=0A=
+static int printVal(char *name,char *val)=0A=
+{=0A=
+	strcat(msg,name);=0A=
+	strcat(msg," ");=0A=
+	strcat(msg,val);=0A=
+	strcat(msg,"\n");=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static int boot_open(struct inode *inode, struct file *file)=0A=
+{=0A=
+	MOD_INC_USE_COUNT;=0A=
+	memset(msg,0,BUF_LEN);=0A=
+	msg_Ptr =3D msg;=0A=
+	return 0;=0A=
+}=0A=
+static int boot_release(struct inode *inode, struct file *file)=0A=
+{=0A=
+	MOD_DEC_USE_COUNT;=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static ssize_t boot_read(struct file *filp,=0A=
+			 char *buffer,    /* The buffer to fill with data */=0A=
+			 size_t length,   /* The length of the buffer     */=0A=
+			 off_t *offset)  /* Our offset in the file       */=0A=
+{=0A=
+	int bytes_read =3D 0;=0A=
+	if(msg_Ptr =3D=3D msg)=0A=
+	{=0A=
+		mapenv(&printVal);=0A=
+	}=0A=
+	if (*msg_Ptr =3D=3D 0){=0A=
+		msg_Ptr =3D msg;=0A=
+		return 0;=0A=
+	}=0A=
+	while (length && *msg_Ptr)=0A=
+	{=0A=
+		put_user(*(msg_Ptr++), buffer++);=0A=
+		length--;=0A=
+		bytes_read++;=0A=
+	}=0A=
+	return bytes_read;=0A=
+}=0A=
+=0A=
+static ssize_t boot_write(struct file *filp,=0A=
+			  const char *buffer,=0A=
+			  size_t length,=0A=
+			  loff_t *offset)=0A=
+{=0A=
+	int bytes_written =3D 0;=0A=
+	char *token1,*token2;=0A=
+	=0A=
+	memset(msg,0,BUF_LEN);=0A=
+	=0A=
+	while(length && *buffer)=0A=
+	{=0A=
+		get_user(msg[bytes_written],buffer++);=0A=
+		length--;=0A=
+		bytes_written++;=0A=
+	}=0A=
+	=0A=
+	token1 =3D strsep(&msg_Ptr,delimiters);=0A=
+	token2 =3D strsep(&msg_Ptr,delimiters);=0A=
+	=0A=
+	if((*token1 !=3D'\0') && (*token2 !=3D '\0'))=0A=
+	{=0A=
+#ifdef DEBUG=0A=
+		printk(__FILE__": setting environment %s to %s\n",token1,token2);=0A=
+#endif=0A=
+		setenv(token1,token2,1);=0A=
+	}=0A=
+	else if(*token1 !=3D '\0')=0A=
+	{=0A=
+#ifdef DEBUG=0A=
+		printk(__FILE__": pugring environment variable %s\n",token1);=0A=
+#endif=0A=
+		unsetenv(token1);=0A=
+	}=0A=
+	else=0A=
+	{=0A=
+#ifdef DEBUG=0A=
+		printk(__FILE__": purging all environment variables\n");=0A=
+#endif=0A=
+		purgeenv();=0A=
+	}=0A=
+	=0A=
+	return bytes_written;=0A=
+}=0A=
+=0A=
+=0A=
+static int __init init_procfs_nvram(void)=0A=
+{=0A=
+	int rv =3D 0;=0A=
+	=0A=
+	/* create directory */=0A=
+	nvram =3D proc_mkdir(MODULE_NAME, NULL);=0A=
+	if(nvram =3D=3D NULL) {=0A=
+#ifdef DEBUG=0A=
+		printk(__FILE__": Cannot make proc entry for 'nvram'\n");=0A=
+#endif=0A=
+		rv =3D -ENOMEM;=0A=
+		goto out1;=0A=
+	}=0A=
+#ifdef DEBUG=0A=
+	printk(__FILE__": module %s %s initialised\n", MODULE_NAME, =
MODULE_VERSION);=0A=
+#endif=0A=
+	if (register_chrdev(BOOT_MAJOR,"boot", &boot_fops) <0)=0A=
+	{=0A=
+#ifdef DEBUG     =0A=
+		printk(__FILE__": Cannot register 'boot' device.\n");=0A=
+#endif=0A=
+		rv =3D -EINVAL;=0A=
+		goto out2;=0A=
+	}=0A=
+	=0A=
+#ifdef DEBUG     =0A=
+	printk(__FILE__": device 'boot' (major %d) =
registered\n",BOOT_MAJOR);=0A=
+#endif=0A=
+        =0A=
+	boot =3D proc_mknod("boot", S_IFCHR | 0644, nvram, MKDEV(BOOT_MAJOR, =
0));=0A=
+	if(boot =3D=3D NULL) {=0A=
+#ifdef DEBUG=0A=
+		printk(__FILE__": Cannot make proc entry for boot.\n");=0A=
+#endif=0A=
+		rv =3D -ENOMEM;=0A=
+		goto out3;=0A=
+	}=0A=
+	=0A=
+	boot->owner =3D THIS_MODULE;=0A=
+	=0A=
+	return 0;=0A=
+	=0A=
+ out3:=0A=
+	unregister_chrdev(BOOT_MAJOR,"boot");=0A=
+ out2:=0A=
+	remove_proc_entry(MODULE_NAME, NULL);=0A=
+ out1:=0A=
+	return rv;=0A=
+}=0A=
+=0A=
+=0A=
+static void __exit cleanup_procfs_nvram(void)=0A=
+{=0A=
+	remove_proc_entry("boot", nvram);=0A=
+	unregister_chrdev(BOOT_MAJOR,"boot");=0A=
+	remove_proc_entry(MODULE_NAME, NULL);=0A=
+#ifdef DEBUG=0A=
+	printk("%s %s removed\n", MODULE_NAME, MODULE_VERSION);=0A=
+#endif=0A=
+}=0A=
+=0A=
+=0A=
+module_init(init_procfs_nvram);=0A=
+module_exit(cleanup_procfs_nvram);=0A=
+=0A=
+MODULE_AUTHOR("idt");=0A=
+MODULE_DESCRIPTION("proc interface for nvram");=0A=
+MODULE_LICENSE("GPL");=0A=
+=0A=
+EXPORT_NO_SYMBOLS;=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/prom.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/prom.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/prom.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/prom.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,141 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     IDT EB32355 kernel boot-parameters setup=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/string.h>=0A=
+#include <linux/console.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <linux/bootmem.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serialP.h>=0A=
+#include <asm/serial.h>=0A=
+#include <linux/ioport.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32355.h>=0A=
+=0A=
+unsigned int idt_cpu_freq =3D CONFIG_IDT_BOARD_FREQ;=0A=
+EXPORT_SYMBOL(idt_cpu_freq);=0A=
+extern void setup_serial_port(int);=0A=
+=0A=
+=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+extern void mapenv(int (*func)(char *, char *));=0A=
+static int make_bootparm(char *name,char *val)=0A=
+{ =0A=
+	if (strncmp(name, "bootparm", 8) =3D=3D 0) {=0A=
+		strcat(arcs_cmdline,val);=0A=
+		strcat(arcs_cmdline," ");=0A=
+	}=0A=
+	else if(strncmp(name, "HZ", 2) =3D=3D 0) {=0A=
+		idt_cpu_freq =3D simple_strtoul(val, 0, 10);=0A=
+		printk("CPU Clock at %d Hz (from HZ environment variable)\n",=0A=
+		       idt_cpu_freq);=0A=
+	}=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Parses environment variable strings in NVRAM, copying strings=0A=
+ * beginning with "bootparm?=3D" to arcs_cmdline[]. For example,=0A=
+ *=0A=
+ *    netaddr=3D10.0.1.95=0A=
+ *    bootaddr=3D10.0.0.139=0A=
+ *    bootfile=3Dvmlinus=0A=
+ *    bootparm1=3Droot=3D/dev/nfs=0A=
+ *    bootparm2=3Dip=3D10.0.1.95=0A=
+ *=0A=
+ * is parsed to:=0A=
+ *=0A=
+ *      root=3D/dev/nfs ip=3D10.0.1.95=0A=
+ *=0A=
+ * in arcs_cmdline[].=0A=
+ */=0A=
+static void prom_init_cmdline(void)=0A=
+{ =0A=
+	memset(arcs_cmdline,0,sizeof(arcs_cmdline));=0A=
+	mapenv(&make_bootparm);=0A=
+}=0A=
+#else=0A=
+/* Kernel Boot parameters */=0A=
+static unsigned char bootparm[]=3D"console=3DttyS0,9600";=0A=
+#endif=0A=
+extern unsigned long mips_machgroup;=0A=
+extern unsigned long mips_machtype;=0A=
+=0A=
+const char *get_system_type(void)=0A=
+{=0A=
+	return "IDT 79EB355";=0A=
+}=0A=
+=0A=
+struct resource rc32300_res_ram =3D {=0A=
+	"RAM",=0A=
+	0,=0A=
+	RAM_SIZE,=0A=
+	IORESOURCE_MEM=0A=
+};=0A=
+=0A=
+char * __init prom_getcmdline(void)=0A=
+{=0A=
+	return &(arcs_cmdline[0]);=0A=
+}=0A=
+=0A=
+void __init prom_init(void)=0A=
+{=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+	/* set up command line */=0A=
+	prom_init_cmdline();=0A=
+#else=0A=
+	sprintf(arcs_cmdline,"%s",bootparm);=0A=
+#endif=0A=
+	=0A=
+	setup_serial_port(0);     // UART0=0A=
+	setup_serial_port(1);     // UART1=0A=
+	=0A=
+	/* set our arch type */=0A=
+	mips_machgroup =3D MACH_GROUP_IDT;=0A=
+	mips_machtype =3D MACH_IDT_EB355;=0A=
+	add_memory_region(0,=0A=
+			  rc32300_res_ram.end - rc32300_res_ram.start,=0A=
+			  BOOT_MEM_RAM);=0A=
+	=0A=
+}=0A=
+=0A=
+void prom_free_prom_memory(void)=0A=
+{=0A=
+}=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/reset.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/reset.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/reset.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/reset.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,70 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     IDT EB32355 reset/power-off routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/pm.h>=0A=
+#include <linux/slab.h>=0A=
+#include <linux/sysctl.h>=0A=
+=0A=
+#include <asm/string.h>=0A=
+#include <asm/uaccess.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/cacheflush.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32355.h>=0A=
+=0A=
+void rc32300_restart(char *command)=0A=
+{=0A=
+	set_c0_status((ST0_BEV | ST0_ERL));=0A=
+	set_c0_config(CONF_CM_UNCACHED);=0A=
+	flush_cache_all();=0A=
+	write_c0_wired(0);=0A=
+	=0A=
+	rc32300_writel(0x80000001, RESET_CNTL);=0A=
+}=0A=
+=0A=
+void rc32300_halt(void)=0A=
+{=0A=
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");=0A=
+	while (1)=0A=
+		__asm__(".set\tmips3\n\t"=0A=
+	                "wait\n\t"=0A=
+			".set\tmips0");=0A=
+}=0A=
+=0A=
+void rc32300_power_off(void)=0A=
+{=0A=
+	rc32300_halt();=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/serial.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/serial.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/serial.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/serial.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,82 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Serial Port Setup (2 UART)=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/tty.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serial_core.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/irq.h>=0A=
+#include <asm/serial.h>=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+=0A=
+extern int __init early_serial_setup(struct uart_port *port);=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+=0A=
+extern int __init setup_serial_port(int port)=0A=
+{ =0A=
+	static struct uart_port serial_req[2];=0A=
+	memset(serial_req, 0, sizeof(serial_req));=0A=
+	if(port =3D=3D 0){=0A=
+		serial_req[0].type       =3D PORT_16550A;=0A=
+		serial_req[0].line       =3D 0;=0A=
+		serial_req[0].irq        =3D RC32300_UART0_IRQ;=0A=
+		serial_req[0].flags      =3D STD_COM_FLAGS;=0A=
+		serial_req[0].uartclk    =3D idt_cpu_freq;=0A=
+		serial_req[0].iotype     =3D SERIAL_IO_MEM;=0A=
+		serial_req[0].membase    =3D (char *) =
KSEG1ADDR(RC32300_UART0_BASE);=0A=
+		serial_req[0].mapbase   =3D KSEG1ADDR(RC32300_UART0_BASE);=0A=
+		serial_req[0].regshift   =3D 2;=0A=
+		early_serial_setup(&serial_req[0]);=0A=
+	}=0A=
+	else if (port =3D=3D 1){=0A=
+		serial_req[1].type       =3D PORT_16550A;=0A=
+		serial_req[1].line       =3D 1;=0A=
+		serial_req[1].irq        =3D RC32300_UART1_IRQ;=0A=
+		serial_req[1].flags      =3D STD_COM_FLAGS;=0A=
+		serial_req[1].uartclk    =3D idt_cpu_freq;=0A=
+		serial_req[1].iotype     =3D SERIAL_IO_MEM;=0A=
+		serial_req[1].membase    =3D (char *) =
KSEG1ADDR(RC32300_UART1_BASE);=0A=
+		serial_req[1].mapbase   =3D KSEG1ADDR(RC32300_UART1_BASE);=0A=
+		serial_req[1].regshift   =3D 2;=0A=
+		early_serial_setup(&serial_req[1]);=0A=
+	}=0A=
+	return(0);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/serial_gdb.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/serial_gdb.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/serial_gdb.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/serial_gdb.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,273 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *      EB355 specific polling driver for 16550 UART.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/serial_reg.h>=0A=
+=0A=
+/* set remote gdb baud rate at 115200 */=0A=
+=0A=
+#define GDB_BAUD 115200=0A=
+#define CONS_BAUD 9600=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+=0A=
+/* turn this on to watch the debug protocol echoed on the console port =
*/=0A=
+#undef DEBUG_REMOTE_DEBUG=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define CONS_PORT 0xb8050003u=0A=
+#define GDB_PORT  0xb8050023u=0A=
+#else=0A=
+#define CONS_PORT 0xb8050000u=0A=
+#define GDB_PORT  0xb8050020u=0A=
+#endif=0A=
+           =0A=
+volatile unsigned char *ports[2] =3D {=0A=
+	(volatile unsigned char *)CONS_PORT,=0A=
+	(volatile unsigned char *)GDB_PORT=0A=
+};=0A=
+=0A=
+=0A=
+void reset_gdb_port(void);=0A=
+void cons_putc(char c);=0A=
+int port_getc(int port);=0A=
+void port_putc(int port, char c);=0A=
+=0A=
+int cons_getc(void)=0A=
+{=0A=
+	return port_getc(0);=0A=
+}=0A=
+=0A=
+void cons_putc(char c)=0A=
+{=0A=
+	port_putc(0, c);=0A=
+}=0A=
+=0A=
+void cons_puts(char *s)=0A=
+{=0A=
+	while(*s) {=0A=
+		if(*s =3D=3D '\n') cons_putc('\r');=0A=
+		cons_putc(*s);=0A=
+		s++;=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_do_putn(int n)=0A=
+{=0A=
+	if(n) {=0A=
+		cons_do_putn(n / 10);=0A=
+		cons_putc(n % 10 + '0');=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_putn(int n)=0A=
+{=0A=
+	if(n < 0) {=0A=
+		cons_putc('-');=0A=
+		n =3D -n;=0A=
+	}=0A=
+=0A=
+	if (n =3D=3D 0) {=0A=
+		cons_putc('0');=0A=
+	} else {=0A=
+		cons_do_putn(n);=0A=
+	}=0A=
+}=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+static enum {HUH, SENDING, GETTING} state;=0A=
+=0A=
+static void sent(int c)=0A=
+{=0A=
+	switch(state) {=0A=
+	case HUH:=0A=
+	case GETTING:=0A=
+		cons_puts("\nSNT ");=0A=
+		state =3D SENDING;=0A=
+		/* fall through */=0A=
+	case SENDING:=0A=
+		cons_putc(c);=0A=
+		break;=0A=
+	}       =0A=
+}=0A=
+=0A=
+static void got(int c)=0A=
+{=0A=
+	switch(state) {=0A=
+	case HUH:=0A=
+	case SENDING:=0A=
+		cons_puts("\nGOT ");=0A=
+		state =3D GETTING;=0A=
+		/* fall through */=0A=
+	case GETTING:=0A=
+		cons_putc(c);=0A=
+		break;=0A=
+	}       =0A=
+}=0A=
+#endif /* DEBUG_REMOTE_DEBUG */=0A=
+=0A=
+static int first =3D 1;=0A=
+=0A=
+int getDebugChar(void)=0A=
+{=0A=
+	int c;=0A=
+=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+	c =3D port_getc(1);=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	got(c);=0A=
+#endif=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+	int c;=0A=
+=0A=
+	while((*(port + UART_LSR * 4) & UART_LSR_DR) =3D=3D 0) {=0A=
+		continue;=0A=
+	}       	=0A=
+=0A=
+	c =3D *(port + UART_RX * 4);=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc_ready(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+=0A=
+	return *(port + UART_LSR * 4) & UART_LSR_DR;=0A=
+}=0A=
+=0A=
+int isDebugReady(void)=0A=
+{=0A=
+	return port_getc_ready(1);=0A=
+}=0A=
+=0A=
+void putDebugChar(char c)=0A=
+{=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	sent(c);=0A=
+#endif=0A=
+=0A=
+	port_putc(1, c);=0A=
+}=0A=
+=0A=
+#define OK_TO_XMT (UART_LSR_TEMT | UART_LSR_THRE)=0A=
+=0A=
+void port_putc(int p, char c)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+	volatile unsigned char *lsr =3D port + UART_LSR * 4;=0A=
+=0A=
+	while((*lsr & OK_TO_XMT) !=3D OK_TO_XMT) {=0A=
+		continue;=0A=
+	}=0A=
+=0A=
+	*(port + UART_TX * 4) =3D c;=0A=
+}=0A=
+=0A=
+void reset_gdb_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[1];=0A=
+	unsigned int DIVISOR =3D (idt_cpu_freq / 16 / GDB_BAUD);=0A=
+=0A=
+	first =3D 0;=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	cons_puts("reset_gdb_port: initializing remote debug serial port =
(internal UART 1, ");=0A=
+	cons_putn(GDB_BAUD);=0A=
+	cons_puts("baud, MHz=3D");=0A=
+	cons_putn(idt_cpu_freq);=0A=
+	cons_puts(", divisor=3D");=0A=
+	cons_putn(DIVISOR);=0A=
+	cons_puts(")\n");=0A=
+#endif=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + UART_CSR * 4) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + UART_FCR * 4) =3D UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR =
| =0A=
+		UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+	*(port + UART_DLL * 4) =3D DIVISOR;=0A=
+	*(port + UART_DLM * 4) =3D DIVISOR >> 8;=0A=
+=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + UART_IER * 4) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + UART_MCR * 4) =3D 0;=0A=
+}=0A=
+=0A=
+void reset_cons_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[0];=0A=
+	  unsigned int DIVISOR =3D (idt_cpu_freq / 16 / CONS_BAUD);=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + UART_CSR * 4) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + UART_FCR * 4) =3D UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR =
| =0A=
+		UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+=0A=
+	*(port + UART_DLL * 4) =3D DIVISOR;=0A=
+	*(port + UART_DLM * 4) =3D DIVISOR >> 8;=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + UART_IER * 4) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + UART_MCR * 4) =3D 0;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/setup.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/setup.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/setup.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/setup.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,138 @@=0A=
+/**********************************************************************=
****=0A=
+*=0A=
+*  BRIEF MODULE DESCRIPTION=0A=
+*     IDT EB32355 board setup=0A=
+*=0A=
+*  Copyright 2006 IDT Inc.=0A=
+*  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+*=0A=
+*         =0A=
+*  This program is free software; you can redistribute  it and/or =
modify it=0A=
+*  under  the terms of  the GNU General  Public License as published =
by the=0A=
+*  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+*  option) any later version.=0A=
+*=0A=
+*  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+*  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+*  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+*  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+*  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+*  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+*  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR =
TORT=0A=
+*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+*  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+*=0A=
+*  You should have received a copy of the  GNU General Public License =
along=0A=
+*  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+*  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+*=0A=
+***********************************************************************=
***=0A=
+*/=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/pm.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/tty.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serial_core.h>=0A=
+=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/irq.h>=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/eisa.h>=0A=
+#include <linux/hdreg.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <linux/console.h>=0A=
+#include <linux/fb.h>=0A=
+#include <linux/tty.h>=0A=
+=0A=
+#include <asm/reboot.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32355.h>=0A=
+=0A=
+extern void (*board_time_init)(void);=0A=
+extern void (*board_timer_setup)(struct irqaction *irq);=0A=
+extern void rc32300_time_init(void);=0A=
+extern void rc32300_timer_setup(struct irqaction *irq);=0A=
+extern char * __init prom_getcmdline(void);=0A=
+extern void rc32300_restart(char *);=0A=
+extern void rc32300_halt(void);=0A=
+extern void rc32300_power_off(void);=0A=
+extern int init_lcd(void);=0A=
+extern int idtprintf(const char *fmt, ...);=0A=
+=0A=
+static int __init idt_setup(void)=0A=
+{=0A=
+	char* argptr;=0A=
+	argptr =3D prom_getcmdline();=0A=
+	=0A=
+#ifdef CONFIG_SERIAL_8250_CONSOLE=0A=
+	if ((argptr =3D strstr(argptr, "console=3D")) =3D=3D NULL) {=0A=
+		argptr =3D prom_getcmdline();=0A=
+		strcat(argptr, " console=3DttyS0,9600");=0A=
+	}=0A=
+#endif=0A=
+	=0A=
+	board_time_init =3D rc32300_time_init;=0A=
+	board_timer_setup =3D rc32300_timer_setup;=0A=
+	=0A=
+	_machine_restart =3D rc32300_restart;=0A=
+	_machine_halt =3D rc32300_halt;=0A=
+	pm_power_off =3D rc32300_power_off;=0A=
+	=0A=
+	set_io_port_base(KSEG1);=0A=
+	=0A=
+	// clear out any wired entries=0A=
+	write_c0_wired(0);=0A=
+	=0A=
+	/*=0A=
+	 * Setup Device 3. The EPLD (U13) splits device 3 chip-select=0A=
+	 * into seperate chip selects for the TDM, LCD, and RTC=0A=
+	 * devices. Timings are from IDT-SIM source.=0A=
+	 */=0A=
+	rc32300_writel(0x00000000, DEV0_MASK   + 3*DEV_REG_OFFSET);=0A=
+	rc32300_writel(TDM_BASE,   DEV0_BASE   + 3*DEV_REG_OFFSET);=0A=
+	rc32300_writel(0x0FFFFF84, DEV0_CNTL   + 3*DEV_REG_OFFSET);=0A=
+	rc32300_writel(0x00001FFF, DEV0_TIMING + 3*DEV_REG_OFFSET);=0A=
+	rc32300_writel(0xFFFF0000, DEV0_MASK   + 3*DEV_REG_OFFSET);=0A=
+	=0A=
+	init_lcd();=0A=
+	idtprintf("IDT-Linux 2.6");=0A=
+	=0A=
+	=0A=
+#ifdef CONFIG_MTD=0A=
+	/*=0A=
+	 * Setup device 2 for flash devices. Set for=0A=
+	 * 32-bit databus size, write-enable.=0A=
+	 */=0A=
+	rc32300_writel(0x00000000, DEV0_MASK   + 2*DEV_REG_OFFSET);=0A=
+	rc32300_writel(FLASH_BASE, DEV0_BASE   + 2*DEV_REG_OFFSET);=0A=
+	/* timings are from IDT/sim source */=0A=
+	rc32300_writel(0x03CF3316, DEV0_CNTL   + 2*DEV_REG_OFFSET);=0A=
+	rc32300_writel(0x00001133, DEV0_TIMING + 2*DEV_REG_OFFSET);=0A=
+	rc32300_writel(0xFF800000, DEV0_MASK   + 2*DEV_REG_OFFSET);=0A=
+#endif=0A=
+	=0A=
+	=0A=
+	/* Disable Watchdog timer */=0A=
+	rc32300_writel(0, 0xb8028040);=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+//early_initcall(idt_setup);=0A=
+=0A=
+void __init plat_setup(void){=0A=
+  idt_setup();=0A=
+}=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/time.c =
idtlinux/arch/mips/idt-boards/rc32300/EB355/time.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB355/time.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB355/time.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,133 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *    IDT EB32355 timer routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ * =0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/spinlock.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <linux/irq.h>=0A=
+#include <linux/timex.h>=0A=
+=0A=
+#include <linux/param.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/hardirq.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/debug.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32355.h>=0A=
+=0A=
+static unsigned long r4k_offset; /* Amount to incr compare reg each =
time */=0A=
+static unsigned long r4k_cur;    /* What counter should be at next =
timer irq */=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+#if defined(CONFIG_IDT_79EB355) && defined(CONFIG_MIPS_RTC)=0A=
+extern void rtc_ds1501_init(void);=0A=
+#endif=0A=
+=0A=
+=0A=
+/* =0A=
+ * Figure out the r4k offset, the amount to increment the compare=0A=
+ * register for each time tick. There is no RTC available.=0A=
+ *=0A=
+ * The RC32300 counts at half the CPU *core* speed.=0A=
+ */=0A=
+=0A=
+static unsigned long __init cal_r4koff(void)=0A=
+{=0A=
+	mips_hpt_frequency =3D idt_cpu_freq * IDT_CLOCK_MULT / 2;=0A=
+	return (mips_hpt_frequency / HZ);=0A=
+}=0A=
+=0A=
+=0A=
+void __init rc32300_time_init(void)=0A=
+{=0A=
+	unsigned int est_freq, flags;=0A=
+	=0A=
+	local_irq_save(flags);=0A=
+	=0A=
+	printk("calculating r4koff... ");=0A=
+	r4k_offset =3D cal_r4koff();=0A=
+	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);=0A=
+	=0A=
+	est_freq =3D 2*r4k_offset*HZ;	=0A=
+	est_freq +=3D 5000;    /* round */=0A=
+	est_freq -=3D est_freq%10000;=0A=
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000, =0A=
+	       (est_freq%1000000)*100/1000000);=0A=
+	local_irq_restore(flags);=0A=
+	=0A=
+#if defined(CONFIG_IDT_79EB355) && defined(CONFIG_MIPS_RTC)=0A=
+	rtc_ds1501_init();=0A=
+#endif=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+void __init rc32300_timer_setup(struct irqaction *irq)=0A=
+{=0A=
+	/* we are using the cpu counter for timer interrupts */=0A=
+	setup_irq(MIPS_CPU_TIMER_IRQ, irq);=0A=
+	=0A=
+	/* to generate the first timer interrupt */=0A=
+	r4k_cur =3D (read_c0_count() + r4k_offset);=0A=
+	write_c0_compare(r4k_cur);=0A=
+}=0A=
+=0A=
+static inline void ack_r4ktimer(unsigned long newval)=0A=
+{=0A=
+	write_c0_compare(newval);=0A=
+}=0A=
+=0A=
+=0A=
+asmlinkage void idt_timer_interrupt(int irq,struct pt_regs *regs)=0A=
+{ =0A=
+#ifdef CONFIG_KGDB=0A=
+	void kgdb_check(void);=0A=
+#endif=0A=
+=0A=
+	irq_enter();=0A=
+	kstat_this_cpu.irqs[irq]++;=0A=
+	timer_interrupt(irq, NULL, regs);=0A=
+	irq_exit();=0A=
+=0A=
+#ifdef CONFIG_KGDB=0A=
+	kgdb_check();=0A=
+#endif=0A=
+}=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/csu_idt.S =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/csu_idt.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/csu_idt.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/csu_idt.S	=
2006-03-09 16:25:47.000000000 -0800=0A=
@@ -0,0 +1,320 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialization code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+#include "iregdef.h"=0A=
+#include "idtcpu.h"=0A=
+#include "idthdr.h"=0A=
+	=0A=
+#define  MHZ (CONFIG_IDT_BOARD_FREQ/(1000*1000))=0A=
+	=0A=
+#include "s365led.h"	=0A=
+#include "s365ram.h"=0A=
+=0A=
+	=0A=
+/*--------------------------------------------------------------=0A=
+* prom entry point table=0A=
+*-------------------------------------------------------------*/=0A=
+=0A=
+FRAME(start,sp,0,ra)=0A=
+=0A=
+	j	idtstart  /* begin monitor from start |00| */=0A=
+	=0A=
+idtstart:=0A=
+=0A=
+	.set noreorder=0A=
+	=0A=
+	mtc0	zero, C0_CAUSE=0A=
+	li	v0, 0x0=0A=
+	or	v0, (SR_CU0 | SR_BEV | SR_DE)=0A=
+	mtc0	v0, C0_SR=0A=
+=0A=
+	mfc0	v1, C0_CONFIG=0A=
+	li	v0, CFG_C_NCHRNT_WB  /* CFG_C_NCHRNT_WB  CFG_C_NCHRNT_WT_NWA =
CFG_C_UNCACHED */=0A=
+	and	v1, ~(0x7)=0A=
+	or	v1, v1, v0=0A=
+	mtc0	v1, C0_CONFIG=0A=
+	nop=0A=
+	nop=0A=
+	li	t0, ERR_CNTL_STATUS  =0A=
+	sw	zero, 0(t0)=0A=
+=0A=
+/* ------------------- Setup Device Controller =
---------------------------- */=0A=
+	li	t0, DEV_CTL_BASE      	/* load 2 base address registers' base    =
*/=0A=
+=0A=
+	lui	t2, 0xB800=0A=
+	lw	t1, 0x8004(t2)        	/* get BCV                                =
*/=0A=
+	li	t2, 0x60              	/* check width of boot device 16/32 bit   =
*/=0A=
+	and	t1, t1, t2=0A=
+	li	t2, 0x20=0A=
+	bne	t1, t2, 1f=0A=
+	nop=0A=
+/* 16 bit device - boot from PROM - CS1 is FLASH                      	=
*/=0A=
+	li	t1, DEV_PROM_CTRL     	/* device0 control parameter              =
*/=0A=
+	sw	t1, 0x8(t0)           	/* set the control register  CS0          =
*/=0A=
+	li	t1, DEV_PROM_TC       	/* device0 timing config parameter        =
*/=0A=
+	sw	t1, 0xC(t0)=0A=
+=0A=
+	li	t1, DEV1_BASE         	/* set the device base register for CS1   =
*/=0A=
+	sw	t1, 0x10(t0)=0A=
+	li	t1, DEV_FLASH_MASK    	/* set the device mask register for CS1   =
*/=0A=
+	sw	t1, 0x14(t0) =0A=
+	li	t1, DEV_FLASH_CTRL    	/* set the device control register for =
CS1*/=0A=
+	sw	t1, 0x18(t0)=0A=
+	li	t1, DEV_FLASH_TC      	/* set the device timing register for CS1 =
*/=0A=
+	sw	t1, 0x1C(t0) =0A=
+	b	2f                    =0A=
+        nop=0A=
+1:=0A=
+/* 32 bit device - boot from FLASH - CS1 is PROM                      	=
*/=0A=
+	li	t1, DEV_FLASH_CTRL    	/* device0 control parameter              =
*/=0A=
+	sw	t1, 0x8(t0)           	/* set the control register  CS0          =
*/=0A=
+	li	t1, DEV_FLASH_TC      	/* device0 timing config parameter        =
*/=0A=
+	sw	t1, 0xC(t0)=0A=
+	li	t1, DEV1_BASE		/* set the device base register for CS1   */=0A=
+	sw	t1, 0x10(t0)=0A=
+	li	t1, DEV_PROM_MASK     	/* set the device mask register for CS1   =
*/=0A=
+	sw	t1, 0x14(t0) =0A=
+	li	t1, DEV_PROM_CTRL     	/* set the device control register for =
CS1*/=0A=
+	sw	t1, 0x18(t0)=0A=
+	li	t1, DEV_PROM_TC       	/* set the device timing register for CS1 =
*/=0A=
+	sw	t1, 0x1C(t0) =0A=
+2:=0A=
+	li	t1, DEV2_BASE         	/* set the device base register for CS2   =
*/=0A=
+	sw	t1, 0x20(t0)=0A=
+	li	t1, DEV2_MASK         	/* set the device mask register for CS2   =
*/=0A=
+	sw	t1, 0x24(t0) =0A=
+	li	t1, DEV2_CTRL         	/* set the device control register for =
CS2*/=0A=
+	sw	t1, 0x28(t0) =0A=
+	li	t1, DEV2_TC           	/* set the device timing register for CS2 =
*/=0A=
+	sw	t1, 0x2C(t0) =0A=
+=0A=
+	li	t1, DEV3_BASE	        /* set the device base register for CS3   =
*/=0A=
+	sw	t1, 0x30(t0)=0A=
+	li	t1, DEV3_MASK         	/* set the device mask register for CS3   =
*/=0A=
+	sw	t1, 0x34(t0) =0A=
+	li	t1, DEV3_CTRL         	/* set the device control register for =
CS3*/=0A=
+	sw	t1, 0x38(t0)=0A=
+	li	t1, DEV3_TC           	/* set the device timing register for CS3 =
*/=0A=
+	sw	t1, 0x3C(t0) =0A=
+=0A=
+	li	t1, DEV4_BASE         	/* set the device base register for CS4   =
*/=0A=
+	sw	t1, 0x40(t0)=0A=
+	li	t1, DEV4_MASK         	/* set the device mask register for CS4   =
*/=0A=
+	sw	t1, 0x44(t0) =0A=
+	li	t1, DEV4_CTRL         	/* set the device control register for =
CS4*/=0A=
+	sw	t1, 0x48(t0)=0A=
+	li	t1, DEV4_TC           	/* set the device timing register for CS4 =
*/=0A=
+	sw	t1, 0x4C(t0) =0A=
+=0A=
+	li	t1, DEV5_BASE         	/* set the device base register for CS5   =
*/=0A=
+	sw	t1, 0x50(t0)=0A=
+	li	t1, DEV5_MASK         	/* set the device mask register for CS5   =
*/=0A=
+	sw	t1, 0x54(t0) =0A=
+	li	t1, DEV5_CTRL         	/* set the device control register for =
CS5*/=0A=
+	sw	t1, 0x58(t0)=0A=
+	li	t1, DEV5_TC		/* set the device timing register for CS5 */=0A=
+	sw	t1, 0x5C(t0)=0A=
+=0A=
+/* ------------------ Initialize GPIO =
------------------------------------- */=0A=
+	li	t0, GPIO_BASE=0A=
+	li	t1, GPIO_FUNC=0A=
+	sw	t1, 0x0(t0)=0A=
+  	li	t1, GPIO_CFG=0A=
+	sw	t1, 0x4(t0)=0A=
+  	li	t1, GPIO_OUT=0A=
+	sw	t1, 0x8(t0)=0A=
+=0A=
+/* ------------- Clear PCI Local Base Control registers =
------------------- */=0A=
+	li    t0, 0xb8068000=0A=
+	sw    zero, 0x18(t0)=0A=
+	sw    zero, 0x24(t0)=0A=
+	sw    zero, 0x30(t0)=0A=
+	sw    zero, 0x3c(t0)=0A=
+/* ------------------- Assert PCI reset =
----------------------------------- */=0A=
+	lw    t1, (t0)=0A=
+	andi  t2, t1, 0x1=0A=
+	beqz  t2, 2f=0A=
+	      nop=0A=
+	andi  t2, t1, 0x3fe=0A=
+	sw    t2, (t0)=0A=
+	li    t2, 0x1000=0A=
+1:=0A=
+	addi  t2, -1=0A=
+	bnez  t2, 1b=0A=
+	      nop=0A=
+2:=0A=
+	ori   t2, t1, 0x1=0A=
+	sw    t2, (t0)=0A=
+	lui   t2, 0x2=0A=
+rip:=0A=
+	lw    t1, 4(t0)=0A=
+	and   t1, t1, t2=0A=
+	bnez  t1, rip=0A=
+	      nop=0A=
+=0A=
+	DISPLAY('I','S','D','R')=0A=
+=0A=
+	li	t0, SDRAM_BASE 		/* load t0 with internal registers' base address =
*/=0A=
+=0A=
+/*-------------- Initialize SDRAM Base and Mask Registers =
----------*/=0A=
+=0A=
+	li	t1, SDRAM_BNK0_BASE	/* load SDRAM bank 0 physical address in t1 =
*/=0A=
+	sw	t1, 0x0(t0)		/* set SDRAM bank 0 base */=0A=
+	li	t1, SDRAM_BNK1_BASE	/* load SDRAM bank 1 physical address in t1 =
*/=0A=
+	sw	t1, 0x8(t0)		/* set SDRAM bank 1 base */=0A=
+	li	t1, SDRAM_BNK0_ABASE	/* load Alternate SDRAM bank 0 physical =
address in t1 */=0A=
+	sw	t1, 0x20(t0)		/* set Alternate SDRAM bank 0 base */=0A=
+=0A=
+	li	t1, SDRAM_BNK0_MASK	/* load SDRAM bank 0 size in t1 */=0A=
+	sw	t1, 0x4(t0)		/* set SDRAM bank 0 mask */=0A=
+	li	t1, SDRAM_BNK1_MASK	/* load SDRAM bank 1 size in t1 */=0A=
+	sw	t1, 0xC(t0)		/* set SDRAM bank 1 mask */=0A=
+	li	t1, SDRAM_BNK0_AMASK	/* load Alternate SDRAM bank 0 size in t1 =
*/=0A=
+	sw	t1, 0x24(t0)		/* set Alternate SDRAM bank 0 mask */=0A=
+=0A=
+/*-------------- Setup and Enable Refresh Timer =
--------------------*/=0A=
+	li	t1, DISABLE_TIMER 	/* load diable timer bit settings into t1 */=0A=
+	sw	t1, 0x1C(t0)    		/* disable timer */=0A=
+        nop=0A=
+=0A=
+/*-------------- Enable SDRAM Controller =
---------------------------*/=0A=
+	li	t1, SDRAM_CR_BS=0A=
+	sw	t1, 0x10(t0)=0A=
+        nop=0A=
+          =0A=
+/*-------------- Delay Loop =
----------------------------------------*/=0A=
+	li	v0, 10000 /* 8x256us */=0A=
+1:  =0A=
+	bne	v0, zero,1b=0A=
+	subu	v0, 1   /* BDSLOT  */=0A=
+        nop=0A=
+        nop=0A=
+/*-------------- Setup Precharge Command =
---------------------------*/=0A=
+	li	t2, 2=0A=
+	li	t3, 0=0A=
+1:  =0A=
+	li	t1, SDRAM_PC_VAL=0A=
+	sw	t1, 0x10(t0)=0A=
+        nop=0A=
+        nop=0A=
+	lw	t7, 0x10(t0)=0A=
+        nop=0A=
+	li	t4, DATA_PATTERN=0A=
+	li	t5, 0xA0000000 | SDRAM_BNK0_BASE=0A=
+	sw	t4, 0x0(t5)=0A=
+	addu	t3, 1=0A=
+	bne	t3, t2, 1b=0A=
+        nop=0A=
+/*-------------- Setup Refresh Command =
-----------------------------*/=0A=
+	li	t2, 8=0A=
+	li	t3, 0=0A=
+1:  =0A=
+	li	t1, SDRAM_RFRSH_CMD=0A=
+	sw	t1, 0x10(t0)=0A=
+	sw	t4, 0x0(t5) 		/* note: t5 not disturbed */=0A=
+	addu	t3, 1=0A=
+	bne	t3, t2, 1b=0A=
+        nop=0A=
+/*-------------- Setup up to write to Mode Register =
----------------*/=0A=
+	li	t1, SDRAM_MODE_REG=0A=
+	sw	t1, 0x10(t0)=0A=
+	addu	t5, 0x80=0A=
+	sw	t4, 0x0(t5)=0A=
+=0A=
+/*-------------- Setup and Enable Refresh Timer =
--------------------*/=0A=
+=0A=
+	li	t1, DISABLE_TIMER   	/* load diable timer bit settings into t1 =
*/=0A=
+	sw	t1, 0x1c(t0)        	/* disable timer */=0A=
+	sw	zero, 0x14(t0)    	/* set SDRAM refresh timer count register bit =
settings */=0A=
+=0A=
+	li	t1, SDRAM_RF_CMPR_SE_BS   /* load SDRAM refresh timer compare =
register bit settings in t1 */=0A=
+	sw	t1, 0x18(t0)    		/* set SDRAM refresh timer compare register bit =
settings */=0A=
+=0A=
+	li	t1, ENABLE_TIMER    	/* load timer enable bit */=0A=
+	sw	t1, 0x1c(t0)    		/* enable refresh timer */=0A=
+=0A=
+	li	t1, SDRAM_CR_BS=0A=
+	sw	t1, 0x10(t0)=0A=
+=0A=
+  /* the memory system may need some time to start up... */=0A=
+	li	v0, 10000 		/* 8x256us */=0A=
+1:  =0A=
+	bne	v0, zero, 1b=0A=
+	subu	v0, 1=0A=
+        nop=0A=
+        nop=0A=
+=0A=
+/**********************************************************************=
**=0A=
+** before doing anything=0A=
+** initialize the section of memory used by cache initialization=0A=
+** whenever you boot out of ROM or reset-vector=0A=
+** This assumed to be 1MB.=0A=
+** --Sugan (11-22-96)=0A=
+***********************************************************************=
*/=0A=
+	=0A=
+	li	t0, 0xa0000000=0A=
+	li	t1, 0xa0100000=0A=
+1:=0A=
+	sw	zero, 0x00(t0)=0A=
+	sw	zero, 0x04(t0)=0A=
+	sw	zero, 0x08(t0)=0A=
+	sw	zero, 0x0c(t0)=0A=
+	addiu	t0, 16=0A=
+	nop=0A=
+	blt	t0, t1, 1b=0A=
+	nop=0A=
+	nop=0A=
+	nop=0A=
+3:=0A=
+	mfc0	t0, C0_SR=0A=
+	nop=0A=
+	nop=0A=
+	and	t0, ~SR_BEV=0A=
+	mtc0	t0, C0_SR=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+	DISPLAY('U','N','Z','P')=0A=
+=0A=
+/* Jump to zImage start */=0A=
+	=0A=
+	la      k0, zstartup=0A=
+	j       k0=0A=
+	nop=0A=
+	nop=0A=
+			=0A=
+ENDFRAME(start)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/head.S =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/head.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/head.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/head.S	2006-03-09 =
16:25:47.000000000 -0800=0A=
@@ -0,0 +1,134 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialisation code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/cacheops.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+#include <asm/regdef.h>=0A=
+=0A=
+#define IndexInvalidate_I       0x00=0A=
+=0A=
+	.set noreorder=0A=
+	.cprestore=0A=
+	LEAF(zstartup)=0A=
+zstartup:=0A=
+=0A=
+        la      sp, .stack=0A=
+	move	s0, a0=0A=
+	move	s1, a1=0A=
+	move	s2, a2=0A=
+	move	s3, a3=0A=
+=0A=
+	/* Clear BSS */=0A=
+	la	a0, .stack=0A=
+	la	a2, _end=0A=
+1:	sw	zero, 0(a0)=0A=
+	bne	a2, a0, 1b=0A=
+	addu	a0, 4=0A=
+#if 1=0A=
+	/* flush the I-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80002000  # end address (8KB I-Cache)=0A=
+	subu	k1, 128=0A=
+2:=0A=
+	.set mips3=0A=
+	cache	IndexInvalidate_I, 0(k0)=0A=
+	cache	IndexInvalidate_I, 16(k0)=0A=
+	cache	IndexInvalidate_I, 32(k0)=0A=
+	cache	IndexInvalidate_I, 48(k0)=0A=
+	cache	IndexInvalidate_I, 64(k0)=0A=
+	cache	IndexInvalidate_I, 80(k0)=0A=
+	cache	IndexInvalidate_I, 96(k0)=0A=
+	cache	IndexInvalidate_I, 112(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 2b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+#endif=0A=
+#if 1=0A=
+	/* flush the D-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80000400  # end address (2KB I-Cache)=0A=
+	subu	k1, 128=0A=
+3:	=0A=
+	.set mips3=0A=
+	/* First way */=0A=
+	cache	Index_Writeback_Inv_D, 0(k0)=0A=
+	cache	Index_Writeback_Inv_D, 16(k0)=0A=
+	cache	Index_Writeback_Inv_D, 32(k0)=0A=
+	cache	Index_Writeback_Inv_D, 48(k0)=0A=
+	cache	Index_Writeback_Inv_D, 64(k0)=0A=
+	cache	Index_Writeback_Inv_D, 80(k0)=0A=
+	cache	Index_Writeback_Inv_D, 96(k0)=0A=
+	cache	Index_Writeback_Inv_D, 112(k0)=0A=
+	/* Second way */=0A=
+	cache	Index_Writeback_Inv_D, 1024(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1040(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1056(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1072(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1088(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1104(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1120(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1136(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 3b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+#endif=0A=
+	=0A=
+=0A=
+	la	ra, 4f=0A=
+	la	k0, decompress_kernel=0A=
+	jr	k0=0A=
+	nop=0A=
+4:=0A=
+=0A=
+	move	a0, s0=0A=
+	move	a1, s1=0A=
+	move	a2, s2=0A=
+	move	a3, s3=0A=
+	li	k0, KERNEL_ENTRY=0A=
+	jr	k0=0A=
+	nop=0A=
+5:=0A=
+	b 5b=0A=
+	END(zstartup)=0A=
+=0A=
+	.bss=0A=
+	.fill 0x2000=0A=
+	EXPORT(.stack)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/idtcpu.h =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/idtcpu.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/idtcpu.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/idtcpu.h	=
2006-03-09 16:25:47.000000000 -0800=0A=
@@ -0,0 +1,614 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#if defined(__IDTCPU_H__)=0A=
+#else=0A=
+#define __IDTCPU_H__=0A=
+=0A=
+=0A=
+/*=0A=
+** memory configuration and mapping=0A=
+*/=0A=
+#define K0BASE	0x80000000=0A=
+#define K0SIZE	0x20000000=0A=
+#define K1BASE	0xa0000000=0A=
+#define K1SIZE	0x20000000=0A=
+#define K2BASE	0xc0000000=0A=
+#if defined(S364)=0A=
+#define K2SIZE	0x3e000000=0A=
+#define ICEBASE	0xff000000=0A=
+#define ICESIZE	0x01000000=0A=
+#else=0A=
+#define K2SIZE	0x20000000=0A=
+#endif=0A=
+#if defined(CPU_R4000)=0A=
+#define KSBASE	0xe0000000=0A=
+#define KSSIZE	0x20000000=0A=
+#endif=0A=
+=0A=
+#define KUBASE	0=0A=
+#define KUSIZE	0x80000000=0A=
+=0A=
+/*=0A=
+** Exception Vectors=0A=
+*/=0A=
+#if defined(CPU_R3000)=0A=
+#define	UT_VEC	K0BASE			/* utlbmiss vector */=0A=
+#define E_VEC	(K0BASE+0x80)		/* exception vevtor */=0A=
+#endif=0A=
+#if defined(CPU_R4000) || defined S364  /*(CPU_R32364)      */=0A=
+#define	T_VEC	(K0BASE+0x000)		/* tlbmiss vector */=0A=
+#define X_VEC	(K0BASE+0x080)		/* xtlbmiss vector */=0A=
+#define C_VEC	(K1BASE+0x100)		/* cache error vector */=0A=
+#define E_VEC	(K0BASE+0x180)		/* exception vector */=0A=
+#define I_VEC	(K0BASE+0X200)		/* interrupt vector */=0A=
+#endif=0A=
+#define	R_VEC	(K1BASE+0x1fc00000)	/* reset vector */=0A=
+=0A=
+/*=0A=
+** Address conversion macros=0A=
+*/=0A=
+#ifdef CLANGUAGE=0A=
+#define	CAST(as) (as)=0A=
+#else=0A=
+#define	CAST(as)=0A=
+#endif=0A=
+#define	K0_TO_K1(x)	(CAST(unsigned)(x)|0xA0000000)	/* kseg0 to kseg1 =
*/=0A=
+#define	K1_TO_K0(x)	(CAST(unsigned)(x)&0x9FFFFFFF)	/* kseg1 to kseg0 =
*/=0A=
+#define	K0_TO_PHYS(x)	(CAST(unsigned)(x)&0x1FFFFFFF)	/* kseg0 to =
physical */=0A=
+#define	K1_TO_PHYS(x)	(CAST(unsigned)(x)&0x1FFFFFFF)	/* kseg1 to =
physical */=0A=
+#define	PHYS_TO_K0(x)	(CAST(unsigned)(x)|0x80000000)	/* physical to =
kseg0 */=0A=
+#define	PHYS_TO_K1(x)	(CAST(unsigned)(x)|0xA0000000)	/* physical to =
kseg1 */=0A=
+=0A=
+/*=0A=
+**	Cache size constants=0A=
+*/=0A=
+/* Sugan changed so that MINCACHE is 0x200 instead of 0x800 */=0A=
+#define	MINCACHE	0x200		/* 512 bytes  */=0A=
+#define	MAXCACHE	0x40000		/* 256*1024   256k */	=0A=
+=0A=
+#if defined CPU_R32364                  /* Includes RC32364, RC32332, =
RC32334 */=0A=
+#define	CFG_ICE		0x80000000	/* ICE detect */=0A=
+#define	CFG_ECMASK	0x70000000	/* System Clock Ratio */=0A=
+#define	CFG_ECBY2	0x00000000 	/* divide by 2 */=0A=
+#define	CFG_ECBY3	0x10000000 	/* divide by 3 */=0A=
+#define	CFG_ECBY4	0x20000000 	/* divide by 4 */=0A=
+#define	CFG_NBL		0x00800000	/* Non-Blocking load pending */=0A=
+#define	CFG_BE		0x00008000	/* Big Endian */=0A=
+#define	CFG_ICMASK	0x00000e00	/* Instruction cache size */=0A=
+#define	CFG_ICSHIFT	9=0A=
+#define	CFG_DCMASK	0x000001c0	/* Data cache size */=0A=
+#define	CFG_DCSHIFT	6=0A=
+#define	CFG_IB		0x00000020	/* Instruction cache line size */=0A=
+#define	CFG_DB		0x00000010	/* Data cache line size */=0A=
+#define	CFG_K0MASK	0x00000007	/* KSEG0 coherency algorithm */=0A=
+=0A=
+/*=0A=
+ * R32364 primary cache mode=0A=
+ */=0A=
+#define CFG_C_NCHRNT_WT_NWA	0=0A=
+#define CFG_C_NCHRNT_WT		1=0A=
+#define CFG_C_UNCACHED		2=0A=
+#define CFG_C_NCHRNT_WB		3=0A=
+=0A=
+/* Cache Operations */=0A=
+#define Index_Invalidate_I               0x0         /* 0       0 =
*/=0A=
+#define Index_Writeback_Inv_D            0x1         /* 0       1 =
*/=0A=
+#define Index_Invalidate_SI              0x2         /* 0       2 =
*/=0A=
+#define Index_Writeback_Inv_SD           0x3         /* 0       3 =
*/=0A=
+#define Index_Load_Tag_I                 0x4         /* 1       0 =
*/=0A=
+#define Index_Load_Tag_D                 0x5         /* 1       1 =
*/=0A=
+#define Index_Load_Tag_SI                0x6         /* 1       2 =
*/=0A=
+#define Index_Load_Tag_SD                0x7         /* 1       3 =
*/=0A=
+#define Index_Store_Tag_I                0x8         /* 2       0 =
*/=0A=
+#define Index_Store_Tag_D                0x9         /* 2       1 =
*/=0A=
+#define Index_Store_Tag_SI               0xA         /* 2       2 =
*/=0A=
+#define Index_Store_Tag_SD               0xB         /* 2       3 =
*/=0A=
+#define Create_Dirty_Exc_D               0xD         /* 3       1 =
*/=0A=
+#define Create_Dirty_Exc_SD              0xF         /* 3       3 =
*/=0A=
+#define Hit_Invalidate_I                 0x10        /* 4       0 =
*/=0A=
+#define Hit_Invalidate_D                 0x11        /* 4       1 =
*/=0A=
+#define Hit_Invalidate_SI                0x12        /* 4       2 =
*/=0A=
+#define Hit_Invalidate_SD                0x13        /* 4       3 =
*/=0A=
+#define Hit_Writeback_Inv_D              0x15        /* 5       1 =
*/=0A=
+#define Hit_Writeback_Inv_SD             0x17        /* 5       3 =
*/=0A=
+#define Fill_I                           0x14        /* 5       0 =
*/=0A=
+#define Hit_Writeback_D                  0x19        /* 6       1 =
*/=0A=
+#define Hit_Writeback_SD                 0x1B        /* 6       3 =
*/=0A=
+#define Hit_Writeback_I                  0x18        /* 6       0 =
*/=0A=
+#define Hit_Set_Virtual_SI               0x1E        /* 7       2 =
*/=0A=
+#define Hit_Set_Virtual_SD               0x1F        /* 7       3 =
*/=0A=
+#define CFG_EW32        0x00040000      /* 32 bit */=0A=
+#endif /* CPU_R32364 */=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+/* R4000 configuration register definitions */=0A=
+#define CFG_CM		0x80000000	/* Master-Checker mode */=0A=
+#define CFG_ECMASK	0x70000000	/* System Clock Ratio */=0A=
+#define CFG_ECBY2	0x00000000 	/* divide by 2 */=0A=
+#define CFG_ECBY3	0x10000000 	/* divide by 3 */=0A=
+#define CFG_ECBY4	0x20000000 	/* divide by 4 */=0A=
+#define CFG_EPMASK	0x0f000000	/* Transmit data pattern */=0A=
+#define CFG_EPD		0x00000000	/* D */=0A=
+#define CFG_EPDDX	0x01000000	/* DDX */=0A=
+#define CFG_EPDDXX	0x02000000	/* DDXX */=0A=
+#define CFG_EPDXDX	0x03000000	/* DXDX */=0A=
+#define CFG_EPDDXXX	0x04000000	/* DDXXX */=0A=
+#define CFG_EPDDXXXX	0x05000000	/* DDXXXX */=0A=
+#define CFG_EPDXXDXX	0x06000000	/* DXXDXX */=0A=
+#define CFG_EPDDXXXXX	0x07000000	/* DDXXXXX */=0A=
+#define CFG_EPDXXXDXXX	0x08000000	/* DXXXDXXX */=0A=
+#define CFG_SBMASK	0x00c00000	/* Secondary cache block size */=0A=
+#define CFG_SBSHIFT	22=0A=
+#define CFG_SB4		0x00000000	/* 4 words */=0A=
+#define CFG_SB8		0x00400000	/* 8 words */=0A=
+#define CFG_SB16	0x00800000	/* 16 words */=0A=
+#define CFG_SB32	0x00c00000	/* 32 words */=0A=
+#define CFG_SS		0x00200000	/* Split secondary cache */=0A=
+#define CFG_SW		0x00100000	/* Secondary cache port width */=0A=
+#define CFG_EWMASK	0x000c0000	/* System port width */=0A=
+#define CFG_EWSHIFT	18=0A=
+#define CFG_EW64	0x00000000	/* 64 bit */=0A=
+#define CFG_EW32	0x00040000	/* 32 bit */=0A=
+/* #if defined(CPU_R5000) */=0A=
+/* Sugan added for R5000 L2 cache 07-17-96 */=0A=
+#define L2_PAGESIZE	0x1000=0A=
+#define SIZE256K	0x00040000 /* 256KB in Hex */=0A=
+#define CFG_HARDL2	0x00020000 /* Hardware bit that enables/disables=0A=
+				      L2 cache */=0A=
+#define CFG_SE		0x1000=0A=
+#define CFG_SIZE512K	0x00000000 /* size of Scache is 512k */=0A=
+#define CFG_SIZE1MB 	0x00100000 /* size of Scache is 1MB */=0A=
+#define CFG_SIZE2MB 	0x00200000 /* size of Scache is 2MB */=0A=
+#define CFG_SIZEMASK	0x00300000 /* size mask */=0A=
+/* #endif */=0A=
+#define CFG_SC		0x00020000	/* Secondary cache absent */=0A=
+#define CFG_SM		0x00010000	/* Dirty Shared mode disabled */=0A=
+#define CFG_BE		0x00008000	/* Big Endian */=0A=
+#define CFG_EM		0x00004000	/* ECC mode enable */=0A=
+#define CFG_EB		0x00002000	/* Block ordering */=0A=
+#define CFG_ICMASK	0x00000e00	/* Instruction cache size */=0A=
+#define CFG_ICSHIFT	9=0A=
+#define CFG_DCMASK	0x000001c0	/* Data cache size */=0A=
+#define CFG_DCSHIFT	6=0A=
+#define CFG_IB		0x00000020	/* Instruction cache block size */=0A=
+#define CFG_DB		0x00000010	/* Data cache block size */=0A=
+#define CFG_CU		0x00000008	/* Update on Store Conditional */=0A=
+#define CFG_K0MASK	0x00000007	/* KSEG0 coherency algorithm */=0A=
+=0A=
+/*=0A=
+ * R4000 primary cache mode=0A=
+ */=0A=
+#define CFG_C_WRITETHROUGH_CACHE		0=0A=
+#define CFG_C_UNCACHED		2=0A=
+#define CFG_C_NONCOHERENT	3=0A=
+#define CFG_C_COHERENTXCL	4=0A=
+#define CFG_C_COHERENTXCLW	5=0A=
+#define CFG_C_COHERENTUPD	6=0A=
+=0A=
+/*=0A=
+ * R4000 cache operations (should be in assembler...?)=0A=
+ */=0A=
+#if defined(CPU_R5000)=0A=
+#define InvAllScache			 0x03	     /* 0	3 */=0A=
+#define IndexLoadTagScache		 0x07	     /* 1	3 */=0A=
+#define IndexStoreTagScache		 0x0b	     /* 2	3 */=0A=
+#define PageInvScache			 0x17	     /* 5	3 */=0A=
+#endif=0A=
+#define Index_Invalidate_I               0x0         /* 0       0 =
*/=0A=
+#define Index_Writeback_Inv_D            0x1         /* 0       1 =
*/=0A=
+#define Index_Invalidate_SI              0x2         /* 0       2 =
*/=0A=
+#define Index_Writeback_Inv_SD           0x3         /* 0       3 =
*/=0A=
+#define Index_Load_Tag_I                 0x4         /* 1       0 =
*/=0A=
+#define Index_Load_Tag_D                 0x5         /* 1       1 =
*/=0A=
+#define Index_Load_Tag_SI                0x6         /* 1       2 =
*/=0A=
+#define Index_Load_Tag_SD                0x7         /* 1       3 =
*/=0A=
+#define Index_Store_Tag_I                0x8         /* 2       0 =
*/=0A=
+#define Index_Store_Tag_D                0x9         /* 2       1 =
*/=0A=
+#define Index_Store_Tag_SI               0xA         /* 2       2 =
*/=0A=
+#define Index_Store_Tag_SD               0xB         /* 2       3 =
*/=0A=
+#define Create_Dirty_Exc_D               0xD         /* 3       1 =
*/=0A=
+#define Create_Dirty_Exc_SD              0xF         /* 3       3 =
*/=0A=
+#define Hit_Invalidate_I                 0x10        /* 4       0 =
*/=0A=
+#define Hit_Invalidate_D                 0x11        /* 4       1 =
*/=0A=
+#define Hit_Invalidate_SI                0x12        /* 4       2 =
*/=0A=
+#define Hit_Invalidate_SD                0x13        /* 4       3 =
*/=0A=
+#define Hit_Writeback_Inv_D              0x15        /* 5       1 =
*/=0A=
+#define Hit_Writeback_Inv_SD             0x17        /* 5       3 =
*/=0A=
+#define Fill_I                           0x14        /* 5       0 =
*/=0A=
+#define Hit_Writeback_D                  0x19        /* 6       1 =
*/=0A=
+#define Hit_Writeback_SD                 0x1B        /* 6       3 =
*/=0A=
+#define Hit_Writeback_I                  0x18        /* 6       0 =
*/=0A=
+#define Hit_Set_Virtual_SI               0x1E        /* 7       2 =
*/=0A=
+#define Hit_Set_Virtual_SD               0x1F        /* 7       3 =
*/=0A=
+=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** TLB resource defines=0A=
+*/=0A=
+=0A=
+#if defined(CPU_R32364)  =0A=
+#define	N_TLB_ENTRIES	16=0A=
+#endif =0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+#define N_TLB_ENTRIES  48=0A=
+#endif=0A=
+=0A=
+#if defined (CPU_R32364)=0A=
+#define	TLBHI_VPN2MASK	0xffffe000=0A=
+#define	TLBHI_PIDMASK	0x000000ff=0A=
+#define	TLBHI_NPID	256=0A=
+=0A=
+#define	TLBLO_PFNMASK	0x03ffffc0=0A=
+#define	TLBLO_PFNSHIFT	6=0A=
+#define	TLBLO_D		0x00000004	/* writeable */=0A=
+#define	TLBLO_V		0x00000002	/* valid bit */=0A=
+#define	TLBLO_G		0x00000001	/* global access bit */=0A=
+#define	TLBLO_CMASK	0x00000038	/* cache algorithm mask */=0A=
+#define	TLBLO_CSHIFT	3=0A=
+=0A=
+#define	TLBLO_UNCACHED		(CFG_C_UNCACHED<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WT_NWA	(CFG_C_NCHRNT_WT_NWA<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WT		(CFG_C_NCHRNT_WT<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WB		(CFG_C_NCHRNT_WB<<TLBLO_CSHIFT)=0A=
+=0A=
+#elif defined(CPU_R4000)=0A=
+#define	TLBHI_VPN2MASK	0xffffe000=0A=
+#define	TLBHI_PIDMASK	0x000000ff=0A=
+#define	TLBHI_NPID	256=0A=
+=0A=
+#define	TLBLO_PFNMASK	0x3fffffc0=0A=
+#define	TLBLO_PFNSHIFT	6=0A=
+#define	TLBLO_D		0x00000004	/* writeable */=0A=
+#define	TLBLO_V		0x00000002	/* valid bit */=0A=
+#define	TLBLO_G		0x00000001	/* global access bit */=0A=
+#define	TLBLO_CMASK	0x00000038	/* cache algorithm mask */=0A=
+#define	TLBLO_CSHIFT	3=0A=
+=0A=
+#define	TLBLO_UNCACHED		(CFG_C_UNCACHED<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NONCOHERENT	(CFG_C_NONCOHERENT<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTXCL	(CFG_C_COHERENTXCL<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTXCLW	(CFG_C_COHERENTXCLW<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTUPD	(CFG_C_COHERENTUPD<<TLBLO_CSHIFT)=0A=
+#endif=0A=
+#if defined(CPU_R4000)||defined(S364)=0A=
+#define	TLBINX_PROBE	0x80000000=0A=
+#define	TLBINX_INXMASK	0x0000003f=0A=
+=0A=
+#define	TLBRAND_RANDMASK	0x0000003f=0A=
+=0A=
+#define	TLBCTXT_BASEMASK	0xff800000=0A=
+#define	TLBCTXT_BASESHIFT	23=0A=
+=0A=
+#define	TLBCTXT_VPN2MASK	0x007ffff0=0A=
+#define	TLBCTXT_VPN2SHIFT	4=0A=
+=0A=
+#define	TLBPGMASK_MASK		0x01ffe000=0A=
+#endif=0A=
+=0A=
+#define	SR_PE		0x00100000	/* cache parity error */=0A=
+#if defined(CPU_R3000)=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* use boot exception vectors */=0A=
+=0A=
+/* Cache control bits */=0A=
+#define	SR_TS		0x00200000	/* TLB shutdown */=0A=
+#define	SR_CM		0x00080000	/* cache miss */=0A=
+#define	SR_PZ		0x00040000	/* cache parity zero */=0A=
+#define	SR_SWC		0x00020000	/* swap cache */=0A=
+#define	SR_ISC		0x00010000	/* Isolate data cache */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KUO		0x00000020	/* old kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEO		0x00000010	/* old interrupt enable, 1 =3D> enable =
*/=0A=
+#define	SR_KUP		0x00000008	/* prev kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEP		0x00000004	/* prev interrupt enable, 1 =3D> enable =
*/=0A=
+#define	SR_KUC		0x00000002	/* cur kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEC		0x00000001	/* cur interrupt enable, 1 =3D> enable =
*/=0A=
+#endif=0A=
+=0A=
+#if defined S364                        /* (CPU_R32364)        */=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+/* defines for R32364 processor */=0A=
+#define	SR_NBL		0x08000000	/* Non Blocking Load */=0A=
+#define	SR_RE		0X02000000	/* Reverse Endianness */=0A=
+#define	SR_DL		0x01000000	/* Data Cache Locking */=0A=
+#define	SR_IL		0x00800000	/* Instruction Cache Locking */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_SR		0x00100000	/* Soft reset */=0A=
+#define	SR_CH		0x00040000	/* Cache hit */=0A=
+#define	SR_CE		0x00020000	/* Use cache ECC  */=0A=
+#define	SR_DE		0x00010000	/* Disable cache exceptions */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KSMASK	0x00000016	/* Kernel mode mask */=0A=
+#define	SR_KSUSER	0x00000000	/* User Mode */=0A=
+#define	SR_KSKERNEL	0x00000016	/* Kernel Mode */=0A=
+=0A=
+#define	SR_ERL		0x00000004	/* Error level */=0A=
+#define	SR_EXL		0x00000002	/* Exception level */=0A=
+#define	SR_IE		0x00000001	/* Interrupts enabled */=0A=
+#define	NOT_SR_IEC      0xfffffffe      /* assembler problem with =
li=0A=
+~SR_IEC */=0A=
+=0A=
+/* R32364 Cache locking bits */=0A=
+#define SR_ICACHELOCK 0x00800000=0A=
+#define SR_DCACHELOCK 0x01000000=0A=
+=0A=
+#endif /* CPU_R32364 */=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+#define	SR_RP		0x08000000      /* Reduced power operation */=0A=
+#define	SR_FR		0x04000000	/* Additional floating pt registers */=0A=
+#define	SR_RE		0x02000000	/* Reverse endian in user mode */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_TS		0x00200000	/* TLB shutdown */=0A=
+#define	SR_SR		0x00100000	/* Soft reset */=0A=
+#define	SR_CH		0x00040000	/* Cache hit */=0A=
+#define	SR_CE		0x00020000	/* Use cache ECC  */=0A=
+#define	SR_DE		0x00010000	/* Disable cache exceptions */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KSMASK	0x00000018	/* Kernel mode mask */=0A=
+#define	SR_KSUSER	0x00000010	/* User mode */=0A=
+#define	SR_KSSUPER	0x00000008	/* Supervisor mode */=0A=
+#define	SR_KSKERNEL	0x00000000	/* Kernel mode */=0A=
+#define	SR_ERL		0x00000004	/* Error level */=0A=
+#define	SR_EXL		0x00000002	/* Exception level */=0A=
+#define	SR_IE		0x00000001	/* Interrupts enabled */=0A=
+=0A=
+/* R4650 Cache locking bits */=0A=
+#define	SR_ICACHELOCK 0x00800000=0A=
+#define	SR_DCACHELOCK 0x01000000=0A=
+=0A=
+=0A=
+#endif=0A=
+#if defined(CPU_R3000)=0A=
+#define	SR_FR		0x04000000	/* Additional floating point registers */=0A=
+#endif=0A=
+=0A=
+=0A=
+=0A=
+/*=0A=
+ * Cause Register=0A=
+ */=0A=
+#define	CAUSE_BD	0x80000000	/* Branch delay slot */=0A=
+#define	CAUSE_CEMASK	0x30000000	/* coprocessor error */=0A=
+#define	CAUSE_CESHIFT	28=0A=
+#define	CAUSE_IW	0x01000000	/* Instruction watch */=0A=
+#define	CAUSE_DW	0x02000000	/* Data watch */=0A=
+#define	CAUSE_IPE	0x04000000	/* Imprecise exception */=0A=
+=0A=
+=0A=
+#define	CAUSE_IPMASK	0x0000FF00	/* Pending interrupt mask */=0A=
+#define	CAUSE_IPSHIFT	8=0A=
+=0A=
+/* Notice: Watch Exception if Exc. Code is 23 is not included in the =
mask=0A=
+ *	   for R32364.=0A=
+ */=0A=
+#define	CAUSE_EXCMASK	0x0000003C	/* Cause code bits */=0A=
+#define	CAUSE_EXCSHIFT	2=0A=
+=0A=
+#ifndef XDS=0A=
+/*=0A=
+**  Coprocessor 0 registers=0A=
+*/=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3 	*/=0A=
+#define C0_IBASE        $0		/* I base */=0A=
+#define C0_IBOUND       $1		/* I bound */=0A=
+=0A=
+#define	C0_INX			$0		/* tlb index */=0A=
+#define	C0_RAND			$1		/* tlb random */=0A=
+#if defined(CPU_R3000)=0A=
+#define	C0_TLBLO	$2				/* tlb entry low */=0A=
+#define	C0_BUSCTRL		$2		/* bus control R3041 specific */=0A=
+#define	C0_CONFIG		$3		/* cache config */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* count R3041 specific */=0A=
+#define	C0_PORTSIZE		$10	/* port size R3041 specific */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* compare R3041 specific */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#endif=0A=
+=0A=
+#if defined(S364)					/*(CPU_R32364)      */=0A=
+#define	C0_RANDOM		$1=0A=
+#define	C0_TLBLO0		$2		/* tlb entry low 0 */=0A=
+#define	C0_TLBLO1		$3		/* tlb entry low 1 */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_PAGEMASK		$5		/* tlb page mask */=0A=
+#define	C0_WIRED			$6		/* number of wired tlb entries */=0A=
+=0A=
+#define	C0_INX			$0		/* tlb index */=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* timer count */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* timer comparator  */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#define	C0_CONFIG		$16	/* configuration register */=0A=
+=0A=
+#define	C0_IWATCH		$18	/* Instr brk pt Virtual add. */=0A=
+#define	C0_DWATCH		$19	/* Data brk pt Virtual add. */=0A=
+=0A=
+#define	C0_IEPC			$22	/* Imprecise Exception pc */=0A=
+#define	C0_DEPC			$23	/* Debug Exception pc */=0A=
+#define	C0_DEBUG			$24	/* Debug control/status reg */=0A=
+=0A=
+#define	C0_ECC			$26	/* primary cache Parity control */=0A=
+#define	C0_CACHEERR		$27	/* cache error status */=0A=
+#define	C0_TAGLO			$28	/* cache tag lo */=0A=
+#define	C0_TAGHI			$29=0A=
+#define	C0_ERRPC			$30	/* cache error pc */=0A=
+#endif /* CPU_R32364 			*/=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3 	*/=0A=
+#define	C0_DBASE			$2		/* D base */=0A=
+#define	C0_DBOUND		$3		/* D bound */=0A=
+=0A=
+#define	C0_TLBLO0		$2		/* tlb entry low 0 */=0A=
+#define	C0_TLBLO1		$3		/* tlb entry low 1 */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_PAGEMASK		$5		/* tlb page mask */=0A=
+#define	C0_WIRED			$6		/* number of wired tlb entries */=0A=
+=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* cycle count */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* cyccle count comparator  */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#define	C0_CONFIG		$16	/* configuration register */=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3   */=0A=
+#define	C0_CALG			$17	/* Calg rigister */=0A=
+#define	C0_IWATCH		$18	/* IWatch register */=0A=
+#define	C0_DWATCH		$19	/* DWatch register */=0A=
+=0A=
+#define	C0_LLADDR		$17	/* linked load address */=0A=
+#define	C0_WATCHLO		$18	/* watchpoint trap register */=0A=
+#define	C0_WATCHHI		$19	/* watchpoint trap register */=0A=
+#define	C0_XCTXT			$20 	/* extended tlb context */=0A=
+#define	C0_ECC			$26	/* secondary cache ECC control */=0A=
+#define	C0_CACHEERR		$27	/* cache error status */=0A=
+#define	C0_TAGLO			$28	/* cache tag lo */=0A=
+#define	C0_TAGHI			$29	/* cache tag hi */=0A=
+#define	C0_ERRPC			$30	/* cache error pc */=0A=
+#endif=0A=
+#endif =0A=
+#endif /* defined(__IDTCPU_H__) */=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/idthdr.h =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/idthdr.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/idthdr.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/idthdr.h	=
2006-03-09 16:25:47.000000000 -0800=0A=
@@ -0,0 +1,54 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Some macros. Though they are already defined else where in the =
linux=0A=
+ *   tree, they are once again declared here for the ease of syncing =
up with=0A=
+ *    IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef XDS=0A=
+=0A=
+#define	FRAME(name,frm_reg,offset,ret_reg)	\=0A=
+	.globl	name;				\=0A=
+	.ent	name;				\=0A=
+name:;						\=0A=
+	.frame	frm_reg,offset,ret_reg=0A=
+=0A=
+#define ENDFRAME(name) 	.end name=0A=
+=0A=
+#else=0A=
+=0A=
+#define FRAME(name,frm_reg,offset,ret_reg)      \=0A=
+name:=0A=
+=0A=
+#define ENDFRAME(name)=0A=
+=0A=
+#endif=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/image.lds.in =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/image.lds.in=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/image.lds.in	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/image.lds.in	=
2006-03-09 16:25:47.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D IMSTART;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/EB365/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D BSS_START;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/iregdef.h =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/iregdef.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/iregdef.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/iregdef.h	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,285 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#define r0	$0=0A=
+#define r1	$1 /*at assembler temp */=0A=
+#define r2	$2 /*v0 return value */=0A=
+#define r3	$3 /*v1 return value */=0A=
+#define r4	$4 /*a0 argument 0 */=0A=
+#define r5	$5 /*a1 argument 1 */=0A=
+#define r6	$6=0A=
+#define r7	$7=0A=
+#define r8	$8=0A=
+#define r9	$9=0A=
+#define r10	$10=0A=
+#define r11	$11=0A=
+#define r12	$12=0A=
+#define r13	$13=0A=
+=0A=
+#define r14	$14=0A=
+#define r15	$15=0A=
+#define r16	$16 /*s0 called saved */=0A=
+#define r17	$17=0A=
+#define r18	$18=0A=
+#define r19	$19=0A=
+#define r20	$20=0A=
+#define r21	$21=0A=
+#define r22	$22=0A=
+#define r23	$23 /*s7 called saved */=0A=
+#define r24	$24=0A=
+#define r25	$25=0A=
+#define r26	$26 /*k0 kernel temp. */=0A=
+#define r27	$27 /*k1   ""    ""   */=0A=
+#define r28	$28 /*gp global pointer */=0A=
+#define r29	$29 /*sp stack pointer */=0A=
+#define r30	$30 /*fp frame pointer */=0A=
+#define r31	$31 /*ra return address */=0A=
+=0A=
+#define fp0	$f0=0A=
+#define fp1	$f1=0A=
+#define fp2	$f2=0A=
+#define fp3	$f3=0A=
+#define fp4	$f4=0A=
+#define fp5	$f5=0A=
+#define fp6	$f6=0A=
+#define fp7	$f7=0A=
+#define fp8	$f8=0A=
+#define fp9	$f9=0A=
+#define fp10	$f10=0A=
+#define fp11	$f11=0A=
+#define fp12	$f12=0A=
+#define fp13	$f13=0A=
+#define fp14	$f14=0A=
+#define fp15	$f15=0A=
+#define fp16	$f16=0A=
+#define fp17	$f17=0A=
+#define fp18	$f18=0A=
+#define fp19	$f19=0A=
+#define fp20	$f20=0A=
+#define fp21	$f21=0A=
+#define fp22	$f22=0A=
+#define fp23	$f23=0A=
+#define fp24	$f24=0A=
+#define fp25	$f25=0A=
+#define fp26	$f26=0A=
+#define fp27	$f27=0A=
+#define fp28	$f28=0A=
+#define fp29	$f29=0A=
+#define fp30	$f30=0A=
+#define fp31	$f31=0A=
+=0A=
+#define fcr0	$0=0A=
+#define fcr30	$30=0A=
+#define fcr31	$31=0A=
+=0A=
+#define zero	$0	/* wired zero */=0A=
+#define AT	$at	/* assembler temp */=0A=
+#define v0	$2	/* return value */=0A=
+#define v1	$3=0A=
+#define a0	$4	/* argument registers */=0A=
+#define a1	$5=0A=
+#define a2	$6=0A=
+#define a3	$7=0A=
+#define t0	$8	/* caller saved */=0A=
+#define t1	$9=0A=
+#define t2	$10=0A=
+#define t3	$11=0A=
+#define t4	$12=0A=
+#define t5	$13=0A=
+#define t6	$14=0A=
+#define t7	$15=0A=
+#define s0	$16	/* callee saved */=0A=
+#define s1	$17=0A=
+#define s2	$18=0A=
+#define s3	$19=0A=
+#define s4	$20=0A=
+#define s5	$21=0A=
+#define s6	$22=0A=
+#define s7	$23=0A=
+#define t8	$24	/* code generator */=0A=
+#define t9	$25=0A=
+#define k0	$26	/* kernel temporary */=0A=
+#define k1	$27=0A=
+#define gp	$28	/* global pointer */=0A=
+#define sp	$29	/* stack pointer */=0A=
+#define s8	$30	/* yet another saved reg for the callee */=0A=
+#define fp	$30	/* frame pointer - this is being phased out by MIPS =
*/=0A=
+#define ra	$31	/* return address */=0A=
+=0A=
+=0A=
+/*=0A=
+ * register names=0A=
+ */=0A=
+#define	R_R0		0=0A=
+#define	R_R1		1=0A=
+#define	R_R2		2=0A=
+#define	R_R3		3=0A=
+#define	R_R4		4=0A=
+#define	R_R5		5=0A=
+#define	R_R6		6=0A=
+#define	R_R7		7=0A=
+#define	R_R8		8=0A=
+#define	R_R9		9=0A=
+#define	R_R10		10=0A=
+#define	R_R11		11=0A=
+#define	R_R12		12=0A=
+#define	R_R13		13=0A=
+#define	R_R14		14=0A=
+#define	R_R15		15=0A=
+#define	R_R16		16=0A=
+#define	R_R17		17=0A=
+#define	R_R18		18=0A=
+#define	R_R19		19=0A=
+#define	R_R20		20=0A=
+#define	R_R21		21=0A=
+#define	R_R22		22=0A=
+#define	R_R23		23=0A=
+#define	R_R24		24=0A=
+#define	R_R25		25=0A=
+#define	R_R26		26=0A=
+#define	R_R27		27=0A=
+#define	R_R28		28=0A=
+#define	R_R29		29=0A=
+#define	R_R30		30=0A=
+#define	R_R31		31=0A=
+#define	R_F0		32=0A=
+#define	R_F1		33=0A=
+#define	R_F2		34=0A=
+#define	R_F3		35=0A=
+#define	R_F4		36=0A=
+#define	R_F5		37=0A=
+#define	R_F6		38=0A=
+#define	R_F7		39=0A=
+#define	R_F8		40=0A=
+#define	R_F9		41=0A=
+#define	R_F10		42=0A=
+#define	R_F11		43=0A=
+#define	R_F12		44=0A=
+#define	R_F13		45=0A=
+#define	R_F14		46=0A=
+#define	R_F15		47=0A=
+#define	R_F16		48=0A=
+#define	R_F17		49=0A=
+#define	R_F18		50=0A=
+#define	R_F19		51=0A=
+#define	R_F20		52=0A=
+#define	R_F21		53=0A=
+#define	R_F22		54=0A=
+#define	R_F23		55=0A=
+#define	R_F24		56=0A=
+#define	R_F25		57=0A=
+#define	R_F26		58=0A=
+#define	R_F27		59=0A=
+#define	R_F28		60=0A=
+#define	R_F29		61=0A=
+#define	R_F30		62=0A=
+#define	R_F31		63=0A=
+#define NCLIENTREGS	64=0A=
+#define	R_EPC		64=0A=
+#define	R_MDHI		65=0A=
+#define	R_MDLO		66=0A=
+#define	R_SR		67=0A=
+#define	R_CAUSE		68=0A=
+#define	R_TLBHI		69=0A=
+#ifdef CPU_R4000=0A=
+#define	R_TLBLO0	70=0A=
+#else=0A=
+#define	R_TLBLO		70=0A=
+#endif=0A=
+#define	R_BADVADDR	71=0A=
+#define	R_INX		72=0A=
+#define	R_RAND		73=0A=
+#define	R_CTXT		74=0A=
+#define	R_EXCTYPE	75=0A=
+#define R_MODE		76=0A=
+#define	R_PRID		77=0A=
+#define R_FCSR		78=0A=
+#define R_FEIR		79=0A=
+#ifdef CPU_R4000=0A=
+#define	R_TLBLO1	80=0A=
+#define R_PAGEMASK	81=0A=
+#define R_WIRED		82=0A=
+#define R_COUNT		83=0A=
+#define R_COMPARE	84=0A=
+#define R_CONFIG	85=0A=
+#define R_LLADDR	86=0A=
+#define R_WATCHLO	87=0A=
+#define R_WATCHHI	88=0A=
+#define R_ECC		89=0A=
+#define R_CACHEERR	90=0A=
+#define R_TAGLO		91=0A=
+#define R_TAGHI		92=0A=
+#define R_ERRPC		93=0A=
+#endif=0A=
+=0A=
+#ifdef CPU_R4000=0A=
+#define	NREGS		94=0A=
+#else=0A=
+#define NREGS		80=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * compiler defined bindings=0A=
+ */=0A=
+#define	R_ZERO		R_R0=0A=
+#define	R_AT		R_R1=0A=
+#define	R_V0		R_R2=0A=
+#define	R_V1		R_R3=0A=
+#define	R_A0		R_R4=0A=
+#define	R_A1		R_R5=0A=
+#define	R_A2		R_R6=0A=
+#define	R_A3		R_R7=0A=
+#define	R_T0		R_R8=0A=
+#define	R_T1		R_R9=0A=
+#define	R_T2		R_R10=0A=
+#define	R_T3		R_R11=0A=
+#define	R_T4		R_R12=0A=
+#define	R_T5		R_R13=0A=
+#define	R_T6		R_R14=0A=
+#define	R_T7		R_R15=0A=
+#define	R_S0		R_R16=0A=
+#define	R_S1		R_R17=0A=
+#define	R_S2		R_R18=0A=
+#define	R_S3		R_R19=0A=
+#define	R_S4		R_R20=0A=
+#define	R_S5		R_R21=0A=
+#define	R_S6		R_R22=0A=
+#define	R_S7		R_R23=0A=
+#define	R_T8		R_R24=0A=
+#define	R_T9		R_R25=0A=
+#define	R_K0		R_R26=0A=
+#define	R_K1		R_R27=0A=
+#define	R_GP		R_R28=0A=
+#define	R_SP		R_R29=0A=
+#define	R_FP		R_R30=0A=
+#define	R_RA		R_R31=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/Makefile	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,126 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile create a compressed zImage or Rommable rImage=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+#######################################################################=
########=0A=
+# The following is taken from IDT/Sim Makefile=0A=
+#######################################################################=
######=0A=
+TARGET=3D365=0A=
+=0A=
+# following refers to size of the DRAM space.=0A=
+# These are values for the switch DRAMSZ.=0A=
+=0A=
+MB16=3D1=0A=
+MB32=3D2=0A=
+MB64=3D3=0A=
+MB128=3D4=0A=
+MB32SO=3D5=0A=
+=0A=
+MACH=3D -DS$(TARGET) -DEB365 -DS364 -DCPU_R32364 =
-DDRAMSZ=3D$(MB32SO)=0A=
+COMMSWITCHES =3D $(INCDIRS) $(MACH)=0A=
+#***************** END IDT/Sim Makefile =
#####################################=0A=
+ZDEBUG=3D1=0A=
+export ZDEBUG=0A=
+=0A=
+# working space for gunzip:=0A=
+FREE_RAM      :=3D 0x80C00000=0A=
+END_RAM       :=3D 0x80E00000=0A=
+=0A=
+KERNELCONFIG  :=3D $(TOPDIR)/.config=0A=
+include $(KERNELCONFIG)=0A=
+=0A=
+SIZE =3D $(CROSS_COMPILE)size=0A=
+=0A=
+O_FORMAT =3D $(shell $(OBJDUMP) -i | head -2 | grep elf32)=0A=
+=0A=
+SYSTEM	      :=3D $(TOPDIR)/vmlinux=0A=
+ZBSS          :=3D 0x800A0000=0A=
+=0A=
+ZIMSTART      :=3D $(CONFIG_IDT_ZIMAGE_ADDR)=0A=
+RIMSTART      :=3D 0x9FC00000=0A=
+=0A=
+LOADADDR      :=3D 0x$(shell $(NM) $(SYSTEM) | grep "A _text" |cut -f1 =
-d' ')=0A=
+KERNEL_ENTRY  :=3D $(shell $(OBJDUMP) -f $(SYSTEM) | sed -n -e =
's/^start address //p')=0A=
+=0A=
+#######################################################################=
#############=0A=
+ZIMFLAGS        =3D s/IMSTART/$(ZIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+RIMFLAGS        =3D s/IMSTART/$(RIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+CFLAGS	:=3D -fno-pic -nostdinc -G 0 -mno-abicalls -fno-pic -pipe =
-I$(TOPDIR)/include=0A=
+AFLAGS	:=3D -D__ASSEMBLY__ $(CFLAGS)=0A=
+=0A=
+#######################################################################=
#############=0A=
+OBJECTS=3D $(obj)/piggy.o $(obj)/head.o $(obj)/misc.o=0A=
+ifneq ($(ZDEBUG),0)=0A=
+OBJECTS +=3D $(obj)/uart16550.o=0A=
+endif=0A=
+=0A=
+$(obj)/zImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(ZIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/rImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(RIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/piggy.o: $(SYSTEM) $(obj)/Makefile=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(SYSTEM) =
$(SYSTEM).bin=0A=
+	gzip -f -9 < $(SYSTEM).bin > $(SYSTEM).gz=0A=
+	echo "O_FORMAT:  " $(O_FORMAT); =0A=
+	$(LD) -r -b binary --oformat $(O_FORMAT) -o $(obj)/piggy.o =
$(SYSTEM).gz=0A=
+	rm -f $(SYSTEM).bin $(SYSTEM).gz=0A=
+=0A=
+$(obj)/head.o: $(obj)/head.S $(SYSTEM) $(obj)/Makefile=0A=
+	$(CC) $(AFLAGS) -DKERNEL_ENTRY=3D$(KERNEL_ENTRY) -c $(obj)/head.S -o =
$(obj)/head.o=0A=
+=0A=
+$(obj)/misc.o: $(obj)/misc.c $(obj)/Makefile=0A=
+	$(CC) $(CFLAGS) -DLOADADDR=3D$(LOADADDR) -DFREE_RAM=3D$(FREE_RAM) =
-DEND_RAM=3D$(END_RAM) \=0A=
+		-c $< -DZDEBUG=3D$(ZDEBUG) -o $(obj)/misc.o=0A=
+=0A=
+$(obj)/uart16550.o: $(obj)/uart16550.c $(KERNELCONFIG)=0A=
+	$(CC) $(CFLAGS) -c $< -o $(obj)/uart16550.o=0A=
+=0A=
+$(obj)/csu_idt.o: $(obj)/csu_idt.S Makefile $(SYSTEM)=0A=
+	$(CC) $(AFLAGS) $(COMMSWITCHES) -c $< -o $(obj)/csu_idt.o=0A=
+=0A=
+zImage: $(obj)/zImage.lds $(SYSTEM) $(OBJECTS)=0A=
+	$(LD) -T$(obj)/zImage.lds -o $(TOPDIR)/zImage $(OBJECTS)=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/zImage =
$(TOPDIR)/zImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/zImage.bin $(TOPDIR)/zImage.prm=0A=
+	$(SIZE) $(TOPDIR)/zImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/zImage.size=0A=
+	rm -f *.o=0A=
+=0A=
+rImage: $(obj)/rImage.lds $(OBJECTS) $(obj)/csu_idt.o $(SYSTEM)=0A=
+	@rm -f $(TOPDIR)/*.prm=0A=
+	$(LD) -T$(obj)/rImage.lds -o $(TOPDIR)/rImage $(obj)/csu_idt.o =
$(OBJECTS) =0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/rImage =
$(TOPDIR)/rImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/rImage.bin $(TOPDIR)/rImage.prm=0A=
+	$(SIZE) $(TOPDIR)/rImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/rImage.size=0A=
+	rm -f *.o=0A=
+clean:=0A=
+	rm -f *.o $(TOPDIR)/zImage $(TOPDIR)/rImage $(TOPDIR)/*.prm =
$(TOPDIR)/rImage.size $(TOPDIR)/zImage.size=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/misc.c idtlinux=
/arch/mips/idt-boards/rc32300/EB365/boot/misc.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/misc.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/misc.c	2006-03-09 =
16:25:47.000000000 -0800=0A=
@@ -0,0 +1,340 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Code to un-compress linux image=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/types.h>=0A=
+=0A=
+/*=0A=
+ * gzip declarations=0A=
+ */=0A=
+#define OF(args)  args=0A=
+#define STATIC static=0A=
+#define memzero(s, n)     memset ((s), 0, (n))=0A=
+typedef unsigned char uch;=0A=
+typedef unsigned short ush;=0A=
+typedef unsigned long ulg;=0A=
+#define WSIZE 0x8000		/* Window size must be at least 32k, */=0A=
+				/* and a power of two */=0A=
+static uch *inbuf;		/* input buffer */=0A=
+static uch window[WSIZE];	/* Sliding window buffer */=0A=
+=0A=
+/* gzip flag byte */=0A=
+#define ASCII_FLAG   0x01	/* bit 0 set: file probably ASCII text */=0A=
+#define CONTINUATION 0x02	/* bit 1 set: continuation of multi-part =
gzip file */=0A=
+#define EXTRA_FIELD  0x04	/* bit 2 set: extra field present */=0A=
+#define ORIG_NAME    0x08	/* bit 3 set: original file name present =
*/=0A=
+#define COMMENT      0x10	/* bit 4 set: file comment present */=0A=
+#define ENCRYPTED    0x20	/* bit 5 set: file is encrypted */=0A=
+#define RESERVED     0xC0	/* bit 6,7:   reserved */=0A=
+=0A=
+=0A=
+static unsigned insize;	/* valid bytes in inbuf */=0A=
+static unsigned inptr;	/* index of next byte to be processed in inbuf =
*/=0A=
+static unsigned outcnt;	/* bytes in output buffer */=0A=
+=0A=
+void variable_init(void);=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *);=0A=
+extern void putc_init(void);=0A=
+extern void putc(unsigned char c);=0A=
+#endif=0A=
+static int fill_inbuf(void);=0A=
+static void flush_window(void);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+extern char input_data[];=0A=
+=0A=
+extern char input_data_end[];=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void int2hex(unsigned long val)=0A=
+{=0A=
+        unsigned char buf[10];=0A=
+        int i;=0A=
+        for (i =3D 7;  i >=3D 0;  i--)=0A=
+        {=0A=
+                buf[i] =3D "0123456789ABCDEF"[val & 0x0F];=0A=
+                val >>=3D 4;=0A=
+        }=0A=
+        buf[8] =3D '\0';=0A=
+        puts(buf);=0A=
+}=0A=
+#endif=0A=
+=0A=
+static unsigned long byte_count;=0A=
+=0A=
+int get_byte(void)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	static int printCnt;=0A=
+#endif=0A=
+	unsigned char c =3D (inptr < insize ? inbuf[inptr++] : =
fill_inbuf());=0A=
+	byte_count++;=0A=
+=0A=
+#if ZDEBUG > 1=0A=
+	if (printCnt++ < 32)=0A=
+	{=0A=
+	  puts("byte count =3D ");=0A=
+	  int2hex(byte_count);=0A=
+	  puts(" byte val =3D ");=0A=
+	  int2hex(c);=0A=
+	  puts("\n");=0A=
+	}=0A=
+#endif=0A=
+	return c;=0A=
+}=0A=
+=0A=
+/* Diagnostic functions */=0A=
+#ifdef DEBUG=0A=
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}=0A=
+#  define Trace(x) fprintf x=0A=
+#  define Tracev(x) {if (verbose) fprintf x ;}=0A=
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}=0A=
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}=0A=
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}=0A=
+#else=0A=
+#  define Assert(cond,msg)=0A=
+#  define Trace(x)=0A=
+#  define Tracev(x)=0A=
+#  define Tracevv(x)=0A=
+#  define Tracec(c,x)=0A=
+#  define Tracecv(c,x)=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * This is set up by the setup-routine at boot-time=0A=
+ */=0A=
+=0A=
+static long bytes_out;=0A=
+static uch *output_data;=0A=
+static unsigned long output_ptr;=0A=
+=0A=
+=0A=
+static void *malloc(int size);=0A=
+static void free(void *where);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+static unsigned long free_mem_ptr;=0A=
+static unsigned long free_mem_end_ptr;=0A=
+=0A=
+#include "../../../../../../lib/inflate.c"=0A=
+=0A=
+static void *malloc(int size)=0A=
+{=0A=
+	void *p;=0A=
+=0A=
+	if (size < 0)=0A=
+		error("Malloc error\n");=0A=
+	if (free_mem_ptr <=3D 0) error("Memory error\n");=0A=
+=0A=
+	free_mem_ptr =3D (free_mem_ptr + 3) & ~3;	/* Align */=0A=
+=0A=
+	p =3D (void *) free_mem_ptr;=0A=
+	free_mem_ptr +=3D size;=0A=
+=0A=
+	if (free_mem_ptr >=3D free_mem_end_ptr)=0A=
+		error("\nOut of memory\n");=0A=
+=0A=
+	return p;=0A=
+}=0A=
+=0A=
+static void free(void *where)=0A=
+{				/* Don't care */=0A=
+}=0A=
+=0A=
+static void gzip_mark(void **ptr)=0A=
+{=0A=
+	*ptr =3D (void *) free_mem_ptr;=0A=
+}=0A=
+=0A=
+static void gzip_release(void **ptr)=0A=
+{=0A=
+	free_mem_ptr =3D (long) *ptr;=0A=
+}=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *s)=0A=
+{=0A=
+	while (*s) {=0A=
+		if (*s =3D=3D 10)=0A=
+			putc(13);=0A=
+		putc(*s++);=0A=
+	}=0A=
+}=0A=
+#endif=0A=
+void *memset(void *s, int c, size_t n)=0A=
+{=0A=
+	int i;=0A=
+	char *ss =3D (char *) s;=0A=
+=0A=
+	for (i =3D 0; i < n; i++)=0A=
+		ss[i] =3D c;=0A=
+	return s;=0A=
+}=0A=
+=0A=
+void *memcpy(void *__dest, __const void *__src, size_t __n)=0A=
+{=0A=
+	int i;=0A=
+	char *d =3D (char *) __dest, *s =3D (char *) __src;=0A=
+=0A=
+	for (i =3D 0; i < __n; i++)=0A=
+		d[i] =3D s[i];=0A=
+	return __dest;=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Fill the input buffer. This is called only when the buffer is =
empty=0A=
+ * and at least one byte is really needed.=0A=
+ */=0A=
+static int fill_inbuf(void)=0A=
+{=0A=
+	if (insize !=3D 0) {=0A=
+		error("ran out of input data\n");=0A=
+	}=0A=
+=0A=
+	inbuf =3D input_data;=0A=
+	insize =3D &input_data_end[0] - &input_data[0];=0A=
+	inptr =3D 1;=0A=
+	return inbuf[0];=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Write the output window window[0..outcnt-1] and update crc and =
bytes_out.=0A=
+ * (Used for the decompressed data only.)=0A=
+ */=0A=
+static void flush_window(void)=0A=
+{=0A=
+	ulg c =3D crc;		/* temporary variable */=0A=
+	unsigned n;=0A=
+	uch *in, *out, ch;=0A=
+=0A=
+	in =3D window;=0A=
+	out =3D &output_data[output_ptr];=0A=
+	for (n =3D 0; n < outcnt; n++) {=0A=
+		ch =3D *out++ =3D *in++;=0A=
+		c =3D crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);=0A=
+	}=0A=
+	crc =3D c;=0A=
+	bytes_out +=3D (ulg) outcnt;=0A=
+	output_ptr +=3D (ulg) outcnt;=0A=
+	outcnt =3D 0;=0A=
+}=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void check_mem(void)=0A=
+{=0A=
+	int i;=0A=
+=0A=
+	puts("\ncplens =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplens[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\ncplext =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplext[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\nborder =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(border[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\n");=0A=
+}=0A=
+#endif=0A=
+static void error(char *x)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	check_mem();=0A=
+	puts("\n\n");=0A=
+	puts(x);=0A=
+	puts("byte_count =3D ");=0A=
+	int2hex(byte_count);=0A=
+	puts("\n");=0A=
+	puts("\n\n -- Error. System halted");=0A=
+#endif=0A=
+	while (1);		/* Halt */=0A=
+}=0A=
+=0A=
+void variable_init(void)=0A=
+{=0A=
+	byte_count =3D 0;=0A=
+	output_data =3D (char *) LOADADDR;=0A=
+	free_mem_ptr =3D FREE_RAM;=0A=
+	free_mem_end_ptr =3D END_RAM;=0A=
+#if ZDEBUG > 1=0A=
+	puts("output_data      0x");=0A=
+	int2hex((unsigned long)output_data); puts("\n");=0A=
+	puts("free_mem_ptr     0x");=0A=
+	int2hex(free_mem_ptr); puts("\n");=0A=
+	puts("free_mem_end_ptr 0x");=0A=
+	int2hex(free_mem_end_ptr); puts("\n");=0A=
+	puts("input_data       0x");=0A=
+	int2hex((unsigned long)input_data); puts("\n");=0A=
+#endif=0A=
+}=0A=
+=0A=
+int decompress_kernel(void)=0A=
+{=0A=
+#if ZDEBUG > 0=0A=
+  putc_init();=0A=
+#if ZDEBUG > 2=0A=
+  check_mem();=0A=
+#endif=0A=
+#endif=0A=
+=0A=
+  variable_init();=0A=
+=0A=
+  makecrc();=0A=
+#if ZDEBUG > 0=0A=
+  puts("\n");=0A=
+  puts("Uncompressing Linux... \n");=0A=
+#endif=0A=
+  gunzip();		// ...see inflate.c=0A=
+#if ZDEBUG > 0=0A=
+  puts("Ok, booting the kernel.\n");=0A=
+#endif=0A=
+=0A=
+#if ZDEBUG > 1=0A=
+ {=0A=
+  unsigned long *p =3D (unsigned long *)LOADADDR;=0A=
+  int2hex(p[0]); puts("\n");=0A=
+  int2hex(p[1]); puts("\n");=0A=
+  int2hex(p[2]); puts("\n");=0A=
+  int2hex(p[3]); puts("\n");=0A=
+ }=0A=
+#endif=0A=
+=0A=
+  return 0;=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/rImage.lds =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/rImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/rImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/rImage.lds	=
2006-03-09 16:25:47.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x9FC00000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/EB365/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/s365led.h =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/s365led.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/s365led.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/s365led.h	=
2006-03-09 16:25:47.000000000 -0800=0A=
@@ -0,0 +1,62 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU LED address definitions. Though the registers are already =
defined=0A=
+ *   else where under linux tree, they are once again declared here =
for the=0A=
+ *    ease of syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S365LED__=0A=
+#define __S365LED__=0A=
+=0A=
+/*=0A=
+** following few lines define a macro DISPLAY=0A=
+** which is used to write a set of 4 characters=0A=
+** onto the EB365 LED.=0A=
+*/=0A=
+=0A=
+#define GPIO_BASE     PHYS_TO_K1(0x18048000)=0A=
+=0A=
+#define LED_BASE      PHYS_TO_K1(0x0C000000)=0A=
+#define LED_DIGIT0    0x3=0A=
+#define LED_DIGIT1    0x2=0A=
+#define LED_DIGIT2    0x1=0A=
+#define LED_DIGIT3    0x0=0A=
+=0A=
+#define DISPLAY(d0, d1, d2, d3)     \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        li    t7, (d0) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT0(t6)              ;\=0A=
+        li    t7, (d1) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT1(t6)              ;\=0A=
+        li    t7, (d2) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT2(t6)              ;\=0A=
+        li    t7, (d3) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT3(t6)=0A=
+=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/s365ram.h =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/s365ram.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/s365ram.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/s365ram.h	=
2006-03-09 16:25:47.000000000 -0800=0A=
@@ -0,0 +1,144 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT EB365 SDRAM setup values.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S365RAM__=0A=
+#define __S365RAM__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+=0A=
+#define MB16	1=0A=
+#define MB32	2=0A=
+#define MB64	3=0A=
+#define MB128	4=0A=
+#define MB32SO	5=0A=
+=0A=
+#define DEV_CTL_BASE        PHYS_TO_K1(0x18010000)  /* device =
controller regs */=0A=
+#define SDRAM_BASE          PHYS_TO_K1(0x18018000)  /* SDRAM =
controller regs */=0A=
+#define GPIO_FUNC           0x0000609f		    /* SDRAM CLK; MEM[25:22]; =
UART */=0A=
+#define GPIO_CFG	    0x00000020		    /* GPIO5 ouput for SPI CS */=0A=
+#define GPIO_OUT	    0x00000020		    /* GPIO5 ouput 1 */=0A=
+#define ERR_CNTL_STATUS     PHYS_TO_K1(0x18028030)=0A=
+=0A=
+#define DEV1_BASE           0x08000000=0A=
+#define DEV_PROM_MASK       0xFFE00000=0A=
+#define DEV_PROM_CTRL       0x028A2205=0A=
+#define DEV_PROM_TC         0x00000A44=0A=
+#define DEV_FLASH_MASK      0xFF800000=0A=
+#define DEV_FLASH_CTRL      0x028A2206=0A=
+#define DEV_FLASH_TC        0x00000A44=0A=
+=0A=
+#define DEV2_BASE           0x0C000000=0A=
+#define DEV2_MASK           0xFF000000=0A=
+#define DEV2_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV2_TC             0x00000A44=0A=
+=0A=
+#define DEV3_BASE           0x00000000=0A=
+#define DEV3_MASK           0x00000000=0A=
+#define DEV3_CTRL           0x0FFFFFF4              /* ?-bit devices =
*/=0A=
+#define DEV3_TC             0x00001FFF=0A=
+=0A=
+#define DEV4_BASE           0x00000000=0A=
+#define DEV4_MASK           0x00000000=0A=
+#define DEV4_CTRL           0x0FFFFFF4              /* ?-bit devices =
*/=0A=
+#define DEV4_TC             0x00001FFF=0A=
+=0A=
+#define DEV5_BASE           0x00000000=0A=
+#define DEV5_MASK           0x00000000=0A=
+#define DEV5_CTRL           0x0FFFFFF4              /* ?-bit devices =
*/=0A=
+#define DEV5_TC             0x00001FFF=0A=
+=0A=
+#define DATA_PATTERN        0xA5A5A5A5=0A=
+=0A=
+#if DRAMSZ =3D=3D MB32SO=0A=
+=0A=
+/* Address space allocations */=0A=
+#define SDRAM_BNK0_BASE     0x00000000  /* 0 MB */=0A=
+#define SDRAM_BNK0_MASK     0xFE000000=0A=
+#define SDRAM_BNK1_BASE     0x02000000  /* 32 MB */=0A=
+#define SDRAM_BNK1_MASK     0x00000000=0A=
+#define SDRAM_BNK0_ABASE    0x00000000  /* 0 MB */=0A=
+#define SDRAM_BNK0_AMASK    0x00000000=0A=
+=0A=
+/* SDRAM Chip specific setup */=0A=
+#if MHZ =3D=3D 90=0A=
+#define SDRAM_CR_BS 	    0x994330F0 /* SDRAM enable 	*/=0A=
+#define SDRAM_DS_BS 	    0x19433080 /* SDRAM disable */=0A=
+#define SDRAM_PC_VAL  	    0x194330c3 /* Precharge val */=0A=
+#define SDRAM_RFRSH_CMD     0x19433093 /* refresh cmd 	*/=0A=
+#define SDRAM_MODE_REG      0x19433083 /* mode register */=0A=
+#else=0A=
+#define SDRAM_CR_BS 	    0x984330F0 /* SDRAM enable 	*/=0A=
+#define SDRAM_DS_BS 	    0x18433080 /* SDRAM disable */=0A=
+#define SDRAM_PC_VAL  	    0x184330c3 /* Precharge val */=0A=
+#define SDRAM_RFRSH_CMD     0x18433093 /* refresh cmd 	*/=0A=
+#define SDRAM_MODE_REG      0x18433083 /* mode register */=0A=
+#endif=0A=
+=0A=
+#else=0A=
+=0A=
+/* Address space allocations */=0A=
+#define SDRAM_BNK0_BASE     0x00000000  /* 0 MB */=0A=
+#define SDRAM_BNK0_MASK     0xFF000000=0A=
+#define SDRAM_BNK1_BASE     0x01000000  /* 16 MB */=0A=
+#define SDRAM_BNK1_MASK     0x00000000=0A=
+#define SDRAM_BNK0_ABASE    0x00000000  /* 0 MB */=0A=
+#define SDRAM_BNK0_AMASK    0x00000000=0A=
+=0A=
+/* SDRAM Chip specific setup */=0A=
+#if MHZ =3D=3D 90=0A=
+#define SDRAM_CR_BS 	    0x894370F0 /* SDRAM enable 	*/=0A=
+#define SDRAM_DS_BS 	    0x09437080 /* SDRAM disable */=0A=
+#define SDRAM_PC_VAL  	    0x094370c3 /* Precharge val */=0A=
+#define SDRAM_RFRSH_CMD     0x09437093 /* refresh cmd 	*/=0A=
+#define SDRAM_MODE_REG      0x09437083 /* mode register */=0A=
+#else=0A=
+#define SDRAM_CR_BS 	    0x884370F0 /* SDRAM enable 	*/=0A=
+#define SDRAM_DS_BS 	    0x08437080 /* SDRAM disable */=0A=
+#define SDRAM_PC_VAL  	    0x084370c3 /* Precharge val */=0A=
+#define SDRAM_RFRSH_CMD     0x08437093 /* refresh cmd 	*/=0A=
+#define SDRAM_MODE_REG      0x08437083 /* mode register */=0A=
+#endif=0A=
+=0A=
+#endif=0A=
+=0A=
+/* Refresh timer */=0A=
+#define SDRAM_RF_CNT_BS     0x00000000 /* refresh count reg */=0A=
+#define SDRAM_RF_CMPR_BS    0x00000040 /* refresh comp reg  */=0A=
+#if MHZ =3D=3D 90=0A=
+#define SDRAM_RF_CMPR_SE_BS 0x000002EE /* slow expiration   */=0A=
+#else=0A=
+#define SDRAM_RF_CMPR_SE_BS 0x00000271 /* slow expiration   */=0A=
+#endif=0A=
+=0A=
+#define DELAY_200USEC       30000      /* not exactly */=0A=
+#define DISABLE_TIMER       0=0A=
+#define ENABLE_TIMER        1=0A=
+=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/uart16550.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/uart16550.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/uart16550.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/uart16550.c	=
2006-03-09 16:25:47.000000000 -0800=0A=
@@ -0,0 +1,178 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   UART code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ **********************************************************************=
****=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+=0A=
+#define RC32365_REG_BASE   0xb8000000=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32300_UART0_BASE (RC32365_REG_BASE + 0x50003)=0A=
+#else=0A=
+#define RC32300_UART0_BASE (RC32365_REG_BASE + 0x50000)=0A=
+#endif=0A=
+=0A=
+#define BASE		   RC32300_UART0_BASE=0A=
+=0A=
+#define MAX_BAUD		(CONFIG_IDT_BOARD_FREQ / 16)=0A=
+#define REG_OFFSET		0x4=0A=
+=0A=
+/* =3D=3D=3D CONFIG =3D=3D=3D */=0A=
+=0A=
+/*=0A=
+ * #define BASE			0xb2001000=0A=
+ * #define MAX_BAUD		1152000=0A=
+ * #define REG_OFFSET		0x10=0A=
+ */=0A=
+#if (!defined(BASE) || !defined(MAX_BAUD) || !defined(REG_OFFSET))=0A=
+#error You must define BASE, MAX_BAUD and REG_OFFSET in the =
Makefile.=0A=
+#endif=0A=
+=0A=
+#ifndef INIT_SERIAL_PORT=0A=
+#define INIT_SERIAL_PORT	1=0A=
+#endif=0A=
+=0A=
+#ifndef DEFAULT_BAUD=0A=
+//#define DEFAULT_BAUD		UART16550_BAUD_115200=0A=
+#define DEFAULT_BAUD		UART16550_BAUD_9600=0A=
+#endif=0A=
+#ifndef DEFAULT_PARITY=0A=
+#define DEFAULT_PARITY		UART16550_PARITY_NONE=0A=
+#endif=0A=
+#ifndef DEFAULT_DATA=0A=
+#define DEFAULT_DATA		UART16550_DATA_8BIT=0A=
+#endif=0A=
+#ifndef DEFAULT_STOP=0A=
+#define DEFAULT_STOP		UART16550_STOP_1BIT=0A=
+#endif=0A=
+=0A=
+/* =3D=3D=3D END OF CONFIG =3D=3D=3D */=0A=
+=0A=
+typedef         unsigned char uint8;=0A=
+typedef         unsigned int  uint32;=0A=
+=0A=
+#define         UART16550_BAUD_2400             2400=0A=
+#define         UART16550_BAUD_4800             4800=0A=
+#define         UART16550_BAUD_9600             9600=0A=
+#define         UART16550_BAUD_19200            19200=0A=
+#define         UART16550_BAUD_38400            38400=0A=
+#define         UART16550_BAUD_57600            57600=0A=
+#define         UART16550_BAUD_115200           115200=0A=
+=0A=
+#define         UART16550_PARITY_NONE           0=0A=
+#define         UART16550_PARITY_ODD            0x08=0A=
+#define         UART16550_PARITY_EVEN           0x18=0A=
+#define         UART16550_PARITY_MARK           0x28=0A=
+#define         UART16550_PARITY_SPACE          0x38=0A=
+=0A=
+#define         UART16550_DATA_5BIT             0x0=0A=
+#define         UART16550_DATA_6BIT             0x1=0A=
+#define         UART16550_DATA_7BIT             0x2=0A=
+#define         UART16550_DATA_8BIT             0x3=0A=
+=0A=
+#define         UART16550_STOP_1BIT             0x0=0A=
+#define         UART16550_STOP_2BIT             0x4=0A=
+=0A=
+/* register offset */=0A=
+#define		OFS_RCV_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_TRANS_HOLD		(0*REG_OFFSET)=0A=
+#define		OFS_SEND_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_INTR_ENABLE		(1*REG_OFFSET)=0A=
+#define		OFS_INTR_ID		(2*REG_OFFSET)=0A=
+#define		OFS_DATA_FORMAT		(3*REG_OFFSET)=0A=
+#define		OFS_LINE_CONTROL	(3*REG_OFFSET)=0A=
+#define		OFS_MODEM_CONTROL	(4*REG_OFFSET)=0A=
+#define		OFS_RS232_OUTPUT	(4*REG_OFFSET)=0A=
+#define		OFS_LINE_STATUS		(5*REG_OFFSET)=0A=
+#define		OFS_MODEM_STATUS	(6*REG_OFFSET)=0A=
+#define		OFS_RS232_INPUT		(6*REG_OFFSET)=0A=
+#define		OFS_SCRATCH_PAD		(7*REG_OFFSET)=0A=
+=0A=
+#define		OFS_DIVISOR_LSB		(0*REG_OFFSET)=0A=
+#define		OFS_DIVISOR_MSB		(1*REG_OFFSET)=0A=
+=0A=
+#define		UART16550_READ(y)    (*((volatile uint8*)(BASE + y)))=0A=
+#define		UART16550_WRITE(y, z)  ((*((volatile uint8*)(BASE + y))) =3D =
z)=0A=
+=0A=
+static void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 =
stop)=0A=
+{=0A=
+	/* disable interrupts */=0A=
+	UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	UART16550_WRITE(OFS_INTR_ENABLE, 0);=0A=
+=0A=
+	/* set up baud rate */=0A=
+	{=0A=
+		uint32 divisor;=0A=
+=0A=
+		/* set DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x80);=0A=
+=0A=
+		/* set divisor */=0A=
+		divisor =3D MAX_BAUD / baud;=0A=
+		UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);=0A=
+		UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);=0A=
+=0A=
+		/* clear DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	}=0A=
+=0A=
+	/* set data format */=0A=
+	UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);=0A=
+}=0A=
+=0A=
+=0A=
+void=0A=
+putc_init(void)=0A=
+{=0A=
+#if INIT_SERIAL_PORT=0A=
+	Uart16550Init(DEFAULT_BAUD, DEFAULT_DATA, DEFAULT_PARITY, =
DEFAULT_STOP);=0A=
+#endif=0A=
+}=0A=
+=0A=
+void=0A=
+putc(unsigned char c)=0A=
+{=0A=
+	while ((UART16550_READ(OFS_LINE_STATUS) &0x20) =3D=3D 0);=0A=
+	UART16550_WRITE(OFS_SEND_BUFFER, c);=0A=
+}=0A=
+=0A=
+#if 0=0A=
+unsigned char=0A=
+getc(void)=0A=
+{=0A=
+	while((UART16550_READ(OFS_LINE_STATUS) & 0x1) =3D=3D 0);=0A=
+	return UART16550_READ(OFS_RCV_BUFFER);=0A=
+}=0A=
+=0A=
+int=0A=
+tstc(void)=0A=
+{=0A=
+	return((UART16550_READ(OFS_LINE_STATUS) & 0x01) !=3D 0);=0A=
+}=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/zImage.lds =
idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/zImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/boot/zImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/boot/zImage.lds	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x88000000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/EB365/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/idtIRQ.S =
idtlinux/arch/mips/idt-boards/rc32300/EB365/idtIRQ.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/idtIRQ.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/idtIRQ.S	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,66 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Intterrupt dispatcher code for IDT boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+				=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/regdef.h>=0A=
+#include <asm/stackframe.h>=0A=
+=0A=
+	.text=0A=
+	.set	noreorder=0A=
+	.set	noat=0A=
+	.align	5=0A=
+	NESTED(rc32300_IRQ, PT_SIZE, sp)=0A=
+	SAVE_ALL=0A=
+	CLI=0A=
+=0A=
+	.set	at=0A=
+	.set	noreorder=0A=
+=0A=
+	mfc0    t0, CP0_CAUSE=0A=
+	move	a1, sp=0A=
+								  =0A=
+	/* check for r4k counter/timer IRQ. */=0A=
+	=0A=
+	andi    t1, t0, CAUSEF_IP7=0A=
+	beqz    t1, 1f=0A=
+	nop=0A=
+=0A=
+	jal     idt_timer_interrupt=0A=
+	li	a0, 7=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+1:=0A=
+	jal	rc32300_irqdispatch=0A=
+	move	a0, t0=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+=0A=
+	END(rc32300_IRQ)=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/irq.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/irq.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/irq.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/irq.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,284 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Interrupt routines for IDT EB365 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/errno.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/irq.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/signal.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/timex.h>=0A=
+#include <linux/slab.h>=0A=
+#include <linux/random.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/system.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32365_gpio.h>=0A=
+=0A=
+#undef DEBUG_IRQ=0A=
+#ifdef DEBUG_IRQ=0A=
+/* note: prints function name for you */=0A=
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## =
args)=0A=
+#else=0A=
+#define DPRINTK(fmt, args...)=0A=
+#endif=0A=
+=0A=
+extern asmlinkage void rc32300_IRQ(void);=0A=
+=0A=
+static unsigned int startup_irq(unsigned int irq);=0A=
+static void end_irq(unsigned int irq_nr);=0A=
+static void mask_and_ack_irq(unsigned int irq_nr);=0A=
+static void rc32365_enable_irq(unsigned int irq_nr);=0A=
+static void rc32365_disable_irq(unsigned int irq_nr);=0A=
+=0A=
+extern void __init init_generic_irq(void);=0A=
+=0A=
+typedef struct {=0A=
+	u32 mask; =0A=
+	volatile u32 *base_addr;=0A=
+} intr_group_t;=0A=
+=0A=
+static const intr_group_t intr_group[NUM_INTR_GROUPS] =3D {=0A=
+	{ 0x00000fff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 0 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x000001ff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 1 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x00000003, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 2 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x00000fff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 3 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x0000ffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 4 * IC_GROUP_OFFSET) =
}=0A=
+};=0A=
+=0A=
+#define READ_PEND(base) (*(base))=0A=
+#define READ_MASK(base) (*(base + 2))=0A=
+#define WRITE_MASK(base, val) (*(base + 2) =3D (val))=0A=
+=0A=
+static inline int irq_to_group(unsigned int irq_nr)=0A=
+{=0A=
+	return ((irq_nr - GROUP0_IRQ_BASE) >> 5);=0A=
+}=0A=
+=0A=
+static inline int group_to_ip(unsigned int group)=0A=
+{=0A=
+	return group + 2;=0A=
+}=0A=
+=0A=
+static inline void enable_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	clear_c0_cause(ipnum);=0A=
+	set_c0_status(ipnum);=0A=
+}=0A=
+=0A=
+static inline void disable_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	clear_c0_status(ipnum);=0A=
+}=0A=
+=0A=
+static inline void ack_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	unsigned long flags;=0A=
+	=0A=
+	local_irq_save(flags);=0A=
+	=0A=
+	clear_c0_cause(ipnum);=0A=
+	=0A=
+	local_irq_restore(flags);=0A=
+}=0A=
+static void rc32365_enable_irq(unsigned int irq_nr)=0A=
+{=0A=
+	unsigned long flags;=0A=
+	int           ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int  group, intr_bit;=0A=
+	volatile unsigned int  *addr;=0A=
+	=0A=
+	local_irq_save(flags);=0A=
+	=0A=
+	if (ip < 0)=0A=
+		enable_local_irq(irq_nr);=0A=
+	else {=0A=
+		group =3D ip >> 5;=0A=
+		=0A=
+		ip -=3D (group << 5);=0A=
+		intr_bit =3D 1 << ip;=0A=
+    =0A=
+		enable_local_irq(group_to_ip(group));=0A=
+    =0A=
+		addr =3D intr_group[group].base_addr;=0A=
+		WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);=0A=
+	}=0A=
+=0A=
+	local_irq_restore(flags);=0A=
+}=0A=
+=0A=
+static void rc32365_disable_irq(unsigned int irq_nr)=0A=
+{=0A=
+	unsigned long flags;=0A=
+	int           ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int  group, intr_bit, mask;=0A=
+	volatile unsigned int  *addr;=0A=
+=0A=
+	local_irq_save(flags);=0A=
+  =0A=
+	if (ip < 0)=0A=
+		disable_local_irq(irq_nr);=0A=
+	else {=0A=
+		group =3D ip >> 5;=0A=
+=0A=
+		ip -=3D group << 5;=0A=
+		intr_bit =3D 1 << ip;=0A=
+    =0A=
+		addr =3D intr_group[group].base_addr;=0A=
+		=0A=
+		mask =3D READ_MASK(addr);=0A=
+		mask |=3D intr_bit;=0A=
+		WRITE_MASK(addr, mask);=0A=
+    =0A=
+		if (mask =3D=3D intr_group[group].mask)=0A=
+			disable_local_irq(group_to_ip(group));=0A=
+	}=0A=
+  =0A=
+	local_irq_restore(flags);=0A=
+}=0A=
+=0A=
+static unsigned int startup_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32365_enable_irq(irq_nr);=0A=
+	return 0; =0A=
+}=0A=
+=0A=
+static void shutdown_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32365_disable_irq(irq_nr);=0A=
+	return;=0A=
+}=0A=
+=0A=
+static void mask_and_ack_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32365_disable_irq(irq_nr);=0A=
+	ack_local_irq(group_to_ip(irq_to_group(irq_nr)));=0A=
+}=0A=
+=0A=
+static void end_irq(unsigned int irq_nr)=0A=
+{=0A=
+	int ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int intr_bit, group;=0A=
+	volatile unsigned int *addr;=0A=
+=0A=
+	unsigned long flags;=0A=
+=0A=
+	local_irq_save(flags);=0A=
+=0A=
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED | IRQ_INPROGRESS))) =
{=0A=
+		if (ip < 0)=0A=
+			enable_local_irq(irq_nr);=0A=
+		else {=0A=
+			if (irq_nr >=3D RC32365_PCI_INTA_IRQ && irq_nr <=3D =
RC32365_PCI_INTD_IRQ)=0A=
+				gpio->gpioistat =3D 0x0000f0ff;=0A=
+      =0A=
+			group =3D ip >> 5;=0A=
+=0A=
+			ip -=3D (group << 5);=0A=
+			intr_bit =3D 1 << ip;=0A=
+=0A=
+			=0A=
+			enable_local_irq(group_to_ip(group));=0A=
+  =0A=
+			addr =3D intr_group[group].base_addr;=0A=
+			WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);=0A=
+		}=0A=
+	} =0A=
+	else {=0A=
+		printk("warning: end_irq %d did not enable (%x)\n", =0A=
+		       irq_nr, irq_desc[irq_nr].status);=0A=
+	}=0A=
+=0A=
+	local_irq_restore(flags);=0A=
+}=0A=
+=0A=
+static struct hw_interrupt_type rc32365_irq_type =3D {=0A=
+	"RC32365",=0A=
+	startup_irq,=0A=
+	shutdown_irq,=0A=
+	rc32365_enable_irq,=0A=
+	rc32365_disable_irq,=0A=
+	mask_and_ack_irq,=0A=
+	end_irq,=0A=
+	NULL=0A=
+};=0A=
+=0A=
+=0A=
+void __init arch_init_irq(void)=0A=
+{=0A=
+	int i;=0A=
+=0A=
+	printk("Initializing IRQ's: %d of %d\n", RC32365_NR_IRQS,NR_IRQS);  =
=0A=
+	memset(irq_desc, 0, sizeof(irq_desc));=0A=
+	set_except_vector(0, rc32300_IRQ);=0A=
+  =0A=
+	for (i =3D 0; i < RC32365_NR_IRQS; i++) {=0A=
+		irq_desc[i].status =3D IRQ_DISABLED;=0A=
+		irq_desc[i].action =3D NULL;=0A=
+		irq_desc[i].depth =3D 1;=0A=
+		irq_desc[i].handler =3D &rc32365_irq_type;=0A=
+		spin_lock_init(&irq_desc[i].lock);=0A=
+	}=0A=
+}=0A=
+=0A=
+/* Main Interrupt dispatcher */=0A=
+void rc32300_irqdispatch(unsigned long cp0_cause, struct pt_regs =
*regs)=0A=
+{=0A=
+	unsigned int ip, pend, group;=0A=
+	volatile unsigned int *addr;=0A=
+=0A=
+	if ((ip =3D (cp0_cause & 0x7c00))) {=0A=
+		group =3D 21 - rc32300_clz(ip);=0A=
+		=0A=
+		addr =3D intr_group[group].base_addr;=0A=
+=0A=
+		pend =3D READ_PEND(addr);=0A=
+		pend &=3D ~READ_MASK(addr); =0A=
+		pend =3D 39 - rc32300_clz(pend);=0A=
+		do_IRQ((group << 5) + pend, regs);=0A=
+		return;=0A=
+	} =0A=
+	else=0A=
+		return;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/EB365/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/Makefile	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,42 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for IDT EB365 board BSP=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+#  =0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+.S.s:=0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:=0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+obj-y	 :=3D irq.o setup.o idtIRQ.o reset.o prom.o time.o=0A=
+obj-$(CONFIG_KGDB)			+=3D serial_gdb.o=0A=
+obj-$(CONFIG_SERIAL_8250)		+=3D serial.o=0A=
+subdir-$(CONFIG_IDT_BOOT_NVRAM)		+=3D nvram=0A=
+obj-$(CONFIG_IDT_BOOT_NVRAM)		+=3D nvram/built-in.o=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/nvram/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/EB365/nvram/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/nvram/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/nvram/Makefile	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,44 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for IDT EB365 nvram access routines=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+#  =0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+.S.s:   =0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:   =0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+obj-y   :=3D nvram365.o =0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/nvram/nvram365.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/nvram/nvram365.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/nvram/nvram365.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/nvram/nvram365.c	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,342 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram interface routines.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/string.h>=0A=
+#include "nvram365.h"=0A=
+=0A=
+void setenv (char *e, char *v, int rewrite);=0A=
+char *getenv (char *e);=0A=
+void unsetenv (char *e);=0A=
+void purgeenv(void);=0A=
+char *getenv (char *s);=0A=
+void mapenv (int (*func)(char *, char *));=0A=
+=0A=
+static void nvram_initenv(void);=0A=
+=0A=
+static unsigned char=0A=
+nvram_getbyte(int offs)=0A=
+{=0A=
+  return(*((unsigned char*)(NVRAM_BASE + offs)));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setbyte(int offs, unsigned char val)=0A=
+{=0A=
+  unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE + =
offs);=0A=
+=0A=
+  *nvramDataPointer =3D val;=0A=
+}=0A=
+=0A=
+static unsigned short=0A=
+nvram_getshort(int offs)=0A=
+{=0A=
+  return((nvram_getbyte(offs) << 8) | nvram_getbyte(offs + 1));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setshort(int offs, unsigned short val)=0A=
+{=0A=
+  nvram_setbyte(offs, (unsigned char)((val >> 8) & 0xff));=0A=
+  nvram_setbyte(offs + 1, (unsigned char)(val & 0xff));=0A=
+}=0A=
+/*=0A=
+ * calculate NVRAM checksum=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_calcsum(void)=0A=
+{=0A=
+  unsigned short sum =3D NV_MAGIC;=0A=
+  int     i;=0A=
+=0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i +=3D 2)=0A=
+    sum +=3D nvram_getshort(i);=0A=
+  return(sum);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * update the nvram checksum=0A=
+ */=0A=
+static void=0A=
+nvram_updatesum (void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_CSUM, nvram_calcsum());=0A=
+}=0A=
+=0A=
+/*=0A=
+ * test validity of nvram by checksumming it=0A=
+ */=0A=
+static int=0A=
+nvram_isvalid(void)=0A=
+{=0A=
+  static  unsigned int is_valid;=0A=
+=0A=
+  if (is_valid)=0A=
+    return(1);=0A=
+=0A=
+  if (nvram_getshort(NVOFF_MAGIC) !=3D NV_MAGIC)=0A=
+    nvram_initenv();=0A=
+  is_valid =3D 1;=0A=
+  return(1);=0A=
+}=0A=
+=0A=
+/* return nvram address of environment string */=0A=
+static int=0A=
+nvram_matchenv(char *s)=0A=
+{=0A=
+  int envsize, envp, n, i, varsize;=0A=
+  char *var;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  if (envsize > ENV_AVAIL)=0A=
+    return(0);     /* sanity */=0A=
+    =0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  if ((n =3D strlen (s)) > 255)=0A=
+    return(0);=0A=
+    =0A=
+  while (envsize > 0) {=0A=
+    varsize =3D nvram_getbyte(envp);=0A=
+    if (varsize =3D=3D 0 || (envp + varsize) > ENV_TOP)=0A=
+      return(0);   /* sanity */=0A=
+    for (i =3D envp + 1, var =3D s; i <=3D envp + n; i++, var++) {=0A=
+      char c1 =3D nvram_getbyte(i);=0A=
+      char c2 =3D *var;=0A=
+      if (islower(c1))=0A=
+        c1 =3D toupper(c1);=0A=
+      if (islower(c2))=0A=
+        c2 =3D toupper(c2);=0A=
+      if (c1 !=3D c2)=0A=
+        break;=0A=
+    }=0A=
+    if (i > envp + n) {       /* match so far */=0A=
+      if (n =3D=3D varsize - 1)   /* match on boolean */=0A=
+        return(envp);=0A=
+      if (nvram_getbyte(i) =3D=3D '=3D')  /* exact match on variable =
*/=0A=
+        return(envp);=0A=
+    }=0A=
+    envsize -=3D varsize;=0A=
+    envp +=3D varsize;=0A=
+  }=0A=
+  return(0);=0A=
+}=0A=
+=0A=
+static void nvram_initenv(void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_delenv(char *s)=0A=
+{=0A=
+  int nenvp, envp, envsize, nbytes;=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return;=0A=
+=0A=
+  nenvp =3D envp + nvram_getbyte(envp);=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  nbytes =3D envsize - (nenvp - ENV_BASE);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envsize - (nenvp - envp));=0A=
+  while (nbytes--) {=0A=
+    nvram_setbyte(envp, nvram_getbyte(nenvp));=0A=
+    envp++;=0A=
+    nenvp++;=0A=
+  }=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static int=0A=
+nvram_setenv(char *s, char *v)=0A=
+{=0A=
+  int ns, nv, total;=0A=
+  int envp;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return(-1);=0A=
+=0A=
+  nvram_delenv(s);=0A=
+  ns =3D strlen(s);=0A=
+  if (ns =3D=3D 0)=0A=
+    return(0);=0A=
+  if (v && *v) {=0A=
+    nv =3D strlen(v);=0A=
+    total =3D ns + nv + 2;=0A=
+  }=0A=
+  else {=0A=
+    nv =3D 0;=0A=
+    total =3D ns + 1;=0A=
+  }=0A=
+  if (total > 255 || total > ENV_AVAIL - =
nvram_getshort(NVOFF_ENVSIZE))=0A=
+    return(0);=0A=
+=0A=
+  envp =3D ENV_BASE + nvram_getshort(NVOFF_ENVSIZE);=0A=
+=0A=
+  nvram_setbyte(envp, (unsigned char) total); =0A=
+  envp++;=0A=
+=0A=
+  while (ns--) {=0A=
+    nvram_setbyte(envp, *s); =0A=
+    envp++; =0A=
+    s++;=0A=
+  }=0A=
+=0A=
+  if (nv) {=0A=
+    nvram_setbyte(envp, '=3D'); =0A=
+    envp++;=0A=
+    while (nv--) {=0A=
+      nvram_setbyte(envp, *v); =0A=
+      envp++; =0A=
+      v++;=0A=
+    }=0A=
+  }=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envp-ENV_BASE);=0A=
+  nvram_updatesum();=0A=
+  return(0);=0A=
+}=0A=
+=0A=
+static char *=0A=
+nvram_getenv(char *s)=0A=
+{=0A=
+  static char buf[256];   /* FIXME: this cannot be static */=0A=
+  int envp, ns, nbytes, i;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return((char *)0);=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return((char *)0);=0A=
+  ns =3D strlen(s);=0A=
+  if (nvram_getbyte(envp) =3D=3D ns + 1)  /* boolean */=0A=
+    buf[0] =3D '\0';=0A=
+  else {=0A=
+    nbytes =3D nvram_getbyte(envp) - (ns + 2);=0A=
+    envp +=3D ns + 2;=0A=
+    for (i =3D 0; i < nbytes; i++)=0A=
+      buf[i] =3D nvram_getbyte(envp++);=0A=
+    buf[i] =3D '\0';=0A=
+  }=0A=
+  return(buf);=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_unsetenv(char *s)=0A=
+{=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  nvram_delenv(s);=0A=
+}=0A=
+/*=0A=
+ * apply func to each string in environment=0A=
+ */=0A=
+static void=0A=
+nvram_mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  int envsize, envp, n, i, seeneql;=0A=
+  char name[256], value[256];=0A=
+  char c, *s;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  while (envsize > 0) {=0A=
+    value[0] =3D '\0';=0A=
+    seeneql =3D 0;=0A=
+    s =3D name;=0A=
+    n =3D nvram_getbyte(envp);=0A=
+    for (i =3D envp + 1; i < envp + n; i++) {=0A=
+      c =3D nvram_getbyte(i);=0A=
+      if ((c =3D=3D '=3D') && !seeneql) {=0A=
+        *s =3D '\0';=0A=
+        s =3D value;=0A=
+        seeneql =3D 1;=0A=
+        continue;=0A=
+      }=0A=
+      *s++ =3D c;=0A=
+    }=0A=
+    *s =3D '\0';=0A=
+    (*func)(name, value);=0A=
+    envsize -=3D n;=0A=
+    envp +=3D n;=0A=
+  }=0A=
+}=0A=
+/*=0A=
+ * Wrappers to allow 'special' environment variables to get =
processed=0A=
+ */=0A=
+void=0A=
+setenv(char *e, char *v, int rewrite)=0A=
+{=0A=
+  if (nvram_getenv(e) && !rewrite)=0A=
+    return;=0A=
+    =0A=
+  nvram_setenv(e, v);=0A=
+}=0A=
+=0A=
+char *=0A=
+getenv(char *e)=0A=
+{=0A=
+  return(nvram_getenv(e));=0A=
+}=0A=
+=0A=
+void=0A=
+unsetenv(char *e)=0A=
+{=0A=
+  nvram_unsetenv(e);=0A=
+}=0A=
+=0A=
+void=0A=
+purgeenv(void)=0A=
+{=0A=
+  int i;=0A=
+  unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE);=0A=
+  =0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i++)=0A=
+    *nvramDataPointer++ =3D 0;=0A=
+  =0A=
+  nvram_initenv();=0A=
+}=0A=
+=0A=
+void=0A=
+mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  nvram_mapenv(func);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/nvram/nvram365.h =
idtlinux/arch/mips/idt-boards/rc32300/EB365/nvram/nvram365.h=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/nvram/nvram365.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/nvram/nvram365.h	=
2006-03-09 16:25:48.000000000 -0800=0A=
@@ -0,0 +1,60 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram layout definitions=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#define NVRAM_BASE      0xAC800000=0A=
+#define TD_NVRAM_SIZE   0x2000=0A=
+=0A=
+/*=0A=
+ * defining ALGCOMPAT provides backward compatibility=0A=
+ * with Algorithmics derived PROM monitors=0A=
+ */=0A=
+#define NVOFFSET        0   /* use all of NVRAM */=0A=
+=0A=
+/* Offsets to reserved locations */=0A=
+              /* size description */=0A=
+#define NVOFF_MAGIC     (NVOFFSET + 0)  /* 2 magic value */=0A=
+#define NVOFF_CSUM      (NVOFFSET + 2)  /* 2 NVRAM environment =
checksum */=0A=
+#define NVOFF_ENVSIZE   (NVOFFSET + 4)  /* 2 size of 'environment' =
*/=0A=
+#define NVOFF_TEST      (NVOFFSET + 5)  /* 1 cold start test byte =
*/=0A=
+#define NVOFF_ETHADDR   (NVOFFSET + 6)  /* 6 decoded ethernet address =
*/=0A=
+#define NVOFF_UNUSED    (NVOFFSET + 12) /* 0 current end of table =
*/=0A=
+=0A=
+#define NV_MAGIC        0xdeaf          /* nvram magic number */=0A=
+#define NV_RESERVED     32               /* number of reserved bytes =
*/=0A=
+=0A=
+#undef  NVOFF_ETHADDR=0A=
+#define NVOFF_ETHADDR   (NVOFFSET + NV_RESERVED - 6)=0A=
+=0A=
+/* number of bytes available for environment */=0A=
+#define ENV_BASE        (NVOFFSET + NV_RESERVED)=0A=
+#define ENV_TOP         TD_NVRAM_SIZE=0A=
+#define ENV_AVAIL       (ENV_TOP - ENV_BASE)=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/prom.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/prom.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/prom.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/prom.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,117 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     prom interface routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/string.h>=0A=
+#include <linux/console.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <linux/bootmem.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serialP.h>=0A=
+#include <asm/serial.h>=0A=
+#include <linux/ioport.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+extern void setup_serial_port(void);=0A=
+unsigned int idt_cpu_freq =3D CONFIG_IDT_BOARD_FREQ;=0A=
+=0A=
+EXPORT_SYMBOL(idt_cpu_freq);=0A=
+=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+extern void mapenv(int (*func)(char *, char *));=0A=
+static int make_bootparm(char *name,char *val)=0A=
+{ =0A=
+	if (strncmp(name, "bootparm", 8) =3D=3D 0) {=0A=
+		strcat(arcs_cmdline," ");=0A=
+		strcat(arcs_cmdline,val);=0A=
+	}=0A=
+	else if(strncmp(name, "HZ", 2) =3D=3D 0) {=0A=
+		idt_cpu_freq =3D simple_strtoul(val, 0, 10);=0A=
+		printk("CPU Clock at %d Hz (from HZ environment variable)\n",=0A=
+		       idt_cpu_freq);=0A=
+	}=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static void prom_init_cmdline(void)=0A=
+{ =0A=
+	mapenv(&make_bootparm);=0A=
+}=0A=
+=0A=
+#else=0A=
+/* Kernel Boot parameters */=0A=
+//static unsigned char =
bootparm[]=3D"ip=3D157.165.29.36:157.165.29.18::255.255.0.0::eth0";=0A=
+static unsigned char bootparm[]=3D"console=3DttyS0,9600";=0A=
+#endif=0A=
+=0A=
+extern unsigned long mips_machgroup;=0A=
+extern unsigned long mips_machtype;=0A=
+=0A=
+const char *get_system_type(void)=0A=
+{=0A=
+	return "IDT 79EB365";=0A=
+}=0A=
+=0A=
+struct resource rc32300_res_ram =3D {=0A=
+	"RAM",=0A=
+	0,=0A=
+	RAM_SIZE,=0A=
+	IORESOURCE_MEM=0A=
+};=0A=
+=0A=
+char * __init prom_getcmdline(void)=0A=
+{=0A=
+	return &(arcs_cmdline[0]);=0A=
+}=0A=
+=0A=
+void __init prom_init(void)=0A=
+{=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+	prom_init_cmdline();=0A=
+#endif=0A=
+=0A=
+	setup_serial_port();=0A=
+	mips_machgroup =3D MACH_GROUP_IDT;=0A=
+	mips_machtype =3D MACH_IDT_EB365;=0A=
+	add_memory_region(0,rc32300_res_ram.end - =
rc32300_res_ram.start,BOOT_MEM_RAM);=0A=
+  =0A=
+}=0A=
+=0A=
+unsigned long __init prom_free_prom_memory(void)=0A=
+{=0A=
+	return 0;=0A=
+}=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/reset.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/reset.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/reset.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/reset.c	2006-03-09 =
16:25:47.000000000 -0800=0A=
@@ -0,0 +1,67 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Reset EB365 board.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/mm.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <asm/processor.h>=0A=
+#include <asm/reboot.h>=0A=
+#include <asm/system.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32365.h>=0A=
+extern void (*flush_cache_all)(void);=0A=
+=0A=
+void rc32300_restart(char *command)=0A=
+{=0A=
+	set_c0_status((ST0_BEV | ST0_ERL));=0A=
+	set_c0_config(CONF_CM_UNCACHED);=0A=
+	flush_cache_all();=0A=
+	write_c0_wired(0);=0A=
+=0A=
+	rc32300_writel(0x80000001, RESET_CNTL);=0A=
+}=0A=
+=0A=
+void rc32300_halt(void)=0A=
+{=0A=
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");=0A=
+	while (1)=0A=
+		__asm__(".set\tmips3\n\t"=0A=
+	                "wait\n\t"=0A=
+			".set\tmips0");=0A=
+}=0A=
+=0A=
+void rc32300_power_off(void)=0A=
+{=0A=
+	rc32300_halt();=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/serial.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/serial.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/serial.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/serial.c	2006-03-09 =
16:25:47.000000000 -0800=0A=
@@ -0,0 +1,74 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Serial port initialisation.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/tty.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serial_core.h>=0A=
+=0A=
+#include <asm/time.h>=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/irq.h>=0A=
+#include <asm/serial.h>=0A=
+=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+extern int __init early_serial_setup(struct uart_port *port);=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+extern int __init setup_serial_port(void)=0A=
+{ =0A=
+	static struct uart_port serial_req[2];=0A=
+=0A=
+	memset(serial_req, 0, sizeof(serial_req));=0A=
+	serial_req[0].type       =3D PORT_16550A;=0A=
+	serial_req[0].line       =3D 0;=0A=
+	serial_req[0].irq        =3D RC32300_UART0_IRQ;=0A=
+	serial_req[0].flags      =3D STD_COM_FLAGS;=0A=
+	serial_req[0].uartclk    =3D idt_cpu_freq;=0A=
+	serial_req[0].iotype     =3D SERIAL_IO_MEM;=0A=
+	serial_req[0].membase    =3D (char *) =
KSEG1ADDR(RC32300_UART0_BASE);=0A=
+	serial_req[0].mapbase   =3D KSEG1ADDR(RC32300_UART0_BASE);=0A=
+	serial_req[0].regshift   =3D 2;=0A=
+	=0A=
+	early_serial_setup(&serial_req[0]);=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/serial_gdb.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/serial_gdb.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/serial_gdb.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/serial_gdb.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,236 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *      EB365 specific polling driver for 16550 UART.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/serial_reg.h>=0A=
+=0A=
+/* set remote gdb baud rate at 115200 */=0A=
+=0A=
+#define GDB_BAUD 115200=0A=
+#define CONS_BAUD 9600=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+=0A=
+/* turn this on to watch the debug protocol echoed on the console port =
*/=0A=
+#define DEBUG_REMOTE_DEBUG=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define CONS_PORT 0xb8050003u=0A=
+#define GDB_PORT  0xb8050003u=0A=
+#else=0A=
+#define CONS_PORT 0xb8050000u=0A=
+#define GDB_PORT  0xb8050000u=0A=
+#endif=0A=
+           =0A=
+volatile unsigned char *ports[2] =3D {=0A=
+	(volatile unsigned char *)CONS_PORT,=0A=
+	(volatile unsigned char *)GDB_PORT=0A=
+};=0A=
+=0A=
+=0A=
+void reset_gdb_port(void);=0A=
+void cons_putc(char c);=0A=
+int port_getc(int port);=0A=
+void port_putc(int port, char c);=0A=
+=0A=
+int cons_getc(void)=0A=
+{=0A=
+	return port_getc(0);=0A=
+}=0A=
+=0A=
+void cons_putc(char c)=0A=
+{=0A=
+	port_putc(0, c);=0A=
+}=0A=
+=0A=
+void cons_puts(char *s)=0A=
+{=0A=
+	while(*s) {=0A=
+		if(*s =3D=3D '\n') cons_putc('\r');=0A=
+		cons_putc(*s);=0A=
+		s++;=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_do_putn(int n)=0A=
+{=0A=
+	if(n) {=0A=
+		cons_do_putn(n / 10);=0A=
+		cons_putc(n % 10 + '0');=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_putn(int n)=0A=
+{=0A=
+	if(n < 0) {=0A=
+		cons_putc('-');=0A=
+		n =3D -n;=0A=
+	}=0A=
+=0A=
+	if (n =3D=3D 0) {=0A=
+		cons_putc('0');=0A=
+	} else {=0A=
+		cons_do_putn(n);=0A=
+	}=0A=
+}=0A=
+=0A=
+static int first =3D 1;=0A=
+=0A=
+int getDebugChar(void)=0A=
+{=0A=
+	int c;=0A=
+=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+	c =3D port_getc(1);=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+	int c;=0A=
+=0A=
+	while((*(port + UART_LSR * 4) & UART_LSR_DR) =3D=3D 0) {=0A=
+		continue;=0A=
+	}       	=0A=
+=0A=
+	c =3D *(port + UART_RX * 4);=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc_ready(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+=0A=
+	return *(port + UART_LSR * 4) & UART_LSR_DR;=0A=
+}=0A=
+=0A=
+int isDebugReady(void)=0A=
+{=0A=
+	return port_getc_ready(1);=0A=
+}=0A=
+=0A=
+void putDebugChar(char c)=0A=
+{=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+	port_putc(1, c);=0A=
+}=0A=
+=0A=
+#define OK_TO_XMT (UART_LSR_TEMT | UART_LSR_THRE)=0A=
+=0A=
+void port_putc(int p, char c)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+	volatile unsigned char *lsr =3D port + UART_LSR * 4;=0A=
+=0A=
+	while((*lsr & OK_TO_XMT) !=3D OK_TO_XMT) {=0A=
+		continue;=0A=
+	}=0A=
+=0A=
+	*(port + UART_TX * 4) =3D c;=0A=
+}=0A=
+=0A=
+void reset_gdb_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[1];=0A=
+	unsigned int DIVISOR =3D (idt_cpu_freq / 16 / GDB_BAUD);=0A=
+=0A=
+	first =3D 0;=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	cons_puts("\n");=0A=
+	cons_puts("reset_gdb_port: initializing remote debug serial port =
(internal UART 0, baud=3D");=0A=
+	cons_putn(GDB_BAUD);=0A=
+	cons_puts(", MHz=3D");=0A=
+	cons_putn(idt_cpu_freq);=0A=
+	cons_puts(", divisor=3D");=0A=
+	cons_putn(DIVISOR);=0A=
+	cons_puts(")\n");=0A=
+#endif=0A=
+=0A=
+	/* wait for pending transfer to finish */=0A=
+	while((*(port + UART_LSR * 4) & OK_TO_XMT) !=3D OK_TO_XMT);=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + UART_CSR * 4) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + UART_FCR * 4) =3D UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR =
| =0A=
+		UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+	*(port + UART_DLL * 4) =3D DIVISOR;=0A=
+	*(port + UART_DLM * 4) =3D DIVISOR >> 8;=0A=
+=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + UART_IER * 4) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + UART_MCR * 4) =3D 0;=0A=
+}=0A=
+=0A=
+void reset_cons_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[0];=0A=
+	unsigned int DIVISOR =3D (idt_cpu_freq / 16 / CONS_BAUD);=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + UART_CSR * 4) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + UART_FCR * 4) =3D UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR =
| =0A=
+		UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+=0A=
+	*(port + UART_DLL * 4) =3D DIVISOR;=0A=
+	*(port + UART_DLM * 4) =3D DIVISOR >> 8;=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + UART_IER * 4) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + UART_MCR * 4) =3D 0;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/setup.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/setup.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/setup.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/setup.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,157 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     setup routines for IDT EB365 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/pm.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/tty.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serial_core.h>=0A=
+=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/irq.h>=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/eisa.h>=0A=
+#include <linux/hdreg.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <linux/console.h>=0A=
+#include <linux/fb.h>=0A=
+#include <linux/tty.h>=0A=
+=0A=
+#include <asm/reboot.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+extern void (*board_time_init)(void);=0A=
+extern void (*board_timer_setup)(struct irqaction *irq);=0A=
+extern void rc32300_time_init(void);=0A=
+extern void rc32300_timer_setup(struct irqaction *irq);=0A=
+extern char * __init prom_getcmdline(void);=0A=
+=0A=
+extern void rc32300_restart(char *);=0A=
+extern void rc32300_halt(void);=0A=
+extern void rc32300_power_off(void);=0A=
+=0A=
+unsigned int cedar_za;=0A=
+=0A=
+#define DIG0 ((volatile unsigned char *)0xAC000003)=0A=
+#define DIG1 ((volatile unsigned char *)0xAC000002)=0A=
+#define DIG2 ((volatile unsigned char *)0xAC000001)=0A=
+#define DIG3 ((volatile unsigned char *)0xAC000000)=0A=
+=0A=
+void idt_disp_char(int i, char c)=0A=
+{=0A=
+	switch (i) {=0A=
+	case 0: *DIG0 =3D c; break;=0A=
+	case 1: *DIG1 =3D c; break;=0A=
+	case 2: *DIG2 =3D c; break;=0A=
+	case 3: *DIG3 =3D c; break;=0A=
+	default: *DIG0 =3D '?'; break;=0A=
+	}=0A=
+}=0A=
+=0A=
+void idt_disp_str(char *s)=0A=
+{=0A=
+	int i;=0A=
+  =0A=
+	if (s =3D=3D 0) {=0A=
+		idt_disp_char(0, 0x20);=0A=
+		idt_disp_char(1, 0x20);=0A=
+		idt_disp_char(2, 0x20);=0A=
+		idt_disp_char(3, 0x20);=0A=
+	} =0A=
+	else {=0A=
+		for (i =3D 0; i < 4; i++) {=0A=
+			if (s[i]) =0A=
+				idt_disp_char(i, s[i]);=0A=
+		}=0A=
+	}=0A=
+}=0A=
+=0A=
+static int __init idt_setup(void)=0A=
+{=0A=
+	char* argptr;=0A=
+	idt_disp_str("Unix");=0A=
+	=0A=
+	argptr =3D prom_getcmdline();=0A=
+=0A=
+#ifdef CONFIG_SERIAL_8250_CONSOLE=0A=
+	if ((argptr =3D strstr(argptr, "console=3D")) =3D=3D NULL) {=0A=
+	  argptr =3D prom_getcmdline();=0A=
+	  strcat(argptr, " console=3DttyS0,9600");=0A=
+	}=0A=
+#endif=0A=
+=0A=
+	board_time_init =3D rc32300_time_init;=0A=
+	board_timer_setup =3D rc32300_timer_setup;=0A=
+=0A=
+	_machine_restart =3D rc32300_restart;=0A=
+	_machine_halt =3D rc32300_halt;=0A=
+	pm_power_off =3D rc32300_power_off;=0A=
+=0A=
+	set_io_port_base(KSEG1);=0A=
+=0A=
+	write_c0_wired(0);=0A=
+=0A=
+	/* Disable Watchdog timer */=0A=
+	rc32300_writel(0, 0xb802803c);=0A=
+=0A=
+	/* Revision ZA? */=0A=
+	cedar_za =3D (rc32300_readl(0xb8000018) & 0xff) ? 0 : 1;=0A=
+=0A=
+	if (cedar_za)=0A=
+		idt_disp_str("ZA  ");=0A=
+	else=0A=
+		idt_disp_str("  ZB");=0A=
+=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+//early_initcall(idt_setup);=0A=
+void __init plat_setup(void){=0A=
+  idt_setup();=0A=
+}=0A=
+=0A=
+int page_is_ram(unsigned long pagenr)=0A=
+{=0A=
+  return 1;=0A=
+}=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/time.c =
idtlinux/arch/mips/idt-boards/rc32300/EB365/time.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/EB365/time.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/EB365/time.c	2006-03-09 =
16:25:48.000000000 -0800=0A=
@@ -0,0 +1,140 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     timer routines for IDT EB365 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ * =0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/spinlock.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <linux/irq.h>=0A=
+#include <linux/timex.h>=0A=
+=0A=
+#include <linux/param.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/hardirq.h>=0A=
+=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/debug.h>=0A=
+#include <asm/time.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+static unsigned long r4k_offset; /* Amount to incr compare reg each =
time */=0A=
+static unsigned long r4k_cur;    /* What counter should be at next =
timer irq */=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+#if defined(CONFIG_MIPS_RTC)=0A=
+extern void rtc_ds1553_init(void);=0A=
+#endif=0A=
+=0A=
+/* =0A=
+ * Figure out the r4k offset, the amount to increment the compare=0A=
+ * register for each time tick. There is no RTC available.=0A=
+ *=0A=
+ * The RC32300 counts at half the CPU *core* speed.=0A=
+ */=0A=
+static unsigned long __init cal_r4koff(void)=0A=
+{=0A=
+	mips_hpt_frequency =3D idt_cpu_freq * IDT_CLOCK_MULT / 2;=0A=
+	return (mips_hpt_frequency / HZ);=0A=
+}=0A=
+=0A=
+=0A=
+void __init rc32300_time_init(void)=0A=
+{=0A=
+	unsigned int est_freq, flags;=0A=
+	=0A=
+	local_irq_save(flags);=0A=
+	=0A=
+	printk("calculating r4koff... ");=0A=
+	r4k_offset =3D cal_r4koff();=0A=
+	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);=0A=
+  =0A=
+	est_freq =3D 2*r4k_offset*HZ;	=0A=
+	est_freq +=3D 5000;    /* round */=0A=
+	est_freq -=3D est_freq%10000;=0A=
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000, =0A=
+	       (est_freq%1000000)*100/1000000);=0A=
+	local_irq_restore(flags);=0A=
+  =0A=
+#if defined(CONFIG_MIPS_RTC)=0A=
+	rtc_ds1553_init();=0A=
+#endif=0A=
+=0A=
+}=0A=
+=0A=
+=0A=
+void __init rc32300_timer_setup(struct irqaction *irq)=0A=
+{=0A=
+	setup_irq(MIPS_CPU_TIMER_IRQ, irq);=0A=
+  =0A=
+  /* to generate the first timer interrupt */=0A=
+	r4k_cur =3D (read_c0_count() + r4k_offset);=0A=
+	write_c0_compare(r4k_cur);=0A=
+}=0A=
+=0A=
+static inline void ack_r4ktimer(unsigned long newval)=0A=
+{=0A=
+	write_c0_compare(newval);=0A=
+}=0A=
+=0A=
+extern void idt_disp_char(int i,char c);=0A=
+=0A=
+asmlinkage void idt_timer_interrupt(int irq,struct pt_regs *regs)=0A=
+{ =0A=
+#ifdef CONFIG_KGDB=0A=
+	void kgdb_check(void);=0A=
+#endif=0A=
+=0A=
+	static unsigned int timerCount =3D 0;=0A=
+	static int toggle =3D 0;=0A=
+	=0A=
+	irq_enter();=0A=
+	kstat_this_cpu.irqs[irq]++;=0A=
+	=0A=
+	if( (timerCount++ % HZ) =3D=3D 0)=0A=
+	{ =0A=
+		toggle ^=3D 1;=0A=
+		idt_disp_char(0,toggle ? 'u' :'U');=0A=
+	}=0A=
+	=0A=
+	timer_interrupt(irq, NULL, regs);=0A=
+	irq_exit();=0A=
+=0A=
+#ifdef CONFIG_KGDB=0A=
+	kgdb_check();=0A=
+#endif=0A=
+}=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/csu_idt.S =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/csu_idt.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/csu_idt.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/csu_idt.S	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,412 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialization code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+=0A=
+#include "iregdef.h"=0A=
+#include "idtcpu.h"=0A=
+#include "idthdr.h"=0A=
+=0A=
+#define MHZ CONFIG_IDT_BOARD_FREQ=0A=
+=0A=
+#include "s364.h"=0A=
+=0A=
+#if defined (S334A)=0A=
+#include "s334aram.h"=0A=
+#elif defined (S334)=0A=
+#include "s334ram.h"=0A=
+#endif	=0A=
+=0A=
+#define IndexInvalidate_I       0x00=0A=
+=0A=
+/*--------------------------------------------------------------=0A=
+** prom entry point table=0A=
+*-------------------------------------------------------------*/=0A=
+FRAME(start,sp,0,ra)=0A=
+	j idtstart=0A=
+=0A=
+idtstart:=0A=
+	.set	noreorder=0A=
+=0A=
+#if defined(CPU_R32364)=0A=
+	li	t0,PORT_WIDTH_CONTROL=0A=
+	li	t1,PORT_SETUP=0A=
+	sw	t1,0x0(t0)=0A=
+	li	t0,BTA_CONTROL=0A=
+	li	t1,BTA_SETUP=0A=
+	sw	t1,0x0(t0)=0A=
+	li	t0,SYS_BTA_CTRL=0A=
+	sw	t1,0x0(t0)=0A=
+#if MHZ > 50000000=0A=
+	li      t0,SYS_ALT_CTRL=0A=
+        li      t1,SYS_ALT_SETUP=0A=
+        sw      t1,0x0(t0)=0A=
+#endif=0A=
+        li      v0,0x00=0A=
+	or	v0,(SR_CU0|SR_BEV|SR_DE)=0A=
+#endif=0A=
+	mtc0	v0,C0_SR		# state unknown on reset=0A=
+	mtc0	zero,C0_CAUSE		# clear software interrupts=0A=
+=0A=
+#ifdef S334=0A=
+	/* initialize the PIO Direction for UART RC32334/2*/=0A=
+#define PIO_BASE_ADDR     0xb8000600=0A=
+#define PIO_DC_SET        0x00500050=0A=
+#define PIO_DC_MASK       0xff0fff0f=0A=
+=0A=
+	li      t0,PIO_BASE_ADDR=0A=
+	lw      t1,0x4(t0)=0A=
+	nop=0A=
+	li      t2,PIO_DC_MASK          #mask the UART bits=0A=
+	and     t1,t1,t2=0A=
+	nop=0A=
+	li      t2,PIO_DC_SET           #rx0=3Drx1=3Dinput, =
tx0=3Dtx1=3Doutput=0A=
+	or      t1,t1,t2=0A=
+	nop=0A=
+	sw      t1,0x4(t0)=0A=
+=0A=
+	/*  disable the PCI bus error */=0A=
+        lui     t1,0xb800=0A=
+	ori     t1,t1,0x10=0A=
+	nop=0A=
+	lw      t0,0x0(t1)=0A=
+	nop=0A=
+	nop=0A=
+	ori     t0,t0,0x80=0A=
+	nop=0A=
+	sw      t0,0x0(t1)=0A=
+	nop=0A=
+	nop=0A=
+	nop=0A=
+#endif=0A=
+=0A=
+#if defined(CPU_R4000) || defined(CPU_R32364)=0A=
+	mfc0	v1,C0_CONFIG=0A=
+	/* Set cache mode: write-back */=0A=
+	li	v0, CFG_C_NCHRNT_WB  /* CFG_C_NCHRNT_WB CFG_C_NCHRNT_WT_NWA =
CFG_C_UNCACHED */=0A=
+	and	v1,~(0x7)=0A=
+	or	v1,v1,v0=0A=
+	mtc0	v1,C0_CONFIG=0A=
+	nop=0A=
+	nop=0A=
+	li	t0,MEM_BASE_BASE	/* load 2 base address registers' base */=0A=
+=0A=
+	li	t1,MBA_REG0		/* load into  memory base address register 0 */=0A=
+	sw	t1,0x0(t0)		/* set the memory base address register for Chip =
Select 0 - EPROM */=0A=
+=0A=
+	li	t1,MBM_REG0		/* load into  memory base mask register 0 */=0A=
+	sw	t1,0x4(t0)		/* set the memory base mask register for Chip Select 0 =
- EPROM */=0A=
+=0A=
+=0A=
+	li	t0,MEM_CTL_BASE		/* load all control registers' base address */=0A=
+=0A=
+	li      t1,MCR_CS0_BS           /* load  memory control register chip =
select 0 bit settings */=0A=
+	sw	t1,0x0(t0)		/* set the control register for Chip Select 0 - EPROM =
*/=0A=
+=0A=
+	nop=0A=
+=0A=
+	li	t1,MCR_CS1_BS		/* load into upper half memory control register =
chip select 1 bit settings */=0A=
+	sw	t1,0x4(t0)		/* set the control register for Chip Select 1 - SRAM =
*/=0A=
+	nop=0A=
+#ifdef S334=0A=
+	li      t1,MCR_CS2_BS           /* initialize CHIP-SELECT2 */=0A=
+        sw      t1,0x08(t0)=0A=
+	nop=0A=
+=0A=
+	li      t1,MCR_CS3_BS           /* initialize CHIP-SELECT3 */=0A=
+        sw      t1,0x0C(t0)=0A=
+	nop=0A=
+=0A=
+	li      t1,MCR_CS4_BS           /* initialize CHIP-SELECT4 for LED =
*/=0A=
+	sw      t1,0x10(t0)=0A=
+	nop=0A=
+=0A=
+#endif=0A=
+	li	t1,MCR_CS5_BS		/* load into upper half memory control register =
chip select 5 bit settings */=0A=
+	sw	t1,0x14(t0)		/* set the control register for Chip Select 5 - =
External UART */=0A=
+	nop=0A=
+=0A=
+/*------------ load all R32 internal registers' base address =
----------*/=0A=
+	li	t0,R32134_IREG_BASE	/* load t0 with all R32134 internal registers' =
base address */=0A=
+=0A=
+/* ------------------- Disable WatchDog Timer =
--------------------------------- */=0A=
+	li	t1,DISABLE_TIMER=0A=
+	sw	t1,0x730(t0)=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_ONLY || MEMCFG =3D=3D SRAM_N_SDRAM || MEMCFG =
=3D=3D SDRAM_N_SRAM=0A=
+/*--------------- disable EDO Controller =
---------------------------*/=0A=
+	li	t1,0			/* EDO_CR_BS load EDO control register bit settings in t1 =
*/=0A=
+	sw	t1,0x310(t0)		/* Disable  EDO control register */=0A=
+=0A=
+#elif MEMCFG =3D=3D EDO_ONLY || MEMCFG =3D=3D SRAM_N_EDO || MEMCFG =
=3D=3D EDO_N_SRAM=0A=
+/*------------------------- disable SDRAM Controller =
--------------------------*/=0A=
+	li	t1,0=0A=
+	sw	t1,0x300(t0)=0A=
+#endif /* MEMCFG =3D=3D EDO_ONLY || MEMCFG =3D=3D SRAM_N_EDO || MEMCFG =
=3D=3D EDO_N_SRAM */=0A=
+=0A=
+#if MEMCFG !=3D SRAM_ONLY=0A=
+/*-------------- Initialize SDRAM or EDO Base and Mask Registers =
----------*/=0A=
+=0A=
+	li	t1,DRAM_BNK0_BASE	/* load DRAM bank 0 physical address in t1 */=0A=
+	sw	t1,0xC0(t0)		/* set DRAM bank 0 base */=0A=
+	li	t1,DRAM_BNK1_BASE	/* load DRAM bank 1 physical address in t1 */=0A=
+	sw	t1,0xC8(t0)		/* set DRAM bank 1 base */=0A=
+	li	t1,DRAM_BNK2_BASE	/* load DRAM bank 2 physical address in t1 */=0A=
+	sw	t1,0xD0(t0)		/* set DRAM bank 2 base */=0A=
+	li	t1,DRAM_BNK3_BASE	/* load DRAM bank 3 physical address in t1 */=0A=
+	sw	t1,0xD8(t0)		/* set DRAM bank 3 base */=0A=
+=0A=
+	li	t1,DRAM_BNK0_MASK	/* load DRAM bank 0 size in t1 */=0A=
+	sw	t1,0xC4(t0)		/* set DRAM bank 0 mask */=0A=
+	li	t1,DRAM_BNK1_MASK	/* load DRAM bank 1 size in t1 */=0A=
+	sw	t1,0xCC(t0)		/* set DRAM bank 1 mask */=0A=
+	li	t1,DRAM_BNK2_MASK	/* load DRAM bank 2 size in t1 */=0A=
+	sw	t1,0xD4(t0)		/* set DRAM bank 2 mask */=0A=
+	li	t1,DRAM_BNK3_MASK	/* load DRAM bank 3 size in t1 */=0A=
+	sw	t1,0xDC(t0)		/* set DRAM bank 3 mask */=0A=
+=0A=
+#if  MEMCFG =3D=3D SRAM_N_SDRAM || MEMCFG =3D=3D SRAM_N_EDO || MEMCFG =
=3D=3D SDRAM_N_SRAM || MEMCFG =3D=3D EDO_N_SRAM=0A=
+/* ------------------------------- Setup SRAM if in place =
-----------------------------------------*/=0A=
+	li	t0,MEM_BASE_BASE	/* load 2 base address registers' base */=0A=
+	li	t1,MBA_REG1		/* load into memory base address register 1 */=0A=
+	sw	t1,0x8(t0)		/* set the memory base address register for Chip =
Select 1 - SRAM */=0A=
+=0A=
+	li	t1,MBM_REG1		/* load into memory base mask register 1 */=0A=
+	sw	t1,0xC(t0)		/* set the memory base mask register for Chip Select 1 =
- SRAM */=0A=
+#endif /*  MEMCFG =3D=3D SRAM_N_SDRAM || MEMCFG =3D=3D SRAM_N_EDO || =
MEMCFG =3D=3D SDRAM_N_SRAM || MEMCFG =3D=3D EDO_N_SRAM*/=0A=
+=0A=
+#if MEMCFG =3D=3D EDO_ONLY || MEMCFG =3D=3D SRAM_N_EDO || MEMCFG =
=3D=3D EDO_N_SRAM=0A=
+/*-------------- Set EDO control register =
--------------------------*/=0A=
+	li	t1,EDO_CR_BS		/* load EDO control register bit settings in t1 =
*/=0A=
+	sw	t1,0x310(t0)		/* set EDO control register */=0A=
+#endif /* MEMCFG =3D=3D EDO_ONLY || MEMCFG =3D=3D SRAM_N_EDO || MEMCFG =
=3D=3D EDO_N_SRAM */=0A=
+=0A=
+/*-------------- Setup and Enable Refresh Timer =
--------------------*/=0A=
+	li	t0,TIMER_BASE		/* load timer register set base */=0A=
+=0A=
+	li	t1,DISABLE_TIMER	/* load diable timer bit settings into t1 */=0A=
+	sw	t1,0x60(t0)		/* disable timer */=0A=
+        nop=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_ONLY || MEMCFG =3D=3D SRAM_N_SDRAM || MEMCFG =
=3D=3D SDRAM_N_SRAM=0A=
+/*-------------- Enable SDRAM Controller =
---------------------------*/=0A=
+	li	t0,R32134_IREG_BASE=0A=
+	li	t1,SDRAM_CR_BS=0A=
+	sw	t1,0x300(t0)=0A=
+        nop=0A=
+/*-------------- Delay Loop =
----------------------------------------*/=0A=
+	li	v0,10000	/* 8x256us */=0A=
+1:	bne	v0,zero,1b=0A=
+	subu	v0,1		/* BDSLOT  */=0A=
+	nop=0A=
+	nop=0A=
+/*-------------- Setup Precharge Command =
---------------------------*/=0A=
+	li	t2,2=0A=
+	li	t3,0=0A=
+1:	li	t1,SDRAM_PC_VAL=0A=
+	sw	t1,0x300(t0)=0A=
+	nop=0A=
+	nop=0A=
+	lw	t7,0x300(t0)=0A=
+	nop=0A=
+	li	t4,APATTERN=0A=
+#ifdef S334=0A=
+#if DRAMSZ !=3D MB32SO=0A=
+	li	t5,0xA0000000 | DRAM_BNK0_BASE=0A=
+#else=0A=
+#ifdef S334A=0A=
+	li	t5,0xA0000000 | DRAM_BNK0_BASE=0A=
+#else=0A=
+	li	t5,0xA0000000 | DRAM_BNK3_BASE=0A=
+#endif=0A=
+#endif=0A=
+#else=0A=
+	li	t5,0xA0000000 | DRAM_BNK0_BASE=0A=
+#endif=0A=
+	sw	t4,0x0(t5)=0A=
+	addu	t3,1=0A=
+	bne	t3,t2,1b=0A=
+	nop=0A=
+#ifdef S334=0A=
+/*-------------- Setup Refresh Command =
-----------------------------*/=0A=
+	li	t2,8=0A=
+	li	t3,0=0A=
+1:	li	t1,SDRAM_RFRSH_CMD=0A=
+	sw	t1,0x300(t0)=0A=
+	sw	t4,0x0(t5)	/* note: t5 not disturbed */=0A=
+	addu	t3,1=0A=
+	bne	t3,t2,1b=0A=
+	nop=0A=
+#endif=0A=
+/*-------------- Setup up to write to Mode Register =
----------------*/=0A=
+	li	t1,SDRAM_MODE_REG=0A=
+	sw	t1,0x300(t0)=0A=
+#ifdef S1254=0A=
+	addu	t5,0xC0		/* CAS Latency of 3 */=0A=
+#else=0A=
+	addu	t5,0x80=0A=
+#endif=0A=
+	sw	t4,0x0(t5)=0A=
+#ifdef S334=0A=
+	ori     t1,t1,0xff=0A=
+	sw      t1,0x300(t0)=0A=
+=0A=
+/* Set Secondary SDRAM Control register based on revision */=0A=
+	lw      t1,0x18(t0)     /* get SysID */=0A=
+  	andi    t1,0xf0		/* BD slot */=0A=
+  	beqz    t1,2f           /* skip if Z part */=0A=
+  	li      t3,0x10=0A=
+  	beq     t1,t3,1f      	/* Y part? */=0A=
+  	li      t2,0x2        	/* BD slot */=0A=
+  	ori     t2,0x200       	/* Add tWR for X part */=0A=
+1:=0A=
+  	sw      t2, 0x304(t0)   /* set secondary SDRAM control register =
*/=0A=
+        nop=0A=
+2:=0A=
+#endif=0A=
+#endif /* MEMCFG =3D=3D SDRAM_ONLY || MEMCFG =3D=3D SRAM_N_SDRAM || =
MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+/*-------------- Setup and Enable Refresh Timer --------------------*/=0A=
+=0A=
+	li	t0,TIMER_BASE		/* load timer register set base */=0A=
+=0A=
+	li	t1,0			/* load DRAM refresh timer count register bit settings in =
t1 */=0A=
+	sw	t1,0x64(t0)		/* set DRAM refresh timer count register bit settings =
*/=0A=
+=0A=
+	li	t1,DRAM_RF_CMPR_BS	/* load DRAM refresh timer compare register bit =
settings in t1 */=0A=
+	sw	t1,0x68(t0)		/* set DRAM refresh timer compare register bit =
settings */=0A=
+=0A=
+	li	t1,CPU_BERR_BS=0A=
+	sw	t1,0x48(t0)=0A=
+	li	t1,IP_BERR_BS=0A=
+	sw	t1,0x58(t0)=0A=
+=0A=
+	li	t1,ENABLE_TIMER		/* load timer enable bit */=0A=
+	sw	t1,0x60(t0)		/* enable refresh timer */=0A=
+#ifdef S334=0A=
+	/* the memory system may need  some time to start up... */=0A=
+	li	v0,10000	/* 8x256us */=0A=
+1:	bne	v0,zero,1b=0A=
+	subu	v0,1		/* BDSLOT  */=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+	li	t1,DRAM_RF_CMPR_SE_BS	/* load refresh timer compare value for =
slower expiration */=0A=
+	sw	t1,0x68(t0)		/* set compare register again */=0A=
+#else=0A=
+#if MEMCFG =3D=3D EDO_ONLY || MEMCFG =3D=3D EDO_N_SRAM || MEMCFG =
=3D=3D SRAM_N_EDO=0A=
+	/* the memory system may need up to 120us to start up... */=0A=
+	li	v0,128		/* ~256us */=0A=
+1:	bne	v0,zero,1b=0A=
+	subu	v0,1		/* BDSLOT  */=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+	li	t1,DRAM_RF_CMPR_SE_BS	/* load refresh timer compare value for =
slower expiration */=0A=
+	sw	t1,0x68(t0)		/* set compare register again */=0A=
+#endif /* MEMCFG =3D=3D EDO_ONLY || MEMCFG =3D=3D EDO_N_SRAM || MEMCFG =
=3D=3D SRAM_N_EDO */=0A=
+#endif=0A=
+=0A=
+#endif /* MEMCFG !=3D SRAM_ONLY */=0A=
+#if MEMCFG =3D=3D SRAM_ONLY=0A=
+/* ------------------------------- Setup SRAM if in place =
-----------------------------------------*/=0A=
+=0A=
+/*=0A=
+** write some thing else in DRAM BANK 0 BASE address first since it =
has 0 by default.=0A=
+*/=0A=
+	li	t1,0x01000000	/* load DRAM bank 0 physical address in t1 */=0A=
+	sw	t1,0xC0(t0)		/* set DRAM bank 0 base */=0A=
+=0A=
+	li	t0,MEM_BASE_BASE	/* load 2 base address registers' base */=0A=
+	li	t1,MBA_REG1		/* load into memory base address register 1 */=0A=
+	sw	t1,0x8(t0)		/* set the memory base address register for Chip =
Select 1 - SRAM */=0A=
+=0A=
+	li	t1,MBM_REG1		/* load into memory base mask register 1 */=0A=
+	sw	t1,0xC(t0)		/* set the memory base mask register for Chip Select 1 =
- SRAM */=0A=
+#endif /* MEMCFG =3D=3D SRAM_ONLY */=0A=
+=0A=
+=0A=
+#endif /* (CPU_R4000) || defined(CPU_R32364) */=0A=
+=0A=
+#if defined(S364)=0A=
+=0A=
+/*=0A=
+** before doing anything=0A=
+** initialize the section of memory used by cache initialization=0A=
+** whenever you boot out of ROM or reset-vector=0A=
+** This assumed to be 1MB.=0A=
+** --Sugan (11-22-96)=0A=
+*/=0A=
+	li	t0, 0xa0000000=0A=
+	li	t1, 0xa0100000=0A=
+1:=0A=
+        sw      zero,0x00(t0)=0A=
+        sw      zero,0x04(t0)=0A=
+        sw      zero,0x08(t0)=0A=
+        sw      zero,0x0c(t0)=0A=
+	addiu	t0,16		# DO NOT put this instruction in the=0A=
+                                # delay slot of "blt t0,t1,1b" since =
it=0A=
+                                # will run over the 1M boundary for 16 =
byte=0A=
+	                        # more which would cause problem if we =
have=0A=
+	                        # exactly 1M memory available on board.=0A=
+	nop=0A=
+	blt	t0,t1,1b=0A=
+        nop=0A=
+	nop=0A=
+	nop=0A=
+3:=0A=
+	mfc0	t0,C0_SR=0A=
+	nop=0A=
+	nop=0A=
+	and	t0,~SR_BEV=0A=
+	mtc0	t0,C0_SR=0A=
+	nop=0A=
+	nop=0A=
+4:=0A=
+#endif=0A=
+=0A=
+	li	v0,100000		/* large delay */=0A=
+1:	subu	v0,1			/* BDSLOT  */=0A=
+	bne	v0,zero,1b=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+       la      k0, zstartup=0A=
+       j      k0=0A=
+       nop=0A=
+       nop=0A=
+=0A=
+ENDFRAME(start)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/head.S =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/head.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/head.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/head.S	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,134 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialisation code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/cacheops.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+#include <asm/regdef.h>=0A=
+=0A=
+#define IndexInvalidate_I       0x00=0A=
+=0A=
+	.set noreorder=0A=
+	.cprestore=0A=
+	LEAF(zstartup)=0A=
+zstartup:=0A=
+=0A=
+        la      sp, .stack=0A=
+	move	s0, a0=0A=
+	move	s1, a1=0A=
+	move	s2, a2=0A=
+	move	s3, a3=0A=
+=0A=
+	/* Clear BSS */=0A=
+	la	a0, .stack=0A=
+	la	a2, _end=0A=
+1:	sw	zero, 0(a0)=0A=
+	bne	a2, a0, 1b=0A=
+	addu	a0, 4=0A=
+#if 1=0A=
+	/* flush the I-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80002000  # end address (8KB I-Cache)=0A=
+	subu	k1, 128=0A=
+2:=0A=
+	.set mips3=0A=
+	cache	IndexInvalidate_I, 0(k0)=0A=
+	cache	IndexInvalidate_I, 16(k0)=0A=
+	cache	IndexInvalidate_I, 32(k0)=0A=
+	cache	IndexInvalidate_I, 48(k0)=0A=
+	cache	IndexInvalidate_I, 64(k0)=0A=
+	cache	IndexInvalidate_I, 80(k0)=0A=
+	cache	IndexInvalidate_I, 96(k0)=0A=
+	cache	IndexInvalidate_I, 112(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 2b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+#endif=0A=
+#if 1=0A=
+	/* flush the D-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80000400  # end address (2KB I-Cache)=0A=
+	subu	k1, 128=0A=
+3:	=0A=
+	.set mips3=0A=
+	/* First way */=0A=
+	cache	Index_Writeback_Inv_D, 0(k0)=0A=
+	cache	Index_Writeback_Inv_D, 16(k0)=0A=
+	cache	Index_Writeback_Inv_D, 32(k0)=0A=
+	cache	Index_Writeback_Inv_D, 48(k0)=0A=
+	cache	Index_Writeback_Inv_D, 64(k0)=0A=
+	cache	Index_Writeback_Inv_D, 80(k0)=0A=
+	cache	Index_Writeback_Inv_D, 96(k0)=0A=
+	cache	Index_Writeback_Inv_D, 112(k0)=0A=
+	/* Second way */=0A=
+	cache	Index_Writeback_Inv_D, 1024(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1040(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1056(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1072(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1088(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1104(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1120(k0)=0A=
+	cache	Index_Writeback_Inv_D, 1136(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 3b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+#endif=0A=
+	=0A=
+=0A=
+	la	ra, 4f=0A=
+	la	k0, decompress_kernel=0A=
+	jr	k0=0A=
+	nop=0A=
+4:=0A=
+=0A=
+	move	a0, s0=0A=
+	move	a1, s1=0A=
+	move	a2, s2=0A=
+	move	a3, s3=0A=
+	li	k0, KERNEL_ENTRY=0A=
+	jr	k0=0A=
+	nop=0A=
+5:=0A=
+	b 5b=0A=
+	END(zstartup)=0A=
+=0A=
+	.bss=0A=
+	.fill 0x2000=0A=
+	EXPORT(.stack)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/idtcpu.h =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/idtcpu.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/idtcpu.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/idtcpu.h	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,614 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#if defined(__IDTCPU_H__)=0A=
+#else=0A=
+#define __IDTCPU_H__=0A=
+=0A=
+=0A=
+/*=0A=
+** memory configuration and mapping=0A=
+*/=0A=
+#define K0BASE	0x80000000=0A=
+#define K0SIZE	0x20000000=0A=
+#define K1BASE	0xa0000000=0A=
+#define K1SIZE	0x20000000=0A=
+#define K2BASE	0xc0000000=0A=
+#if defined(S364)=0A=
+#define K2SIZE	0x3e000000=0A=
+#define ICEBASE	0xff000000=0A=
+#define ICESIZE	0x01000000=0A=
+#else=0A=
+#define K2SIZE	0x20000000=0A=
+#endif=0A=
+#if defined(CPU_R4000)=0A=
+#define KSBASE	0xe0000000=0A=
+#define KSSIZE	0x20000000=0A=
+#endif=0A=
+=0A=
+#define KUBASE	0=0A=
+#define KUSIZE	0x80000000=0A=
+=0A=
+/*=0A=
+** Exception Vectors=0A=
+*/=0A=
+#if defined(CPU_R3000)=0A=
+#define	UT_VEC	K0BASE			/* utlbmiss vector */=0A=
+#define E_VEC	(K0BASE+0x80)		/* exception vevtor */=0A=
+#endif=0A=
+#if defined(CPU_R4000) || defined S364  /*(CPU_R32364)      */=0A=
+#define	T_VEC	(K0BASE+0x000)		/* tlbmiss vector */=0A=
+#define X_VEC	(K0BASE+0x080)		/* xtlbmiss vector */=0A=
+#define C_VEC	(K1BASE+0x100)		/* cache error vector */=0A=
+#define E_VEC	(K0BASE+0x180)		/* exception vector */=0A=
+#define I_VEC	(K0BASE+0X200)		/* interrupt vector */=0A=
+#endif=0A=
+#define	R_VEC	(K1BASE+0x1fc00000)	/* reset vector */=0A=
+=0A=
+/*=0A=
+** Address conversion macros=0A=
+*/=0A=
+#ifdef CLANGUAGE=0A=
+#define	CAST(as) (as)=0A=
+#else=0A=
+#define	CAST(as)=0A=
+#endif=0A=
+#define	K0_TO_K1(x)	(CAST(unsigned)(x)|0xA0000000)	/* kseg0 to kseg1 =
*/=0A=
+#define	K1_TO_K0(x)	(CAST(unsigned)(x)&0x9FFFFFFF)	/* kseg1 to kseg0 =
*/=0A=
+#define	K0_TO_PHYS(x)	(CAST(unsigned)(x)&0x1FFFFFFF)	/* kseg0 to =
physical */=0A=
+#define	K1_TO_PHYS(x)	(CAST(unsigned)(x)&0x1FFFFFFF)	/* kseg1 to =
physical */=0A=
+#define	PHYS_TO_K0(x)	(CAST(unsigned)(x)|0x80000000)	/* physical to =
kseg0 */=0A=
+#define	PHYS_TO_K1(x)	(CAST(unsigned)(x)|0xA0000000)	/* physical to =
kseg1 */=0A=
+=0A=
+/*=0A=
+**	Cache size constants=0A=
+*/=0A=
+/* Sugan changed so that MINCACHE is 0x200 instead of 0x800 */=0A=
+#define	MINCACHE	0x200		/* 512 bytes  */=0A=
+#define	MAXCACHE	0x40000		/* 256*1024   256k */	=0A=
+=0A=
+#if defined CPU_R32364                  /* Includes RC32364, RC32332, =
RC32334 */=0A=
+#define	CFG_ICE		0x80000000	/* ICE detect */=0A=
+#define	CFG_ECMASK	0x70000000	/* System Clock Ratio */=0A=
+#define	CFG_ECBY2	0x00000000 	/* divide by 2 */=0A=
+#define	CFG_ECBY3	0x10000000 	/* divide by 3 */=0A=
+#define	CFG_ECBY4	0x20000000 	/* divide by 4 */=0A=
+#define	CFG_NBL		0x00800000	/* Non-Blocking load pending */=0A=
+#define	CFG_BE		0x00008000	/* Big Endian */=0A=
+#define	CFG_ICMASK	0x00000e00	/* Instruction cache size */=0A=
+#define	CFG_ICSHIFT	9=0A=
+#define	CFG_DCMASK	0x000001c0	/* Data cache size */=0A=
+#define	CFG_DCSHIFT	6=0A=
+#define	CFG_IB		0x00000020	/* Instruction cache line size */=0A=
+#define	CFG_DB		0x00000010	/* Data cache line size */=0A=
+#define	CFG_K0MASK	0x00000007	/* KSEG0 coherency algorithm */=0A=
+=0A=
+/*=0A=
+ * R32364 primary cache mode=0A=
+ */=0A=
+#define CFG_C_NCHRNT_WT_NWA	0=0A=
+#define CFG_C_NCHRNT_WT		1=0A=
+#define CFG_C_UNCACHED		2=0A=
+#define CFG_C_NCHRNT_WB		3=0A=
+=0A=
+/* Cache Operations */=0A=
+#define Index_Invalidate_I               0x0         /* 0       0 =
*/=0A=
+#define Index_Writeback_Inv_D            0x1         /* 0       1 =
*/=0A=
+#define Index_Invalidate_SI              0x2         /* 0       2 =
*/=0A=
+#define Index_Writeback_Inv_SD           0x3         /* 0       3 =
*/=0A=
+#define Index_Load_Tag_I                 0x4         /* 1       0 =
*/=0A=
+#define Index_Load_Tag_D                 0x5         /* 1       1 =
*/=0A=
+#define Index_Load_Tag_SI                0x6         /* 1       2 =
*/=0A=
+#define Index_Load_Tag_SD                0x7         /* 1       3 =
*/=0A=
+#define Index_Store_Tag_I                0x8         /* 2       0 =
*/=0A=
+#define Index_Store_Tag_D                0x9         /* 2       1 =
*/=0A=
+#define Index_Store_Tag_SI               0xA         /* 2       2 =
*/=0A=
+#define Index_Store_Tag_SD               0xB         /* 2       3 =
*/=0A=
+#define Create_Dirty_Exc_D               0xD         /* 3       1 =
*/=0A=
+#define Create_Dirty_Exc_SD              0xF         /* 3       3 =
*/=0A=
+#define Hit_Invalidate_I                 0x10        /* 4       0 =
*/=0A=
+#define Hit_Invalidate_D                 0x11        /* 4       1 =
*/=0A=
+#define Hit_Invalidate_SI                0x12        /* 4       2 =
*/=0A=
+#define Hit_Invalidate_SD                0x13        /* 4       3 =
*/=0A=
+#define Hit_Writeback_Inv_D              0x15        /* 5       1 =
*/=0A=
+#define Hit_Writeback_Inv_SD             0x17        /* 5       3 =
*/=0A=
+#define Fill_I                           0x14        /* 5       0 =
*/=0A=
+#define Hit_Writeback_D                  0x19        /* 6       1 =
*/=0A=
+#define Hit_Writeback_SD                 0x1B        /* 6       3 =
*/=0A=
+#define Hit_Writeback_I                  0x18        /* 6       0 =
*/=0A=
+#define Hit_Set_Virtual_SI               0x1E        /* 7       2 =
*/=0A=
+#define Hit_Set_Virtual_SD               0x1F        /* 7       3 =
*/=0A=
+#define CFG_EW32        0x00040000      /* 32 bit */=0A=
+#endif /* CPU_R32364 */=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+/* R4000 configuration register definitions */=0A=
+#define CFG_CM		0x80000000	/* Master-Checker mode */=0A=
+#define CFG_ECMASK	0x70000000	/* System Clock Ratio */=0A=
+#define CFG_ECBY2	0x00000000 	/* divide by 2 */=0A=
+#define CFG_ECBY3	0x10000000 	/* divide by 3 */=0A=
+#define CFG_ECBY4	0x20000000 	/* divide by 4 */=0A=
+#define CFG_EPMASK	0x0f000000	/* Transmit data pattern */=0A=
+#define CFG_EPD		0x00000000	/* D */=0A=
+#define CFG_EPDDX	0x01000000	/* DDX */=0A=
+#define CFG_EPDDXX	0x02000000	/* DDXX */=0A=
+#define CFG_EPDXDX	0x03000000	/* DXDX */=0A=
+#define CFG_EPDDXXX	0x04000000	/* DDXXX */=0A=
+#define CFG_EPDDXXXX	0x05000000	/* DDXXXX */=0A=
+#define CFG_EPDXXDXX	0x06000000	/* DXXDXX */=0A=
+#define CFG_EPDDXXXXX	0x07000000	/* DDXXXXX */=0A=
+#define CFG_EPDXXXDXXX	0x08000000	/* DXXXDXXX */=0A=
+#define CFG_SBMASK	0x00c00000	/* Secondary cache block size */=0A=
+#define CFG_SBSHIFT	22=0A=
+#define CFG_SB4		0x00000000	/* 4 words */=0A=
+#define CFG_SB8		0x00400000	/* 8 words */=0A=
+#define CFG_SB16	0x00800000	/* 16 words */=0A=
+#define CFG_SB32	0x00c00000	/* 32 words */=0A=
+#define CFG_SS		0x00200000	/* Split secondary cache */=0A=
+#define CFG_SW		0x00100000	/* Secondary cache port width */=0A=
+#define CFG_EWMASK	0x000c0000	/* System port width */=0A=
+#define CFG_EWSHIFT	18=0A=
+#define CFG_EW64	0x00000000	/* 64 bit */=0A=
+#define CFG_EW32	0x00040000	/* 32 bit */=0A=
+/* #if defined(CPU_R5000) */=0A=
+/* Sugan added for R5000 L2 cache 07-17-96 */=0A=
+#define L2_PAGESIZE	0x1000=0A=
+#define SIZE256K	0x00040000 /* 256KB in Hex */=0A=
+#define CFG_HARDL2	0x00020000 /* Hardware bit that enables/disables=0A=
+				      L2 cache */=0A=
+#define CFG_SE		0x1000=0A=
+#define CFG_SIZE512K	0x00000000 /* size of Scache is 512k */=0A=
+#define CFG_SIZE1MB 	0x00100000 /* size of Scache is 1MB */=0A=
+#define CFG_SIZE2MB 	0x00200000 /* size of Scache is 2MB */=0A=
+#define CFG_SIZEMASK	0x00300000 /* size mask */=0A=
+/* #endif */=0A=
+#define CFG_SC		0x00020000	/* Secondary cache absent */=0A=
+#define CFG_SM		0x00010000	/* Dirty Shared mode disabled */=0A=
+#define CFG_BE		0x00008000	/* Big Endian */=0A=
+#define CFG_EM		0x00004000	/* ECC mode enable */=0A=
+#define CFG_EB		0x00002000	/* Block ordering */=0A=
+#define CFG_ICMASK	0x00000e00	/* Instruction cache size */=0A=
+#define CFG_ICSHIFT	9=0A=
+#define CFG_DCMASK	0x000001c0	/* Data cache size */=0A=
+#define CFG_DCSHIFT	6=0A=
+#define CFG_IB		0x00000020	/* Instruction cache block size */=0A=
+#define CFG_DB		0x00000010	/* Data cache block size */=0A=
+#define CFG_CU		0x00000008	/* Update on Store Conditional */=0A=
+#define CFG_K0MASK	0x00000007	/* KSEG0 coherency algorithm */=0A=
+=0A=
+/*=0A=
+ * R4000 primary cache mode=0A=
+ */=0A=
+#define CFG_C_WRITETHROUGH_CACHE		0=0A=
+#define CFG_C_UNCACHED		2=0A=
+#define CFG_C_NONCOHERENT	3=0A=
+#define CFG_C_COHERENTXCL	4=0A=
+#define CFG_C_COHERENTXCLW	5=0A=
+#define CFG_C_COHERENTUPD	6=0A=
+=0A=
+/*=0A=
+ * R4000 cache operations (should be in assembler...?)=0A=
+ */=0A=
+#if defined(CPU_R5000)=0A=
+#define InvAllScache			 0x03	     /* 0	3 */=0A=
+#define IndexLoadTagScache		 0x07	     /* 1	3 */=0A=
+#define IndexStoreTagScache		 0x0b	     /* 2	3 */=0A=
+#define PageInvScache			 0x17	     /* 5	3 */=0A=
+#endif=0A=
+#define Index_Invalidate_I               0x0         /* 0       0 =
*/=0A=
+#define Index_Writeback_Inv_D            0x1         /* 0       1 =
*/=0A=
+#define Index_Invalidate_SI              0x2         /* 0       2 =
*/=0A=
+#define Index_Writeback_Inv_SD           0x3         /* 0       3 =
*/=0A=
+#define Index_Load_Tag_I                 0x4         /* 1       0 =
*/=0A=
+#define Index_Load_Tag_D                 0x5         /* 1       1 =
*/=0A=
+#define Index_Load_Tag_SI                0x6         /* 1       2 =
*/=0A=
+#define Index_Load_Tag_SD                0x7         /* 1       3 =
*/=0A=
+#define Index_Store_Tag_I                0x8         /* 2       0 =
*/=0A=
+#define Index_Store_Tag_D                0x9         /* 2       1 =
*/=0A=
+#define Index_Store_Tag_SI               0xA         /* 2       2 =
*/=0A=
+#define Index_Store_Tag_SD               0xB         /* 2       3 =
*/=0A=
+#define Create_Dirty_Exc_D               0xD         /* 3       1 =
*/=0A=
+#define Create_Dirty_Exc_SD              0xF         /* 3       3 =
*/=0A=
+#define Hit_Invalidate_I                 0x10        /* 4       0 =
*/=0A=
+#define Hit_Invalidate_D                 0x11        /* 4       1 =
*/=0A=
+#define Hit_Invalidate_SI                0x12        /* 4       2 =
*/=0A=
+#define Hit_Invalidate_SD                0x13        /* 4       3 =
*/=0A=
+#define Hit_Writeback_Inv_D              0x15        /* 5       1 =
*/=0A=
+#define Hit_Writeback_Inv_SD             0x17        /* 5       3 =
*/=0A=
+#define Fill_I                           0x14        /* 5       0 =
*/=0A=
+#define Hit_Writeback_D                  0x19        /* 6       1 =
*/=0A=
+#define Hit_Writeback_SD                 0x1B        /* 6       3 =
*/=0A=
+#define Hit_Writeback_I                  0x18        /* 6       0 =
*/=0A=
+#define Hit_Set_Virtual_SI               0x1E        /* 7       2 =
*/=0A=
+#define Hit_Set_Virtual_SD               0x1F        /* 7       3 =
*/=0A=
+=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** TLB resource defines=0A=
+*/=0A=
+=0A=
+#if defined(CPU_R32364)  =0A=
+#define	N_TLB_ENTRIES	16=0A=
+#endif =0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+#define N_TLB_ENTRIES  48=0A=
+#endif=0A=
+=0A=
+#if defined (CPU_R32364)=0A=
+#define	TLBHI_VPN2MASK	0xffffe000=0A=
+#define	TLBHI_PIDMASK	0x000000ff=0A=
+#define	TLBHI_NPID	256=0A=
+=0A=
+#define	TLBLO_PFNMASK	0x03ffffc0=0A=
+#define	TLBLO_PFNSHIFT	6=0A=
+#define	TLBLO_D		0x00000004	/* writeable */=0A=
+#define	TLBLO_V		0x00000002	/* valid bit */=0A=
+#define	TLBLO_G		0x00000001	/* global access bit */=0A=
+#define	TLBLO_CMASK	0x00000038	/* cache algorithm mask */=0A=
+#define	TLBLO_CSHIFT	3=0A=
+=0A=
+#define	TLBLO_UNCACHED		(CFG_C_UNCACHED<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WT_NWA	(CFG_C_NCHRNT_WT_NWA<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WT		(CFG_C_NCHRNT_WT<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WB		(CFG_C_NCHRNT_WB<<TLBLO_CSHIFT)=0A=
+=0A=
+#elif defined(CPU_R4000)=0A=
+#define	TLBHI_VPN2MASK	0xffffe000=0A=
+#define	TLBHI_PIDMASK	0x000000ff=0A=
+#define	TLBHI_NPID	256=0A=
+=0A=
+#define	TLBLO_PFNMASK	0x3fffffc0=0A=
+#define	TLBLO_PFNSHIFT	6=0A=
+#define	TLBLO_D		0x00000004	/* writeable */=0A=
+#define	TLBLO_V		0x00000002	/* valid bit */=0A=
+#define	TLBLO_G		0x00000001	/* global access bit */=0A=
+#define	TLBLO_CMASK	0x00000038	/* cache algorithm mask */=0A=
+#define	TLBLO_CSHIFT	3=0A=
+=0A=
+#define	TLBLO_UNCACHED		(CFG_C_UNCACHED<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_NONCOHERENT	(CFG_C_NONCOHERENT<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTXCL	(CFG_C_COHERENTXCL<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTXCLW	(CFG_C_COHERENTXCLW<<TLBLO_CSHIFT)=0A=
+#define	TLBLO_COHERENTUPD	(CFG_C_COHERENTUPD<<TLBLO_CSHIFT)=0A=
+#endif=0A=
+#if defined(CPU_R4000)||defined(S364)=0A=
+#define	TLBINX_PROBE	0x80000000=0A=
+#define	TLBINX_INXMASK	0x0000003f=0A=
+=0A=
+#define	TLBRAND_RANDMASK	0x0000003f=0A=
+=0A=
+#define	TLBCTXT_BASEMASK	0xff800000=0A=
+#define	TLBCTXT_BASESHIFT	23=0A=
+=0A=
+#define	TLBCTXT_VPN2MASK	0x007ffff0=0A=
+#define	TLBCTXT_VPN2SHIFT	4=0A=
+=0A=
+#define	TLBPGMASK_MASK		0x01ffe000=0A=
+#endif=0A=
+=0A=
+#define	SR_PE		0x00100000	/* cache parity error */=0A=
+#if defined(CPU_R3000)=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* use boot exception vectors */=0A=
+=0A=
+/* Cache control bits */=0A=
+#define	SR_TS		0x00200000	/* TLB shutdown */=0A=
+#define	SR_CM		0x00080000	/* cache miss */=0A=
+#define	SR_PZ		0x00040000	/* cache parity zero */=0A=
+#define	SR_SWC		0x00020000	/* swap cache */=0A=
+#define	SR_ISC		0x00010000	/* Isolate data cache */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KUO		0x00000020	/* old kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEO		0x00000010	/* old interrupt enable, 1 =3D> enable =
*/=0A=
+#define	SR_KUP		0x00000008	/* prev kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEP		0x00000004	/* prev interrupt enable, 1 =3D> enable =
*/=0A=
+#define	SR_KUC		0x00000002	/* cur kernel/user, 0 =3D> k, 1 =3D> u =
*/=0A=
+#define	SR_IEC		0x00000001	/* cur interrupt enable, 1 =3D> enable =
*/=0A=
+#endif=0A=
+=0A=
+#if defined S364                        /* (CPU_R32364)        */=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+/* defines for R32364 processor */=0A=
+#define	SR_NBL		0x08000000	/* Non Blocking Load */=0A=
+#define	SR_RE		0X02000000	/* Reverse Endianness */=0A=
+#define	SR_DL		0x01000000	/* Data Cache Locking */=0A=
+#define	SR_IL		0x00800000	/* Instruction Cache Locking */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_SR		0x00100000	/* Soft reset */=0A=
+#define	SR_CH		0x00040000	/* Cache hit */=0A=
+#define	SR_CE		0x00020000	/* Use cache ECC  */=0A=
+#define	SR_DE		0x00010000	/* Disable cache exceptions */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KSMASK	0x00000016	/* Kernel mode mask */=0A=
+#define	SR_KSUSER	0x00000000	/* User Mode */=0A=
+#define	SR_KSKERNEL	0x00000016	/* Kernel Mode */=0A=
+=0A=
+#define	SR_ERL		0x00000004	/* Error level */=0A=
+#define	SR_EXL		0x00000002	/* Exception level */=0A=
+#define	SR_IE		0x00000001	/* Interrupts enabled */=0A=
+#define	NOT_SR_IEC      0xfffffffe      /* assembler problem with =
li=0A=
+~SR_IEC */=0A=
+=0A=
+/* R32364 Cache locking bits */=0A=
+#define SR_ICACHELOCK 0x00800000=0A=
+#define SR_DCACHELOCK 0x01000000=0A=
+=0A=
+#endif /* CPU_R32364 */=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+#define	SR_CUMASK	0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3		0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2		0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1		0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0		0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+#define	SR_RP		0x08000000      /* Reduced power operation */=0A=
+#define	SR_FR		0x04000000	/* Additional floating pt registers */=0A=
+#define	SR_RE		0x02000000	/* Reverse endian in user mode */=0A=
+=0A=
+#define	SR_BEV		0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_TS		0x00200000	/* TLB shutdown */=0A=
+#define	SR_SR		0x00100000	/* Soft reset */=0A=
+#define	SR_CH		0x00040000	/* Cache hit */=0A=
+#define	SR_CE		0x00020000	/* Use cache ECC  */=0A=
+#define	SR_DE		0x00010000	/* Disable cache exceptions */=0A=
+=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK	0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8	0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7	0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6	0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5	0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4	0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3	0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2	0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1	0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0	0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT	8=0A=
+=0A=
+#define	SR_IBIT8	0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7	0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6	0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5	0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4	0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3	0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2	0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1	0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KSMASK	0x00000018	/* Kernel mode mask */=0A=
+#define	SR_KSUSER	0x00000010	/* User mode */=0A=
+#define	SR_KSSUPER	0x00000008	/* Supervisor mode */=0A=
+#define	SR_KSKERNEL	0x00000000	/* Kernel mode */=0A=
+#define	SR_ERL		0x00000004	/* Error level */=0A=
+#define	SR_EXL		0x00000002	/* Exception level */=0A=
+#define	SR_IE		0x00000001	/* Interrupts enabled */=0A=
+=0A=
+/* R4650 Cache locking bits */=0A=
+#define	SR_ICACHELOCK 0x00800000=0A=
+#define	SR_DCACHELOCK 0x01000000=0A=
+=0A=
+=0A=
+#endif=0A=
+#if defined(CPU_R3000)=0A=
+#define	SR_FR		0x04000000	/* Additional floating point registers */=0A=
+#endif=0A=
+=0A=
+=0A=
+=0A=
+/*=0A=
+ * Cause Register=0A=
+ */=0A=
+#define	CAUSE_BD	0x80000000	/* Branch delay slot */=0A=
+#define	CAUSE_CEMASK	0x30000000	/* coprocessor error */=0A=
+#define	CAUSE_CESHIFT	28=0A=
+#define	CAUSE_IW	0x01000000	/* Instruction watch */=0A=
+#define	CAUSE_DW	0x02000000	/* Data watch */=0A=
+#define	CAUSE_IPE	0x04000000	/* Imprecise exception */=0A=
+=0A=
+=0A=
+#define	CAUSE_IPMASK	0x0000FF00	/* Pending interrupt mask */=0A=
+#define	CAUSE_IPSHIFT	8=0A=
+=0A=
+/* Notice: Watch Exception if Exc. Code is 23 is not included in the =
mask=0A=
+ *	   for R32364.=0A=
+ */=0A=
+#define	CAUSE_EXCMASK	0x0000003C	/* Cause code bits */=0A=
+#define	CAUSE_EXCSHIFT	2=0A=
+=0A=
+#ifndef XDS=0A=
+/*=0A=
+**  Coprocessor 0 registers=0A=
+*/=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3 	*/=0A=
+#define C0_IBASE        $0		/* I base */=0A=
+#define C0_IBOUND       $1		/* I bound */=0A=
+=0A=
+#define	C0_INX			$0		/* tlb index */=0A=
+#define	C0_RAND			$1		/* tlb random */=0A=
+#if defined(CPU_R3000)=0A=
+#define	C0_TLBLO	$2				/* tlb entry low */=0A=
+#define	C0_BUSCTRL		$2		/* bus control R3041 specific */=0A=
+#define	C0_CONFIG		$3		/* cache config */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* count R3041 specific */=0A=
+#define	C0_PORTSIZE		$10	/* port size R3041 specific */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* compare R3041 specific */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#endif=0A=
+=0A=
+#if defined(S364)					/*(CPU_R32364)      */=0A=
+#define	C0_RANDOM		$1=0A=
+#define	C0_TLBLO0		$2		/* tlb entry low 0 */=0A=
+#define	C0_TLBLO1		$3		/* tlb entry low 1 */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_PAGEMASK		$5		/* tlb page mask */=0A=
+#define	C0_WIRED			$6		/* number of wired tlb entries */=0A=
+=0A=
+#define	C0_INX			$0		/* tlb index */=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* timer count */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* timer comparator  */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#define	C0_CONFIG		$16	/* configuration register */=0A=
+=0A=
+#define	C0_IWATCH		$18	/* Instr brk pt Virtual add. */=0A=
+#define	C0_DWATCH		$19	/* Data brk pt Virtual add. */=0A=
+=0A=
+#define	C0_IEPC			$22	/* Imprecise Exception pc */=0A=
+#define	C0_DEPC			$23	/* Debug Exception pc */=0A=
+#define	C0_DEBUG			$24	/* Debug control/status reg */=0A=
+=0A=
+#define	C0_ECC			$26	/* primary cache Parity control */=0A=
+#define	C0_CACHEERR		$27	/* cache error status */=0A=
+#define	C0_TAGLO			$28	/* cache tag lo */=0A=
+#define	C0_TAGHI			$29=0A=
+#define	C0_ERRPC			$30	/* cache error pc */=0A=
+#endif /* CPU_R32364 			*/=0A=
+=0A=
+#if defined(CPU_R4000)=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3 	*/=0A=
+#define	C0_DBASE			$2		/* D base */=0A=
+#define	C0_DBOUND		$3		/* D bound */=0A=
+=0A=
+#define	C0_TLBLO0		$2		/* tlb entry low 0 */=0A=
+#define	C0_TLBLO1		$3		/* tlb entry low 1 */=0A=
+#define	C0_CTXT			$4		/* tlb context */=0A=
+#define	C0_PAGEMASK		$5		/* tlb page mask */=0A=
+#define	C0_WIRED			$6		/* number of wired tlb entries */=0A=
+=0A=
+#define	C0_BADVADDR		$8		/* bad virtual address */=0A=
+#define	C0_COUNT			$9		/* cycle count */=0A=
+#define	C0_TLBHI			$10	/* tlb entry hi */=0A=
+#define	C0_COMPARE		$11	/* cyccle count comparator  */=0A=
+#define	C0_SR				$12	/* status register */=0A=
+#define	C0_CAUSE			$13	/* exception cause */=0A=
+#define	C0_EPC			$14	/* exception pc */=0A=
+#define	C0_PRID			$15	/* revision identifier */=0A=
+#define	C0_CONFIG		$16	/* configuration register */=0A=
+=0A=
+/* Evelyn, 12/12/94, for P3   */=0A=
+#define	C0_CALG			$17	/* Calg rigister */=0A=
+#define	C0_IWATCH		$18	/* IWatch register */=0A=
+#define	C0_DWATCH		$19	/* DWatch register */=0A=
+=0A=
+#define	C0_LLADDR		$17	/* linked load address */=0A=
+#define	C0_WATCHLO		$18	/* watchpoint trap register */=0A=
+#define	C0_WATCHHI		$19	/* watchpoint trap register */=0A=
+#define	C0_XCTXT			$20 	/* extended tlb context */=0A=
+#define	C0_ECC			$26	/* secondary cache ECC control */=0A=
+#define	C0_CACHEERR		$27	/* cache error status */=0A=
+#define	C0_TAGLO			$28	/* cache tag lo */=0A=
+#define	C0_TAGHI			$29	/* cache tag hi */=0A=
+#define	C0_ERRPC			$30	/* cache error pc */=0A=
+#endif=0A=
+#endif =0A=
+#endif /* defined(__IDTCPU_H__) */=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/idthdr.h =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/idthdr.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/idthdr.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/idthdr.h	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,54 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Some macros. Though they are already defined else where in the =
linux=0A=
+ *   tree, they are once again declared here for the ease of syncing =
up with=0A=
+ *    IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef XDS=0A=
+=0A=
+#define	FRAME(name,frm_reg,offset,ret_reg)	\=0A=
+	.globl	name;				\=0A=
+	.ent	name;				\=0A=
+name:;						\=0A=
+	.frame	frm_reg,offset,ret_reg=0A=
+=0A=
+#define ENDFRAME(name) 	.end name=0A=
+=0A=
+#else=0A=
+=0A=
+#define FRAME(name,frm_reg,offset,ret_reg)      \=0A=
+name:=0A=
+=0A=
+#define ENDFRAME(name)=0A=
+=0A=
+#endif=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/image.lds.in =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/image.lds.in=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/image.lds.in	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/image.lds.in	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D IMSTART;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/S334/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D BSS_START;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/iregdef.h =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/iregdef.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/iregdef.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/iregdef.h	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,284 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#define r0	$0=0A=
+#define r1	$1 /*at assembler temp */=0A=
+#define r2	$2 /*v0 return value */=0A=
+#define r3	$3 /*v1 return value */=0A=
+#define r4	$4 /*a0 argument 0 */=0A=
+#define r5	$5 /*a1 argument 1 */=0A=
+#define r6	$6=0A=
+#define r7	$7=0A=
+#define r8	$8=0A=
+#define r9	$9=0A=
+#define r10	$10=0A=
+#define r11	$11=0A=
+#define r12	$12=0A=
+#define r13	$13=0A=
+=0A=
+#define r14	$14=0A=
+#define r15	$15=0A=
+#define r16	$16 /*s0 called saved */=0A=
+#define r17	$17=0A=
+#define r18	$18=0A=
+#define r19	$19=0A=
+#define r20	$20=0A=
+#define r21	$21=0A=
+#define r22	$22=0A=
+#define r23	$23 /*s7 called saved */=0A=
+#define r24	$24=0A=
+#define r25	$25=0A=
+#define r26	$26 /*k0 kernel temp. */=0A=
+#define r27	$27 /*k1   ""    ""   */=0A=
+#define r28	$28 /*gp global pointer */=0A=
+#define r29	$29 /*sp stack pointer */=0A=
+#define r30	$30 /*fp frame pointer */=0A=
+#define r31	$31 /*ra return address */=0A=
+=0A=
+#define fp0	$f0=0A=
+#define fp1	$f1=0A=
+#define fp2	$f2=0A=
+#define fp3	$f3=0A=
+#define fp4	$f4=0A=
+#define fp5	$f5=0A=
+#define fp6	$f6=0A=
+#define fp7	$f7=0A=
+#define fp8	$f8=0A=
+#define fp9	$f9=0A=
+#define fp10	$f10=0A=
+#define fp11	$f11=0A=
+#define fp12	$f12=0A=
+#define fp13	$f13=0A=
+#define fp14	$f14=0A=
+#define fp15	$f15=0A=
+#define fp16	$f16=0A=
+#define fp17	$f17=0A=
+#define fp18	$f18=0A=
+#define fp19	$f19=0A=
+#define fp20	$f20=0A=
+#define fp21	$f21=0A=
+#define fp22	$f22=0A=
+#define fp23	$f23=0A=
+#define fp24	$f24=0A=
+#define fp25	$f25=0A=
+#define fp26	$f26=0A=
+#define fp27	$f27=0A=
+#define fp28	$f28=0A=
+#define fp29	$f29=0A=
+#define fp30	$f30=0A=
+#define fp31	$f31=0A=
+=0A=
+#define fcr0	$0=0A=
+#define fcr30	$30=0A=
+#define fcr31	$31=0A=
+=0A=
+#define zero	$0	/* wired zero */=0A=
+#define AT	$at	/* assembler temp */=0A=
+#define v0	$2	/* return value */=0A=
+#define v1	$3=0A=
+#define a0	$4	/* argument registers */=0A=
+#define a1	$5=0A=
+#define a2	$6=0A=
+#define a3	$7=0A=
+#define t0	$8	/* caller saved */=0A=
+#define t1	$9=0A=
+#define t2	$10=0A=
+#define t3	$11=0A=
+#define t4	$12=0A=
+#define t5	$13=0A=
+#define t6	$14=0A=
+#define t7	$15=0A=
+#define s0	$16	/* callee saved */=0A=
+#define s1	$17=0A=
+#define s2	$18=0A=
+#define s3	$19=0A=
+#define s4	$20=0A=
+#define s5	$21=0A=
+#define s6	$22=0A=
+#define s7	$23=0A=
+#define t8	$24	/* code generator */=0A=
+#define t9	$25=0A=
+#define k0	$26	/* kernel temporary */=0A=
+#define k1	$27=0A=
+#define gp	$28	/* global pointer */=0A=
+#define sp	$29	/* stack pointer */=0A=
+#define s8	$30	/* yet another saved reg for the callee */=0A=
+#define fp	$30	/* frame pointer - this is being phased out by MIPS =
*/=0A=
+#define ra	$31	/* return address */=0A=
+=0A=
+=0A=
+/*=0A=
+ * register names=0A=
+ */=0A=
+#define	R_R0		0=0A=
+#define	R_R1		1=0A=
+#define	R_R2		2=0A=
+#define	R_R3		3=0A=
+#define	R_R4		4=0A=
+#define	R_R5		5=0A=
+#define	R_R6		6=0A=
+#define	R_R7		7=0A=
+#define	R_R8		8=0A=
+#define	R_R9		9=0A=
+#define	R_R10		10=0A=
+#define	R_R11		11=0A=
+#define	R_R12		12=0A=
+#define	R_R13		13=0A=
+#define	R_R14		14=0A=
+#define	R_R15		15=0A=
+#define	R_R16		16=0A=
+#define	R_R17		17=0A=
+#define	R_R18		18=0A=
+#define	R_R19		19=0A=
+#define	R_R20		20=0A=
+#define	R_R21		21=0A=
+#define	R_R22		22=0A=
+#define	R_R23		23=0A=
+#define	R_R24		24=0A=
+#define	R_R25		25=0A=
+#define	R_R26		26=0A=
+#define	R_R27		27=0A=
+#define	R_R28		28=0A=
+#define	R_R29		29=0A=
+#define	R_R30		30=0A=
+#define	R_R31		31=0A=
+#define	R_F0		32=0A=
+#define	R_F1		33=0A=
+#define	R_F2		34=0A=
+#define	R_F3		35=0A=
+#define	R_F4		36=0A=
+#define	R_F5		37=0A=
+#define	R_F6		38=0A=
+#define	R_F7		39=0A=
+#define	R_F8		40=0A=
+#define	R_F9		41=0A=
+#define	R_F10		42=0A=
+#define	R_F11		43=0A=
+#define	R_F12		44=0A=
+#define	R_F13		45=0A=
+#define	R_F14		46=0A=
+#define	R_F15		47=0A=
+#define	R_F16		48=0A=
+#define	R_F17		49=0A=
+#define	R_F18		50=0A=
+#define	R_F19		51=0A=
+#define	R_F20		52=0A=
+#define	R_F21		53=0A=
+#define	R_F22		54=0A=
+#define	R_F23		55=0A=
+#define	R_F24		56=0A=
+#define	R_F25		57=0A=
+#define	R_F26		58=0A=
+#define	R_F27		59=0A=
+#define	R_F28		60=0A=
+#define	R_F29		61=0A=
+#define	R_F30		62=0A=
+#define	R_F31		63=0A=
+#define NCLIENTREGS	64=0A=
+#define	R_EPC		64=0A=
+#define	R_MDHI		65=0A=
+#define	R_MDLO		66=0A=
+#define	R_SR		67=0A=
+#define	R_CAUSE		68=0A=
+#define	R_TLBHI		69=0A=
+#ifdef CPU_R4000=0A=
+#define	R_TLBLO0	70=0A=
+#else=0A=
+#define	R_TLBLO		70=0A=
+#endif=0A=
+#define	R_BADVADDR	71=0A=
+#define	R_INX		72=0A=
+#define	R_RAND		73=0A=
+#define	R_CTXT		74=0A=
+#define	R_EXCTYPE	75=0A=
+#define R_MODE		76=0A=
+#define	R_PRID		77=0A=
+#define R_FCSR		78=0A=
+#define R_FEIR		79=0A=
+#ifdef CPU_R4000=0A=
+#define	R_TLBLO1	80=0A=
+#define R_PAGEMASK	81=0A=
+#define R_WIRED		82=0A=
+#define R_COUNT		83=0A=
+#define R_COMPARE	84=0A=
+#define R_CONFIG	85=0A=
+#define R_LLADDR	86=0A=
+#define R_WATCHLO	87=0A=
+#define R_WATCHHI	88=0A=
+#define R_ECC		89=0A=
+#define R_CACHEERR	90=0A=
+#define R_TAGLO		91=0A=
+#define R_TAGHI		92=0A=
+#define R_ERRPC		93=0A=
+#endif=0A=
+=0A=
+#ifdef CPU_R4000=0A=
+#define	NREGS		94=0A=
+#else=0A=
+#define NREGS		80=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * compiler defined bindings=0A=
+ */=0A=
+#define	R_ZERO		R_R0=0A=
+#define	R_AT		R_R1=0A=
+#define	R_V0		R_R2=0A=
+#define	R_V1		R_R3=0A=
+#define	R_A0		R_R4=0A=
+#define	R_A1		R_R5=0A=
+#define	R_A2		R_R6=0A=
+#define	R_A3		R_R7=0A=
+#define	R_T0		R_R8=0A=
+#define	R_T1		R_R9=0A=
+#define	R_T2		R_R10=0A=
+#define	R_T3		R_R11=0A=
+#define	R_T4		R_R12=0A=
+#define	R_T5		R_R13=0A=
+#define	R_T6		R_R14=0A=
+#define	R_T7		R_R15=0A=
+#define	R_S0		R_R16=0A=
+#define	R_S1		R_R17=0A=
+#define	R_S2		R_R18=0A=
+#define	R_S3		R_R19=0A=
+#define	R_S4		R_R20=0A=
+#define	R_S5		R_R21=0A=
+#define	R_S6		R_R22=0A=
+#define	R_S7		R_R23=0A=
+#define	R_T8		R_R24=0A=
+#define	R_T9		R_R25=0A=
+#define	R_K0		R_R26=0A=
+#define	R_K1		R_R27=0A=
+#define	R_GP		R_R28=0A=
+#define	R_SP		R_R29=0A=
+#define	R_FP		R_R30=0A=
+#define	R_RA		R_R31=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/Makefile	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,151 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile create a compressed zImage or Rommable rImage=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+#######################################################################=
########=0A=
+# The following is taken from IDT/Sim Makefile=0A=
+#######################################################################=
########=0A=
+TARGET=3D134=0A=
+TARGETDIR=3DS134_334=0A=
+# Even though this makefile is for S334A board, we continue to use =
files=0A=
+# from the S134 & S334 board based source.  A -DS334A in the =
sources=0A=
+# will distinguish code that is unique to S334A boards.=0A=
+=0A=
+#=0A=
+# following refers to memory type in use in eval board and if more =
than one=0A=
+# then the order is implied.  These are values for the switch =
MEMCFG.=0A=
+#=0A=
+SRAM_ONLY=3D1=0A=
+SDRAM_ONLY=3D2=0A=
+EDO_ONLY=3D3=0A=
+SRAM_N_SDRAM=3D4=0A=
+SRAM_N_EDO=3D5=0A=
+SDRAM_N_SRAM=3D6=0A=
+EDO_N_SRAM=3D7=0A=
+=0A=
+# following refers to size of the DRAM space.=0A=
+# These are values for the switch DRAMSZ.=0A=
+=0A=
+MB32=3D1=0A=
+MB64=3D2=0A=
+MB128=3D3=0A=
+MB32SO=3D4=0A=
+=0A=
+# following refers to the size of the boot EPROM space port width.=0A=
+# These values are for the switch EPRMPRTWD.=0A=
+=0A=
+EP8=3D1=0A=
+EP32=3D2=0A=
+=0A=
+MACH=3D -DS$(TARGET)  -DS334A -DS334 -DS364 -DCPU_R32364 =
-DMEMCFG=3D$(SDRAM_ONLY) -DDRAMSZ=3D$(MB32SO) -DEPRMPRTWD=3D$(EP32)=0A=
+COMMSWITCHES=3D $(INCDIRS) $(MACH)=0A=
+#***************** END IDT/Sim Makefile =
#####################################=0A=
+ZDEBUG=3D0=0A=
+export ZDEBUG=0A=
+=0A=
+# working space for gunzip:=0A=
+FREE_RAM      :=3D 0x80C00000=0A=
+END_RAM       :=3D 0x80E00000=0A=
+=0A=
+KERNELCONFIG  :=3D $(TOPDIR)/.config=0A=
+include $(KERNELCONFIG)=0A=
+=0A=
+SIZE =3D $(CROSS_COMPILE)size=0A=
+=0A=
+O_FORMAT =3D $(shell $(OBJDUMP) -i | head -2 | grep elf32)=0A=
+=0A=
+SYSTEM	      :=3D $(TOPDIR)/vmlinux=0A=
+ZBSS          :=3D 0x800A0000=0A=
+=0A=
+ZIMSTART      :=3D $(CONFIG_IDT_ZIMAGE_ADDR)=0A=
+RIMSTART      :=3D 0x9FC00000=0A=
+=0A=
+LOADADDR      :=3D 0x$(shell $(NM) $(SYSTEM) | grep "A _text" |cut -f1 =
-d' ')=0A=
+KERNEL_ENTRY  :=3D $(shell $(OBJDUMP) -f $(SYSTEM) | sed -n -e =
's/^start address //p')=0A=
+=0A=
+#######################################################################=
#############=0A=
+ZIMFLAGS        =3D s/IMSTART/$(ZIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+RIMFLAGS        =3D s/IMSTART/$(RIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+CFLAGS	:=3D -fno-pic -nostdinc -G 0 -mno-abicalls -fno-pic -pipe =
-I$(TOPDIR)/include=0A=
+AFLAGS	:=3D -D__ASSEMBLY__ $(CFLAGS)=0A=
+=0A=
+#######################################################################=
#############=0A=
+OBJECTS=3D $(obj)/piggy.o $(obj)/head.o $(obj)/misc.o=0A=
+ifneq ($(ZDEBUG),0)=0A=
+OBJECTS +=3D $(obj)/uart16550.o=0A=
+endif=0A=
+=0A=
+$(obj)/zImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(ZIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/rImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(RIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/piggy.o: $(SYSTEM) $(obj)/Makefile=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(SYSTEM) =
$(SYSTEM).bin=0A=
+	gzip -f -9 < $(SYSTEM).bin > $(SYSTEM).gz=0A=
+	echo "O_FORMAT:  " $(O_FORMAT); =0A=
+	$(LD) -r -b binary --oformat $(O_FORMAT) -o $(obj)/piggy.o =
$(SYSTEM).gz=0A=
+	rm -f $(SYSTEM).bin $(SYSTEM).gz=0A=
+=0A=
+$(obj)/head.o: $(obj)/head.S $(SYSTEM) $(obj)/Makefile=0A=
+	$(CC) $(AFLAGS) -DKERNEL_ENTRY=3D$(KERNEL_ENTRY) -c $(obj)/head.S -o =
$(obj)/head.o=0A=
+=0A=
+$(obj)/misc.o: $(obj)/misc.c $(obj)/Makefile=0A=
+	$(CC) $(CFLAGS) -DLOADADDR=3D$(LOADADDR) -DFREE_RAM=3D$(FREE_RAM) =
-DEND_RAM=3D$(END_RAM) \=0A=
+		-c $< -DZDEBUG=3D$(ZDEBUG) -o $(obj)/misc.o=0A=
+=0A=
+$(obj)/uart16550.o: $(obj)/uart16550.c $(KERNELCONFIG)=0A=
+	$(CC) $(CFLAGS) -c $< -o $(obj)/uart16550.o=0A=
+=0A=
+$(obj)/csu_idt.o: $(obj)/csu_idt.S Makefile $(SYSTEM)=0A=
+	$(CC) $(AFLAGS) $(COMMSWITCHES) -c $< -o $(obj)/csu_idt.o=0A=
+=0A=
+zImage: $(obj)/zImage.lds $(SYSTEM) $(OBJECTS)=0A=
+	$(LD) -T$(obj)/zImage.lds -o $(TOPDIR)/zImage $(OBJECTS)=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/zImage =
$(TOPDIR)/zImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/zImage.bin $(TOPDIR)/zImage.prm=0A=
+	$(SIZE) $(TOPDIR)/zImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/zImage.size=0A=
+	rm -f *.o=0A=
+=0A=
+rImage: $(obj)/rImage.lds $(OBJECTS) $(obj)/csu_idt.o $(SYSTEM)=0A=
+	@rm -f $(TOPDIR)/*.prm=0A=
+	$(LD) -T$(obj)/rImage.lds -o $(TOPDIR)/rImage $(obj)/csu_idt.o =
$(OBJECTS) =0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/rImage =
$(TOPDIR)/rImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec -b 0 --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 $(TOPDIR)/rImage.bin =
$(TOPDIR)/rImage0.prm=0A=
+	$(OBJCOPY) -I binary -S -O srec -b 1 --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 $(TOPDIR)/rImage.bin =
$(TOPDIR)/rImage1.prm=0A=
+	$(OBJCOPY) -I binary -S -O srec -b 2 --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 $(TOPDIR)/rImage.bin =
$(TOPDIR)/rImage2.prm=0A=
+	$(OBJCOPY) -I binary -S -O srec -b 3 --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 $(TOPDIR)/rImage.bin =
$(TOPDIR)/rImage3.prm=0A=
+	$(SIZE) $(TOPDIR)/rImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/rImage.size=0A=
+	rm -f *.o=0A=
+=0A=
+clean:=0A=
+	rm -f *.o $(TOPDIR)/zImage $(TOPDIR)/rImage $(TOPDIR)/*.prm =
$(TOPDIR)/rImage.size $(TOPDIR)/zImage.size=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/misc.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/misc.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/misc.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/misc.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,339 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Code to un-compress linux image=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/types.h>=0A=
+=0A=
+/*=0A=
+ * gzip declarations=0A=
+ */=0A=
+#define OF(args)  args=0A=
+#define STATIC static=0A=
+#define memzero(s, n)     memset ((s), 0, (n))=0A=
+typedef unsigned char uch;=0A=
+typedef unsigned short ush;=0A=
+typedef unsigned long ulg;=0A=
+#define WSIZE 0x8000		/* Window size must be at least 32k, */=0A=
+				/* and a power of two */=0A=
+static uch *inbuf;		/* input buffer */=0A=
+static uch window[WSIZE];	/* Sliding window buffer */=0A=
+=0A=
+/* gzip flag byte */=0A=
+#define ASCII_FLAG   0x01	/* bit 0 set: file probably ASCII text */=0A=
+#define CONTINUATION 0x02	/* bit 1 set: continuation of multi-part =
gzip file */=0A=
+#define EXTRA_FIELD  0x04	/* bit 2 set: extra field present */=0A=
+#define ORIG_NAME    0x08	/* bit 3 set: original file name present =
*/=0A=
+#define COMMENT      0x10	/* bit 4 set: file comment present */=0A=
+#define ENCRYPTED    0x20	/* bit 5 set: file is encrypted */=0A=
+#define RESERVED     0xC0	/* bit 6,7:   reserved */=0A=
+=0A=
+=0A=
+static unsigned insize;	/* valid bytes in inbuf */=0A=
+static unsigned inptr;	/* index of next byte to be processed in inbuf =
*/=0A=
+static unsigned outcnt;	/* bytes in output buffer */=0A=
+=0A=
+void variable_init(void);=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *);=0A=
+extern void putc_init(void);=0A=
+extern void putc(unsigned char c);=0A=
+#endif=0A=
+static int fill_inbuf(void);=0A=
+static void flush_window(void);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+extern char input_data[];=0A=
+=0A=
+extern char input_data_end[];=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void int2hex(unsigned long val)=0A=
+{=0A=
+        unsigned char buf[10];=0A=
+        int i;=0A=
+        for (i =3D 7;  i >=3D 0;  i--)=0A=
+        {=0A=
+                buf[i] =3D "0123456789ABCDEF"[val & 0x0F];=0A=
+                val >>=3D 4;=0A=
+        }=0A=
+        buf[8] =3D '\0';=0A=
+        puts(buf);=0A=
+}=0A=
+#endif=0A=
+=0A=
+static unsigned long byte_count;=0A=
+=0A=
+int get_byte(void)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	static int printCnt;=0A=
+#endif=0A=
+	unsigned char c =3D (inptr < insize ? inbuf[inptr++] : =
fill_inbuf());=0A=
+	byte_count++;=0A=
+=0A=
+#if ZDEBUG > 1=0A=
+	if (printCnt++ < 32)=0A=
+	{=0A=
+	  puts("byte count =3D ");=0A=
+	  int2hex(byte_count);=0A=
+	  puts(" byte val =3D ");=0A=
+	  int2hex(c);=0A=
+	  puts("\n");=0A=
+	}=0A=
+#endif=0A=
+	return c;=0A=
+}=0A=
+=0A=
+/* Diagnostic functions */=0A=
+#ifdef DEBUG=0A=
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}=0A=
+#  define Trace(x) fprintf x=0A=
+#  define Tracev(x) {if (verbose) fprintf x ;}=0A=
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}=0A=
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}=0A=
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}=0A=
+#else=0A=
+#  define Assert(cond,msg)=0A=
+#  define Trace(x)=0A=
+#  define Tracev(x)=0A=
+#  define Tracevv(x)=0A=
+#  define Tracec(c,x)=0A=
+#  define Tracecv(c,x)=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * This is set up by the setup-routine at boot-time=0A=
+ */=0A=
+=0A=
+static long bytes_out;=0A=
+static uch *output_data;=0A=
+static unsigned long output_ptr;=0A=
+=0A=
+=0A=
+static void *malloc(int size);=0A=
+static void free(void *where);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+static unsigned long free_mem_ptr;=0A=
+static unsigned long free_mem_end_ptr;=0A=
+=0A=
+#include "../../../../../../lib/inflate.c"=0A=
+=0A=
+static void *malloc(int size)=0A=
+{=0A=
+	void *p;=0A=
+=0A=
+	if (size < 0)=0A=
+		error("Malloc error\n");=0A=
+	if (free_mem_ptr <=3D 0) error("Memory error\n");=0A=
+=0A=
+	free_mem_ptr =3D (free_mem_ptr + 3) & ~3;	/* Align */=0A=
+=0A=
+	p =3D (void *) free_mem_ptr;=0A=
+	free_mem_ptr +=3D size;=0A=
+=0A=
+	if (free_mem_ptr >=3D free_mem_end_ptr)=0A=
+		error("\nOut of memory\n");=0A=
+=0A=
+	return p;=0A=
+}=0A=
+=0A=
+static void free(void *where)=0A=
+{				/* Don't care */=0A=
+}=0A=
+=0A=
+static void gzip_mark(void **ptr)=0A=
+{=0A=
+	*ptr =3D (void *) free_mem_ptr;=0A=
+}=0A=
+=0A=
+static void gzip_release(void **ptr)=0A=
+{=0A=
+	free_mem_ptr =3D (long) *ptr;=0A=
+}=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *s)=0A=
+{=0A=
+	while (*s) {=0A=
+		if (*s =3D=3D 10)=0A=
+			putc(13);=0A=
+		putc(*s++);=0A=
+	}=0A=
+}=0A=
+#endif=0A=
+void *memset(void *s, int c, size_t n)=0A=
+{=0A=
+	int i;=0A=
+	char *ss =3D (char *) s;=0A=
+=0A=
+	for (i =3D 0; i < n; i++)=0A=
+		ss[i] =3D c;=0A=
+	return s;=0A=
+}=0A=
+=0A=
+void *memcpy(void *__dest, __const void *__src, size_t __n)=0A=
+{=0A=
+	int i;=0A=
+	char *d =3D (char *) __dest, *s =3D (char *) __src;=0A=
+=0A=
+	for (i =3D 0; i < __n; i++)=0A=
+		d[i] =3D s[i];=0A=
+	return __dest;=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Fill the input buffer. This is called only when the buffer is =
empty=0A=
+ * and at least one byte is really needed.=0A=
+ */=0A=
+static int fill_inbuf(void)=0A=
+{=0A=
+	if (insize !=3D 0) {=0A=
+		error("ran out of input data\n");=0A=
+	}=0A=
+=0A=
+	inbuf =3D input_data;=0A=
+	insize =3D &input_data_end[0] - &input_data[0];=0A=
+	inptr =3D 1;=0A=
+	return inbuf[0];=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Write the output window window[0..outcnt-1] and update crc and =
bytes_out.=0A=
+ * (Used for the decompressed data only.)=0A=
+ */=0A=
+static void flush_window(void)=0A=
+{=0A=
+	ulg c =3D crc;		/* temporary variable */=0A=
+	unsigned n;=0A=
+	uch *in, *out, ch;=0A=
+=0A=
+	in =3D window;=0A=
+	out =3D &output_data[output_ptr];=0A=
+	for (n =3D 0; n < outcnt; n++) {=0A=
+		ch =3D *out++ =3D *in++;=0A=
+		c =3D crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);=0A=
+	}=0A=
+	crc =3D c;=0A=
+	bytes_out +=3D (ulg) outcnt;=0A=
+	output_ptr +=3D (ulg) outcnt;=0A=
+	outcnt =3D 0;=0A=
+}=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void check_mem(void)=0A=
+{=0A=
+	int i;=0A=
+=0A=
+	puts("\ncplens =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplens[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\ncplext =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplext[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\nborder =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(border[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\n");=0A=
+}=0A=
+#endif=0A=
+static void error(char *x)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	check_mem();=0A=
+	puts("\n\n");=0A=
+	puts(x);=0A=
+	puts("byte_count =3D ");=0A=
+	int2hex(byte_count);=0A=
+	puts("\n");=0A=
+	puts("\n\n -- Error. System halted");=0A=
+#endif=0A=
+	while (1);		/* Halt */=0A=
+}=0A=
+=0A=
+void variable_init(void)=0A=
+{=0A=
+	byte_count =3D 0;=0A=
+	output_data =3D (char *) LOADADDR;=0A=
+	free_mem_ptr =3D FREE_RAM;=0A=
+	free_mem_end_ptr =3D END_RAM;=0A=
+#if ZDEBUG > 1=0A=
+	puts("output_data      0x");=0A=
+	int2hex((unsigned long)output_data); puts("\n");=0A=
+	puts("free_mem_ptr     0x");=0A=
+	int2hex(free_mem_ptr); puts("\n");=0A=
+	puts("free_mem_end_ptr 0x");=0A=
+	int2hex(free_mem_end_ptr); puts("\n");=0A=
+	puts("input_data       0x");=0A=
+	int2hex((unsigned long)input_data); puts("\n");=0A=
+#endif=0A=
+}=0A=
+=0A=
+int decompress_kernel(void)=0A=
+{=0A=
+#if ZDEBUG > 0=0A=
+  putc_init();=0A=
+#if ZDEBUG > 2=0A=
+  check_mem();=0A=
+#endif=0A=
+#endif=0A=
+=0A=
+  variable_init();=0A=
+=0A=
+  makecrc();=0A=
+#if ZDEBUG > 0=0A=
+  puts("\n");=0A=
+  puts("Uncompressing Linux... \n");=0A=
+#endif=0A=
+  gunzip();		// ...see inflate.c=0A=
+#if ZDEBUG > 0=0A=
+  puts("Ok, booting the kernel.\n");=0A=
+#endif=0A=
+=0A=
+#if ZDEBUG > 1=0A=
+ {=0A=
+  unsigned long *p =3D (unsigned long *)LOADADDR;=0A=
+  int2hex(p[0]); puts("\n");=0A=
+  int2hex(p[1]); puts("\n");=0A=
+  int2hex(p[2]); puts("\n");=0A=
+  int2hex(p[3]); puts("\n");=0A=
+ }=0A=
+#endif=0A=
+=0A=
+  return 0;=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/rImage.lds =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/rImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/rImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/rImage.lds	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x9FC00000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/S334/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/s334aram.h =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/s334aram.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/s334aram.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/s334aram.h	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,330 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT S334 SDRAM setup values.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S334RAM__=0A=
+#define __S334RAM__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+=0A=
+#define SRAM_ONLY	1=0A=
+#define SDRAM_ONLY	2=0A=
+/* #define EDO_ONLY	3 */=0A=
+#define SRAM_N_SDRAM	4=0A=
+/* #define SRAM_N_EDO	5 */=0A=
+#define SDRAM_N_SRAM	6=0A=
+/* #define EDO_N_SRAM	7 */=0A=
+=0A=
+#define APATTERN 0xa5a5a5a5=0A=
+=0A=
+#define MB32	1=0A=
+#define MB64	2=0A=
+#define MB128	3=0A=
+#define MB32SO  4=0A=
+=0A=
+#define EP8	1=0A=
+#define EP32	2=0A=
+=0A=
+#define EXTU	1=0A=
+#define INTU	2=0A=
+=0A=
+#ifndef LED_BASE=0A=
+=0A=
+#if defined(EB332)=0A=
+#define	LED_BASE	PHYS_TO_K1(0x10000000)=0A=
+#else=0A=
+#define	LED_BASE	PHYS_TO_K1(0x14000000)=0A=
+#endif /* EB332 */=0A=
+=0A=
+#define	LED_DIGIT0	0xf=0A=
+#define	LED_DIGIT1	0xb=0A=
+#define	LED_DIGIT2	0x7=0A=
+#define	LED_DIGIT3	0x3=0A=
+#define	LED_CLEAR	0x400=0A=
+=0A=
+#endif=0A=
+=0A=
+#define SYS_BTA_CTRL            PHYS_TO_K1(0x18000000)=0A=
+#define SYS_ALT_CTRL            PHYS_TO_K1(0x18000004)=0A=
+=0A=
+#if MHZ < 66000000=0A=
+#define SYS_ALT_SETUP           0x00000003 =0A=
+#define TRCD			0x00500000	/* used in SDRAM set-up (RCD value) */ =0A=
+#else=0A=
+#define SYS_ALT_SETUP           0x00000007  =0A=
+#define TRCD			0x00600000	/* used in SDRAM set-up (RCD value) */  =0A=
+#endif=0A=
+=0A=
+#define	PORT_WIDTH_CONTROL	0xffffe200	/* port width control register =
address */=0A=
+#define	BTA_CONTROL		0xffffe204      /* was 0xffffe240 - hak 06-16-98 =
- BTA control register address */=0A=
+#define	BTA_SETUP		0x3FFFFFFF      /* 3 turnaround cycles for all =
regions */=0A=
+=0A=
+#if EPRMPRTWD =3D=3D EP8=0A=
+=0A=
+#define	PORT_SETUP		0xaa822aaa       /* changed for 8-bit wide NVRAM =
at physical 1200_0000: Upen-000530*/=0A=
+=0A=
+#elif EPRMPRTWD =3D=3D EP32=0A=
+#define PORT_SETUP		0xaa82aaaa	/* boot EPROM space port width =3D 32 =
bits */=0A=
+#else=0A=
+#error "illegal value for eprom port width"=0A=
+#endif=0A=
+=0A=
+#define MEM_CTL_BASE		PHYS_TO_K1(0x18000200)	/* base address of all =
(0-5) Memory Control Registers */=0A=
+#define MEM_BASE_BASE		PHYS_TO_K1(0x18000080)	/* base address of 2 =
(0-1) Base Address Registers */=0A=
+#define R32134_IREG_BASE	PHYS_TO_K1(0x18000000)	/* all R32134 internal =
registers' base address */=0A=
+=0A=
+/* =0A=
+** b14:13=3D>01=3DPROM;b12=3D>1=3D do not assert CS during writes; =
b11:10=3D>00=3D8 bit port =0A=
+** b09:05=3D>08=3D8 wait states; b04:00=3D>08=3D 8 wait states=0A=
+*/=0A=
+=0A=
+#define MCR_CS0_BS		0x31083108  =0A=
+=0A=
+=0A=
+/* =0A=
+** b14:13=3D>00=3DSRAM;b12=3D>0=3D assert CS during writes; =
b11:10=3D>10=3D32 bit port =0A=
+** b09:05=3D>FF=3D31 wait states; b04:00=3D>FF=3D 31 wait states.=0A=
+** NOTE: wait states should be tuned.=0A=
+*/=0A=
+=0A=
+#if defined(EB332)=0A=
+#define MCR_CS1_BS		0x60e760e7=0A=
+#else=0A=
+#define MCR_CS1_BS		0x28632863=0A=
+#endif /* EB332 */=0A=
+#define MCR_CS2_BS		0x60e760e7=0A=
+#define MCR_CS3_BS		0x60e760e7=0A=
+#define MCR_CS4_BS		0x60e760e7     /* S334 LED */=0A=
+=0A=
+/* =0A=
+** b14:13=3D>01=3DI Type;b12=3D>0=3D assert CS during writes; =
b11:10=3D>00=3D8 bit port =0A=
+** b09:05=3D>FF=3D31 wait states; b04:00=3D>FF=3D 31 wait states=0A=
+*/=0A=
+=0A=
+#define MCR_CS5_BS		0x60E760E7=0A=
+=0A=
+#define MBA_REG0		0x1FC00000  /* phys mem base addr reg val for CS 0 - =
EPROM */=0A=
+#define MBM_REG0		0xFFC00000  /* mem base mask reg for CS0 -EPROM-4MB =
*/=0A=
+#define CPU_BERR_BS		0xFF=0A=
+#define IP_BERR_BS		0xFF=0A=
+=0A=
+=0A=
+=0A=
+/*********************************=0A=
+*    SRAM_ONLY section 				*=0A=
+*********************************/=0A=
+=0A=
+#if MEMCFG =3D=3D SRAM_ONLY=0A=
+=0A=
+#define MBA_REG1		0x00000000   /* physical mem bas addr fir CS-1 */=0A=
+#define MBM_REG1		0xFFF00000   /* mem bas mask for CS1 */=0A=
+=0A=
+/****************************************=0A=
+*    SDRAM_ONLY or SDRAM_N_SRAM section *=0A=
+****************************************/=0A=
+=0A=
+#elif MEMCFG =3D=3D SDRAM_ONLY || MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+=0A=
+/* =3D=3D=3D=3D=3D=3D=3D  128 MB DIMM section =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D*/=0A=
+=0A=
+#if DRAMSZ =3D=3D MB128=0A=
+=0A=
+#define DRAM_BNK0_BASE		0x00000000	/* 0 MB */=0A=
+#define DRAM_BNK1_BASE		0x02000000	/* 32 MB */=0A=
+#define DRAM_BNK2_BASE		0x04000000	/* 64 MB */=0A=
+#define DRAM_BNK3_BASE		0x06000000	/* 96 MB */=0A=
+=0A=
+#define DRAM_BNK0_MASK		0xFE000000	/* masks for other banks are =
defined at the end */=0A=
+=0A=
+#define SDRAM_CR_BS		0xB90500FF | TRCD	/* SDRAM enable */=0A=
+#define SDRAM_DS_BS		0x390500FF | TRCD	/* SDRAM disable */=0A=
+#define SDRAM_PC_VAL		0xB90501A0 | TRCD	/* precharge value */=0A=
+#define SDRAM_RFRSH_CMD		0xB9050090 | TRCD	/* refresh command */=0A=
+#define SDRAM_MODE_REG		0xB9050080 | TRCD	/* mode register */=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/* leave a gap of one SDRAM bank's worth of space between end of SDRAM =
and start of SRAM */=0A=
+#define MBA_REG1 		0x0A000000  	/* physical mem bas add for CS1 - =
128MB + 32MB*/=0A=
+#define MBM_REG1 		0xFFF00000  	/* mem bas mask for CS1 - SRAM */=0A=
+#endif 						/* #if MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+/* =3D=3D=3D=3D=3D=3D=3D=3D  32MB DIMM section  =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D*/=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32=0A=
+=0A=
+#define DRAM_BNK0_BASE		0x00000000   	/* 0 MB */=0A=
+#define DRAM_BNK1_BASE		0x00800000	/* 8 MB */=0A=
+#define DRAM_BNK2_BASE		0x01000000	/* 16 MB */=0A=
+#define DRAM_BNK3_BASE		0x01800000	/* 24 MB */=0A=
+=0A=
+#define DRAM_BNK0_MASK		0xFF800000	/* masks for other banks are =
defined at the end */=0A=
+=0A=
+#define SDRAM_CR_BS		0xB90500FF | TRCD	/* SDRAM enable */=0A=
+#define SDRAM_DS_BS		0x390500FF | TRCD	/* SDRAM disable */=0A=
+#define SDRAM_PC_VAL		0xB90501A0 | TRCD	/* precharge value */=0A=
+#define SDRAM_RFRSH_CMD		0xB9050090 | TRCD	/* refresh command */=0A=
+#define SDRAM_MODE_REG		0xB9050080 | TRCD	/* mode register */=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/* leave a gap of one SDRAM bank's worth of space between end of SDRAM =
and start of SRAM */=0A=
+#define MBA_REG1		0x04000000  	/* physical mem bas add for CS1 - =
32MB*/=0A=
+#define MBM_REG1		0xFFF00000  	/* mem bas mask for CS1 - SRAM */=0A=
+#endif 						/* MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+/* =3D=3D=3D=3D=3D=3D=3D  32MB or 64 MB SODIMM section =
=3D=3D=3D=3D=3D=3D=3D=3D */=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32SO=0A=
+=0A=
+#define DRAM_BNK0_BASE		0x00000000	/* 0 MB */=0A=
+#define DRAM_BNK1_BASE		0x01000000	/* 8 MB */=0A=
+#define DRAM_BNK2_BASE		0x02000000	/* 16 MB */=0A=
+#define DRAM_BNK3_BASE		0x03000000	/* 24 MB */=0A=
+=0A=
+#define DRAM_BNK0_MASK		0xFF000000	/* masks for other banks are =
defined at the end */=0A=
+=0A=
+#define SDRAM_CR_BS		0x890580FF | TRCD	/* SDRAM enable */=0A=
+#define SDRAM_DS_BS		0x090580FF | TRCD	/* SDRAM disable */=0A=
+#define SDRAM_PC_VAL		0x890580A0 | TRCD	/* Precharge value */=0A=
+#define SDRAM_RFRSH_CMD		0x89058090 | TRCD	/* Refresh command */=0A=
+#define SDRAM_MODE_REG		0x89058080 | TRCD	/* Mode register */=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/* leave a gap of one SDRAM bank's worth of space between end of SDRAM =
and start of SRAM */=0A=
+#define MBA_REG1		0x04000000	/* physical mem bas add for CS1 - =
32MB*/=0A=
+#define MBM_REG1		0xFFF00000	/* mem bas mask for CS1 - SRAM */=0A=
+#endif 						/* MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+#endif /* DRAMSZ =3D=3D MB32SO */=0A=
+=0A=
+/***************************************************=0A=
+*    SRAM_N_SDRAM section (assumes 1 MB SRAM)     *=0A=
+***************************************************/=0A=
+=0A=
+#elif MEMCFG =3D=3D SRAM_N_SDRAM=0A=
+=0A=
+/* =3D=3D=3D=3D=3D=3D=3D=3D=3D 128MB DIMM section =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D */=0A=
+=0A=
+#if DRAMSZ =3D=3D MB128=0A=
+=0A=
+#define MBA_REG1		0x00000000	/* physical mem bas addr for CS1 */=0A=
+#define MBM_REG1		0xFFF00000	/* mem nase mask for CS1 */=0A=
+=0A=
+/* leave a gap of one SDRAM bank's worth of space between end of SRAM =
and start of SDRAM */=0A=
+#define DRAM_BNK0_BASE		0x02000000	/* bank 0 at 32 MB */=0A=
+#define DRAM_BNK1_BASE		0x04000000	/* 64 MB */=0A=
+#define DRAM_BNK2_BASE		0x06000000	/* 96 MB */=0A=
+#define DRAM_BNK3_BASE		0x08000000	/* 128 MB */=0A=
+=0A=
+#define DRAM_BNK0_MASK		0xFE000000	/* masks for other banks are =
defined at the end */=0A=
+=0A=
+#define SDRAM_CR_BS		0xB95500FF | TRCD	/* SDRAM enable */=0A=
+#define SDRAM_DS_BS		0x395500FF | TRCD	/* SDRAM disable */=0A=
+#define SDRAM_PC_VAL		0xB95501A0 | TRCD	/* precharge value */=0A=
+#define SDRAM_RFRSH_CMD		0xB9550090 | TRCD	/* refresh command */=0A=
+#define SDRAM_MODE_REG		0xB9550080 | TRCD	/* mode register */=0A=
+=0A=
+=0A=
+/* =3D=3D=3D=3D=3D=3D=3D=3D=3D 32MB DIMM section =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D */=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32=0A=
+=0A=
+#define MBA_REG1		0x00000000	/* physical mem bas addr for CS1 */=0A=
+#define MBM_REG1		0xFFF00000	/* mem nase mask for CS1 */=0A=
+=0A=
+/* leave a gap of one SDRAM bank's worth of space between end of SRAM =
and start of SDRAM */=0A=
+#define DRAM_BNK0_BASE		0x00800000=0A=
+#define DRAM_BNK1_BASE		0x01000000=0A=
+#define DRAM_BNK2_BASE		0x01800000=0A=
+#define DRAM_BNK3_BASE		0x02000000=0A=
+=0A=
+#define DRAM_BNK0_MASK		0xFF800000	/* masks for other banks are =
defined at the end */=0A=
+=0A=
+#define SDRAM_CR_BS		0xB95500FF | TRCD	/* SDRAM enable */=0A=
+#define SDRAM_DS_BS		0x395500FF | TRCD	/* SDRAM disable */=0A=
+#define SDRAM_PC_VAL		0xB95501A0 | TRCD	/* precharge value */=0A=
+#define SDRAM_RFRSH_CMD		0xB9550090 | TRCD	/* refresh command */=0A=
+#define SDRAM_MODE_REG		0xB9550080 | TRCD	/* mode register */=0A=
+=0A=
+/* =3D=3D=3D=3D=3D=3D=3D  32MB or 64 MB SODIMM section =
=3D=3D=3D=3D=3D=3D=3D=3D */=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32SO=0A=
+=0A=
+#define MBA_REG1		0x00000000	/* physical mem bas addr for CS1 */=0A=
+#define MBM_REG1		0xFFF00000	/* mem nase mask for CS1 */=0A=
+=0A=
+/* leave a gap of one SDRAM bank's worth of space between end of SRAM =
and start of SDRAM */=0A=
+#define DRAM_BNK0_BASE		0x01000000=0A=
+#define DRAM_BNK1_BASE		0x02000000=0A=
+#define DRAM_BNK2_BASE		0x03000000=0A=
+#define DRAM_BNK3_BASE		0x04000000=0A=
+=0A=
+#define DRAM_BNK0_MASK		0xFF000000	/* masks for other banks are =
defined at the end */=0A=
+=0A=
+#define SDRAM_CR_BS		0x8955C0FF | TRCD	/* SDRAM enable */=0A=
+#define SDRAM_DS_BS		0x0955C0FF | TRCD	/* SDRAM disable */=0A=
+#define SDRAM_PC_VAL		0x8955C0A0 | TRCD	/* precharge value */=0A=
+#define	SDRAM_RFRSH_CMD		0x8955C090 | TRCD	/* refresh command */=0A=
+#define SDRAM_MODE_REG     	0x8955C080 | TRCD	/* mode register */=0A=
+=0A=
+#else=0A=
+#error "unrecognized dram size"=0A=
+#endif /* DRAMSZ */=0A=
+=0A=
+#else=0A=
+#error "unrecogized memory configuration parameter"=0A=
+#endif /* error */=0A=
+=0A=
+/* These settings apply to all types of SDRAM modules */=0A=
+#if MEMCFG !=3D SRAM_ONLY=0A=
+=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+=0A=
+#define DRAM_RF_CNT_BS		0x00000000   /* Refresh Count Reg setting*/=0A=
+#define DRAM_RF_CMPR_BS		0x00000040   /* Refresh Compare Reg: fast =
expiration */=0A=
+=0A=
+#if MHZ =3D=3D 50000000=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000002E8   /* Refresh Compare Reg: =
standard expiration */=0A=
+#elif MHZ =3D=3D 66500000=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000003E0   /* Refresh Compare Reg: =
standard expiration */=0A=
+#elif	MHZ =3D=3D 75000000=0A=
+#define DRAM_RF_CMPR_SE_BS	0x00000460   /* Refresh Compare Reg: =
standard expiration */=0A=
+#else=0A=
+#error "MHZ setting in the Makefile must be equal to 50000000, =
66500000 or 75000000 "=0A=
+#endif=0A=
+=0A=
+#endif=0A=
+/* parameters for initialising the S134 board EEPROM */=0A=
+#define DESTRUCTIVE 			1=0A=
+#define NONDESTRUCTIVE 		0=0A=
+=0A=
+#endif /* __S334RAM__ */=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/s334ram.h =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/s334ram.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/s334ram.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/s334ram.h	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,836 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT S334 SDRAM setup values.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S334RAM__=0A=
+#define __S334RAM__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+=0A=
+#define SRAM_ONLY	1=0A=
+#define SDRAM_ONLY	2=0A=
+#define EDO_ONLY	3=0A=
+#define SRAM_N_SDRAM	4=0A=
+#define SRAM_N_EDO	5=0A=
+#define SDRAM_N_SRAM	6=0A=
+#define EDO_N_SRAM	7=0A=
+=0A=
+#define MB32	1=0A=
+#define MB64	2=0A=
+#define MB128	3=0A=
+#define MB32SO  4=0A=
+=0A=
+#define EP8	1=0A=
+#define EP32	2=0A=
+=0A=
+#define EXTU	1=0A=
+#define INTU	2=0A=
+=0A=
+#ifndef LED_BASE=0A=
+=0A=
+#if defined(EB332)=0A=
+#define	LED_BASE	PHYS_TO_K1(0x10000000)=0A=
+#define	LED_DIGIT0	0xC=0A=
+#define	LED_DIGIT1	0x8=0A=
+#define	LED_DIGIT2	0x4=0A=
+#define	LED_DIGIT3	0x0=0A=
+#define	LED_CLEAR	0x400=0A=
+#else=0A=
+#define	LED_BASE	PHYS_TO_K1(0x14000000)=0A=
+#define	LED_DIGIT0	0xf=0A=
+#define	LED_DIGIT1	0xb=0A=
+#define	LED_DIGIT2	0x7=0A=
+#define	LED_DIGIT3	0x3=0A=
+#define	LED_CLEAR	0x400=0A=
+#endif=0A=
+=0A=
+#endif=0A=
+=0A=
+#define SYS_BTA_CTRL            PHYS_TO_K1(0x18000000)=0A=
+#define SYS_ALT_CTRL            PHYS_TO_K1(0x18000004)=0A=
+#if MHZ < 67000000=0A=
+#warning : compiling for less than 67 MHz=0A=
+#define SYS_ALT_SETUP           0x00000003  =0A=
+#else=0A=
+#warning : compiling for more than 67 MHz=0A=
+#define SYS_ALT_SETUP           0x00000007   =0A=
+#endif=0A=
+#define	PORT_WIDTH_CONTROL	0xffffe200	/* port width control register =
address */=0A=
+#define	BTA_CONTROL		0xffffe204      /* was 0xffffe240 - hak 06-16-98 =
- BTA control register address */=0A=
+#define	BTA_SETUP		0x3fffffff      /* 3 turnaround cycles for all =
regions */=0A=
+=0A=
+#if EPRMPRTWD =3D=3D EP8=0A=
+/*#define	PORT_SETUP		0xaaa22aaa       was 0xaaa82aaa - hak 06-16-98, =
today 22 is for boot prom and external UART 1-4-99 */=0A=
+#if defined(EB332)=0A=
+#define PORT_SETUP              0xaaa22aaa=0A=
+#else=0A=
+#define	PORT_SETUP		0xaa822aaa       /* changed for 8-bit wide NVRAM =
at physical 1200_0000: Upen-000530*/=0A=
+#endif /* EB332 */=0A=
+#elif EPRMPRTWD =3D=3D EP32=0A=
+#define PORT_SETUP		0xaaa2aaaa	/* boot EPROM space port width =3D 32 =
bits */=0A=
+#else=0A=
+#error "illegal value for eprom port width"=0A=
+#endif=0A=
+=0A=
+#define MEM_CTL_BASE		PHYS_TO_K1(0x18000200)	/* base address of all =
(0-5) Memory Control Registers */=0A=
+#define MEM_BASE_BASE		PHYS_TO_K1(0x18000080)	/* base address of 2 =
(0-1) Base Address Registers */=0A=
+#define R32134_IREG_BASE		PHYS_TO_K1(0x18000000)	/* all R32134 =
internal registers' base address */=0A=
+=0A=
+/* =0A=
+** b14:13=3D>01=3DPROM;b12=3D>1=3D do not assert CS during writes; =
b11:10=3D>00=3D8 bit port =0A=
+** b09:05=3D>0A=3D10 wait states; b04:00=3D>0A=3D 10 wait states=0A=
+*/=0A=
+=0A=
+=0A=
+/*#define MCR_CS0_BS		0x31ef31ef*/=0A=
+#define MCR_CS0_BS		0x30843084=0A=
+=0A=
+/* =0A=
+** b14:13=3D>00=3DSRAM;b12=3D>0=3D assert CS during writes; =
b11:10=3D>10=3D32 bit port =0A=
+** b09:05=3D>FF=3D31 wait states; b04:00=3D>FF=3D 31 wait states.=0A=
+** NOTE: wait states should be tuned.=0A=
+*/=0A=
+=0A=
+=0A=
+/*#define MCR_CS1_BS		0x28e728e7*/=0A=
+#define MCR_CS1_BS		0x28a528a5=0A=
+=0A=
+#define MCR_CS2_BS		0xa0e7a0e7=0A=
+=0A=
+#define MCR_CS3_BS		0xa0e7a0e7=0A=
+=0A=
+#define MCR_CS4_BS		0xa0e7a0e7     /* S334 LED */=0A=
+=0A=
+=0A=
+/* =0A=
+** b14:13=3D>01=3DI Type;b12=3D>0=3D assert CS during writes; =
b11:10=3D>00=3D8 bit port =0A=
+** b09:05=3D>FF=3D31 wait states; b04:00=3D>FF=3D 31 wait states=0A=
+*/=0A=
+=0A=
+#define MCR_CS5_BS		0xa0E7a0E7=0A=
+/*#define MCR_CS5_BS		0x21EF21EF*/=0A=
+=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 0 - =
EPROM=0A=
+** NOTE: for starters see if you can just set the default value: =
0x1FC00000=0A=
+*/=0A=
+#define MBA_REG0		0x1FC00000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 0 - EPROM - 4MB=0A=
+*/=0A=
+#define MBM_REG0		0xFFC00000=0A=
+=0A=
+=0A=
+#define CPU_BERR_BS		0xFF=0A=
+#define IP_BERR_BS		0xFF=0A=
+=0A=
+=0A=
+=0A=
+#if MEMCFG =3D=3D SRAM_ONLY=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1		0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+=0A=
+#elif MEMCFG =3D=3D SDRAM_ONLY || MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/*=0A=
+*************************************=0A=
+** SDRAM_ONLY or SDRAM_N_SRAM section=0A=
+*************************************=0A=
+*/=0A=
+=0A=
+#define APATTERN 0xa5a5a5a5=0A=
+=0A=
+#if DRAMSZ =3D=3D MB128=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 128MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 0MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE		0x00000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 32MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE		0x02000000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 64MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE		0x04000000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 96MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE		0x06000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK		0xFFF00000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS		0xb95500FF	/* old: 0x9EFBOOFF */=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS		0x2AF800FF=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL		0xb95501a0=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+#define	SDRAM_RFRSH_CMD		0xb9550090=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG		0xAAF80080=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+** at 128MB:=0A=
+*/=0A=
+#define MBA_REG1		0x08000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+=0A=
+#endif /* #if MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 32MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 0MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE		0x00000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 8MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE		0x00800000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 16MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE		0x01000000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 24MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE		0x01800000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK		0xFF800000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS		0xB95500FF	/* 11:18:99 0xBAF800FF */=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS		0x395500FF	/* 11:18:99 0x3AF800FF */=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL		0xB95501A0	/* 11:18:99 0xBAF801A0 */=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+#define	SDRAM_RFRSH_CMD		0xB9550090	/* 11:18:99 0xBAF80090 */=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG		0xB9550080	/* 11:18:99 0xBAF80080 */=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS		0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS		0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000002A0=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+** at 32MB:=0A=
+*/=0A=
+#define MBA_REG1		0x04000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+#endif /* MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32SO=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 32MB SODIMM section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 0MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE		0x03000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 8MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE		0x02000000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 16MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE		0x01000000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 24MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE		0x00000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK		0xFF000000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+/*#define SDRAM_CR_BS		0x8E78C0FF */   /* 11:18:99 0xBAF800FF */=0A=
+#define SDRAM_CR_BS		0x895580FF=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+/* #define SDRAM_DS_BS		0x0E78C0FF*/	/* 11:18:99 0x3AF800FF */=0A=
+#define SDRAM_DS_BS		0x095580FF=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+/* #define SDRAM_PC_VAL		0x8E78C0A0*/	/* 11:18:99 0xBAF801A0 */=0A=
+#define SDRAM_PC_VAL		0x895580A0=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+/* #define	SDRAM_RFRSH_CMD	  0x8E78C090*/	/* 11:18:99 0xBAF80090 */=0A=
+#define	SDRAM_RFRSH_CMD	        0x89558090=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+/*#define SDRAM_MODE_REG	0x8E78C080*/	/* 11:18:99 0xBAF80080 */=0A=
+#define SDRAM_MODE_REG	        0x89558080=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS		0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS		0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000002A0=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+** at 32MB:=0A=
+*/=0A=
+#define MBA_REG1		0x04000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+#endif /* MEMCFG =3D=3D SDRAM_N_SRAM */=0A=
+=0A=
+#endif /* DRAMSZ =3D=3D MB32SO */=0A=
+=0A=
+#elif MEMCFG =3D=3D EDO_ONLY || MEMCFG =3D=3D EDO_N_SRAM=0A=
+/*=0A=
+*****************************************=0A=
+** EDO only section or EDO_N_SRAM section=0A=
+*****************************************=0A=
+*/=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 0MB=0A=
+*/=0A=
+#define DRAM_BNK0_BASE		0x00000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 16MB=0A=
+*/=0A=
+#define DRAM_BNK1_BASE		0x01000000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 32MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE		0x02000000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 48MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE		0x03000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK		0xFF000000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+=0A=
+/*=0A=
+** EDO control register bit settings=0A=
+*/=0A=
+=0A=
+#define EDO_CR_BS		0x80000BA8	/* 0x80000E02 */=0A=
+=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS		0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS		0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000000A0=0A=
+=0A=
+/*=0A=
+** EDO control register bit settings=0A=
+*/=0A=
+=0A=
+#define EDO_CR_BS		0x80000BA8	/* 0x80000E02 */=0A=
+=0A=
+#if MEMCFG =3D=3D EDO_N_SRAM=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+** at 64MB:=0A=
+*/=0A=
+#define MBA_REG1		0x04000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+#endif /* MEMCFG =3D=3D EDO_N_SRAM */=0A=
+=0A=
+#elif MEMCFG =3D=3D SRAM_N_SDRAM=0A=
+=0A=
+#define APATTERN 0xa5a5a5a5=0A=
+=0A=
+/*=0A=
+*******************************=0A=
+** SRAM and SDRAM section=0A=
+*******************************=0A=
+*/=0A=
+#if DRAMSZ =3D=3D MB128=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 128MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1		0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 32MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE		0x02000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 64MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE		0x04000000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 96MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE		0x06000000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 128MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE		0x08000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK		0xFE000000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS		0xAAF800FF	/* old: 0x9EFBOOFF */=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS		0x2AF800FF=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL		0xAAF801A0=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+#define	SDRAM_RFRSH_CMD		0xAAF80090=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG		0xAAF80080=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS		0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS		0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000000A0=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 32MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1		0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 8MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE		0x00800000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 16MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE		0x01000000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 24MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE		0x01800000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 64MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE		0x02000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK		0xFF800000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+#define SDRAM_CR_BS		0xB95500FF	/* 11:18:99 0xBAF800FF */=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+#define SDRAM_DS_BS		0x395500FF	/* 11:18:99 0x3AF800FF */=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+#define SDRAM_PC_VAL		0xB95501A0	/* 11:18:99 0xBAF801A0 */=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+#define	SDRAM_RFRSH_CMD		0xB9550090	/* 11:18:99 0xBAF80090 */=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+#define SDRAM_MODE_REG		0xB9550080	/* 11:18:99 0xBAF80080 */=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS		0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS		0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000001A0	/* 11:18:99 0x000000A0 */=0A=
+=0A=
+#elif DRAMSZ =3D=3D MB32SO=0A=
+/*=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+=3D=3D 32MB section=0A=
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=0A=
+*/=0A=
+=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1		0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 8MB:=0A=
+*/=0A=
+#define DRAM_BNK0_BASE		0x04000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 16MB:=0A=
+*/=0A=
+#define DRAM_BNK1_BASE		0x03000000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 24MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE		0x02000000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 64MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE		0x01000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK		0xFF000000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** SDRAM ENABLE Settings=0A=
+*/=0A=
+/* #define SDRAM_CR_BS		0x8E78C0FF*/	/* 11:18:99 0xBAF800FF */=0A=
+#define SDRAM_CR_BS		0x8955C0FF=0A=
+/*=0A=
+** SDRAM DISABLE Settings=0A=
+*/=0A=
+/* #define SDRAM_DS_BS		0x0E78C0FF*/	/* 11:18:99 0x3AF800FF */=0A=
+#define SDRAM_DS_BS		0x0955C0FF=0A=
+/*=0A=
+** Precharge Value=0A=
+*/=0A=
+/* #define SDRAM_PC_VAL		0x8E78C0A0*/	/* 11:18:99 0xBAF801A0 */=0A=
+#define SDRAM_PC_VAL		0x8955C0A0=0A=
+/*=0A=
+** Refresh Cmd=0A=
+*/=0A=
+/*#define	SDRAM_RFRSH_CMD	  0x8E78C090*/	/* 11:18:99 0xBAF80090 */=0A=
+#define	SDRAM_RFRSH_CMD	        0x8955C090=0A=
+/*=0A=
+** Mode Register=0A=
+*/=0A=
+/*#define SDRAM_MODE_REG      0x8E78C080*/	/* 11:18:99 0xBAF80080 =
*/=0A=
+#define SDRAM_MODE_REG          0x8955C080=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS		0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS		0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000001A0	/* 11:18:99 0x000000A0 */=0A=
+=0A=
+#else=0A=
+#error "unrecognized dram size"=0A=
+#endif /* DRAMSZ */=0A=
+=0A=
+#elif MEMCFG =3D=3D SRAM_N_EDO=0A=
+/*=0A=
+** physical memory base address register value for Chip Select 1 - =
SRAM=0A=
+*/=0A=
+#define MBA_REG1		0x00000000=0A=
+=0A=
+/*=0A=
+** memory base mask register value for Chip Select 1 - SRAM - 1MB=0A=
+*/=0A=
+#define MBM_REG1		0xFFF00000=0A=
+=0A=
+/*=0A=
+** DRAM BANK0 BASE.  Starting Bank at 16MB=0A=
+*/=0A=
+#define DRAM_BNK0_BASE		0x01000000=0A=
+/*=0A=
+** DRAM BANK1 BASE. 2nd bank at 32MB=0A=
+*/=0A=
+#define DRAM_BNK1_BASE		0x02000000=0A=
+/*=0A=
+** DRAM BANK2 BASE. 3rd bank at 48MB:=0A=
+*/=0A=
+#define DRAM_BNK2_BASE		0x03000000=0A=
+/*=0A=
+** DRAM BANK3 BASE. 4th bank at 64MB:=0A=
+*/=0A=
+#define DRAM_BNK3_BASE		0x04000000=0A=
+/*=0A=
+** DRAM Bank 0 Mask=0A=
+*/=0A=
+#define DRAM_BNK0_MASK		0xFF000000=0A=
+/*=0A=
+** DRAM Bank 1 Mask=0A=
+*/=0A=
+#define DRAM_BNK1_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 2 Mask=0A=
+*/=0A=
+#define DRAM_BNK2_MASK		DRAM_BNK0_MASK=0A=
+/*=0A=
+** DRAM Bank 3 Mask=0A=
+*/=0A=
+#define DRAM_BNK3_MASK		DRAM_BNK0_MASK=0A=
+=0A=
+/*=0A=
+** EDO control register bit settings=0A=
+*/=0A=
+#define EDO_CR_BS		0x80000BA8	/* 0x80000E02 */=0A=
+=0A=
+/*=0A=
+** Refresh Count Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CNT_BS		0x00000000=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings=0A=
+*/=0A=
+#define DRAM_RF_CMPR_BS		0x00000040=0A=
+/*=0A=
+** Refresh Compare Register Bit Settings for Slow Expiration=0A=
+*/=0A=
+#define DRAM_RF_CMPR_SE_BS	0x000000A0=0A=
+=0A=
+#else=0A=
+#error "unrecogized memory configuration parameter"=0A=
+#endif /* error */=0A=
+=0A=
+/* parameters for initialising the S134 board EEPROM */=0A=
+#define DESTRUCTIVE 1=0A=
+#define NONDESTRUCTIVE 0=0A=
+=0A=
+#endif /* __S334RAM__ */=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/s364.h =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/s364.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/s364.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/s364.h	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,155 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT S334 definitions=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S364134__=0A=
+#define __S364134__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+#ifndef GPIO_BASE=0A=
+#ifdef S355=0A=
+#define GPIO_BASE PHYS_TO_K1(0x18040000)=0A=
+#else=0A=
+#define GPIO_BASE PHYS_TO_K1(0x18000600)=0A=
+#endif=0A=
+#endif=0A=
+/*=0A=
+** following defines simple and uniform to save and restore context=0A=
+** when enrtering and leaving as assemblu language program when =
memory=0A=
+** and registers are both premiunm.=0A=
+*/=0A=
+#define SAVE_CNTXT    \=0A=
+  subu  sp,64;    \=0A=
+  sw  t0,60(sp);  \=0A=
+  sw  t1,56(sp);  \=0A=
+  sw  t2,52(sp);  \=0A=
+  sw  t3,48(sp);  \=0A=
+  sw  t4,44(sp);  \=0A=
+  sw  t5,40(sp);  \=0A=
+  sw  t6,36(sp);  \=0A=
+  sw  t7,32(sp);  \=0A=
+  sw  t8,28(sp);  \=0A=
+  sw  t9,24(sp);  \=0A=
+  sw  a0,20(sp);  \=0A=
+  sw  a1,16(sp);  \=0A=
+  sw  a2,12(sp);  \=0A=
+  sw  a3,8(sp); \=0A=
+  sw  ra,4(sp)=0A=
+=0A=
+#define RSTR_CNTXT    \=0A=
+  lw  t0,60(sp);  \=0A=
+  lw  t1,56(sp);  \=0A=
+  lw  t2,52(sp);  \=0A=
+  lw  t3,48(sp);  \=0A=
+  lw  t4,44(sp);  \=0A=
+  lw  t5,40(sp);  \=0A=
+  lw  t6,36(sp);  \=0A=
+  lw  t7,32(sp);  \=0A=
+  lw  t8,28(sp);  \=0A=
+  lw  t9,24(sp);  \=0A=
+  lw  a0,20(sp);  \=0A=
+  lw  a1,16(sp);  \=0A=
+  lw  a2,12(sp);  \=0A=
+  lw  a3,8(sp); \=0A=
+  lw  ra,4(sp); \=0A=
+  add sp,64=0A=
+=0A=
+/*=0A=
+** Following define is to specify a maximum value for a software=0A=
+** busy wait counter.=0A=
+*/=0A=
+=0A=
+#define LP_CNT_100NS  1000      /* set this based on processor speed =
*/=0A=
+#define LP_CNT_3S     1000000   /* set this based on processor speed =
*/=0A=
+=0A=
+/*=0A=
+** Following are other common timer definitions.=0A=
+*/=0A=
+#ifdef S355=0A=
+#define TIMER_BASE    PHYS_TO_K1(0x18028000)  =0A=
+#define TIMEOUT_COUNT 0x00000FFF=0A=
+#else=0A=
+#define TIMER_BASE    PHYS_TO_K1(0x18000700)  =0A=
+#endif=0A=
+#define ENABLE_TIMER  0x1=0A=
+#define DISABLE_TIMER 0x0=0A=
+#define BIG_VALUE     0xFFFFFFFF=0A=
+=0A=
+#ifdef S355=0A=
+/* There is no DISPLAY on 355 boards*/=0A=
+#elif defined(S334)=0A=
+/*=0A=
+** following few lines define a macro DISPLAY=0A=
+** which is used to write a set of 4 characters=0A=
+** onto the S334 LED.=0A=
+*/=0A=
+=0A=
+#if defined(EB332)=0A=
+#define LED_BASE      PHYS_TO_K1(0x10000000)=0A=
+#define LED_DIGIT0    0xc=0A=
+#define LED_DIGIT1    0x8=0A=
+#define LED_DIGIT2    0x4=0A=
+#define LED_DIGIT3    0x0=0A=
+=0A=
+#define LED_CLEAR     0x400=0A=
+=0A=
+#else=0A=
+#define LED_BASE      PHYS_TO_K1(0x14000000)=0A=
+#define LED_DIGIT0    0xf=0A=
+#define LED_DIGIT1    0xb=0A=
+#define LED_DIGIT2    0x7=0A=
+#define LED_DIGIT3    0x3=0A=
+=0A=
+#define LED_CLEAR     0x400=0A=
+=0A=
+#endif=0A=
+=0A=
+#define DISPLAY(d0, d1, d2, d3)     \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        lb    t7, LED_CLEAR(t6)               ;\=0A=
+              nop                             ;\=0A=
+        li    t7, (d0) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT0(t6)              ;\=0A=
+        li    t7, (d1) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT1(t6)              ;\=0A=
+        li    t7, (d2) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT2(t6)              ;\=0A=
+        li    t7, (d3) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT3(t6)=0A=
+=0A=
+#define LEDCLEAR()              \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        lb    t7, LED_CLEAR(t6)               ;\=0A=
+              nop=0A=
+=0A=
+#endif=0A=
+=0A=
+#define DESTRUCTIVE     1=0A=
+#define NONDESTRUCTIVE  0=0A=
+=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/uart16550.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/uart16550.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/uart16550.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/uart16550.c	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,178 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   UART code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+=0A=
+#define RC32334_REG_BASE   0xb8000000=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32300_UART0_BASE (RC32334_REG_BASE + 0x0803)=0A=
+#else=0A=
+#define RC32300_UART0_BASE (RC32334_REG_BASE + 0x0800)=0A=
+#endif=0A=
+=0A=
+#define BASE		RC32300_UART0_BASE=0A=
+=0A=
+#define MAX_BAUD	(CONFIG_IDT_BOARD_FREQ / 16)=0A=
+#define REG_OFFSET	0x4=0A=
+=0A=
+/* =3D=3D=3D CONFIG =3D=3D=3D */=0A=
+=0A=
+/*=0A=
+ * #define BASE			0xb2001000=0A=
+ * #define MAX_BAUD		1152000=0A=
+ * #define REG_OFFSET		0x10=0A=
+ */=0A=
+#if (!defined(BASE) || !defined(MAX_BAUD) || !defined(REG_OFFSET))=0A=
+#error You must define BASE, MAX_BAUD and REG_OFFSET in the =
Makefile.=0A=
+#endif=0A=
+=0A=
+#ifndef INIT_SERIAL_PORT=0A=
+#define INIT_SERIAL_PORT	1=0A=
+#endif=0A=
+=0A=
+#ifndef DEFAULT_BAUD=0A=
+//#define DEFAULT_BAUD		UART16550_BAUD_115200=0A=
+#define DEFAULT_BAUD		UART16550_BAUD_9600=0A=
+#endif=0A=
+#ifndef DEFAULT_PARITY=0A=
+#define DEFAULT_PARITY		UART16550_PARITY_NONE=0A=
+#endif=0A=
+#ifndef DEFAULT_DATA=0A=
+#define DEFAULT_DATA		UART16550_DATA_8BIT=0A=
+#endif=0A=
+#ifndef DEFAULT_STOP=0A=
+#define DEFAULT_STOP		UART16550_STOP_1BIT=0A=
+#endif=0A=
+=0A=
+/* =3D=3D=3D END OF CONFIG =3D=3D=3D */=0A=
+=0A=
+typedef         unsigned char uint8;=0A=
+typedef         unsigned int  uint32;=0A=
+=0A=
+#define         UART16550_BAUD_2400             2400=0A=
+#define         UART16550_BAUD_4800             4800=0A=
+#define         UART16550_BAUD_9600             9600=0A=
+#define         UART16550_BAUD_19200            19200=0A=
+#define         UART16550_BAUD_38400            38400=0A=
+#define         UART16550_BAUD_57600            57600=0A=
+#define         UART16550_BAUD_115200           115200=0A=
+=0A=
+#define         UART16550_PARITY_NONE           0=0A=
+#define         UART16550_PARITY_ODD            0x08=0A=
+#define         UART16550_PARITY_EVEN           0x18=0A=
+#define         UART16550_PARITY_MARK           0x28=0A=
+#define         UART16550_PARITY_SPACE          0x38=0A=
+=0A=
+#define         UART16550_DATA_5BIT             0x0=0A=
+#define         UART16550_DATA_6BIT             0x1=0A=
+#define         UART16550_DATA_7BIT             0x2=0A=
+#define         UART16550_DATA_8BIT             0x3=0A=
+=0A=
+#define         UART16550_STOP_1BIT             0x0=0A=
+#define         UART16550_STOP_2BIT             0x4=0A=
+=0A=
+/* register offset */=0A=
+#define		OFS_RCV_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_TRANS_HOLD		(0*REG_OFFSET)=0A=
+#define		OFS_SEND_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_INTR_ENABLE		(1*REG_OFFSET)=0A=
+#define		OFS_INTR_ID		(2*REG_OFFSET)=0A=
+#define		OFS_DATA_FORMAT		(3*REG_OFFSET)=0A=
+#define		OFS_LINE_CONTROL	(3*REG_OFFSET)=0A=
+#define		OFS_MODEM_CONTROL	(4*REG_OFFSET)=0A=
+#define		OFS_RS232_OUTPUT	(4*REG_OFFSET)=0A=
+#define		OFS_LINE_STATUS		(5*REG_OFFSET)=0A=
+#define		OFS_MODEM_STATUS	(6*REG_OFFSET)=0A=
+#define		OFS_RS232_INPUT		(6*REG_OFFSET)=0A=
+#define		OFS_SCRATCH_PAD		(7*REG_OFFSET)=0A=
+=0A=
+#define		OFS_DIVISOR_LSB		(0*REG_OFFSET)=0A=
+#define		OFS_DIVISOR_MSB		(1*REG_OFFSET)=0A=
+=0A=
+#define		UART16550_READ(y)    (*((volatile uint8*)(BASE + y)))=0A=
+#define		UART16550_WRITE(y, z)  ((*((volatile uint8*)(BASE + y))) =3D =
z)=0A=
+=0A=
+static void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 =
stop)=0A=
+{=0A=
+	/* disable interrupts */=0A=
+	UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	UART16550_WRITE(OFS_INTR_ENABLE, 0);=0A=
+=0A=
+	/* set up baud rate */=0A=
+	{=0A=
+		uint32 divisor;=0A=
+=0A=
+		/* set DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x80);=0A=
+=0A=
+		/* set divisor */=0A=
+		divisor =3D MAX_BAUD / baud;=0A=
+		UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);=0A=
+		UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);=0A=
+=0A=
+		/* clear DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	}=0A=
+=0A=
+	/* set data format */=0A=
+	UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);=0A=
+}=0A=
+=0A=
+=0A=
+void=0A=
+putc_init(void)=0A=
+{=0A=
+#if INIT_SERIAL_PORT=0A=
+	Uart16550Init(DEFAULT_BAUD, DEFAULT_DATA, DEFAULT_PARITY, =
DEFAULT_STOP);=0A=
+#endif=0A=
+}=0A=
+=0A=
+void=0A=
+putc(unsigned char c)=0A=
+{=0A=
+	while ((UART16550_READ(OFS_LINE_STATUS) &0x20) =3D=3D 0);=0A=
+	UART16550_WRITE(OFS_SEND_BUFFER, c);=0A=
+}=0A=
+=0A=
+#if 0=0A=
+unsigned char=0A=
+getc(void)=0A=
+{=0A=
+	while((UART16550_READ(OFS_LINE_STATUS) & 0x1) =3D=3D 0);=0A=
+	return UART16550_READ(OFS_RCV_BUFFER);=0A=
+}=0A=
+=0A=
+int=0A=
+tstc(void)=0A=
+{=0A=
+	return((UART16550_READ(OFS_LINE_STATUS) & 0x01) !=3D 0);=0A=
+}=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/zImage.lds =
idtlinux/arch/mips/idt-boards/rc32300/S334/boot/zImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/boot/zImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/boot/zImage.lds	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x80800000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32300/S334/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/idtIRQ.S =
idtlinux/arch/mips/idt-boards/rc32300/S334/idtIRQ.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/idtIRQ.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/idtIRQ.S	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,68 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Interrupt dispatcher code for IDT boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+				=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/regdef.h>=0A=
+#include <asm/stackframe.h>=0A=
+=0A=
+	.text=0A=
+	.set	noreorder=0A=
+	.set	noat=0A=
+	.align	5=0A=
+	NESTED(rc32300_IRQ, PT_SIZE, sp)=0A=
+	SAVE_ALL=0A=
+	CLI=0A=
+=0A=
+	.set	at=0A=
+	.set	noreorder=0A=
+=0A=
+	mfc0    t0, CP0_CAUSE=0A=
+	move	a1, sp=0A=
+								  =0A=
+	/* check for r4k counter/timer IRQ. */=0A=
+	=0A=
+	andi    t1, t0, CAUSEF_IP7=0A=
+	beqz    t1, 1f=0A=
+	nop=0A=
+=0A=
+	jal     idt_timer_interrupt=0A=
+	li	a0, 7=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+1:=0A=
+	jal	rc32300_irqdispatch=0A=
+	move	a0, t0=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+=0A=
+	END(rc32300_IRQ)=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/irq.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/irq.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/irq.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/irq.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,429 @@=0A=
+/*=0A=
+ * BRIEF MODULE DESCRIPTION=0A=
+ *	RC32334 interrupt routines.=0A=
+ *=0A=
+ * Copyright 2001 MontaVista Software Inc.=0A=
+ * Author: MontaVista Software, Inc.=0A=
+ *		stevel@mvista.com or source@mvista.com=0A=
+ *=0A=
+ *  This program is free software; you can redistribute	 it and/or =
modify it=0A=
+ *  under  the terms of	 the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the	License, or (at =
your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ */=0A=
+#include <linux/errno.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/signal.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/timex.h>=0A=
+#include <linux/slab.h>=0A=
+#include <linux/random.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+=0A=
+#undef DEBUG_IRQ=0A=
+//#define DEBUG_IRQ=0A=
+#ifdef DEBUG_IRQ=0A=
+/* note: prints function name for you */=0A=
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## =
args)=0A=
+#else=0A=
+#define DPRINTK(fmt, args...)=0A=
+#endif=0A=
+=0A=
+extern asmlinkage void rc32300_IRQ(void);=0A=
+=0A=
+static unsigned int startup_irq(unsigned int irq);=0A=
+static void end_irq(unsigned int irq_nr);=0A=
+static void mask_and_ack_irq(unsigned int irq_nr);=0A=
+static void rc32300_enable_irq(unsigned int irq_nr);=0A=
+static void rc32300_disable_irq(unsigned int irq_nr);=0A=
+=0A=
+extern void __init init_generic_irq(void);=0A=
+=0A=
+#ifdef CONFIG_PM=0A=
+extern void counter0_irq(int irq, void *dev_id, struct pt_regs =
*regs);=0A=
+#endif=0A=
+=0A=
+=0A=
+typedef struct {=0A=
+  int irq_base;   /* Base IRQ # of this interrupt group */=0A=
+  int num_irqs;   /* Number of IRQs in this group */=0A=
+  u32 mask;       /* mask of valid bits in pending/mask/clear=0A=
+			   registers */=0A=
+} intr_group_t;=0A=
+=0A=
+static const intr_group_t intr_group[NUM_INTR_GROUPS] =3D {=0A=
+	{ -1, NUM_INTR_GROUPS, 0x00007ffe },  /* Group 0 indicates intrs =
in=0A=
+						 groups 1-14 */=0A=
+	{ GROUP1_IRQ_BASE,   1, 0x00000001 }, // bus error intr=0A=
+	{ GROUP2_IRQ_BASE,  12, 0x00000ffb }, // PIO active low intrs=0A=
+	{ GROUP3_IRQ_BASE,   8, 0x000000fb }, // PIO active high intrs=0A=
+	{ GROUP4_IRQ_BASE,   8, 0x000000ff }, // Timer Rollover intrs=0A=
+	{ GROUP5_IRQ_BASE,   3, 0x00000007 }, // UART0 intrs=0A=
+	{ GROUP6_IRQ_BASE,   3, 0x00000007 }, // UART1 intrs=0A=
+	{ GROUP7_IRQ_BASE,   5, 0x0000001f }, // DMA Ch0 intrs=0A=
+	{ GROUP8_IRQ_BASE,   5, 0x0000001f }, // DMA Ch1 intrs=0A=
+	{ GROUP9_IRQ_BASE,   5, 0x0000001f }, // DMA Ch2 intrs=0A=
+	{ GROUP10_IRQ_BASE,  5, 0x0000001f }, // DMA Ch3 intrs=0A=
+	{ GROUP11_IRQ_BASE,  4, 0x0000000f }, // PCI Ctlr error intrs=0A=
+	{ GROUP12_IRQ_BASE, 16, 0x0000ffff }, // PCI Satellite intrs=0A=
+	{ GROUP13_IRQ_BASE,  4, 0x0000000f }, // PCI to CPU mailbox intrs=0A=
+	{ GROUP14_IRQ_BASE,  1, 0x00000001 }  // SPI intr=0A=
+};=0A=
+=0A=
+#define READ_PEND(g) \=0A=
+       rc32300_readl(IC_GROUP0_PEND + (g)*IC_GROUP_OFFSET)=0A=
+#define WRITE_PEND(g,val) \=0A=
+       rc32300_writel((val), IC_GROUP0_PEND + (g)*IC_GROUP_OFFSET)=0A=
+#define READ_MASK(g) \=0A=
+       rc32300_readl(IC_GROUP0_MASK + (g)*IC_GROUP_OFFSET)=0A=
+#define WRITE_MASK(g,val) \=0A=
+       rc32300_writel((val), IC_GROUP0_MASK + (g)*IC_GROUP_OFFSET)=0A=
+#define READ_CLEAR(g) \=0A=
+       rc32300_readl(IC_GROUP0_CLEAR + (g)*IC_GROUP_OFFSET)=0A=
+#define WRITE_CLEAR(g,val) \=0A=
+       rc32300_writel((val), IC_GROUP0_CLEAR + (g)*IC_GROUP_OFFSET)=0A=
+=0A=
+static inline int irq_to_group(unsigned int irq_nr)=0A=
+{=0A=
+	int i;=0A=
+	for (i=3DNUM_INTR_GROUPS-1; i > 0; i--) {=0A=
+		if (irq_nr >=3D intr_group[i].irq_base)=0A=
+			break;=0A=
+	}=0A=
+=0A=
+	return i;=0A=
+}=0A=
+=0A=
+static inline int ip_to_irq(int ipnum)=0A=
+{=0A=
+	return ipnum;=0A=
+}=0A=
+=0A=
+static inline int irq_to_ip(int irq)=0A=
+{=0A=
+	return (irq < GROUP1_IRQ_BASE) ? irq : 5;=0A=
+}=0A=
+=0A=
+static inline void enable_local_irq(unsigned int irq_nr)=0A=
+{=0A=
+	int ipnum =3D irq_to_ip(irq_nr);=0A=
+	clear_c0_cause(1 << (ipnum + 8));=0A=
+	set_c0_status(1 << (ipnum + 8));=0A=
+}=0A=
+=0A=
+static inline void disable_local_irq(unsigned int irq_nr)=0A=
+{=0A=
+	int ipnum =3D irq_to_ip(irq_nr);=0A=
+	clear_c0_status(1 << (ipnum + 8));=0A=
+}=0A=
+=0A=
+static inline void ack_local_irq(unsigned int irq_nr)=0A=
+{=0A=
+	int ipnum =3D irq_to_ip(irq_nr);=0A=
+	clear_c0_cause(1 << (ipnum + 8));=0A=
+}=0A=
+=0A=
+static void enable_exp_irq(unsigned int irq_nr, int group)=0A=
+{=0A=
+	const intr_group_t* g =3D &intr_group[group];=0A=
+	u32 mask, intr_bit;=0A=
+	=0A=
+	// calc interrupt bit within group=0A=
+	intr_bit =3D (1 << (irq_nr - g->irq_base)) & g->mask;=0A=
+=0A=
+	if (!intr_bit)=0A=
+		return;=0A=
+	=0A=
+	DPRINTK("irq %d (group %d, mask %d)\n",=0A=
+		irq_nr, group, intr_bit);=0A=
+	=0A=
+	// first enable IP5 (IRQ3)=0A=
+	clear_c0_cause(1 << (5 + 8));=0A=
+	set_c0_status(1 << (5 + 8));=0A=
+	=0A=
+	// Clear the pending bit for the group=0A=
+	WRITE_CLEAR(0, (1 << group));=0A=
+	=0A=
+	// unmask appropriate group bit in group 0=0A=
+	mask =3D READ_MASK(0);=0A=
+=0A=
+	WRITE_MASK(0, mask | (1 << group));=0A=
+=0A=
+	// Clear the pending bit within the group=0A=
+	WRITE_CLEAR(group, intr_bit);=0A=
+=0A=
+	// unmask intr within group=0A=
+	mask =3D READ_MASK(group) & g->mask;=0A=
+=0A=
+	WRITE_MASK(group, mask | intr_bit);=0A=
+=0A=
+}=0A=
+=0A=
+static void disable_exp_irq(unsigned int irq_nr, int group)=0A=
+{=0A=
+	const intr_group_t* g =3D &intr_group[group];=0A=
+	u32 mask, intr_bit;=0A=
+	=0A=
+	// calc interrupt bit within group=0A=
+	intr_bit =3D (1 << (irq_nr - g->irq_base)) & g->mask;=0A=
+	if (!intr_bit)=0A=
+		return;=0A=
+	=0A=
+	DPRINTK("irq%d (group %d, mask %d)\n",=0A=
+		irq_nr, group, intr_bit);=0A=
+	=0A=
+	// mask intr within group=0A=
+	mask =3D READ_MASK(group) & g->mask;=0A=
+	mask &=3D ~intr_bit; // mask the intr bit=0A=
+	WRITE_MASK(group, mask);=0A=
+	=0A=
+	/*=0A=
+	  if there are no more interrupts enabled in this=0A=
+	  group, mask appropriate group bit in group 0=0A=
+	*/=0A=
+	if (!mask) {=0A=
+		mask =3D READ_MASK(0);=0A=
+		WRITE_MASK(0, mask & ~(1 << group));=0A=
+	}=0A=
+}=0A=
+=0A=
+static void ack_exp_irq(unsigned int irq_nr, int group)=0A=
+{=0A=
+	const intr_group_t* g =3D &intr_group[group];=0A=
+	u32 intr_bit;=0A=
+	=0A=
+	// calc interrupt bit within group=0A=
+	intr_bit =3D (1 << (irq_nr - g->irq_base)) & g->mask;=0A=
+	if (intr_bit) {=0A=
+		// clear intr within group=0A=
+		WRITE_CLEAR(group, intr_bit);=0A=
+	}=0A=
+	=0A=
+	/*=0A=
+	  if there are no more interrupts pending in this=0A=
+	  group, clear appropriate group pending bit in group 0=0A=
+	*/=0A=
+	if (!(READ_PEND(group) & g->mask)) {=0A=
+		WRITE_CLEAR(0, 1 << group);=0A=
+	}=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32300_enable_irq(unsigned int irq_nr)=0A=
+{=0A=
+  unsigned long flags;=0A=
+  local_irq_save(flags);=0A=
+=0A=
+  if (irq_nr < GROUP1_IRQ_BASE)=0A=
+    enable_local_irq(irq_nr);=0A=
+  else {=0A=
+    int group =3D irq_to_group(irq_nr);=0A=
+    enable_exp_irq(irq_nr, group);=0A=
+  }=0A=
+=0A=
+  local_irq_restore(flags);=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32300_disable_irq(unsigned int irq_nr)=0A=
+{=0A=
+  unsigned long flags;=0A=
+  local_irq_save(flags);=0A=
+=0A=
+	if (irq_nr < GROUP1_IRQ_BASE)=0A=
+		disable_local_irq(irq_nr);=0A=
+	else {=0A=
+		int group =3D irq_to_group(irq_nr);=0A=
+		disable_exp_irq(irq_nr, group);=0A=
+	}=0A=
+	=0A=
+	local_irq_restore(flags);=0A=
+}=0A=
+=0A=
+=0A=
+void rc32300_ack_irq(unsigned int irq_nr)=0A=
+{=0A=
+	if (irq_nr < GROUP1_IRQ_BASE) {=0A=
+		ack_local_irq(irq_nr);=0A=
+	} else {=0A=
+		int group =3D irq_to_group(irq_nr);=0A=
+		ack_exp_irq(irq_nr, group);=0A=
+	}=0A=
+}=0A=
+=0A=
+static unsigned int startup_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32300_enable_irq(irq_nr);=0A=
+	return 0; =0A=
+}=0A=
+=0A=
+=0A=
+static void shutdown_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32300_disable_irq(irq_nr);=0A=
+	return;=0A=
+}=0A=
+=0A=
+=0A=
+static void mask_and_ack_irq(unsigned int irq_nr)=0A=
+{=0A=
+  unsigned long flags;=0A=
+  =0A=
+  local_irq_save(flags);=0A=
+  if (irq_nr < GROUP1_IRQ_BASE) {=0A=
+    disable_local_irq(irq_nr);=0A=
+    ack_local_irq(irq_nr);=0A=
+  } else {=0A=
+    int group =3D irq_to_group(irq_nr);=0A=
+    disable_exp_irq(irq_nr, group);=0A=
+    ack_exp_irq(irq_nr, group);=0A=
+  }=0A=
+  local_irq_restore(flags);=0A=
+	=0A=
+}=0A=
+=0A=
+static void end_irq(unsigned int irq_nr)=0A=
+{=0A=
+  unsigned long flags;=0A=
+=0A=
+  local_irq_save(flags);=0A=
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {=0A=
+		if (irq_nr < GROUP1_IRQ_BASE) {=0A=
+			ack_local_irq(irq_nr);=0A=
+			enable_local_irq(irq_nr);=0A=
+		} else {=0A=
+			int group =3D irq_to_group(irq_nr);=0A=
+			ack_exp_irq(irq_nr, group);=0A=
+			enable_exp_irq(irq_nr, group);=0A=
+		}=0A=
+	} else {=0A=
+		printk("warning: end_irq %d did not enable (%x)\n", =0A=
+		       irq_nr, irq_desc[irq_nr].status);=0A=
+	}=0A=
+  local_irq_restore(flags);=0A=
+}=0A=
+=0A=
+static struct hw_interrupt_type rc32300_irq_type =3D {=0A=
+	"RC32334",=0A=
+	startup_irq,=0A=
+	shutdown_irq,=0A=
+	rc32300_enable_irq,=0A=
+	rc32300_disable_irq,=0A=
+	mask_and_ack_irq,=0A=
+	end_irq,=0A=
+	NULL=0A=
+};=0A=
+=0A=
+=0A=
+void __init arch_init_irq(void)=0A=
+{=0A=
+	int i;=0A=
+	unsigned long cp0_status;=0A=
+=0A=
+	printk("Initializing IRQ's: %d\n", RC32334_NR_IRQS);=0A=
+=0A=
+	cp0_status =3D read_c0_status();=0A=
+	memset(irq_desc, 0, sizeof(irq_desc));=0A=
+	set_except_vector(0, rc32300_IRQ);=0A=
+=0A=
+	for (i =3D 0; i < RC32334_NR_IRQS; i++) {=0A=
+                irq_desc[i].status =3D IRQ_DISABLED;=0A=
+                irq_desc[i].action =3D NULL;=0A=
+                irq_desc[i].depth =3D 1;=0A=
+		irq_desc[i].handler =3D &rc32300_irq_type;=0A=
+                spin_lock_init(&irq_desc[i].lock);=0A=
+	}=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Interrupts are nested. Even if an interrupt handler is =
registered=0A=
+ * as "fast", we might get another interrupt before we return from=0A=
+ * *_dispatch().=0A=
+ */=0A=
+=0A=
+/* Dispatch to expanded interrupts */=0A=
+static void int3_dispatch(struct pt_regs *regs)=0A=
+{=0A=
+	int group, intr;=0A=
+	const intr_group_t* g;=0A=
+	u32 pend, group0_pend;=0A=
+=0A=
+	group0_pend =3D READ_PEND(0) & intr_group[0].mask;=0A=
+	group0_pend &=3D READ_MASK(0); // only unmasked groups=0A=
+	if (!group0_pend)=0A=
+		return; // no interrupts in any group!=0A=
+=0A=
+	group =3D 31 - rc32300_clz(group0_pend);=0A=
+	// group i has pending interrupts=0A=
+	g =3D &intr_group[group];=0A=
+	pend =3D READ_PEND(group) & g->mask;=0A=
+	pend &=3D READ_MASK(group); // only unmasked interrupts=0A=
+=0A=
+	if (!pend)=0A=
+		return; // no interrupts in this group ???=0A=
+		=0A=
+	intr =3D 31 - rc32300_clz(pend);=0A=
+#ifdef DEBUG_IRQ=0A=
+	idtprintf("%02d%02d", group, intr);=0A=
+#endif=0A=
+	do_IRQ(g->irq_base + intr, regs);=0A=
+}=0A=
+=0A=
+static void mips_spurious_interrupt(struct pt_regs *regs)=0A=
+{=0A=
+#if 0=0A=
+        return;=0A=
+#else=0A=
+        printk("got spurious interrupt\n");=0A=
+#endif=0A=
+}=0A=
+=0A=
+/* Main Interrupt dispatcher */=0A=
+void rc32300_irqdispatch(unsigned long cp0_cause, struct pt_regs =
*regs)=0A=
+{=0A=
+	unsigned long ip;=0A=
+	int ipnum;=0A=
+	=0A=
+	ip =3D (cp0_cause >> 8) & 0xff;=0A=
+	=0A=
+	if (!ip) {=0A=
+		mips_spurious_interrupt(regs);=0A=
+		return;=0A=
+	}=0A=
+	=0A=
+	ipnum =3D 31 - rc32300_clz(ip);=0A=
+	if (ipnum =3D=3D 5) {=0A=
+		int3_dispatch(regs);=0A=
+	} else {=0A=
+		int irq =3D ip_to_irq(ipnum);=0A=
+		do_IRQ(irq, regs);=0A=
+	}=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/S334/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/Makefile	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,42 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for IDT S334A board BSP=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+#  =0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+.S.s:=0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:=0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+obj-y	 :=3D irq.o setup.o idtIRQ.o reset.o prom.o time.o =0A=
+obj-$(CONFIG_KGDB)		+=3D serial_gdb.o=0A=
+obj-$(CONFIG_SERIAL_8250) 	+=3D serial.o=0A=
+subdir-$(CONFIG_IDT_BOOT_NVRAM) +=3D nvram=0A=
+obj-$(CONFIG_IDT_BOOT_NVRAM) 	+=3D nvram/built-in.o=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/nvram/Makefile =
idtlinux/arch/mips/idt-boards/rc32300/S334/nvram/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/nvram/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/nvram/Makefile	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,37 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for IDT S334 nvram access routines=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+.S.s:   =0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:   =0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+=0A=
+obj-y   :=3D nvram334.o spi.o=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/nvram/nvram334.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/nvram/nvram334.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/nvram/nvram334.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/nvram/nvram334.c	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,534 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram interface routines.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ **********************************************************************=
****=0A=
+ */=0A=
+=0A=
+#define NVRAM_SPI=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/string.h>=0A=
+#include "nvram334.h"=0A=
+=0A=
+#if defined(NVRAM_SPI)=0A=
+#define WREN    0x0E=0A=
+#define WRDI    0x0C=0A=
+#define RDSR    0x0D=0A=
+#define WRSR    0x09=0A=
+#define READ    0x0B=0A=
+#define WRITE   0x0A=0A=
+=0A=
+extern void  enable_chipselect_spi(void);=0A=
+extern unsigned int send_to_spi(unsigned int);=0A=
+extern void  disable_chipselect_spi(void);=0A=
+=0A=
+extern void setenv(char *e, char *v, int rewrite);=0A=
+extern char * getenv(char *e);=0A=
+extern void unsetenv(char *e);=0A=
+extern void mapenv(int (*func)(char *, char *));=0A=
+extern void purgeenv(void);=0A=
+=0A=
+static void NVWR(unsigned int uiAddr, unsigned char ucData) =0A=
+{=0A=
+  unsigned int uiStatus =3D 1;=0A=
+	=0A=
+  enable_chipselect_spi();=0A=
+  send_to_spi((unsigned int)(WREN));=0A=
+  disable_chipselect_spi();=0A=
+=0A=
+  /* send the Read Status command to AT25256 */=0A=
+  /* AT25256 EPROM is not ready if LSB=3D1 */=0A=
+  while (uiStatus & 0x1) {=0A=
+    enable_chipselect_spi();=0A=
+    send_to_spi((unsigned int)(RDSR));=0A=
+    uiStatus =3D send_to_spi(0);=0A=
+    disable_chipselect_spi();=0A=
+  }=0A=
+  /*.........................................................=0A=
+    send WRITE to SPI (followed by high_addr, low_addr, data)=0A=
+    .........................................................=0A=
+  */=0A=
+  enable_chipselect_spi();=0A=
+  send_to_spi((unsigned int)(WRITE));=0A=
+  send_to_spi(uiAddr >> 8);        /* offset into EPROM space - high =
byte */=0A=
+  send_to_spi(uiAddr);             /* offset into EPROM space - low =
byte */=0A=
+  send_to_spi((unsigned int)(ucData));  /* actual data to write into =
EPROM */=0A=
+  disable_chipselect_spi();=0A=
+=0A=
+  /* send the Read Status command to AT25256 */=0A=
+  /* AT25256 EPROM is not ready if LSB=3D1 */=0A=
+  uiStatus =3D 1;=0A=
+  while (uiStatus & 0x1) {=0A=
+    enable_chipselect_spi();=0A=
+    send_to_spi((unsigned int)(RDSR));=0A=
+    uiStatus =3D send_to_spi(0);=0A=
+    disable_chipselect_spi();=0A=
+  }=0A=
+}=0A=
+=0A=
+unsigned char=0A=
+NVRD(unsigned int uiAddr) =0A=
+{=0A=
+	unsigned char ret;=0A=
+	unsigned int uiStatus =3D 1;=0A=
+	=0A=
+  /* send the Read Status command to AT25256 */=0A=
+  /* AT25256 EPROM is not ready if LSB=3D1 */=0A=
+  while (uiStatus & 0x1) {=0A=
+    enable_chipselect_spi();=0A=
+    send_to_spi((unsigned int)(RDSR));=0A=
+    uiStatus =3D send_to_spi(0);=0A=
+    disable_chipselect_spi();=0A=
+  }=0A=
+  /*.........................................................=0A=
+   send READ to SPI (followed by high_addr, low_addr)=0A=
+   .........................................................=0A=
+  */  =0A=
+  enable_chipselect_spi(); =0A=
+  send_to_spi((unsigned int)(READ));=0A=
+  send_to_spi(uiAddr >> 8);  /* offset into EPROM space - high byte =
*/=0A=
+  send_to_spi(uiAddr);       /* offset into EPROM space - low byte =
*/=0A=
+  ret =3D send_to_spi(0);     /* dummy write returns data from EPROM, =
save it*/=0A=
+  disable_chipselect_spi();=0A=
+  return(ret);=0A=
+}=0A=
+#else=0A=
+unsigned char=0A=
+NVRD(unsigned int x)=0A=
+{=0A=
+  unsigned char nv_data;=0A=
+=0A=
+  nv_data =3D (unsigned char)(*(((unsigned char*)(NVRAM_BASE))+ =
x));=0A=
+  return(nv_data);=0A=
+}=0A=
+=0A=
+void =0A=
+NVWR(unsigned int x , unsigned char v)=0A=
+{=0A=
+  int i =3D 0;=0A=
+  =0A=
+  *(((unsigned char*)(NVRAM_BASE)) + x) =3D v;=0A=
+=0A=
+  while (++i < 0x1000) ;=0A=
+}=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * The *env routines provide wrappers to the nvram_*env=0A=
+ * routines to allow any special processing of the environment=0A=
+ * to be carried out=0A=
+ * Yes this is a bit naff=0A=
+ */=0A=
+=0A=
+unsigned char=0A=
+nvram_getbyte(int offs)=0A=
+{=0A=
+  return(NVRD(offs));=0A=
+}=0A=
+=0A=
+void=0A=
+nvram_setbyte(int offs, unsigned char val)=0A=
+{=0A=
+  NVWR(offs, val);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * BigEndian!=0A=
+ */=0A=
+unsigned short=0A=
+nvram_getshort(int offs)=0A=
+{=0A=
+  return((nvram_getbyte(offs) << 8) | nvram_getbyte(offs + 1));=0A=
+}=0A=
+=0A=
+void=0A=
+nvram_setshort(int offs, unsigned short val)=0A=
+{=0A=
+  nvram_setbyte(offs, (unsigned char)((val >> 8) & 0xff));=0A=
+  nvram_setbyte(offs + 1, (unsigned char)(val & 0xff));=0A=
+}=0A=
+=0A=
+unsigned int=0A=
+nvram_getint(int offs)=0A=
+{=0A=
+  unsigned int val;=0A=
+  val =3D nvram_getbyte(offs) << 24;=0A=
+  val |=3D nvram_getbyte(offs + 1) << 16;=0A=
+  val |=3D nvram_getbyte(offs + 2) << 8;=0A=
+  val |=3D nvram_getbyte(offs + 3);=0A=
+  return (val);=0A=
+}=0A=
+=0A=
+void=0A=
+nvram_setint(int offs, unsigned int val)=0A=
+{=0A=
+  nvram_setbyte(offs, val >> 24);=0A=
+  nvram_setbyte(offs + 1, val >> 16);=0A=
+  nvram_setbyte(offs + 2, val >> 8);=0A=
+  nvram_setbyte(offs + 3, val);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * calculate NVRAM checksum=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_calcsum (void)=0A=
+{=0A=
+  unsigned short sum =3D NV_MAGIC;=0A=
+  int     i;=0A=
+=0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i +=3D 2)=0A=
+    sum +=3D nvram_getshort(i);=0A=
+  return(sum);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * update the nvram checksum=0A=
+ */=0A=
+static void=0A=
+nvram_updatesum (void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_CSUM, nvram_calcsum());=0A=
+#if !defined(NVRAM_SPI)=0A=
+  eeprom_write_s334();=0A=
+#endif=0A=
+}=0A=
+=0A=
+/*=0A=
+ * test validity of nvram by checksumming it=0A=
+ */=0A=
+static int=0A=
+nvram_isvalid(void)=0A=
+{=0A=
+  static unsigned int is_valid;=0A=
+  unsigned short sum =3D NV_MAGIC;=0A=
+=0A=
+  if (is_valid)=0A=
+    return 1;=0A=
+=0A=
+#if !defined(NVRAM_SPI)=0A=
+  eeprom_read_s334();=0A=
+#endif=0A=
+  if (nvram_getshort(NVOFF_MAGIC) !=3D NV_MAGIC)=0A=
+    return (0);=0A=
+  sum =3D nvram_calcsum ();=0A=
+  nvram_setshort(NVOFF_CSUM,sum);=0A=
+=0A=
+  is_valid =3D 1;=0A=
+  return(1);=0A=
+}=0A=
+=0A=
+/* return nvram address of environment string */=0A=
+static int=0A=
+nvram_matchenv(char *s)=0A=
+{=0A=
+  int envsize, envp, n, i, varsize;=0A=
+  char *var;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  if (envsize > ENV_AVAIL)=0A=
+    return (0);     /* sanity */=0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  if ((n =3D strlen (s)) > 255)=0A=
+    return (0);=0A=
+  while (envsize > 0) {=0A=
+    varsize =3D NVRD(envp);=0A=
+    if (varsize =3D=3D 0 || (envp + varsize) > ENV_TOP)=0A=
+      return (0);   /* sanity */=0A=
+    for (i =3D envp + 1, var =3D s; i <=3D envp + n; i++, var++) {=0A=
+  char c1 =3D NVRD(i);=0A=
+  char c2 =3D *var;=0A=
+  if (islower (c1))=0A=
+      c1 =3D toupper (c1);=0A=
+  if (islower (c2))=0A=
+      c2 =3D toupper (c2);=0A=
+  if (c1 !=3D c2)=0A=
+      break;=0A=
+    }=0A=
+    if (i > envp + n) {   /* match so far */=0A=
+      if (n =3D=3D varsize - 1) /* match on boolean */=0A=
+        return(envp);=0A=
+      if (NVRD(i) =3D=3D '=3D') /* exact match on variable */=0A=
+        return(envp);=0A=
+    }=0A=
+    envsize -=3D varsize;=0A=
+    envp +=3D varsize;=0A=
+  }=0A=
+  return(0);=0A=
+}=0A=
+=0A=
+void=0A=
+nvram_initenv(void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_delenv(char *s)=0A=
+{=0A=
+  int nenvp, envp, envsize, nbytes;=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return;=0A=
+  nenvp =3D envp + NVRD(envp);=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  nbytes =3D envsize - (nenvp - ENV_BASE);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envsize - (nenvp - envp));=0A=
+  while (nbytes--) {=0A=
+    NVWR (envp, NVRD(nenvp));=0A=
+    envp++;=0A=
+    nenvp++;=0A=
+  }=0A=
+=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+=0A=
+static int=0A=
+nvram_setenv(char *s, char *v)=0A=
+{=0A=
+  int ns, nv, total;=0A=
+  int envp;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return (-1);=0A=
+=0A=
+  nvram_delenv(s);=0A=
+  ns =3D strlen(s);=0A=
+  if (ns =3D=3D 0)=0A=
+    return(-1);=0A=
+  if (v && *v) {=0A=
+    nv =3D strlen(v);=0A=
+    total =3D ns + nv + 2;=0A=
+  }=0A=
+  else {=0A=
+    nv =3D 0;=0A=
+    total =3D ns + 1;=0A=
+  }=0A=
+  if (total > 255 || total > ENV_AVAIL - =
nvram_getshort(NVOFF_ENVSIZE))=0A=
+    return(-1);=0A=
+  envp =3D ENV_BASE + nvram_getshort(NVOFF_ENVSIZE);=0A=
+  NVWR(envp, (unsigned char) total); envp++;=0A=
+  while (ns--) {=0A=
+    NVWR(envp, *s); envp++; s++;=0A=
+  }=0A=
+  if (nv) {=0A=
+    NVWR(envp, '=3D'); envp++;=0A=
+    while (nv--) {=0A=
+      NVWR(envp, *v); envp++; v++;=0A=
+    }=0A=
+  }=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envp - ENV_BASE);=0A=
+  nvram_updatesum();=0A=
+  return(0);=0A=
+}=0A=
+=0A=
+char *=0A=
+nvram_getenv(char *s)=0A=
+{=0A=
+  static char buf[256];   /* FIXME: this cannot be static */=0A=
+  int envp, ns, nbytes, i;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return((char *)0);=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return((char *)0);=0A=
+  ns =3D strlen(s);=0A=
+  if (NVRD(envp) =3D=3D ns + 1) /* boolean */=0A=
+    buf[0] =3D '\0';=0A=
+  else {=0A=
+    nbytes =3D NVRD(envp) - (ns + 2);=0A=
+    envp +=3D ns + 2;=0A=
+    for (i =3D 0; i < nbytes; i++)=0A=
+      buf[i] =3D NVRD(envp++);=0A=
+    buf[i] =3D '\0';=0A=
+  }=0A=
+  return (buf);=0A=
+}=0A=
+=0A=
+void=0A=
+nvram_unsetenv(char *s)=0A=
+{=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  nvram_delenv(s);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * apply func to each string in environment=0A=
+ */=0A=
+void=0A=
+nvram_mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  int envsize, envp, n, i, seeneql;=0A=
+  char name[256], value[256];=0A=
+  char c, *s;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  while (envsize > 0) {=0A=
+    value[0] =3D '\0';=0A=
+    seeneql =3D 0;=0A=
+    s =3D name;=0A=
+    n =3D NVRD(envp);=0A=
+    for (i =3D envp + 1; i < envp + n; i++) {=0A=
+      c =3D NVRD(i);=0A=
+      if ((c =3D=3D '=3D') && !seeneql){=0A=
+        *s =3D '\0';=0A=
+        s =3D value;=0A=
+        seeneql =3D 1;=0A=
+        continue;=0A=
+      }=0A=
+      *s++ =3D c;=0A=
+    }=0A=
+    *s =3D '\0';=0A=
+    (*func)(name, value);=0A=
+    envsize -=3D n;=0A=
+    envp +=3D n;=0A=
+  }=0A=
+}=0A=
+=0A=
+#ifdef DEBUG=0A=
+void=0A=
+nvram_dumpenv(void)=0A=
+{=0A=
+  int envsize, envp, n, i;=0A=
+  char *var;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  printf ("NVRAM Environment:\n");=0A=
+  while (envsize) {=0A=
+    n =3D NVRD(envp);=0A=
+    for (i =3D envp + 1; i < envp + n; i++)=0A=
+      consputc (NVRD(i));=0A=
+    consputc('\n');=0A=
+    envsize -=3D n;=0A=
+    envp +=3D n;=0A=
+  }=0A=
+  consputc('\n');=0A=
+}=0A=
+#endif=0A=
+=0A=
+#if 0=0A=
+static unsigned int=0A=
+digit(char c)=0A=
+{=0A=
+  if ('0' <=3D c && c <=3D '9')=0A=
+    return(c - '0');=0A=
+  if ('A' <=3D c && c <=3D 'Z')=0A=
+    return(10 + c - 'A');=0A=
+  if ('a' <=3D c && c <=3D 'z')=0A=
+    return(10 + c - 'a');=0A=
+  return(~0);=0A=
+}=0A=
+#endif=0A=
+/*=0A=
+ * Wrappers to allow 'special' environment variables to get =
processed=0A=
+ */=0A=
+void=0A=
+setenv(char *e, char *v, int rewrite)=0A=
+{=0A=
+  if (nvram_getenv(e) && !rewrite)=0A=
+    return;=0A=
+=0A=
+  nvram_setenv(e, v);=0A=
+}=0A=
+=0A=
+char *=0A=
+getenv(char *e)=0A=
+{=0A=
+  return(nvram_getenv (e));=0A=
+}=0A=
+=0A=
+void=0A=
+unsetenv(char *e)=0A=
+{=0A=
+  nvram_unsetenv(e);=0A=
+}=0A=
+=0A=
+void=0A=
+mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  nvram_mapenv(func);=0A=
+}=0A=
+=0A=
+#if !defined(NVRAM_SPI)=0A=
+#define WAIT(x) {int i =3D 0; while(++i < (x)) ; }=0A=
+void eeprom_read_s334()=0A=
+{=0A=
+  static IsVirgin;=0A=
+=0A=
+  if (IsVirgin)=0A=
+    return;=0A=
+=0A=
+  IsVirgin =3D 1;=0A=
+  NVRD(0x401);=0A=
+  WAIT(0x1000);=0A=
+  if (nvram_getshort(NVOFF_MAGIC) !=3D NV_MAGIC)=0A=
+    nvram_initenv();=0A=
+}=0A=
+=0A=
+void eeprom_write_s334()=0A=
+{=0A=
+  NVWR(0x401, 0x20);=0A=
+  WAIT(0x8000);=0A=
+}=0A=
+=0A=
+extern void=0A=
+purgeenv(void)=0A=
+{=0A=
+  int i;=0A=
+=0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i++)=0A=
+    *(((unsigned char*)(NVRAM_BASE)) + i) =3D 0;=0A=
+  nvram_initenv();=0A=
+  eeprom_write_s334();=0A=
+}=0A=
+#else=0A=
+extern void=0A=
+purgeenv(void)=0A=
+{=0A=
+  int i;=0A=
+=0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i++)=0A=
+    NVWR(i, 0);=0A=
+  nvram_initenv();=0A=
+}=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/nvram/nvram334.h =
idtlinux/arch/mips/idt-boards/rc32300/S334/nvram/nvram334.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/nvram/nvram334.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/nvram/nvram334.h	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,81 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram layout definitions=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ **********************************************************************=
****=0A=
+ */=0A=
+=0A=
+#ifndef _NVRAM_=0A=
+#define _NVRAM_=0A=
+=0A=
+#define TD_NVRAM_SIZE  512=0A=
+=0A=
+#if !defined(NVRAM_SPI)=0A=
+#define NVRAM_BASE     0xb2000000=0A=
+#define NVRAM_WRITE   (NVRAM_BASE + 0x00000400)=0A=
+#define NVRAM_READ     NVRAM_WRITE=0A=
+=0A=
+void eeprom_read_s334();=0A=
+void eeprom_write_s334();=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * defining ALGCOMPAT provides backward compatibility=0A=
+ * with Algorithmics derived PROM monitors=0A=
+ */=0A=
+#define ALGCOMPAT=0A=
+#ifdef ALGCOMPAT=0A=
+#define NVOFFSET  0   /* use all of NVRAM */=0A=
+#else=0A=
+#define NVOFFSET  1024    /* first 1Kb reserved for DECelx */=0A=
+#endif=0A=
+=0A=
+/* Offsets to reserved locations */=0A=
+              /* size description */=0A=
+#define NVOFF_MAGIC   (NVOFFSET + 0)  /* 2 magic value */=0A=
+#define NVOFF_CSUM    (NVOFFSET + 2)  /* 2 NVRAM environment checksum =
*/=0A=
+#define NVOFF_ENVSIZE (NVOFFSET + 4)  /* 1 size of 'environment' */=0A=
+#define NVOFF_TEST    (NVOFFSET + 5)  /* 1 cold start test byte */=0A=
+#define NVOFF_ETHADDR (NVOFFSET + 6)  /* 6 decoded ethernet address =
*/=0A=
+#define NVOFF_UNUSED  (NVOFFSET + c)  /* 0 current end of table */=0A=
+=0A=
+#define NV_MAGIC       0xdeaf         /* nvram magic number */=0A=
+#define NV_RESERVED    64             /* number of reserved bytes =
*/=0A=
+=0A=
+#ifdef ALGCOMPAT=0A=
+/* ho hum... */=0A=
+#undef NVOFF_ETHADDR=0A=
+#define NVOFF_ETHADDR (NVOFFSET + NV_RESERVED - 6)=0A=
+#endif=0A=
+=0A=
+/* number of bytes available for environment */=0A=
+#define ENV_BASE      (NVOFFSET + NV_RESERVED)=0A=
+#define ENV_TOP        TD_NVRAM_SIZE=0A=
+#define ENV_AVAIL     (ENV_TOP - ENV_BASE)=0A=
+=0A=
+#endif /* _NVRAM_ */=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/nvram/spi.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/nvram/spi.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/nvram/spi.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/nvram/spi.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,205 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     SPI interface routines.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/module.h>=0A=
+=0A=
+#define SPI_CNT       0xB8000900=0A=
+#define SPI_CNTL      0xB8000904=0A=
+#define SPI_STAT      0xB8000908=0A=
+#define SPI_DATA      0xB800090C=0A=
+=0A=
+#define SPI_CNT_DIV   0x00000008=0A=
+#define SPI_CNTL_VAL  0x0000007C=0A=
+#define SPI_STAT_SPIF 0x00000080=0A=
+=0A=
+#define GPIO_DAT      0xB8000600=0A=
+#define GPIO_DIR      0xB8000604=0A=
+#define GPIO_FUN      0xB8000608=0A=
+=0A=
+#define GPIO_SPI_CS   0x00000200=0A=
+=0A=
+#define CACHED_DLY    0x00003FFF=0A=
+#define UNCACHED_DLY  0x000000FF=0A=
+=0A=
+         /* AT25256 command definitions */=0A=
+#define WREN    0x0E=0A=
+#define WRDI    0x0C=0A=
+#define RDSR    0x0D=0A=
+#define WRSR    0x09=0A=
+#define READ    0x0B=0A=
+#define WRITE   0x0A=0A=
+=0A=
+extern unsigned int send_to_spi(unsigned int uiData);=0A=
+extern void enable_chipselect_spi(void);=0A=
+extern void disable_chipselect_spi(void);=0A=
+extern void initialize_hardware(void);=0A=
+=0A=
+static void delay(void);=0A=
+/* --------------------------------------------------*/=0A=
+static void delay(void)=0A=
+{=0A=
+	int i =3D CACHED_DLY;   /* we are running cached, longer count for =
delay */=0A=
+	while (i--);=0A=
+}=0A=
+=0A=
+/* --------------------------------------------------=0A=
+   Initialize the GPIO registers related to SPI functionality=0A=
+*/=0A=
+static void initialize_GPIO(void)=0A=
+{=0A=
+	unsigned int uiTempReg;=0A=
+	volatile unsigned int *uipGpioDir;=0A=
+	volatile unsigned int *uipGpioFun;=0A=
+	=0A=
+	uipGpioDir =3D (volatile unsigned int *)GPIO_DIR;=0A=
+	uipGpioFun =3D (volatile unsigned int *)GPIO_FUN;=0A=
+	/* .......... set up PIO Direction Register at =
GPIO_BASE+4.........=0A=
+	   PIO[10,9,8,7] are used for SPI.=0A=
+	   However, these correspond to bits 11,10,9,8 in PIO DIR REG=0A=
+	*/=0A=
+	uiTempReg  =3D *uipGpioDir;=0A=
+	*uipGpioDir =3D ((uiTempReg & 0x0F0FF) | 0x0E00);  /* bits 11,10,9 =
output(1), 8 input(0) - SPI */=0A=
+	=0A=
+	/* ........ set up PIO Effect/Function Select Register at =
GPIO_BASE+8=0A=
+	   PIO[10,9,8,7] are used for SPI.=0A=
+	   However, these correspond to bits 11,10,9,8 in PIO EFF/FUN REG=0A=
+	*/=0A=
+	=0A=
+	uiTempReg  =3D *uipGpioFun;=0A=
+	*uipGpioFun =3D ((uiTempReg & 0x0F0FF) | 0x0D00); /* spi_ss_n (bit9) =
is GPIO (0),rest are special/SPI (1)*/=0A=
+}=0A=
+=0A=
+/* --------------------------------------------------=0A=
+ */=0A=
+extern void disable_chipselect_spi(void)=0A=
+{=0A=
+	/* Write a 1 at chip select*/=0A=
+	*(volatile unsigned int *)GPIO_DAT |=3D GPIO_SPI_CS;=0A=
+}=0A=
+=0A=
+/*****************************************************************=0A=
+ * Sends data through SPI interface , returns data read from SPI.=0A=
+ * Input parameter: data to be sent=0A=
+ * Return value:    data read back from SPI=0A=
+ * SPI always transfers data in both directions simultaneously.=0A=
+ * To read back data which is in response to the previous command,=0A=
+ * do a dummy write to SPI which will read back the data you need.=0A=
+ * The word "data" is used here in a generic sense, it could =
actually=0A=
+ * be a SPI command written to SPI or status read back from SPI.=0A=
+ ****************************************************************/=0A=
+=0A=
+extern unsigned int send_to_spi(unsigned int uiData)=0A=
+{=0A=
+	/* write data */=0A=
+	delay();        /* let AT25256 do its write for awhile */=0A=
+	*(volatile unsigned int *)SPI_DATA =3D uiData;=0A=
+	=0A=
+	/* wait until transfer is finished */=0A=
+	delay();        /* let AT25256 do its write for awhile */=0A=
+	while (!(*(volatile unsigned int *)SPI_STAT & SPI_STAT_SPIF))=0A=
+		;=0A=
+	=0A=
+	/* wait until transfer is finished */=0A=
+	delay();        /* let AT25256 do its write for awhile */=0A=
+	=0A=
+	/* in SPI, reads and writes occur simultaneously */=0A=
+	return(*(volatile unsigned int *)SPI_DATA);       /* return SPI Data =
Register */=0A=
+}=0A=
+=0A=
+/* --------------------------------------------------=0A=
+ */=0A=
+=0A=
+extern void enable_chipselect_spi(void)=0A=
+{=0A=
+	/* Write a 0 at chip select*/=0A=
+	*(volatile unsigned int *)GPIO_DAT &=3D ~GPIO_SPI_CS;=0A=
+}=0A=
+=0A=
+/* --------------------------------------------------=0A=
+   Initialize the various SPI registers=0A=
+*/=0A=
+static void initialize_SPI(void)=0A=
+{=0A=
+	unsigned int uiTempReg;=0A=
+	=0A=
+	/* ........... Initialize SPI Clock Register=0A=
+	   ........... Depends on board's system frequency ........=0A=
+	*/=0A=
+	=0A=
+	*(volatile unsigned int *)SPI_CNT =3D SPI_CNT_DIV;       /* SPI =
prescalar counter */=0A=
+	/* this is further divided by 2 in the chip.=0A=
+	   AT25256 works at 3 MHz or under */=0A=
+	=0A=
+	disable_chipselect_spi();=0A=
+=0A=
+	/* Interrupts disabled, SPI on and Master, CPOL/CPHA=3D1,1, clock/2 =
*/=0A=
+	*(volatile unsigned int *)SPI_CNTL =3D SPI_CNTL_VAL;=0A=
+	=0A=
+	/* .......... Clearing SPIF bit  ..............  */=0A=
+	uiTempReg =3D *(volatile unsigned int *)SPI_STAT;    /* dummy read =
*/=0A=
+	uiTempReg =3D *(volatile unsigned int *)SPI_DATA;    /* dummy read =
*/=0A=
+}=0A=
+=0A=
+/* --------------------------------------------------=0A=
+*/=0A=
+static void initialize_AT25256(void)=0A=
+{=0A=
+	unsigned int uiAtmelStatus;=0A=
+	=0A=
+	enable_chipselect_spi();=0A=
+	send_to_spi((unsigned int)(WRSR));=0A=
+	send_to_spi((unsigned int)(0x82));  /* AT25256 Status info to write =
*/=0A=
+	/* 1000_0010: protect no blocks, WPEN,WEN=3D1 */=0A=
+	/* send the Read Status command to AT25256 */=0A=
+	send_to_spi((unsigned int)(RDSR));=0A=
+	=0A=
+	/* dummy write so we can read AT25256 status info */=0A=
+	uiAtmelStatus =3D send_to_spi(0);=0A=
+	disable_chipselect_spi();=0A=
+	=0A=
+	/* AT25256 EPROM is not ready if LSB=3D1 */=0A=
+	while (uiAtmelStatus & 0x1) {=0A=
+		enable_chipselect_spi();=0A=
+		send_to_spi((unsigned int)(RDSR));=0A=
+		uiAtmelStatus =3D send_to_spi(0);=0A=
+		disable_chipselect_spi();=0A=
+	}=0A=
+}=0A=
+/* --------------------------------------------------=0A=
+ */=0A=
+extern void initialize_hardware(void)=0A=
+{=0A=
+	initialize_GPIO();=0A=
+	initialize_SPI();=0A=
+	initialize_AT25256();=0A=
+}=0A=
+EXPORT_SYMBOL(initialize_hardware);=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/prom.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/prom.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/prom.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/prom.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,117 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     prom interface routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/string.h>=0A=
+#include <linux/console.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <linux/bootmem.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serialP.h>=0A=
+#include <asm/serial.h>=0A=
+#include <linux/ioport.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+unsigned int idt_cpu_freq =3D CONFIG_IDT_BOARD_FREQ;=0A=
+EXPORT_SYMBOL(idt_cpu_freq);=0A=
+=0A=
+extern void setup_serial_port(void);=0A=
+=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+extern void initialize_hardware(void);=0A=
+extern void mapenv(int (*func)(char *, char *));=0A=
+=0A=
+static int make_bootparm(char *name,char *val)=0A=
+{=0A=
+	if (strncmp(name, "bootparm", 8) =3D=3D 0) {=0A=
+		strcat(arcs_cmdline,val);=0A=
+		strcat(arcs_cmdline," ");=0A=
+	}=0A=
+	else if(strncmp(name, "HZ", 2) =3D=3D 0) {=0A=
+		idt_cpu_freq =3D simple_strtoul(val, 0, 10);=0A=
+		printk("CPU Clock at %d Hz (from HZ environment variable)\n",=0A=
+		       idt_cpu_freq);=0A=
+	}=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static void prom_init_cmdline(void)=0A=
+{=0A=
+	initialize_hardware();=0A=
+	memset(arcs_cmdline,0,sizeof(arcs_cmdline));=0A=
+	mapenv(&make_bootparm);=0A=
+}=0A=
+#endif=0A=
+extern unsigned long mips_machgroup;=0A=
+extern unsigned long mips_machtype;=0A=
+=0A=
+const char *get_system_type(void)=0A=
+{=0A=
+	return "IDT 79S334A";=0A=
+}=0A=
+=0A=
+struct resource rc32300_res_ram =3D {=0A=
+	"RAM",=0A=
+	0,=0A=
+	RAM_SIZE,=0A=
+	IORESOURCE_MEM=0A=
+};=0A=
+=0A=
+char * __init prom_getcmdline(void)=0A=
+{=0A=
+	return &(arcs_cmdline[0]);=0A=
+}=0A=
+=0A=
+void prom_init(void)=0A=
+{=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+	prom_init_cmdline();=0A=
+#endif=0A=
+=0A=
+	setup_serial_port();=0A=
+	/* set our arch type */=0A=
+	mips_machgroup =3D MACH_GROUP_IDT;=0A=
+	mips_machtype =3D MACH_IDT_S334;=0A=
+	add_memory_region(0,=0A=
+			  rc32300_res_ram.end - rc32300_res_ram.start,=0A=
+			  BOOT_MEM_RAM);=0A=
+	return;=0A=
+}=0A=
+=0A=
+void prom_free_prom_memory(void)=0A=
+{=0A=
+}=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/reset.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/reset.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/reset.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/reset.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,71 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Reset EB365 board.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#include <linux/sched.h>=0A=
+#include <linux/mm.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <asm/processor.h>=0A=
+#include <asm/reboot.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/cacheflush.h>=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32334.h>=0A=
+=0A=
+void rc32300_restart(char *command)=0A=
+{=0A=
+	set_c0_status((ST0_BEV | ST0_ERL));=0A=
+	set_c0_config(CONF_CM_UNCACHED);=0A=
+	flush_cache_all();=0A=
+	write_c0_wired(0);=0A=
+=0A=
+	// Trigger the WatchDog Timer (Timer 3) to warm reset=0A=
+	rc32300_writel(0, TIMER0_CNTL + 3*TIMER_REG_OFFSET);=0A=
+	rc32300_writel(0xd8, CPU_IP_BUSERR_CNTL);=0A=
+	rc32300_writel(0, TIMER0_COUNT + 3*TIMER_REG_OFFSET);=0A=
+	rc32300_writel(2, TIMER0_COMPARE + 3*TIMER_REG_OFFSET);=0A=
+	rc32300_writel(1, TIMER0_CNTL + 3*TIMER_REG_OFFSET);=0A=
+}=0A=
+=0A=
+void rc32300_halt(void)=0A=
+{=0A=
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");=0A=
+	while (1)=0A=
+		__asm__(".set\tmips3\n\t"=0A=
+	                "wait\n\t"=0A=
+			".set\tmips0");=0A=
+}=0A=
+=0A=
+void rc32300_power_off(void)=0A=
+{=0A=
+	rc32300_halt();=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/serial.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/serial.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/serial.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/serial.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,72 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Serial port initialisation.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/tty.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serial_core.h>=0A=
+=0A=
+#include <asm/time.h>=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/irq.h>=0A=
+#include <asm/serial.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+=0A=
+extern int __init early_serial_setup(struct uart_port *port);=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+extern int __init setup_serial_port(void)=0A=
+{ =0A=
+  static struct uart_port serial_req[2];=0A=
+=0A=
+  memset(serial_req, 0, sizeof(serial_req));=0A=
+  serial_req[0].type       =3D PORT_16550A;=0A=
+  serial_req[0].line       =3D 0;=0A=
+  serial_req[0].irq        =3D RC32300_UART0_IRQ;=0A=
+  serial_req[0].flags      =3D STD_COM_FLAGS;=0A=
+  serial_req[0].uartclk    =3D idt_cpu_freq;=0A=
+  serial_req[0].iotype     =3D SERIAL_IO_MEM;=0A=
+  serial_req[0].membase    =3D (char *) =
KSEG1ADDR(RC32300_UART0_BASE);=0A=
+  serial_req[0].mapbase    =3D KSEG1ADDR(RC32300_UART0_BASE);=0A=
+  serial_req[0].regshift   =3D 2;=0A=
+=0A=
+  early_serial_setup(&serial_req[0]);=0A=
+=0A=
+  return(0);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/serial_gdb.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/serial_gdb.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/serial_gdb.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/serial_gdb.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,272 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *      S334A specific polling driver for 16550 UART.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/serial_reg.h>=0A=
+=0A=
+/* set remote gdb baud rate at 115200 */=0A=
+=0A=
+#define GDB_BAUD 115200=0A=
+#define CONS_BAUD 9600=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+=0A=
+/* turn this on to watch the debug protocol echoed on the console port =
*/=0A=
+#undef DEBUG_REMOTE_DEBUG=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define CONS_PORT 0xb8000803u=0A=
+#define GDB_PORT  0xb8000823u=0A=
+#else=0A=
+#define CONS_PORT 0xb8000800u=0A=
+#define GDB_PORT  0xb8000820u=0A=
+#endif=0A=
+           =0A=
+volatile unsigned char *ports[2] =3D {=0A=
+	(volatile unsigned char *)CONS_PORT,=0A=
+	(volatile unsigned char *)GDB_PORT=0A=
+};=0A=
+=0A=
+=0A=
+void reset_gdb_port(void);=0A=
+void cons_putc(char c);=0A=
+int port_getc(int port);=0A=
+void port_putc(int port, char c);=0A=
+=0A=
+int cons_getc(void)=0A=
+{=0A=
+	return port_getc(0);=0A=
+}=0A=
+=0A=
+void cons_putc(char c)=0A=
+{=0A=
+	port_putc(0, c);=0A=
+}=0A=
+=0A=
+void cons_puts(char *s)=0A=
+{=0A=
+	while(*s) {=0A=
+		if(*s =3D=3D '\n') cons_putc('\r');=0A=
+		cons_putc(*s);=0A=
+		s++;=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_do_putn(int n)=0A=
+{=0A=
+	if(n) {=0A=
+		cons_do_putn(n / 10);=0A=
+		cons_putc(n % 10 + '0');=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_putn(int n)=0A=
+{=0A=
+	if(n < 0) {=0A=
+		cons_putc('-');=0A=
+		n =3D -n;=0A=
+	}=0A=
+=0A=
+	if (n =3D=3D 0) {=0A=
+		cons_putc('0');=0A=
+	} else {=0A=
+		cons_do_putn(n);=0A=
+	}=0A=
+}=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+static enum {HUH, SENDING, GETTING} state;=0A=
+=0A=
+static void sent(int c)=0A=
+{=0A=
+	switch(state) {=0A=
+	case HUH:=0A=
+	case GETTING:=0A=
+		cons_puts("\nSNT ");=0A=
+		state =3D SENDING;=0A=
+		/* fall through */=0A=
+	case SENDING:=0A=
+		cons_putc(c);=0A=
+		break;=0A=
+	}       =0A=
+}=0A=
+=0A=
+static void got(int c)=0A=
+{=0A=
+	switch(state) {=0A=
+	case HUH:=0A=
+	case SENDING:=0A=
+		cons_puts("\nGOT ");=0A=
+		state =3D GETTING;=0A=
+		/* fall through */=0A=
+	case GETTING:=0A=
+		cons_putc(c);=0A=
+		break;=0A=
+	}       =0A=
+}=0A=
+#endif /* DEBUG_REMOTE_DEBUG */=0A=
+=0A=
+static int first =3D 1;=0A=
+=0A=
+int getDebugChar(void)=0A=
+{=0A=
+	int c;=0A=
+=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+	c =3D port_getc(1);=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	got(c);=0A=
+#endif=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+	int c;=0A=
+=0A=
+	while((*(port + UART_LSR * 4) & UART_LSR_DR) =3D=3D 0) {=0A=
+		continue;=0A=
+	}       	=0A=
+=0A=
+	c =3D *(port + UART_RX * 4);=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc_ready(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+=0A=
+	return *(port + UART_LSR * 4) & UART_LSR_DR;=0A=
+}=0A=
+=0A=
+int isDebugReady(void)=0A=
+{=0A=
+	return port_getc_ready(1);=0A=
+}=0A=
+=0A=
+void putDebugChar(char c)=0A=
+{=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	sent(c);=0A=
+#endif=0A=
+=0A=
+	port_putc(1, c);=0A=
+}=0A=
+=0A=
+#define OK_TO_XMT (UART_LSR_TEMT | UART_LSR_THRE)=0A=
+=0A=
+void port_putc(int p, char c)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+	volatile unsigned char *lsr =3D port + UART_LSR * 4;=0A=
+=0A=
+	while((*lsr & OK_TO_XMT) !=3D OK_TO_XMT) {=0A=
+		continue;=0A=
+	}=0A=
+=0A=
+	*(port + UART_TX * 4) =3D c;=0A=
+}=0A=
+=0A=
+void reset_gdb_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[1];=0A=
+	unsigned int DIVISOR =3D (idt_cpu_freq / 16 / GDB_BAUD);=0A=
+=0A=
+	first =3D 0;=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	cons_puts("reset_gdb_port: initializing remote debug serial port =
(internal UART 1, ");=0A=
+	cons_putn(GDB_BAUD);=0A=
+	cons_puts("baud, MHz=3D");=0A=
+	cons_putn(idt_cpu_freq);=0A=
+	cons_puts(", divisor=3D");=0A=
+	cons_putn(DIVISOR);=0A=
+	cons_puts(")\n");=0A=
+#endif=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + UART_CSR * 4) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + UART_FCR * 4) =3D UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR =
| =0A=
+		UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+	*(port + UART_DLL * 4) =3D DIVISOR;=0A=
+	*(port + UART_DLM * 4) =3D DIVISOR >> 8;=0A=
+=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + UART_IER * 4) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + UART_MCR * 4) =3D 0;=0A=
+}=0A=
+=0A=
+void reset_cons_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[0];=0A=
+	  unsigned int DIVISOR =3D (idt_cpu_freq / 16 / CONS_BAUD);=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + UART_CSR * 4) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + UART_FCR * 4) =3D UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR =
| =0A=
+		UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+=0A=
+	*(port + UART_DLL * 4) =3D DIVISOR;=0A=
+	*(port + UART_DLM * 4) =3D DIVISOR >> 8;=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + UART_IER * 4) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + UART_MCR * 4) =3D 0;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/setup.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/setup.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/setup.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/setup.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,226 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     setup routines for IDT EB365 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/pm.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/tty.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serial_core.h>=0A=
+=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/irq.h>=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/eisa.h>=0A=
+#include <linux/hdreg.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <linux/console.h>=0A=
+#include <linux/fb.h>=0A=
+#include <linux/tty.h>=0A=
+=0A=
+#include <asm/reboot.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+extern void (*board_time_init)(void);=0A=
+extern void (*board_timer_setup)(struct irqaction *irq);=0A=
+extern void rc32300_time_init(void);=0A=
+extern void rc32300_timer_setup(struct irqaction *irq);=0A=
+extern char * __init prom_getcmdline(void);=0A=
+=0A=
+extern void rc32300_restart(char *);=0A=
+extern void rc32300_halt(void);=0A=
+extern void rc32300_power_off(void);=0A=
+extern void rc32300_ack_irq(unsigned int);=0A=
+#define DIG0 ((volatile unsigned char *)KSEG1ADDR(LCD_DIGIT0))=0A=
+#define DIG1 ((volatile unsigned char *)KSEG1ADDR(LCD_DIGIT1))=0A=
+#define DIG2 ((volatile unsigned char *)KSEG1ADDR(LCD_DIGIT2))=0A=
+#define DIG3 ((volatile unsigned char *)KSEG1ADDR(LCD_DIGIT3))=0A=
+=0A=
+=0A=
+=0A=
+void idt_disp_char(int i, char c)=0A=
+{ =0A=
+	switch (i) {=0A=
+	case 0: *DIG0 =3D c; break;=0A=
+	case 1: *DIG1 =3D c; break;=0A=
+	case 2: *DIG2 =3D c; break;=0A=
+	case 3: *DIG3 =3D c; break;=0A=
+	default: *DIG0 =3D '?'; break;=0A=
+	}=0A=
+}=0A=
+=0A=
+=0A=
+int idtprintf(const char *fmt, ...)=0A=
+{=0A=
+	va_list args;=0A=
+	int i, len;=0A=
+	char str[256];=0A=
+	static int lcd_digit_reg[4] =3D {=0A=
+		KSEG1ADDR(LCD_DIGIT0),=0A=
+		KSEG1ADDR(LCD_DIGIT1),=0A=
+		KSEG1ADDR(LCD_DIGIT2),=0A=
+		KSEG1ADDR(LCD_DIGIT3)=0A=
+	};=0A=
+=0A=
+	va_start(args, fmt);=0A=
+	len =3D vsprintf(str, fmt, args);=0A=
+	va_end(args);=0A=
+=0A=
+	len =3D len > 4 ? 4 : len;=0A=
+	readb(KSEG1ADDR(LCD_CLEAR)); // clear the display=0A=
+	for (i =3D 0; i < len; i++) {=0A=
+		if (str[i])=0A=
+			writeb(str[i], lcd_digit_reg[i]);=0A=
+	}=0A=
+	=0A=
+	return len;=0A=
+}=0A=
+=0A=
+=0A=
+int  rc32334_be_handler(struct pt_regs *regs,int fixup)=0A=
+{=0A=
+        int data =3D regs->cp0_cause & 4;=0A=
+	u32 cntl;=0A=
+	extern void rc32300_ack_irq(unsigned int irq_nr);=0A=
+	=0A=
+	printk("RC32334 %s bus error:\n", data ? "Data" : "Instruction");=0A=
+	printk("  EPC =3D=3D %08lx, RA =3D=3D %08lx\n",=0A=
+	       regs->cp0_epc, regs->regs[31]);=0A=
+	printk("  CPU bus address =3D=3D %08x\n",=0A=
+	       rc32300_readl(CPU_BUSERR_ADDR));=0A=
+	printk("  IP bus address =3D=3D %08x\n",=0A=
+	       rc32300_readl(CPU_IP_BUSERR_ADDR));=0A=
+	cntl =3D rc32300_readl(CPU_IP_BUSERR_CNTL);=0A=
+	printk("  Bus error occured on a %s on %s bus\n",=0A=
+	       cntl & 1 ? "read" : "write",=0A=
+	       cntl & 4 ? "CPU" : "IP");=0A=
+=0A=
+	// ack the bus errors=0A=
+	rc32300_ack_irq(GROUP4_IRQ_BASE+4); // ack timer 4 rollover intr=0A=
+	rc32300_ack_irq(GROUP4_IRQ_BASE+5); // ack timer 5 rollover intr=0A=
+	rc32300_ack_irq(GROUP1_IRQ_BASE);   // ack bus error intr=0A=
+	rc32300_writel(cntl & ~0x07, CPU_IP_BUSERR_CNTL);=0A=
+=0A=
+        die_if_kernel("Oops", regs);=0A=
+        force_sig(SIGBUS, current);=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+void __init bus_error_init(void)=0A=
+{=0A=
+	/*=0A=
+	 * The RC32334 uses two timers to count-out bus=0A=
+	 * timeouts. In addition to bus error exceptions,=0A=
+	 * the timer timeouts can trigger interrupts.=0A=
+	 *=0A=
+	 * On CPU reads, a bus error will cause an exception as well=0A=
+	 * as an interrupt. On CPU writes, a bus error only causes=0A=
+	 * an interrupt.=0A=
+	 */=0A=
+=0A=
+	/*=0A=
+	 * Disable CPU and IP Bus Error exceptions (PCI scan will=0A=
+	 * cause bus timeouts), and disable WatchDog.=0A=
+	 */=0A=
+	rc32300_writel(0x98, CPU_IP_BUSERR_CNTL);=0A=
+=0A=
+	rc32300_writel(0, TIMER0_CNTL + 4*TIMER_REG_OFFSET);=0A=
+	rc32300_writel(0, TIMER0_CNTL + 5*TIMER_REG_OFFSET);=0A=
+	rc32300_writel(0x3fff, TIMER0_COMPARE + 4*TIMER_REG_OFFSET);=0A=
+	rc32300_writel(0x3fff, TIMER0_COMPARE + 5*TIMER_REG_OFFSET);=0A=
+	rc32300_writel(1, TIMER0_CNTL + 4*TIMER_REG_OFFSET);=0A=
+	rc32300_writel(1, TIMER0_CNTL + 5*TIMER_REG_OFFSET);=0A=
+	=0A=
+}=0A=
+=0A=
+extern int (*board_be_handler)(struct pt_regs *regs, int is_fixup);=0A=
+=0A=
+static int __init idt_setup(void)=0A=
+{=0A=
+	char* argptr;=0A=
+=0A=
+	argptr =3D prom_getcmdline();=0A=
+=0A=
+	board_time_init =3D rc32300_time_init;=0A=
+	board_timer_setup =3D rc32300_timer_setup;=0A=
+	board_be_handler =3D rc32334_be_handler;=0A=
+	_machine_restart =3D rc32300_restart;=0A=
+	_machine_halt =3D rc32300_halt;=0A=
+	pm_power_off =3D rc32300_power_off;=0A=
+=0A=
+	set_io_port_base(KSEG1);=0A=
+=0A=
+	// clear out any wired entries=0A=
+	write_c0_wired(0);=0A=
+=0A=
+	bus_error_init();=0A=
+=0A=
+	readb(KSEG1ADDR(LCD_CLEAR)); // clear the 4-digit LCD display=0A=
+=0A=
+	idtprintf("Unix");=0A=
+=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+int page_is_ram(unsigned long pagenr)=0A=
+{=0A=
+	return 1;=0A=
+}=0A=
+=0A=
+static int __init buserror_enable(void)=0A=
+{=0A=
+  // ack any bus errors=0A=
+=0A=
+  rc32300_ack_irq(GROUP4_IRQ_BASE+4); // ack timer 4 rollover intr=0A=
+  rc32300_ack_irq(GROUP4_IRQ_BASE+5); // ack timer 5 rollover intr=0A=
+  rc32300_ack_irq(GROUP1_IRQ_BASE);   // ack bus error intr=0A=
+=0A=
+  /*=0A=
+   * Enable CPU and IP Bus Error exceptions, and disable WatchDog.=0A=
+   */=0A=
+  rc32300_writel(0x18, CPU_IP_BUSERR_CNTL);=0A=
+  return 0;=0A=
+}=0A=
+=0A=
+//early_initcall(idt_setup);=0A=
+void __init plat_setup(void){=0A=
+  idt_setup();=0A=
+}=0A=
+=0A=
+__initcall(buserror_enable);=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/time.c =
idtlinux/arch/mips/idt-boards/rc32300/S334/time.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32300/S334/time.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32300/S334/time.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,149 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *    IDT S334 timer routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/spinlock.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <linux/irq.h>=0A=
+#include <linux/timex.h>=0A=
+=0A=
+#include <linux/param.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/hardirq.h>=0A=
+=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/debug.h>=0A=
+#include <asm/time.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+static unsigned long r4k_offset; /* Amount to incr compare reg each =
time */=0A=
+static unsigned long r4k_cur;    /* What counter should be at next =
timer irq */=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+#if defined(CONFIG_IDT_79EB365) && defined(CONFIG_MIPS_RTC)=0A=
+extern void rtc_ds1553_init(void);=0A=
+#elif defined(CONFIG_IDT_79EB355) && defined(CONFIG_MIPS_RTC)=0A=
+extern void rtc_ds1501_init(void);=0A=
+#endif=0A=
+=0A=
+/* =0A=
+ * Figure out the r4k offset, the amount to increment the compare=0A=
+ * register for each time tick. There is no RTC available.=0A=
+ *=0A=
+ * The RC32300 counts at half the CPU *core* speed.=0A=
+ */=0A=
+static unsigned long __init cal_r4koff(void)=0A=
+{=0A=
+  mips_hpt_frequency =3D idt_cpu_freq * IDT_CLOCK_MULT / 2;=0A=
+  return (mips_hpt_frequency / HZ);=0A=
+}=0A=
+=0A=
+=0A=
+void __init rc32300_time_init(void)=0A=
+{=0A=
+  unsigned int est_freq, flags;=0A=
+  =0A=
+  local_irq_save(flags);=0A=
+  =0A=
+  printk("calculating r4koff... ");=0A=
+  r4k_offset =3D cal_r4koff();=0A=
+  printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);=0A=
+  =0A=
+  est_freq =3D 2*r4k_offset*HZ;	=0A=
+  est_freq +=3D 5000;    /* round */=0A=
+  est_freq -=3D est_freq%10000;=0A=
+  printk("CPU frequency %d.%02d MHz\n", est_freq/1000000, =0A=
+	 (est_freq%1000000)*100/1000000);=0A=
+  local_irq_restore(flags);=0A=
+  =0A=
+#if defined(CONFIG_IDT_79EB365) && defined(CONFIG_MIPS_RTC)=0A=
+  rtc_ds1553_init();=0A=
+#elif defined(CONFIG_IDT_79EB355) && defined(CONFIG_MIPS_RTC)=0A=
+  rtc_ds1501_init();=0A=
+#endif=0A=
+=0A=
+}=0A=
+=0A=
+=0A=
+void __init rc32300_timer_setup(struct irqaction *irq)=0A=
+{=0A=
+  /* we are using the cpu counter for timer interrupts */=0A=
+  setup_irq(MIPS_CPU_TIMER_IRQ, irq);=0A=
+=0A=
+#if 0  =0A=
+  /* to generate the first timer interrupt */=0A=
+  r4k_cur =3D (read_c0_count() + r4k_offset);=0A=
+  write_c0_compare(r4k_cur);=0A=
+#endif=0A=
+}=0A=
+=0A=
+static inline void ack_r4ktimer(unsigned long newval)=0A=
+{=0A=
+  write_c0_compare(newval);=0A=
+}=0A=
+=0A=
+extern void idt_disp_char(int i,char c);=0A=
+=0A=
+asmlinkage void idt_timer_interrupt(int irq,struct pt_regs *regs)=0A=
+{ =0A=
+#ifdef CONFIG_KGDB=0A=
+  void kgdb_check(void);=0A=
+#endif=0A=
+=0A=
+  static unsigned int timerCount =3D 0;=0A=
+  static int toggle =3D 0;=0A=
+=0A=
+  irq_enter();=0A=
+  kstat_this_cpu.irqs[irq]++;=0A=
+=0A=
+  if( (timerCount++ % HZ) =3D=3D 0)=0A=
+    { =0A=
+      toggle ^=3D 1;=0A=
+      idt_disp_char(0,toggle ? 'u' :'U');=0A=
+    }=0A=
+=0A=
+  timer_interrupt(irq, NULL, regs);=0A=
+  irq_exit();=0A=
+=0A=
+#ifdef CONFIG_KGDB=0A=
+  kgdb_check();=0A=
+#endif=0A=
+}=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/csu_idt.S =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/csu_idt.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/csu_idt.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/csu_idt.S	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,345 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialization code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+	=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+=0A=
+#define MHZ CONFIG_IDT_BOARD_FREQ=0A=
+		=0A=
+#include "idthdr.h"=0A=
+#include "iregdef.h"=0A=
+#include "idtcpu.h"=0A=
+#include "s434ram.h"=0A=
+#include "s434.h"=0A=
+=0A=
+#define IndexInvalidate_I       0x00=0A=
+=0A=
+/*--------------------------------------------------------------=0A=
+** prom entry point table=0A=
+*-------------------------------------------------------------*/=0A=
+=0A=
+FRAME(start,sp,0,ra)=0A=
+  j idtstart        /* begin monitor from start       |00| */=0A=
+=0A=
+idtstart:=0A=
+=0A=
+  .set  noreorder=0A=
+      mtc0  zero, C0_CAUSE=0A=
+            nop=0A=
+      li    v0, 0x0=0A=
+      or    v0, (SR_CU0 | SR_BEV)=0A=
+      mtc0  v0, C0_SR=0A=
+            nop=0A=
+      mfc0  v1, C0_CONFIG=0A=
+            nop=0A=
+      and   v1, ~(0x7)=0A=
+      ori   v1, 0x3=0A=
+      mtc0  v1, C0_CONFIG=0A=
+            nop=0A=
+            nop=0A=
+            =0A=
+/* ------------------- Disable WatchDog Timer =
----------------------------- */=0A=
+      li    t0, WTC_BASE=0A=
+      sw    zero, 0x3C(t0) /* WTC */=0A=
+/* ------ Alternate functions for GPIO pins =
--------------------------------*/=0A=
+/* only UART0, UART1 and mem_addr */=0A=
+      li    t0, GPIO_BASE=0A=
+      li    t1, 0xf3=0A=
+      sw    t1, 0x0(t0)=0A=
+=0A=
+#if !defined(PCISAT)=0A=
+/* ------------------- Assert PCI reset =
----------------------------------- */=0A=
+			li    t0, 0xb8080000=0A=
+      lw    t1, (t0)=0A=
+      andi  t2, t1, 0x1=0A=
+      beqz  t2, 2f=0A=
+            nop=0A=
+      andi  t2, t1, 0x3fe=0A=
+      sw    t2, (t0)=0A=
+      li    t2, 0x1000=0A=
+1:=0A=
+      addi  t2, -1=0A=
+      bnez  t2, 1b=0A=
+            nop=0A=
+2:=0A=
+      ori   t2, t1, 0x1=0A=
+      sw    t2, (t0)=0A=
+      lui   t2, 0x2=0A=
+rip:=0A=
+      lw    t1, 4(t0)=0A=
+      and   t1, t1, t2=0A=
+      bnez  t1, rip=0A=
+            nop=0A=
+#endif=0A=
+=0A=
+/* ------------------- Setup Device Controller ------------------------=
---- */=0A=
+      li    t0, DEV_CTL_BASE      /* load 2 base address registers' =
base    */=0A=
+      li    t1, DEV0_CTRL         /* device0 control parameter         =
     */=0A=
+      sw    t1, 0x8(t0)           /* set the control register  CS0     =
     */=0A=
+      li    t1, DEV0_TC           /* device0 timing config parameter   =
     */=0A=
+      sw    t1, 0xC(t0)=0A=
+      li    t1, DEV1_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x10(t0)=0A=
+      li    t1, DEV1_MASK         /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x14(t0) =0A=
+      li    t1, DEV1_CTRL         /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x18(t0)=0A=
+      li    t1, DEV1_TC           /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x1C(t0) =0A=
+=0A=
+      li    t1, DEV2_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x20(t0)=0A=
+      li    t1, DEV2_MASK         /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x24(t0) =0A=
+      li    t1, DEV2_CTRL         /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x28(t0)=0A=
+      li    t1, DEV2_TC           /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x2C(t0) =0A=
+=0A=
+      li    t1, DEV3_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x30(t0)=0A=
+      li    t1, DEV3_MASK         /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x34(t0) =0A=
+      li    t1, DEV3_CTRL         /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x38(t0)=0A=
+      li    t1, DEV3_TC           /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x3C(t0) =0A=
+=0A=
+      DISPLAY('I','D','D','R')=0A=
+#if MEMCFG !=3D SRAM_ONLY=0A=
+=0A=
+/* ------------- INITIALIZE DDR SDRAM CONTROLLER =
---------------------------*/=0A=
+=0A=
+      li    t1, 0x0               /* Add 200 microseconds of delay =
*/=0A=
+      li    t2, DELAY_200USEC=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+=0A=
+/*-------------- Initialize DDR Base and Mask Registers =
--------------------*/=0A=
+=0A=
+      li    t0, DDR_BASE=0A=
+=0A=
+  /* Load the DDRC, reset  Refresh Enable */=0A=
+      li    t1, DDRC_VAL_AT_INIT=0A=
+      sw    t1, 0x10(t0)=0A=
+      =0A=
+      sw    zero, 0x4(t0)=0A=
+      sw    zero, 0xc(t0)=0A=
+      sw    zero, 0x18(t0)=0A=
+=0A=
+  /* Store DDRBASE */=0A=
+      li    t1, DDR_BASE_VAL=0A=
+      sw    t1, 0x0(t0)=0A=
+=0A=
+  /* Store DDRMASK */=0A=
+      li    t1, DDR_MASK_VAL=0A=
+      sw    t1, 0x4(t0)=0A=
+=0A=
+  /* Store DDRABASE */=0A=
+      li    t1, DDR_ABASE_VAL=0A=
+      sw    t1, 0x14(t0)=0A=
+=0A=
+  /* Load DDRAMASK to disable alternate Mapping */=0A=
+      li    t1, DDR_AMASK_VAL=0A=
+      sw    t1, 0x18(t0)=0A=
+=0A=
+      li    t1, DDR_CUST_NOP      /* Write to DDR Custom transaction =
register */=0A=
+      sw    t1, 0x20(t0)=0A=
+=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Add 200 microseconds of delay */=0A=
+      li    t1, 0x0=0A=
+      li    t2, DELAY_200USEC=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+            =0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_CUST_PRECHARGE=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate A10 high to pre-charge both the banks */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_PRECHARGE_OFFSET | DDR_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_LD_EMODE_REG=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate EMODE register contents on A15-A2 */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_EMODE_VAL | DDR_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_LD_MODE_REG=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate Mode register contents on the address bus A15-A2  */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_DLL_RES_MODE_VAL | DDR_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Delay of  1.6 microseconds ~ 300 delay iteration value */=0A=
+      li    t1, 0x0=0A=
+      li    t2, 500=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+=0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_CUST_PRECHARGE=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate A10 high to pre-charge both the banks */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_PRECHARGE_OFFSET | DDR_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Implements 9 cycles of Auto refresh allowing=0A=
+     sufficient margin for stability*/=0A=
+      li    t4, 9=0A=
+      li    t3, 0=0A=
+1:=0A=
+      li    t1, DDR_CUST_REFRESH=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Read it back to flush CPU write buffers */=0A=
+      lw    t1, 0x20(t0)=0A=
+=0A=
+  /* Access DDR */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+      add   t3, 1=0A=
+      bne   t3, t4, 1b=0A=
+            nop=0A=
+=0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_LD_MODE_REG=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate Mode Register contents on the address bus A12-A0 */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_DLL_MODE_VAL | DDR_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Initialize the refresh timer with fast refresh count */=0A=
+      li    t0, RCOUNT=0A=
+      li    t1, DDR_REF_CMP_FAST=0A=
+      =0A=
+  /* Set the RCOMPARE register */=0A=
+      sw    t1, 0x4(t0)=0A=
+=0A=
+  /* Enable the Refresh timer */=0A=
+      li    t1, 0x1           /* CE set to enabled the  Refresh =
counter */=0A=
+      sw    t1, 0x8(t0)=0A=
+=0A=
+  /* Enable RE-refresh enable in the DDRC register */=0A=
+      li    t0, DDR_BASE=0A=
+      li    t1, DDRC_VAL_NORMAL=0A=
+      sw    t1, 0x10(t0)=0A=
+=0A=
+  /* Add 200 microseconds of delay */=0A=
+      li    t1, 0x0=0A=
+      li    t2, DELAY_200USEC=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+=0A=
+      li    t0, RCOUNT=0A=
+=0A=
+  /* Disable the refresh counter before changing the compare value =
*/=0A=
+      sw    zero, 0x8(t0)=0A=
+=0A=
+  /* Set the RCOMPARE register with value gotten above */=0A=
+      li    t3, DDR_REF_CMP_VAL=0A=
+      sw    t3, 0x4(t0)=0A=
+=0A=
+  /* Enable the Refresh timer */=0A=
+      li    t1, 0x1           /* CE set to enabled the  Refresh =
counter */=0A=
+      sw    t1, 0x8(t0)=0A=
+=0A=
+  /* Add 200 microseconds of delay */=0A=
+      li    t1, 0x0=0A=
+      li    t2, DELAY_200USEC=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+=0A=
+#endif=0A=
+	li    t0, 0xa0000000=0A=
+	li    t1, 0xa0100000=0A=
+1:=0A=
+	sw    zero, 0x00(t0)=0A=
+	sw    zero, 0x04(t0)=0A=
+	sw    zero, 0x08(t0)=0A=
+	sw    zero, 0x0c(t0)=0A=
+	addiu t0, 16=0A=
+	nop=0A=
+	blt   t0, t1, 1b=0A=
+	nop=0A=
+	nop=0A=
+	nop=0A=
+3:=0A=
+	mfc0  t0, C0_SR=0A=
+	nop=0A=
+	nop=0A=
+	and   t0, ~SR_BEV=0A=
+	mtc0  t0, C0_SR=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+4:	=0A=
+	=0A=
+/* Jump to zImage startup */=0A=
+	        =0A=
+	la     k0, zstartup=0A=
+	j      k0=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+ENDFRAME(start)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/head.S =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/head.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/head.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/head.S	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,126 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialisation code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+	=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/cacheops.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+#include <asm/regdef.h>=0A=
+=0A=
+#define IndexInvalidate_I       0x00=0A=
+=0A=
+	.set noreorder=0A=
+	.cprestore=0A=
+	LEAF(zstartup)=0A=
+zstartup:=0A=
+=0A=
+        la      sp, .stack=0A=
+	move	s0, a0=0A=
+	move	s1, a1=0A=
+	move	s2, a2=0A=
+	move	s3, a3=0A=
+=0A=
+	/* Clear BSS */=0A=
+	/* Note: when zImage is in ROM, _edata and _bss point to=0A=
+	 * ROM space even when using -Tbss on the linker command line;=0A=
+	 * maybe ld.script needs to be corrected.=0A=
+	 */=0A=
+	la	a0, .stack=0A=
+	la	a2, _end=0A=
+1:	sw	zero, 0(a0)=0A=
+	bne	a2, a0, 1b=0A=
+	addu	a0, 4=0A=
+=0A=
+	/* flush the I-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80004000  # end address (16KB I-Cache)=0A=
+	subu	k1, 128=0A=
+=0A=
+2:=0A=
+	.set mips3=0A=
+	cache   IndexInvalidate_I, 0(k0)=0A=
+	cache   IndexInvalidate_I, 16(k0)=0A=
+	cache   IndexInvalidate_I, 32(k0)=0A=
+	cache   IndexInvalidate_I, 48(k0)=0A=
+	cache   IndexInvalidate_I, 64(k0)=0A=
+	cache   IndexInvalidate_I, 80(k0)=0A=
+	cache   IndexInvalidate_I, 96(k0)=0A=
+	cache   IndexInvalidate_I, 112(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 2b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+=0A=
+	/* flush the D-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80004000  # end address (16KB I-Cache)=0A=
+	subu	k1, 128=0A=
+=0A=
+2:=0A=
+	.set mips3=0A=
+	cache   Index_Writeback_Inv_D, 0(k0)=0A=
+	cache   Index_Writeback_Inv_D, 16(k0)=0A=
+	cache   Index_Writeback_Inv_D, 32(k0)=0A=
+	cache   Index_Writeback_Inv_D, 48(k0)=0A=
+	cache   Index_Writeback_Inv_D, 64(k0)=0A=
+	cache   Index_Writeback_Inv_D, 80(k0)=0A=
+	cache   Index_Writeback_Inv_D, 96(k0)=0A=
+	cache   Index_Writeback_Inv_D, 112(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 2b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+=0A=
+	la	ra, 3f=0A=
+	la	k0, decompress_kernel=0A=
+	jr	k0=0A=
+	nop=0A=
+3:=0A=
+=0A=
+	move	a0, s0=0A=
+	move	a1, s1=0A=
+	move	a2, s2=0A=
+	move	a3, s3=0A=
+	li	k0, KERNEL_ENTRY=0A=
+	jr	k0=0A=
+	nop=0A=
+4:=0A=
+	b 4b=0A=
+	END(zstartup)=0A=
+=0A=
+	.bss=0A=
+	.fill 0x2000=0A=
+	EXPORT(.stack)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/idtcpu.h =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/idtcpu.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/idtcpu.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/idtcpu.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,336 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#if !defined(__IDTCPU_H__)=0A=
+#define __IDTCPU_H__=0A=
+/*=0A=
+** memory configuration and mapping=0A=
+*/=0A=
+#define K0BASE		0x80000000=0A=
+#define K0SIZE		0x20000000=0A=
+#define K1BASE		0xa0000000=0A=
+#define K1SIZE		0x20000000=0A=
+#define K2BASE		0xc0000000=0A=
+#if defined(CPU_R32364)=0A=
+#define K2SIZE		0x40000000=0A=
+#define ICEBASE		0xff000000=0A=
+#define ICESIZE		0x01000000=0A=
+#elif defined(CPU_R32438) || defined(CPU_R32434)=0A=
+#define K2SIZE		0x20000000=0A=
+#define K3BASE		0xe0000000=0A=
+#define K3SIZE          0x20000000=0A=
+#define ICEBASE		0xff200000=0A=
+#define ICESIZE		0x00200000=0A=
+#endif=0A=
+=0A=
+#define KUBASE		0=0A=
+#define KUSIZE		0x80000000=0A=
+=0A=
+/*=0A=
+** Exception Vectors=0A=
+*/=0A=
+=0A=
+#define	T_VEC	(K0BASE + 0x000)			/* tlbmiss vector */=0A=
+#define X_VEC	(K0BASE + 0x080)			/* xtlbmiss vector */=0A=
+#define C_VEC	(K1BASE + 0x100)			/* cache error vector */=0A=
+#define E_VEC	(K0BASE + 0x180)			/* exception vector */=0A=
+#define I_VEC	(K0BASE + 0X200)			/* interrupt vector */=0A=
+#define	R_VEC	(K1BASE + 0x1fc00000)	/* reset vector */=0A=
+=0A=
+/*=0A=
+** Address conversion macros=0A=
+*/=0A=
+#ifdef CLANGUAGE=0A=
+#define	CAST(as) (as)=0A=
+#else=0A=
+#define	CAST(as)=0A=
+#endif=0A=
+=0A=
+#define	K0_TO_K1(x)		(CAST(unsigned)(x) | 0xA0000000)	/* kseg0 to =
kseg1 */=0A=
+#define	K1_TO_K0(x)		(CAST(unsigned)(x) & 0x9FFFFFFF)	/* kseg1 to =
kseg0 */=0A=
+#define	K0_TO_PHYS(x)	(CAST(unsigned)(x) & 0x1FFFFFFF)	/* kseg0 to =
physical */=0A=
+#define	K1_TO_PHYS(x)	(CAST(unsigned)(x) & 0x1FFFFFFF)	/* kseg1 to =
physical */=0A=
+#define	PHYS_TO_K0(x)	(CAST(unsigned)(x) | 0x80000000)	/* physical to =
kseg0 */=0A=
+#define	PHYS_TO_K1(x)	(CAST(unsigned)(x) | 0xA0000000)	/* physical to =
kseg1 */=0A=
+=0A=
+#if defined(CPU_R32364)             /* Includes RC32332, RC32334 */=0A=
+#define	CFG_ICE					0x80000000	/* ICE detect */=0A=
+#define	CFG_ECMASK			0x70000000	/* System Clock Ratio */=0A=
+#define	CFG_ECBY2				0x00000000 	/* divide by 2 */=0A=
+#define	CFG_ECBY3				0x10000000 	/* divide by 3 */=0A=
+#define	CFG_ECBY4				0x20000000 	/* divide by 4 */=0A=
+#define	CFG_BE					0x00008000	/* Big Endian */=0A=
+#define	CFG_ICMASK			0x00000e00	/* Instruction cache size */=0A=
+#define	CFG_ICSHIFT			9=0A=
+#define	CFG_DCMASK			0x000001c0	/* Data cache size */=0A=
+#define	CFG_DCSHIFT			6=0A=
+#define	CFG_IB					0x00000020	/* Instruction cache line size */=0A=
+#define	CFG_DB					0x00000010	/* Data cache line size */=0A=
+#define	CFG_K0MASK			0x00000007	/* KSEG0 coherency algorithm */=0A=
+#elif defined(CPU_R32438) || defined(CPU_R32434)=0A=
+#define	CFG_MM					0x00060000  /* write buffer Merge Mode */=0A=
+#define CFG_BM					0x00010000  /* Burst Mode */=0A=
+#define	CFG_BE					0x00008000	/* Big Endian */=0A=
+#define	CFG_K0MASK			0x00000007	/* KSEG0 coherency algorithm */=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * Primary cache mode=0A=
+ */=0A=
+#if defined(CPU_R32364)=0A=
+#define CFG_C_NCHRNT_WT_NWA			0=0A=
+#define CFG_C_NCHRNT_WT					1=0A=
+#define CFG_C_UNCACHED					2=0A=
+#define CFG_C_NCHRNT_WB					3=0A=
+=0A=
+/* Cache Operations */=0A=
+#define Index_Invalidate_I      0x0         /* 0       0 */=0A=
+#define Index_Writeback_Inv_D   0x1         /* 0       1 */=0A=
+#define Index_Invalidate_SI     0x2         /* 0       2 */=0A=
+#define Index_Writeback_Inv_SD  0x3         /* 0       3 */=0A=
+#define Index_Load_Tag_I        0x4         /* 1       0 */=0A=
+#define Index_Load_Tag_D        0x5         /* 1       1 */=0A=
+#define Index_Load_Tag_SI       0x6         /* 1       2 */=0A=
+#define Index_Load_Tag_SD       0x7         /* 1       3 */=0A=
+#define Index_Store_Tag_I       0x8         /* 2       0 */=0A=
+#define Index_Store_Tag_D       0x9         /* 2       1 */=0A=
+#define Index_Store_Tag_SI      0xA         /* 2       2 */=0A=
+#define Index_Store_Tag_SD      0xB         /* 2       3 */=0A=
+#define Create_Dirty_Exc_D      0xD         /* 3       1 */=0A=
+#define Create_Dirty_Exc_SD     0xF         /* 3       3 */=0A=
+#define Hit_Invalidate_I        0x10        /* 4       0 */=0A=
+#define Hit_Invalidate_D        0x11        /* 4       1 */=0A=
+#define Hit_Invalidate_SI       0x12        /* 4       2 */=0A=
+#define Hit_Invalidate_SD       0x13        /* 4       3 */=0A=
+#define Hit_Writeback_Inv_D     0x15        /* 5       1 */=0A=
+#define Hit_Writeback_Inv_SD    0x17        /* 5       3 */=0A=
+#define Fill_I                  0x14        /* 5       0 */=0A=
+#define Hit_Writeback_D         0x19        /* 6       1 */=0A=
+#define Hit_Writeback_SD        0x1B        /* 6       3 */=0A=
+#define Hit_Writeback_I         0x18        /* 6       0 */=0A=
+#define Hit_Set_Virtual_SI      0x1E        /* 7       2 */=0A=
+#define Hit_Set_Virtual_SD      0x1F        /* 7       3 */=0A=
+#define CFG_EW32        				0x00040000      /* 32 bit */=0A=
+#elif defined(CPU_R32438) || defined(CPU_R32434)=0A=
+#define CFG_C_UNCACHED					2=0A=
+#define CFG_C_NCHRNT_WB					3=0A=
+=0A=
+/* Cache Operations */=0A=
+#define Index_Invalidate_I      0x0         /* 0       0 */=0A=
+#define Index_Invalidate_D      0x1         /* 0       0 */=0A=
+#define Index_Load_Tag_I        0x4         /* 1       0 */=0A=
+#define Index_Load_Tag_D        0x5         /* 1       1 */=0A=
+#define Index_Store_Tag_I       0x8         /* 2       0 */=0A=
+#define Index_Store_Tag_D       0x9         /* 2       1 */=0A=
+#define Hit_Invalidate_I        0x10        /* 4       0 */=0A=
+#define Hit_Invalidate_D        0x11        /* 4       1 */=0A=
+#define Fill_I                  0x14        /* 5       0 */=0A=
+#define Fetch_Lock_I						0x1C        /* 7       0 */=0A=
+#define Fetch_Lock_D						0x1D        /* 7       1 */=0A=
+#define CFG_EW32        				0x00040000      /* 32 bit */=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** TLB resource defines=0A=
+*/=0A=
+=0A=
+#define	N_TLB_ENTRIES				16=0A=
+#define	TLBHI_VPN2MASK			0xffffe000=0A=
+#define	TLBHI_PIDMASK				0x000000ff=0A=
+#define	TLBHI_NPID					256=0A=
+=0A=
+#define	TLBLO_PFNMASK				0x03ffffc0=0A=
+#define	TLBLO_PFNSHIFT			6=0A=
+#define	TLBLO_D							0x00000004	/* writeable */=0A=
+#define	TLBLO_V							0x00000002	/* valid bit */=0A=
+#define	TLBLO_G							0x00000001	/* global access bit */=0A=
+#define	TLBLO_CMASK					0x00000038	/* cache algorithm mask */=0A=
+#define	TLBLO_CSHIFT				3=0A=
+=0A=
+#define	TLBLO_UNCACHED			(CFG_C_UNCACHED << TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WT_NWA	(CFG_C_NCHRNT_WT_NWA << TLBLO_CSHIFT)=0A=
+#if defined(CPU_R32364)=0A=
+#define	TLBLO_NCHRNT_WT			(CFG_C_NCHRNT_WT << TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WB			(CFG_C_NCHRNT_WB << TLBLO_CSHIFT)=0A=
+#endif=0A=
+=0A=
+#define	TLBINX_PROBE				0x80000000=0A=
+#define	TLBINX_INXMASK			0x0000003f=0A=
+=0A=
+#define	TLBRAND_RANDMASK		0x0000003f=0A=
+=0A=
+#define	TLBCTXT_BASEMASK		0xff800000=0A=
+#define	TLBCTXT_BASESHIFT		23=0A=
+=0A=
+#define	TLBCTXT_VPN2MASK		0x007ffff0=0A=
+#define	TLBCTXT_VPN2SHIFT		4=0A=
+=0A=
+#define	TLBPGMASK_MASK			0x01ffe000=0A=
+=0A=
+#define	SR_CUMASK				0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3					0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2					0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1					0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0					0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+/* #define	SR_PE						0x00100000*/  /* cache parity error */=0A=
+=0A=
+#if defined(CPU_R32364)=0A=
+#define	SR_RE						0X02000000	/* Reverse Endianness */=0A=
+#define	SR_DL						0x01000000	/* Data Cache Locking */=0A=
+#define	SR_IL						0x00800000	/* Instruction Cache Locking */=0A=
+=0A=
+#define	SR_BEV					0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_SR						0x00100000	/* Soft reset */=0A=
+#define	SR_CH						0x00040000	/* Cache hit */=0A=
+#define	SR_CE						0x00020000	/* Use cache ECC  */=0A=
+#define	SR_DE						0x00010000	/* Disable cache exceptions */=0A=
+=0A=
+#elif defined(CPU_R32438) || defined(CPU_R32434)=0A=
+#define	SR_RP						0X08000000	/* Reduced Power mode */=0A=
+=0A=
+#define	SR_RE						0X02000000	/* Reverse Endianness */=0A=
+=0A=
+#define	SR_BEV					0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_TS						0X00200000	/* TLB Shutdown */=0A=
+#define	SR_SR						0x00100000	/* Soft reset */=0A=
+#define	SR_NMI					0X00080000	/* NMI */=0A=
+#endif=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK				0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8				0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7				0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6				0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5				0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4				0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3				0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2				0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1				0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0				0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT		8=0A=
+=0A=
+#define	SR_IBIT8				0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7				0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6				0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5				0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4				0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3				0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2				0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1				0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KSMASK				0x00000016	/* Kernel mode mask */=0A=
+#define	SR_KSUSER				0x00000000	/* User Mode */=0A=
+#define	SR_KSKERNEL			0x00000016	/* Kernel Mode */=0A=
+=0A=
+#define	SR_ERL					0x00000004	/* Error level */=0A=
+#define	SR_EXL					0x00000002	/* Exception level */=0A=
+#define	SR_IE						0x00000001	/* Interrupts enabled */=0A=
+#define	NOT_SR_IEC      0xfffffffe  /* assembler problem with li =
~SR_IEC */=0A=
+=0A=
+/*=0A=
+ * Cause Register=0A=
+ */=0A=
+#define	CAUSE_BD				0x80000000	/* Branch delay slot */=0A=
+#define	CAUSE_CEMASK		0x30000000	/* coprocessor error */=0A=
+#define	CAUSE_CESHIFT		28=0A=
+#if defined(CPU_R32364)=0A=
+#define	CAUSE_IPE				0x04000000	/* Imprecise exception */=0A=
+#define	CAUSE_DW				0x02000000	/* Data watch */=0A=
+#define	CAUSE_IW				0x01000000	/* Instruction watch */=0A=
+#elif defined(CPU_R32438) || defined(CPU_R32434)=0A=
+#define CAUSE_IV			 	0x00800000	/* Interrupt Vector location */=0A=
+#define CAUSE_WP			 	0x00400000	/* Watch Exception deferred */=0A=
+#endif=0A=
+=0A=
+#define	CAUSE_IPMASK		0x0000FF00	/* Pending interrupt mask */=0A=
+#define	CAUSE_IPSHIFT		8=0A=
+=0A=
+/* Notice: Watch Exception if Exc. Code is 23 is not included in the =
mask=0A=
+ *	   for R32364.=0A=
+ */=0A=
+#define	CAUSE_EXCMASK		0x0000003C	/* Cause code bits */=0A=
+#define	CAUSE_EXCSHIFT	2=0A=
+=0A=
+#ifndef XDS=0A=
+/*=0A=
+**  Coprocessor 0 registers=0A=
+*/=0A=
+#define	C0_INX					$0		/* tlb index */=0A=
+#define	C0_RANDOM				$1=0A=
+#define	C0_TLBLO0				$2		/* tlb entry low 0 */=0A=
+#define	C0_TLBLO1				$3		/* tlb entry low 1 */=0A=
+#define	C0_CTXT					$4		/* tlb context */=0A=
+#define	C0_PAGEMASK			$5		/* tlb page mask */=0A=
+#define	C0_WIRED				$6		/* number of wired tlb entries */=0A=
+=0A=
+#define	C0_BADVADDR			$8		/* bad virtual address */=0A=
+#define	C0_COUNT				$9		/* timer count */=0A=
+#define	C0_TLBHI				$10		/* tlb entry hi */=0A=
+#define	C0_COMPARE			$11		/* timer comparator  */=0A=
+#define	C0_SR						$12		/* status register */=0A=
+#define	C0_CAUSE				$13		/* exception cause */=0A=
+#define	C0_EPC					$14		/* exception pc */=0A=
+#define	C0_PRID					$15		/* revision identifier */=0A=
+#define	C0_CONFIG				$16		/* configuration register */=0A=
+=0A=
+#if defined(CPU_R32364)=0A=
+#define	C0_IWATCH				$18		/* Instr brk pt Virtual add. */=0A=
+#define	C0_DWATCH				$19		/* Data brk pt Virtual add. */=0A=
+=0A=
+#define	C0_IEPC					$22		/* Imprecise Exception pc */=0A=
+#define	C0_DEPC					$23		/* Debug Exception pc */=0A=
+#define	C0_DEBUG				$24		/* Debug control/status reg */=0A=
+=0A=
+#define	C0_ECC					$26		/* primary cache Parity control */=0A=
+#define	C0_CACHEERR			$27		/* cache error status */=0A=
+#define	C0_TAGLO				$28		/* cache tag lo */=0A=
+#define	C0_ERRPC				$30		/* cache error pc */=0A=
+#elif defined(CPU_R32438) || defined(CPU_R32434)=0A=
+#define	C0_WATCHLO			$18		/* Watchpoint address (low) */=0A=
+#define	C0_WATCHHI			$19		/* Watchpoint address (high) */=0A=
+=0A=
+#define	C0_DEBUG				$23		/* Debug control/status reg */=0A=
+#define	C0_DEPC					$24		/* Debug Exception pc */=0A=
+=0A=
+#define	C0_ERRCTL				$26		/* Cache Error Control */=0A=
+#define	C0_TAGLO				$28		/* Cache Tag Lo */=0A=
+#define	C0_ERRPC				$30		/* Cache Error PC */=0A=
+#define C0_DESAVE				$31		/* Debug scratchpad reg. */=0A=
+#endif =0A=
+=0A=
+#endif=0A=
+#endif /* defined(__IDTCPU_H__) */=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/idthdr.h =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/idthdr.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/idthdr.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/idthdr.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,53 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Some macros. Though they are already defined else where in the =
linux=0A=
+ *   tree, they are once again declared here for the ease of syncing =
up with=0A=
+ *    IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef XDS=0A=
+=0A=
+#define	FRAME(name,frm_reg,offset,ret_reg)	\=0A=
+	.globl	name;				\=0A=
+	.ent	name;				\=0A=
+name:;						\=0A=
+	.frame	frm_reg,offset,ret_reg=0A=
+=0A=
+#define ENDFRAME(name) 	.end name=0A=
+=0A=
+#else=0A=
+=0A=
+#define FRAME(name,frm_reg,offset,ret_reg)      \=0A=
+name:=0A=
+=0A=
+#define ENDFRAME(name)=0A=
+=0A=
+#endif=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/image.lds.in =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/image.lds.in=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/image.lds.in	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/image.lds.in	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D IMSTART;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32434/EB434/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D BSS_START;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/iregdef.h =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/iregdef.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/iregdef.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/iregdef.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,274 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifdef CLANGUAGE=0A=
+struct ireg_desc {=0A=
+	char 	*ptr_field_name;	/* field name   */=0A=
+	short	num_digits;				/* number ofdigits to display */=0A=
+	short	num_spaces;				/* number of spaces to follow */=0A=
+	reg_t	fld_mask;					/* mask to extract value of field */=0A=
+	int	fld_shift;					/* shift amount to position field */=0A=
+  short    cpu;=0A=
+	char *CONST *ptr_enum_list;	/* ptr to an enumeration list */=0A=
+	  };=0A=
+=0A=
+/*=0A=
+** reg_name - structure that gives the reg. name, alt. reg name=0A=
+**		the reg index for fetching the value, the number=0A=
+**		of spaces req. so a tabular display will align=0A=
+**		a pointer to a structure defining the fields if=0A=
+**		required and a flag for the output type.=0A=
+*/=0A=
+struct reg_name {=0A=
+	char	*register_name;=0A=
+	char	*alt_reg_name;=0A=
+	short	reg_index;=0A=
+	short	space_pad;=0A=
+	CONST struct ireg_desc *ptr_reg_desc_flds;=0A=
+	unsigned char format_type;=0A=
+	unsigned char print_type;=0A=
+	short   reg_group;=0A=
+  short    cpu;=0A=
+	  };=0A=
+=0A=
+/* print format specifiers */=0A=
+#define PRT_HEX		0=0A=
+#define PRT_SGL 	1=0A=
+#define PRT_DBL 	2=0A=
+=0A=
+/* register group classifiers */=0A=
+#define GRP_CPU		0x0001=0A=
+#define GRP_FPR		0x0002=0A=
+#define GRP_FPS		0x0004=0A=
+#define GRP_FPD		0x0008=0A=
+#define GRP_CP0		0x0010=0A=
+#define GRP_CP0R	0x0020=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** register names=0A=
+*/=0A=
+#define r0		$0=0A=
+#define r1		$1=0A=
+#define r2		$2=0A=
+#define r3		$3=0A=
+#define r4		$4=0A=
+#define r5		$5=0A=
+#define r6		$6=0A=
+#define r7		$7=0A=
+#define r8		$8=0A=
+#define r9		$9=0A=
+#define r10		$10=0A=
+#define r11		$11=0A=
+#define r12		$12=0A=
+#define r13		$13=0A=
+#define r14		$14=0A=
+#define r15		$15=0A=
+#define r16		$16=0A=
+#define r17		$17=0A=
+#define r18		$18=0A=
+#define r19		$19=0A=
+#define r20		$20=0A=
+#define r21		$21=0A=
+#define r22		$22=0A=
+#define r23		$23=0A=
+#define r24		$24=0A=
+#define r25		$25=0A=
+#define r26		$26=0A=
+#define r27		$27=0A=
+#define r28		$28=0A=
+#define r29		$29=0A=
+#define r30		$30=0A=
+#define r31		$31=0A=
+=0A=
+#define zero	$0		/* wired zero */=0A=
+#define AT		$at		/* assembler temp */=0A=
+#define v0		$2		/* return value */=0A=
+#define v1		$3=0A=
+#define a0		$4		/* argument registers a0-a3 */=0A=
+#define a1		$5=0A=
+#define a2		$6=0A=
+#define a3		$7=0A=
+#define t0		$8		/* caller saved  t0-t9 */=0A=
+#define t1		$9=0A=
+#define t2		$10=0A=
+#define t3		$11=0A=
+#define t4		$12=0A=
+#define t5		$13=0A=
+#define t6		$14=0A=
+#define t7		$15=0A=
+#define s0		$16		/* callee saved s0-s8 */=0A=
+#define s1		$17=0A=
+#define s2		$18=0A=
+#define s3		$19=0A=
+#define s4		$20=0A=
+#define s5		$21=0A=
+#define s6		$22=0A=
+#define s7		$23=0A=
+#define t8		$24=0A=
+#define t9		$25=0A=
+#define k0		$26		/* kernel usage */=0A=
+#define k1		$27		/* kernel usage */=0A=
+#define gp		$28		/* sdata pointer */=0A=
+#define sp		$29		/* stack pointer */=0A=
+#define s8		$30		/* yet another saved reg for the callee */=0A=
+#define fp		$30		/* frame pointer - this is being phased out by MIPS =
*/=0A=
+#define ra		$31		/* return address */=0A=
+=0A=
+/*=0A=
+** relative position of registers in save reg area=0A=
+*/=0A=
+#define	R_R0		0=0A=
+#define	R_R1		1=0A=
+#define	R_R2		2=0A=
+#define	R_R3		3=0A=
+#define	R_R4		4=0A=
+#define	R_R5		5=0A=
+#define	R_R6		6=0A=
+#define	R_R7		7=0A=
+#define	R_R8		8=0A=
+#define	R_R9		9=0A=
+#define	R_R10		10=0A=
+#define	R_R11		11=0A=
+#define	R_R12		12=0A=
+#define	R_R13		13=0A=
+#define	R_R14		14=0A=
+#define	R_R15		15=0A=
+#define	R_R16		16=0A=
+#define	R_R17		17=0A=
+#define	R_R18		18=0A=
+#define	R_R19		19=0A=
+#define	R_R20		20=0A=
+#define	R_R21		21=0A=
+#define	R_R22		22=0A=
+#define	R_R23		23=0A=
+#define	R_R24		24=0A=
+#define	R_R25		25=0A=
+#define	R_R26		26=0A=
+#define	R_R27		27=0A=
+#define	R_R28		28=0A=
+#define	R_R29		29=0A=
+#define	R_R30		30=0A=
+#define	R_R31		31=0A=
+#define NCLIENTREGS	32=0A=
+#define	R_EPC				32=0A=
+#define	R_MDHI			33=0A=
+#define	R_MDLO		  34=0A=
+#define	R_SR				35=0A=
+#define	R_CAUSE			36=0A=
+#define	R_TLBHI			37=0A=
+#define	R_TLBLO0		38=0A=
+#define	R_BADVADDR	39=0A=
+#define	R_INX				40=0A=
+#define	R_RAND			41=0A=
+#define	R_CTXT			42=0A=
+#define	R_EXCTYPE		43=0A=
+#define R_MODE			44=0A=
+#define R_PRID			45=0A=
+#define R_TLBLO1		46=0A=
+#define R_PAGEMASK	47=0A=
+#define R_WIRED			48=0A=
+#define R_COUNT			49=0A=
+#define R_COMPARE		50=0A=
+#define R_CONFIG		51=0A=
+#if defined(CPU_R32434)=0A=
+#define R_WATCHLO   52=0A=
+#define R_WATCHHI   53=0A=
+#elif defined(CPU_R32364)=0A=
+#define R_IWATCH    52=0A=
+#define R_DWATCH    53=0A=
+#define R_ECC				54=0A=
+#define R_CACHEERR	55=0A=
+#endif=0A=
+#define R_TAGLO			56=0A=
+#define R_TAGHI			57=0A=
+#define R_ERRPC			58=0A=
+=0A=
+#define NREGS			  59=0A=
+=0A=
+#if __mips >=3D 3=0A=
+=0A=
+#define R_SZ		8=0A=
+#ifndef CLANGUAGE=0A=
+#define sreg		sd=0A=
+#define lreg		ld=0A=
+#define rmfc0		mfc0=0A=
+#define rmtc0		mtc0=0A=
+#endif=0A=
+=0A=
+#else=0A=
+=0A=
+#define R_SZ		4=0A=
+#ifndef CLANGUAGE=0A=
+#define sreg		sw=0A=
+#define lreg		lw=0A=
+#define rmfc0		mfc0=0A=
+#define rmtc0		mtc0=0A=
+#endif=0A=
+=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** For those who like to think in terms of the compiler names for the =
regs=0A=
+*/=0A=
+#define	R_ZERO	R_R0=0A=
+#define	R_AT		R_R1=0A=
+#define	R_V0		R_R2=0A=
+#define	R_V1		R_R3=0A=
+#define	R_A0		R_R4=0A=
+#define	R_A1		R_R5=0A=
+#define	R_A2		R_R6=0A=
+#define	R_A3		R_R7=0A=
+#define	R_T0		R_R8=0A=
+#define	R_T1		R_R9=0A=
+#define	R_T2		R_R10=0A=
+#define	R_T3		R_R11=0A=
+#define	R_T4		R_R12=0A=
+#define	R_T5		R_R13=0A=
+#define	R_T6		R_R14=0A=
+#define	R_T7		R_R15=0A=
+#define	R_S0		R_R16=0A=
+#define	R_S1		R_R17=0A=
+#define	R_S2		R_R18=0A=
+#define	R_S3		R_R19=0A=
+#define	R_S4		R_R20=0A=
+#define	R_S5		R_R21=0A=
+#define	R_S6		R_R22=0A=
+#define	R_S7		R_R23=0A=
+#define	R_T8		R_R24=0A=
+#define	R_T9		R_R25=0A=
+#define	R_K0		R_R26=0A=
+#define	R_K1		R_R27=0A=
+#define	R_GP		R_R28=0A=
+#define	R_SP		R_R29=0A=
+#define	R_FP		R_R30=0A=
+#define	R_RA		R_R31=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/Makefile =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/Makefile	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,134 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile create a compressed zImage or Rommable rImage=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+#######################################################################=
########=0A=
+# The following is taken from IDT/Sim Makefile=0A=
+#######################################################################=
######=0A=
+TARGET=3D434=0A=
+TARGETDIR=3DS434=0A=
+=0A=
+#=0A=
+# following refers to memory type in use in eval board and if more =
than one=0A=
+# then the order is implied.  These are values for the switch =
MEMCFG.=0A=
+#=0A=
+SRAM_ONLY=3D1=0A=
+SDRAM_ONLY=3D2=0A=
+SRAM_N_SDRAM=3D3=0A=
+SDRAM_N_SRAM=3D4=0A=
+=0A=
+# following refers to size of the DRAM space.=0A=
+# These are values for the switch DRAMSZ.=0A=
+=0A=
+MB32=3D1=0A=
+MB64=3D2=0A=
+MB128=3D3=0A=
+MB32SO=3D4=0A=
+=0A=
+MACH=3D -DEB434 -DS434 -DCPU_R32434 -DMIPSEL -DINET =
-DMEMCFG=3D$(SDRAM_ONLY) -DDRAMSZ=3D$(MB32) -DIDTSIM -DMHZ=3D$(MHZ) =
-DNVRAM_RTC -DUSE_SPI=0A=
+COMMSWITCHES =3D $(MACH)=0A=
+#***************** END IDT/Sim Makefile =
##################################### =0A=
+ZDEBUG=3D1=0A=
+export ZDEBUG=0A=
+=0A=
+# working space for gunzip:=0A=
+FREE_RAM      :=3D 0x80C00000=0A=
+END_RAM       :=3D 0x80E00000=0A=
+=0A=
+KERNELCONFIG  :=3D $(TOPDIR)/.config=0A=
+include $(KERNELCONFIG)=0A=
+=0A=
+SIZE =3D $(CROSS_COMPILE)size=0A=
+=0A=
+O_FORMAT =3D $(shell $(OBJDUMP) -i | head -2 | grep elf32)=0A=
+=0A=
+SYSTEM	      :=3D $(TOPDIR)/vmlinux=0A=
+ZBSS          :=3D 0x800A0000=0A=
+=0A=
+ZIMSTART      :=3D $(CONFIG_IDT_ZIMAGE_ADDR)=0A=
+RIMSTART      :=3D 0x9FC00000=0A=
+=0A=
+LOADADDR      :=3D 0x$(shell $(NM) $(SYSTEM) | grep "A _text" |cut -f1 =
-d' ')=0A=
+KERNEL_ENTRY  :=3D $(shell $(OBJDUMP) -f $(SYSTEM) | sed -n -e =
's/^start address //p')=0A=
+=0A=
+#######################################################################=
#############=0A=
+ZIMFLAGS        =3D s/IMSTART/$(ZIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+RIMFLAGS        =3D s/IMSTART/$(RIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+CFLAGS	:=3D -fno-pic -nostdinc -G 0 -mno-abicalls -fno-pic -pipe =
-I$(TOPDIR)/include=0A=
+AFLAGS	:=3D -D__ASSEMBLY__ $(CFLAGS)=0A=
+=0A=
+#######################################################################=
#############=0A=
+OBJECTS=3D $(obj)/piggy.o $(obj)/head.o $(obj)/misc.o=0A=
+ifneq ($(ZDEBUG),0)=0A=
+OBJECTS +=3D $(obj)/uart16550.o=0A=
+endif=0A=
+=0A=
+$(obj)/zImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(ZIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/rImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(RIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/piggy.o: $(SYSTEM) $(obj)/Makefile=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(SYSTEM) =
$(SYSTEM).bin=0A=
+	gzip -f -9 < $(SYSTEM).bin > $(SYSTEM).gz=0A=
+	echo "O_FORMAT:  " $(O_FORMAT); =0A=
+	$(LD) -r -b binary --oformat $(O_FORMAT) -o $(obj)/piggy.o =
$(SYSTEM).gz=0A=
+	rm -f $(SYSTEM).bin $(SYSTEM).gz=0A=
+=0A=
+$(obj)/head.o: $(obj)/head.S $(SYSTEM) $(obj)/Makefile=0A=
+	$(CC) $(AFLAGS) -DKERNEL_ENTRY=3D$(KERNEL_ENTRY) -c $(obj)/head.S -o =
$(obj)/head.o=0A=
+=0A=
+$(obj)/misc.o: $(obj)/misc.c $(obj)/Makefile=0A=
+	$(CC) $(CFLAGS) -DLOADADDR=3D$(LOADADDR) -DFREE_RAM=3D$(FREE_RAM) =
-DEND_RAM=3D$(END_RAM) \=0A=
+		-c $< -DZDEBUG=3D$(ZDEBUG) -o $(obj)/misc.o=0A=
+=0A=
+$(obj)/uart16550.o: $(obj)/uart16550.c $(KERNELCONFIG)=0A=
+	$(CC) $(CFLAGS) -c $< -o $(obj)/uart16550.o=0A=
+=0A=
+$(obj)/csu_idt.o: $(obj)/csu_idt.S Makefile $(SYSTEM)=0A=
+	$(CC) $(AFLAGS) $(COMMSWITCHES) -c $< -o $(obj)/csu_idt.o=0A=
+=0A=
+zImage: $(obj)/zImage.lds $(SYSTEM) $(OBJECTS)=0A=
+	$(LD) -T$(obj)/zImage.lds -o $(TOPDIR)/zImage $(OBJECTS)=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/zImage =
$(TOPDIR)/zImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/zImage.bin $(TOPDIR)/zImage.prm=0A=
+	$(SIZE) $(TOPDIR)/zImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/zImage.size=0A=
+	rm -f *.o=0A=
+=0A=
+rImage: $(obj)/rImage.lds $(SYSTEM) $(OBJECTS) $(obj)/csu_idt.o=0A=
+	@rm -f $(TOPDIR)/*.prm=0A=
+	$(LD) -T$(obj)/rImage.lds -o $(TOPDIR)/rImage $(obj)/csu_idt.o =
$(OBJECTS) =0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/rImage =
$(TOPDIR)/rImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/rImage.bin $(TOPDIR)/rImage.prm=0A=
+	$(SIZE) $(TOPDIR)/rImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/rImage.size=0A=
+	rm -f *.o=0A=
+clean:=0A=
+	rm -f *.o $(TOPDIR)/zImage* $(TOPDIR)/rImage* $(TOPDIR)/*.prm =
$(TOPDIR)/rImage.size $(TOPDIR)/zImage.size=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/misc.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/misc.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/misc.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/misc.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,339 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Code to un-compress linux image=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/types.h>=0A=
+=0A=
+/*=0A=
+ * gzip declarations=0A=
+ */=0A=
+#define OF(args)  args=0A=
+#define STATIC static=0A=
+#define memzero(s, n)     memset ((s), 0, (n))=0A=
+typedef unsigned char uch;=0A=
+typedef unsigned short ush;=0A=
+typedef unsigned long ulg;=0A=
+#define WSIZE 0x8000		/* Window size must be at least 32k, */=0A=
+				/* and a power of two */=0A=
+static uch *inbuf;		/* input buffer */=0A=
+static uch window[WSIZE];	/* Sliding window buffer */=0A=
+=0A=
+/* gzip flag byte */=0A=
+#define ASCII_FLAG   0x01	/* bit 0 set: file probably ASCII text */=0A=
+#define CONTINUATION 0x02	/* bit 1 set: continuation of multi-part =
gzip file */=0A=
+#define EXTRA_FIELD  0x04	/* bit 2 set: extra field present */=0A=
+#define ORIG_NAME    0x08	/* bit 3 set: original file name present =
*/=0A=
+#define COMMENT      0x10	/* bit 4 set: file comment present */=0A=
+#define ENCRYPTED    0x20	/* bit 5 set: file is encrypted */=0A=
+#define RESERVED     0xC0	/* bit 6,7:   reserved */=0A=
+=0A=
+=0A=
+static unsigned insize;	/* valid bytes in inbuf */=0A=
+static unsigned inptr;	/* index of next byte to be processed in inbuf =
*/=0A=
+static unsigned outcnt;	/* bytes in output buffer */=0A=
+=0A=
+void variable_init(void);=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *);=0A=
+extern void putc_init(void);=0A=
+extern void putc(unsigned char c);=0A=
+#endif=0A=
+static int fill_inbuf(void);=0A=
+static void flush_window(void);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+extern char input_data[];=0A=
+=0A=
+extern char input_data_end[];=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void int2hex(unsigned long val)=0A=
+{=0A=
+        unsigned char buf[10];=0A=
+        int i;=0A=
+        for (i =3D 7;  i >=3D 0;  i--) {=0A=
+                buf[i] =3D "0123456789ABCDEF"[val & 0x0F];=0A=
+                val >>=3D 4;=0A=
+        }=0A=
+        buf[8] =3D '\0';=0A=
+        puts(buf);=0A=
+}=0A=
+#endif=0A=
+=0A=
+static unsigned long byte_count;=0A=
+=0A=
+int get_byte(void)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	static int printCnt;=0A=
+#endif=0A=
+	unsigned char c =3D (inptr < insize ? inbuf[inptr++] : =
fill_inbuf());=0A=
+	byte_count++;=0A=
+	=0A=
+#if ZDEBUG > 1=0A=
+	if (printCnt++ < 32) {=0A=
+		puts("byte count =3D ");=0A=
+		int2hex(byte_count);=0A=
+		puts(" byte val =3D ");=0A=
+		int2hex(c);=0A=
+		puts("\n");=0A=
+	}=0A=
+#endif=0A=
+	return c;=0A=
+}=0A=
+=0A=
+/* Diagnostic functions */=0A=
+#ifdef DEBUG=0A=
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}=0A=
+#  define Trace(x) fprintf x=0A=
+#  define Tracev(x) {if (verbose) fprintf x ;}=0A=
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}=0A=
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}=0A=
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}=0A=
+#else=0A=
+#  define Assert(cond,msg)=0A=
+#  define Trace(x)=0A=
+#  define Tracev(x)=0A=
+#  define Tracevv(x)=0A=
+#  define Tracec(c,x)=0A=
+#  define Tracecv(c,x)=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * This is set up by the setup-routine at boot-time=0A=
+ */=0A=
+=0A=
+static long bytes_out;=0A=
+static uch *output_data;=0A=
+static unsigned long output_ptr;=0A=
+=0A=
+=0A=
+static void *malloc(int size);=0A=
+static void free(void *where);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+static unsigned long free_mem_ptr;=0A=
+static unsigned long free_mem_end_ptr;=0A=
+=0A=
+#include "../../../../../../lib/inflate.c"=0A=
+=0A=
+static void *malloc(int size)=0A=
+{=0A=
+	void *p;=0A=
+	=0A=
+	if (size < 0)=0A=
+		error("Malloc error\n");=0A=
+	if (free_mem_ptr <=3D 0) error("Memory error\n");=0A=
+	=0A=
+	free_mem_ptr =3D (free_mem_ptr + 3) & ~3;	/* Align */=0A=
+	=0A=
+	p =3D (void *) free_mem_ptr;=0A=
+	free_mem_ptr +=3D size;=0A=
+	=0A=
+	if (free_mem_ptr >=3D free_mem_end_ptr)=0A=
+		error("\nOut of memory\n");=0A=
+	=0A=
+	return p;=0A=
+}=0A=
+=0A=
+static void free(void *where)=0A=
+{				/* Don't care */=0A=
+}=0A=
+=0A=
+static void gzip_mark(void **ptr)=0A=
+{=0A=
+	*ptr =3D (void *) free_mem_ptr;=0A=
+}=0A=
+=0A=
+static void gzip_release(void **ptr)=0A=
+{=0A=
+	free_mem_ptr =3D (long) *ptr;=0A=
+}=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *s)=0A=
+{=0A=
+	while (*s) {=0A=
+		if (*s =3D=3D 10)=0A=
+			putc(13);=0A=
+		putc(*s++);=0A=
+	}=0A=
+}=0A=
+#endif=0A=
+=0A=
+void *memset(void *s, int c, size_t n)=0A=
+{=0A=
+	int i;=0A=
+	char *ss =3D (char *) s;=0A=
+	=0A=
+	for (i =3D 0; i < n; i++)=0A=
+		ss[i] =3D c;=0A=
+	return s;=0A=
+}=0A=
+=0A=
+void *memcpy(void *__dest, __const void *__src, size_t __n)=0A=
+{=0A=
+	int i;=0A=
+	char *d =3D (char *) __dest, *s =3D (char *) __src;=0A=
+	=0A=
+	for (i =3D 0; i < __n; i++)=0A=
+		d[i] =3D s[i];=0A=
+	return __dest;=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Fill the input buffer. This is called only when the buffer is =
empty=0A=
+ * and at least one byte is really needed.=0A=
+ */=0A=
+static int fill_inbuf(void)=0A=
+{=0A=
+	if (insize !=3D 0) {=0A=
+		error("ran out of input data\n");=0A=
+	}=0A=
+	=0A=
+	inbuf =3D input_data;=0A=
+	insize =3D &input_data_end[0] - &input_data[0];=0A=
+	inptr =3D 1;=0A=
+	return inbuf[0];=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Write the output window window[0..outcnt-1] and update crc and =
bytes_out.=0A=
+ * (Used for the decompressed data only.)=0A=
+ */=0A=
+static void flush_window(void)=0A=
+{=0A=
+	ulg c =3D crc;		/* temporary variable */=0A=
+	unsigned n;=0A=
+	uch *in, *out, ch;=0A=
+	=0A=
+	in =3D window;=0A=
+	out =3D &output_data[output_ptr];=0A=
+	for (n =3D 0; n < outcnt; n++) {=0A=
+		ch =3D *out++ =3D *in++;=0A=
+		c =3D crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);=0A=
+	}=0A=
+	crc =3D c;=0A=
+	bytes_out +=3D (ulg) outcnt;=0A=
+	output_ptr +=3D (ulg) outcnt;=0A=
+	outcnt =3D 0;=0A=
+}=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void check_mem(void)=0A=
+{=0A=
+	int i;=0A=
+	=0A=
+	puts("\ncplens =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplens[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\ncplext =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplext[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\nborder =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(border[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\n");=0A=
+}=0A=
+#endif=0A=
+=0A=
+static void error(char *x)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	check_mem();=0A=
+	puts("\n\n");=0A=
+	puts(x);=0A=
+	puts("byte_count =3D ");=0A=
+	int2hex(byte_count);=0A=
+	puts("\n");=0A=
+	puts("\n\n -- Error. System halted");=0A=
+#endif=0A=
+	while (1);		/* Halt */=0A=
+}=0A=
+=0A=
+void variable_init(void)=0A=
+{=0A=
+	byte_count =3D 0;=0A=
+	output_data =3D (char *) LOADADDR;=0A=
+	free_mem_ptr =3D FREE_RAM;=0A=
+	free_mem_end_ptr =3D END_RAM;=0A=
+#if ZDEBUG > 1=0A=
+	puts("output_data      0x");=0A=
+	int2hex((unsigned long)output_data); puts("\n");=0A=
+	puts("free_mem_ptr     0x");=0A=
+	int2hex(free_mem_ptr); puts("\n");=0A=
+	puts("free_mem_end_ptr 0x");=0A=
+	int2hex(free_mem_end_ptr); puts("\n");=0A=
+	puts("input_data       0x");=0A=
+	int2hex((unsigned long)input_data); puts("\n");=0A=
+#endif=0A=
+}=0A=
+=0A=
+int decompress_kernel(void)=0A=
+{=0A=
+#if ZDEBUG > 0=0A=
+	putc_init();=0A=
+#if ZDEBUG > 2=0A=
+	check_mem();=0A=
+#endif=0A=
+#endif=0A=
+	=0A=
+	variable_init();=0A=
+	=0A=
+	makecrc();=0A=
+#if ZDEBUG > 0=0A=
+	puts("\n");=0A=
+	puts("Uncompressing Linux... \n");=0A=
+#endif=0A=
+	gunzip();		// ...see inflate.c=0A=
+#if ZDEBUG > 0=0A=
+	puts("Ok, booting the kernel.\n");=0A=
+#endif=0A=
+	=0A=
+#if ZDEBUG > 1=0A=
+	{=0A=
+		unsigned long *p =3D (unsigned long *)LOADADDR;=0A=
+		int2hex(p[0]); puts("\n");=0A=
+		int2hex(p[1]); puts("\n");=0A=
+		int2hex(p[2]); puts("\n");=0A=
+		int2hex(p[3]); puts("\n");=0A=
+	}=0A=
+#endif=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/rImage.lds =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/rImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/rImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/rImage.lds	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x9FC00000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32434/EB434/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/s434.h =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/s434.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/s434.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/s434.h	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,137 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Some useful macros.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S434__=0A=
+#define __S434__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+=0A=
+/*=0A=
+** following defines simple and uniform to save and restore context=0A=
+** when enrtering and leaving as assemblu language program when =
memory=0A=
+** and registers are both premiunm.=0A=
+*/=0A=
+#define SAVE_CNTXT  \=0A=
+  subu  sp, 64;     \=0A=
+  sw    t0, 60(sp); \=0A=
+  sw    t1, 56(sp); \=0A=
+  sw    t2, 52(sp); \=0A=
+  sw    t3, 48(sp); \=0A=
+  sw    t4, 44(sp); \=0A=
+  sw    t5, 40(sp); \=0A=
+  sw    t6, 36(sp); \=0A=
+  sw    t7, 32(sp); \=0A=
+  sw    t8, 28(sp); \=0A=
+  sw    t9, 24(sp); \=0A=
+  sw    a0, 20(sp); \=0A=
+  sw    a1, 16(sp); \=0A=
+  sw    a2, 12(sp); \=0A=
+  sw    a3,  8(sp); \=0A=
+  sw    ra,  4(sp)=0A=
+=0A=
+#define RSTR_CNTXT  \=0A=
+  lw    t0, 60(sp); \=0A=
+  lw    t1, 56(sp); \=0A=
+  lw    t2, 52(sp); \=0A=
+  lw    t3, 48(sp); \=0A=
+  lw    t4, 44(sp); \=0A=
+  lw    t5, 40(sp); \=0A=
+  lw    t6, 36(sp); \=0A=
+  lw    t7, 32(sp); \=0A=
+  lw    t8, 28(sp); \=0A=
+  lw    t9, 24(sp); \=0A=
+  lw    a0, 20(sp); \=0A=
+  lw    a1, 16(sp); \=0A=
+  lw    a2, 12(sp); \=0A=
+  lw    a3,  8(sp); \=0A=
+  lw    ra,  4(sp); \=0A=
+  add   sp, 64=0A=
+=0A=
+/*=0A=
+** Following define is to specify a maximum value for a software=0A=
+** busy wait counter.=0A=
+*/=0A=
+/*=0A=
+#define LP_CNT_100NS  1000      =0A=
+#define LP_CNT_3S     1000000   =0A=
+*/=0A=
+=0A=
+/*=0A=
+** Following are other common timer definitions.=0A=
+*/=0A=
+#define DDR_BASE           PHYS_TO_K1(0x18018000)=0A=
+#define TIMER_BASE        PHYS_TO_K1(0x18028000)  =0A=
+#define WTC_BASE          PHYS_TO_K1(0x18030000)=0A=
+#define INTERRUPT_BASE    PHYS_TO_K1(0x18038000)=0A=
+#define GPIO_BASE         PHYS_TO_K1(0x18050000)=0A=
+=0A=
+#define TIMEOUT_COUNT     0x00000FFF=0A=
+#define ENABLE_TIMER      0x1=0A=
+#define DISABLE_TIMER     0x0=0A=
+#define BIG_VALUE         0xFFFFFFFF=0A=
+=0A=
+/*=0A=
+** following few lines define a macro DISPLAY=0A=
+** which is used to write a set of 4 characters=0A=
+** onto the EB434/435 LED.=0A=
+*/=0A=
+=0A=
+#ifndef LED_BASE=0A=
+=0A=
+#define LED_BASE    PHYS_TO_K1(0x19000000)=0A=
+#define LED_DIGIT0  0x7=0A=
+#define LED_DIGIT1  0x6=0A=
+#define LED_DIGIT2  0x5=0A=
+#define LED_DIGIT3  0x4=0A=
+#define LED_CLEAR   0x0=0A=
+=0A=
+#endif=0A=
+=0A=
+#define DISPLAY(d0, d1, d2, d3)     \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        lb    t7, LED_CLEAR(t6)               ;\=0A=
+              nop                             ;\=0A=
+        li    t7, (d0) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT0(t6)              ;\=0A=
+        li    t7, (d1) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT1(t6)              ;\=0A=
+        li    t7, (d2) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT2(t6)              ;\=0A=
+        li    t7, (d3) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT3(t6)=0A=
+=0A=
+#define LEDCLEAR()              \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        lb    t7, LED_CLEAR(t6)               ;\=0A=
+              nop=0A=
+=0A=
+#define DESTRUCTIVE     1=0A=
+#define NONDESTRUCTIVE  0=0A=
+=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/s434ram.h =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/s434ram.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/s434ram.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/s434ram.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,161 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT EB434/435 DDR setup values.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#ifndef __S434RAM__=0A=
+#define __S434RAM__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+=0A=
+#define MB32      1=0A=
+#define MB64      2=0A=
+#define MB128     3=0A=
+=0A=
+#define DEV_CTL_BASE        PHYS_TO_K1(0x18010000)  /* device =
controller regs */=0A=
+#define DDR_CTL_BASE        PHYS_TO_K1(0x18018010)  /* DDR controller =
regs */=0A=
+=0A=
+#define DEV0_BASE           0x1FC00000=0A=
+#define DEV0_MASK           0xFFC00000=0A=
+#define DEV1_BASE           0x1A000000=0A=
+#define DEV1_MASK           0xFE000000=0A=
+#define DEV2_BASE           0x19000000=0A=
+#define DEV2_MASK           0xFF000000=0A=
+#define DEV3_BASE           0x00000000=0A=
+#define DEV3_MASK           0x00000000=0A=
+=0A=
+#if MHZ =3D=3D 100000000=0A=
+#define DEV0_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV0_TC             0x00000000=0A=
+#define DEV1_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV1_TC             0x00000000=0A=
+#define DEV2_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV2_TC             0x00000000=0A=
+#define DEV3_CTRL           0x0FFFFFF4              /* 8-bit devices =
*/=0A=
+#define DEV3_TC             0x00001FFF=0A=
+=0A=
+#elif MHZ =3D=3D 133000000=0A=
+#define DEV0_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV0_TC             0x00000000=0A=
+#define DEV1_CTRL           0x05208324              /* 8-bit devices =
*/=0A=
+#define DEV1_TC             0x00000000=0A=
+#define DEV2_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV2_TC             0x00000000=0A=
+#define DEV3_CTRL           0x0FFFFFF4              /* 8-bit devices =
*/=0A=
+#define DEV3_TC             0x00001FFF=0A=
+=0A=
+#elif MHZ =3D=3D 150000000=0A=
+#define DEV0_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV0_TC             0x00000000=0A=
+#define DEV1_CTRL           0x05208324              /* 8-bit devices =
*/=0A=
+#define DEV1_TC             0x00000000=0A=
+#define DEV2_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV2_TC             0x00000000=0A=
+#define DEV3_CTRL           0x0FFFFFF4              /* 8-bit devices =
*/=0A=
+#define DEV3_TC             0x00001FFF=0A=
+=0A=
+=0A=
+#elif MHZ =3D=3D 175000000=0A=
+#define DEV0_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV0_TC             0x00000000=0A=
+#define DEV1_CTRL           0x05208324              /* 8-bit devices =
*/=0A=
+#define DEV1_TC             0x00000000=0A=
+#define DEV2_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV2_TC             0x00000000=0A=
+#define DEV3_CTRL           0x0FFFFFF4              /* 8-bit devices =
*/=0A=
+#define DEV3_TC             0x00001FFF=0A=
+=0A=
+#elif MHZ =3D=3D 200000000=0A=
+#define DEV0_CTRL           0x05208324              /* 8-bit devices =
*/=0A=
+#define DEV0_TC             0x00000000=0A=
+#define DEV1_CTRL           0x06308324              /* 8-bit devices =
*/=0A=
+#define DEV1_TC             0x00000000=0A=
+#define DEV2_CTRL           0x05208324              /* 8-bit devices =
*/=0A=
+#define DEV2_TC             0x00000000=0A=
+#define DEV3_CTRL           0x0FFFFFF4              /* 8-bit devices =
*/=0A=
+#define DEV3_TC             0x00001FFF=0A=
+#endif=0A=
+=0A=
+#define DATA_PATTERN        0xA5A5A5A5=0A=
+#define RCOUNT              PHYS_TO_K1(0x18028030)=0A=
+=0A=
+#if DRAMSZ =3D=3D MB32=0A=
+=0A=
+#define DDR_BASE_VAL          0x00000000=0A=
+#define DDR_MASK_VAL          0xFE000000=0A=
+#define DDR_ABASE_VAL         0x08000000=0A=
+#define DDR_AMASK_VAL         0x00000000=0A=
+=0A=
+#if MHZ =3D=3D 100000000=0A=
+#define DDRC_VAL_NORMAL       0x82184800=0A=
+#define DDRC_VAL_AT_INIT      0x02184800=0A=
+#define DDR_REF_CMP_VAL       0x0000030c=0A=
+#elif MHZ =3D=3D 133000000=0A=
+#define DDRC_VAL_NORMAL       0x82984800=0A=
+#define DDRC_VAL_AT_INIT      0x02984800=0A=
+#define DDR_REF_CMP_VAL       0x0000040e=0A=
+#elif MHZ =3D=3D 150000000=0A=
+#define DDRC_VAL_NORMAL       0x82984800=0A=
+#define DDRC_VAL_AT_INIT      0x02984800=0A=
+#define DDR_REF_CMP_VAL       0x00000492=0A=
+#elif MHZ =3D=3D 175000000=0A=
+#define DDRC_VAL_NORMAL       0x82994800=0A=
+#define DDRC_VAL_AT_INIT      0x02994800=0A=
+#define DDR_REF_CMP_VAL       0x00000516=0A=
+#elif MHZ =3D=3D 200000000=0A=
+#define DDRC_VAL_NORMAL       0x82994800=0A=
+#define DDRC_VAL_AT_INIT      0x02994800=0A=
+#define DDR_REF_CMP_VAL       0x00000618=0A=
+#else=0A=
+#warning illegal value for MHZ=0A=
+#endif=0A=
+=0A=
+#define DDR_REF_CMP_FAST      0x00000080=0A=
+=0A=
+#define DDR_CUST_NOP          0x0000003F=0A=
+#define DDR_CUST_PRECHARGE    0x00000033=0A=
+#define DDR_CUST_REFRESH      0x00000027=0A=
+#define DDR_LD_MODE_REG       0x00000023=0A=
+#define DDR_LD_EMODE_REG      0x00000063=0A=
+=0A=
+/* =0A=
+ * All generated addresses for DDR init during custom transactions are =
shifted=0A=
+ * by two address lines - see spec for used DDR chip=0A=
+ */=0A=
+#define DDR_PRECHARGE_OFFSET  0x00001000  /* 0x0400 - 9-bit page*/=0A=
+#define DDR_EMODE_VAL         0x00000000  /* 0x0000 */=0A=
+#define DDR_DLL_RES_MODE_VAL  0x00000584  /* 0x0161 - Reset DLL, CL2.5 =
*/=0A=
+#define DDR_DLL_MODE_VAL      0x00000184  /* 0x0061 - CL2.5 */=0A=
+=0A=
+#define DELAY_200USEC         25000       /* not exactly */=0A=
+=0A=
+#else=0A=
+#error "unrecognized dram size"=0A=
+#endif=0A=
+=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/uart16550.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/uart16550.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/uart16550.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/uart16550.c	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,154 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   UART code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#define RC32434_REG_BASE   0xb8000000=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58003)=0A=
+#else=0A=
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58000)=0A=
+#endif=0A=
+=0A=
+#define BASE		        RC32434_UART0_BASE=0A=
+#define MAX_BAUD		(CONFIG_IDT_BOARD_FREQ / 16)=0A=
+#define REG_OFFSET		0x4=0A=
+=0A=
+=0A=
+#if (!defined(BASE) || !defined(MAX_BAUD) || !defined(REG_OFFSET))=0A=
+#error You must define BASE, MAX_BAUD and REG_OFFSET in the =
Makefile.=0A=
+#endif=0A=
+=0A=
+#ifndef INIT_SERIAL_PORT=0A=
+#define INIT_SERIAL_PORT	1=0A=
+#endif=0A=
+=0A=
+#ifndef DEFAULT_BAUD=0A=
+//#define DEFAULT_BAUD		UART16550_BAUD_115200=0A=
+#define DEFAULT_BAUD		UART16550_BAUD_9600=0A=
+#endif=0A=
+#ifndef DEFAULT_PARITY=0A=
+#define DEFAULT_PARITY		UART16550_PARITY_NONE=0A=
+#endif=0A=
+#ifndef DEFAULT_DATA=0A=
+#define DEFAULT_DATA		UART16550_DATA_8BIT=0A=
+#endif=0A=
+#ifndef DEFAULT_STOP=0A=
+#define DEFAULT_STOP		UART16550_STOP_1BIT=0A=
+#endif=0A=
+=0A=
+/* =3D=3D=3D END OF CONFIG =3D=3D=3D */=0A=
+=0A=
+typedef         unsigned char uint8;=0A=
+typedef         unsigned int  uint32;=0A=
+=0A=
+#define         UART16550_BAUD_2400             2400=0A=
+#define         UART16550_BAUD_4800             4800=0A=
+#define         UART16550_BAUD_9600             9600=0A=
+#define         UART16550_BAUD_19200            19200=0A=
+#define         UART16550_BAUD_38400            38400=0A=
+#define         UART16550_BAUD_57600            57600=0A=
+#define         UART16550_BAUD_115200           115200=0A=
+=0A=
+#define         UART16550_PARITY_NONE           0=0A=
+#define         UART16550_PARITY_ODD            0x08=0A=
+#define         UART16550_PARITY_EVEN           0x18=0A=
+#define         UART16550_PARITY_MARK           0x28=0A=
+#define         UART16550_PARITY_SPACE          0x38=0A=
+=0A=
+#define         UART16550_DATA_5BIT             0x0=0A=
+#define         UART16550_DATA_6BIT             0x1=0A=
+#define         UART16550_DATA_7BIT             0x2=0A=
+#define         UART16550_DATA_8BIT             0x3=0A=
+=0A=
+#define         UART16550_STOP_1BIT             0x0=0A=
+#define         UART16550_STOP_2BIT             0x4=0A=
+=0A=
+/* register offset */=0A=
+#define		OFS_RCV_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_TRANS_HOLD		(0*REG_OFFSET)=0A=
+#define		OFS_SEND_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_INTR_ENABLE		(1*REG_OFFSET)=0A=
+#define		OFS_INTR_ID		(2*REG_OFFSET)=0A=
+#define		OFS_DATA_FORMAT		(3*REG_OFFSET)=0A=
+#define		OFS_LINE_CONTROL	(3*REG_OFFSET)=0A=
+#define		OFS_MODEM_CONTROL	(4*REG_OFFSET)=0A=
+#define		OFS_RS232_OUTPUT	(4*REG_OFFSET)=0A=
+#define		OFS_LINE_STATUS		(5*REG_OFFSET)=0A=
+#define		OFS_MODEM_STATUS	(6*REG_OFFSET)=0A=
+#define		OFS_RS232_INPUT		(6*REG_OFFSET)=0A=
+#define		OFS_SCRATCH_PAD		(7*REG_OFFSET)=0A=
+=0A=
+#define		OFS_DIVISOR_LSB		(0*REG_OFFSET)=0A=
+#define		OFS_DIVISOR_MSB		(1*REG_OFFSET)=0A=
+=0A=
+#define		UART16550_READ(y)    (*((volatile uint8*)(BASE + y)))=0A=
+#define		UART16550_WRITE(y, z)  ((*((volatile uint8*)(BASE + y))) =3D =
z)=0A=
+=0A=
+static void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 =
stop)=0A=
+{=0A=
+	/* disable interrupts */=0A=
+	UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	UART16550_WRITE(OFS_INTR_ENABLE, 0);=0A=
+	=0A=
+	/* set up baud rate */=0A=
+	{=0A=
+		uint32 divisor;=0A=
+		=0A=
+		/* set DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x80);=0A=
+		=0A=
+		/* set divisor */=0A=
+		divisor =3D MAX_BAUD / baud;=0A=
+		UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);=0A=
+		UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);=0A=
+		=0A=
+		/* clear DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	}=0A=
+	=0A=
+	/* set data format */=0A=
+	UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);=0A=
+}=0A=
+=0A=
+=0A=
+void=0A=
+putc_init(void)=0A=
+{=0A=
+#if INIT_SERIAL_PORT=0A=
+	Uart16550Init(DEFAULT_BAUD, DEFAULT_DATA, DEFAULT_PARITY, =
DEFAULT_STOP);=0A=
+#endif=0A=
+}=0A=
+=0A=
+void=0A=
+putc(unsigned char c)=0A=
+{=0A=
+	while ((UART16550_READ(OFS_LINE_STATUS) &0x20) =3D=3D 0);=0A=
+	UART16550_WRITE(OFS_SEND_BUFFER, c);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/zImage.lds =
idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/zImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/boot/zImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/boot/zImage.lds	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x9b000000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32434/EB434/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/idtIRQ.S =
idtlinux/arch/mips/idt-boards/rc32434/EB434/idtIRQ.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/idtIRQ.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/idtIRQ.S	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,79 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Intterrupt dispatcher code for IDT boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+		=0A=
+	=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/regdef.h>=0A=
+#include <asm/stackframe.h>=0A=
+=0A=
+	.text=0A=
+	.set	noreorder=0A=
+	.set	noat=0A=
+	.align	5=0A=
+	NESTED(idtIRQ, PT_SIZE, sp)=0A=
+	.set noat=0A=
+	SAVE_ALL=0A=
+	CLI=0A=
+=0A=
+	.set	at=0A=
+	.set	noreorder=0A=
+=0A=
+	/* Get the pending interrupts */=0A=
+	mfc0    t0, CP0_CAUSE=0A=
+	nop=0A=
+			 =0A=
+	/* Isolate the allowed ones by anding the irq mask */=0A=
+	mfc0    t2, CP0_STATUS=0A=
+	move	a1, sp		/* need a nop here, hence we anticipate */=0A=
+	andi    t0, CAUSEF_IP=0A=
+	and     t0, t2=0A=
+								  =0A=
+	/* check for r4k counter/timer IRQ. */=0A=
+	=0A=
+	andi    t1, t0, CAUSEF_IP7=0A=
+	beqz    t1, 1f=0A=
+	nop=0A=
+=0A=
+	jal     idt_timer_interrupt	=0A=
+=0A=
+	li	a0, 7=0A=
+=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+1:=0A=
+	jal	rc32434_irqdispatch=0A=
+	move	a0, t0=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+=0A=
+	END(idtIRQ)=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/irq.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/irq.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/irq.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/irq.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,263 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Interrupt routines for IDT EB434/435 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/errno.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/signal.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/timex.h>=0A=
+#include <linux/slab.h>=0A=
+#include <linux/random.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434_gpio.h>=0A=
+=0A=
+#include <asm/irq.h>=0A=
+=0A=
+#undef DEBUG_IRQ=0A=
+#ifdef DEBUG_IRQ=0A=
+/* note: prints function name for you */=0A=
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## =
args)=0A=
+#else=0A=
+#define DPRINTK(fmt, args...)=0A=
+#endif=0A=
+=0A=
+extern asmlinkage void idtIRQ(void);=0A=
+static unsigned int startup_irq(unsigned int irq);=0A=
+static void end_irq(unsigned int irq_nr);=0A=
+static void mask_and_ack_irq(unsigned int irq_nr);=0A=
+static void rc32434_enable_irq(unsigned int irq_nr);=0A=
+static void rc32434_disable_irq(unsigned int irq_nr);=0A=
+=0A=
+extern void __init init_generic_irq(void);=0A=
+=0A=
+typedef struct {=0A=
+	u32 mask;=0A=
+	volatile u32 *base_addr;=0A=
+} intr_group_t;=0A=
+=0A=
+static const intr_group_t intr_group[NUM_INTR_GROUPS] =3D {=0A=
+	{ 0x0000efff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 0 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x00001fff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 1 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x00000007, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 2 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0x0003ffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 3 * IC_GROUP_OFFSET) =
},=0A=
+	{ 0xffffffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 4 * IC_GROUP_OFFSET) =
}=0A=
+};=0A=
+=0A=
+#define READ_PEND(base) (*(base))=0A=
+#define READ_MASK(base) (*(base + 2))=0A=
+#define WRITE_MASK(base, val) (*(base + 2) =3D (val))=0A=
+=0A=
+static inline int irq_to_group(unsigned int irq_nr)=0A=
+{=0A=
+	return ((irq_nr - GROUP0_IRQ_BASE) >> 5);=0A=
+}=0A=
+=0A=
+static inline int group_to_ip(unsigned int group)=0A=
+{=0A=
+	return group + 2;=0A=
+}=0A=
+=0A=
+static inline void enable_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	clear_c0_cause(ipnum);=0A=
+	set_c0_status(ipnum);=0A=
+}=0A=
+=0A=
+static inline void disable_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	clear_c0_status(ipnum);=0A=
+}=0A=
+=0A=
+static inline void ack_local_irq(unsigned int ip)=0A=
+{=0A=
+	int ipnum =3D 0x100 << ip;=0A=
+	clear_c0_cause(ipnum);=0A=
+}=0A=
+=0A=
+static void rc32434_enable_irq(unsigned int irq_nr)=0A=
+{=0A=
+	int           ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int  group, intr_bit;=0A=
+	volatile unsigned int  *addr;=0A=
+	if (ip < 0) {=0A=
+		enable_local_irq(irq_nr);=0A=
+	}=0A=
+	else {=0A=
+		// calculate group=0A=
+		group =3D ip >> 5;=0A=
+		=0A=
+		// calc interrupt bit within group=0A=
+		ip -=3D (group << 5);=0A=
+		intr_bit =3D 1 << ip;=0A=
+		=0A=
+		// first enable the IP mapped to this IRQ=0A=
+		enable_local_irq(group_to_ip(group));=0A=
+		=0A=
+		addr =3D intr_group[group].base_addr;=0A=
+		// unmask intr within group=0A=
+		WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);=0A=
+	}=0A=
+}=0A=
+=0A=
+static void rc32434_disable_irq(unsigned int irq_nr)=0A=
+{=0A=
+	int           ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int  group, intr_bit, mask;=0A=
+	volatile unsigned int  *addr;=0A=
+	=0A=
+	// calculate group=0A=
+	group =3D ip >> 5;=0A=
+	=0A=
+	// calc interrupt bit within group=0A=
+	ip -=3D group << 5;=0A=
+	intr_bit =3D 1 << ip;=0A=
+	=0A=
+	addr =3D intr_group[group].base_addr;=0A=
+	// mask intr within group=0A=
+	mask =3D READ_MASK(addr);=0A=
+	mask |=3D intr_bit;=0A=
+	WRITE_MASK(addr, mask);=0A=
+	=0A=
+	/*=0A=
+	  if there are no more interrupts enabled in this=0A=
+	  group, disable corresponding IP=0A=
+	*/=0A=
+	if (mask =3D=3D intr_group[group].mask)=0A=
+		disable_local_irq(group_to_ip(group));=0A=
+}=0A=
+=0A=
+static unsigned int startup_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32434_enable_irq(irq_nr);=0A=
+	return 0; =0A=
+}=0A=
+=0A=
+static void shutdown_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32434_disable_irq(irq_nr);=0A=
+	return;=0A=
+}=0A=
+=0A=
+static void mask_and_ack_irq(unsigned int irq_nr)=0A=
+{=0A=
+	rc32434_disable_irq(irq_nr);=0A=
+	ack_local_irq(group_to_ip(irq_to_group(irq_nr)));=0A=
+}=0A=
+=0A=
+static void end_irq(unsigned int irq_nr)=0A=
+{=0A=
+	=0A=
+	int ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+	unsigned int intr_bit, group;=0A=
+	volatile unsigned int *addr;=0A=
+	=0A=
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED | IRQ_INPROGRESS))) =
{=0A=
+		if (irq_nr =3D=3D GROUP4_IRQ_BASE + 11)=0A=
+			gpio->gpioistat =3D 0xfffff7ff;=0A=
+		=0A=
+		group =3D ip >> 5;=0A=
+		=0A=
+		// calc interrupt bit within group=0A=
+		ip -=3D (group << 5);=0A=
+		intr_bit =3D 1 << ip;=0A=
+		=0A=
+		// first enable the IP mapped to this IRQ=0A=
+		enable_local_irq(group_to_ip(group));=0A=
+		=0A=
+		addr =3D intr_group[group].base_addr;=0A=
+		// unmask intr within group=0A=
+		WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);=0A=
+	} =0A=
+	else {=0A=
+		printk("warning: end_irq %d did not enable (%x)\n", =0A=
+		       irq_nr, irq_desc[irq_nr].status);=0A=
+	}=0A=
+}=0A=
+=0A=
+static struct hw_interrupt_type rc32434_irq_type =3D {=0A=
+	.typename =3D "IDT434",=0A=
+	.startup  =3D startup_irq,=0A=
+	.shutdown =3D shutdown_irq,=0A=
+	.enable   =3D rc32434_enable_irq,=0A=
+	.disable  =3D rc32434_disable_irq,=0A=
+	.ack      =3D mask_and_ack_irq,=0A=
+	.end      =3D end_irq,=0A=
+};=0A=
+=0A=
+void __init arch_init_irq(void)=0A=
+{=0A=
+	int i;=0A=
+	printk("Initializing IRQ's: %d out of %d\n", RC32434_NR_IRQS, =
NR_IRQS);  =0A=
+	memset(irq_desc, 0, sizeof(irq_desc));=0A=
+	set_except_vector(0, idtIRQ);=0A=
+	=0A=
+	for (i =3D 0; i < RC32434_NR_IRQS; i++) {=0A=
+		irq_desc[i].status =3D IRQ_DISABLED;=0A=
+		irq_desc[i].action =3D NULL;=0A=
+		irq_desc[i].depth =3D 1;=0A=
+		irq_desc[i].handler =3D &rc32434_irq_type;=0A=
+		spin_lock_init(&irq_desc[i].lock);=0A=
+	}=0A=
+}=0A=
+=0A=
+/* Main Interrupt dispatcher */=0A=
+void rc32434_irqdispatch(unsigned long cp0_cause, struct pt_regs =
*regs)=0A=
+{=0A=
+	unsigned int ip, pend, group;=0A=
+	volatile unsigned int *addr;=0A=
+	=0A=
+	if ((ip =3D (cp0_cause & 0x7c00))) {=0A=
+		group =3D 21 - rc32434_clz(ip);=0A=
+		=0A=
+		addr =3D intr_group[group].base_addr;=0A=
+		=0A=
+		pend =3D READ_PEND(addr);=0A=
+		pend &=3D ~READ_MASK(addr); // only unmasked interrupts=0A=
+		pend =3D 39 - rc32434_clz(pend);=0A=
+		do_IRQ((group << 5) + pend, regs);=0A=
+		return;=0A=
+	} =0A=
+	else=0A=
+		return;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/Makefile =
idtlinux/arch/mips/idt-boards/rc32434/EB434/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/Makefile	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,41 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for IDT EB434 BSP=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+=0A=
+.S.s:=0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:=0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+obj-y	 :=3D prom.o setup.o idtIRQ.o reset.o irq.o time.o=0A=
+obj-$(CONFIG_KGDB)			+=3D serial_gdb.o=0A=
+obj-$(CONFIG_SERIAL_8250) 		+=3D serial.o=0A=
+subdir-$(CONFIG_IDT_BOOT_NVRAM)		+=3D nvram=0A=
+obj-$(CONFIG_IDT_BOOT_NVRAM)    	+=3D nvram/built-in.o=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/nvram/Make=
file idtlinux/arch/mips/idt-boards/rc32434/EB434/nvram/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/nvram/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/nvram/Makefile	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,39 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for IDT EB434/435 nvram access routines=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+#=0A=
+#=0A=
+#######################################################################=
########=0A=
+=0A=
+obj-y   :=3D nvram434.o=0A=
+obj-m   :=3D $(O_TARGET)=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/nvram/nvram434.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/nvram/nvram434.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/nvram/nvram434.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/nvram/nvram434.c	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,382 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram interface routines.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/string.h>=0A=
+=0A=
+//#include <asm/ds1553rtc.h>=0A=
+#include "nvram434.h"=0A=
+#include "rtc.h"=0A=
+#define  NVRAM_BASE RTCLOCK_BASE=0A=
+=0A=
+extern void setenv (char *e, char *v, int rewrite);=0A=
+extern void unsetenv (char *e);=0A=
+extern void mapenv (int (*func)(char *, char *));=0A=
+extern char *getenv (char *s);=0A=
+extern void purgeenv(void);=0A=
+=0A=
+static void nvram_initenv(void);=0A=
+=0A=
+static unsigned char=0A=
+nvram_getbyte(int offs)=0A=
+{=0A=
+  return(*((unsigned char*)(NVRAM_BASE + offs)));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setbyte(int offs, unsigned char val)=0A=
+{=0A=
+  unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE + =
offs);=0A=
+=0A=
+  *nvramDataPointer =3D val;=0A=
+}=0A=
+=0A=
+/*=0A=
+ * BigEndian!=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_getshort(int offs)=0A=
+{=0A=
+  return((nvram_getbyte(offs) << 8) | nvram_getbyte(offs + 1));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setshort(int offs, unsigned short val)=0A=
+{=0A=
+  nvram_setbyte(offs, (unsigned char)((val >> 8) & 0xff));=0A=
+  nvram_setbyte(offs + 1, (unsigned char)(val & 0xff));=0A=
+}=0A=
+#if 0=0A=
+static unsigned int=0A=
+nvram_getint(int offs)=0A=
+{=0A=
+  unsigned int val;=0A=
+  val =3D nvram_getbyte(offs) << 24;=0A=
+  val |=3D nvram_getbyte(offs + 1) << 16;=0A=
+  val |=3D nvram_getbyte(offs + 2) << 8;=0A=
+  val |=3D nvram_getbyte(offs + 3);=0A=
+  return(val);=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setint(int offs, unsigned int val)=0A=
+{=0A=
+  nvram_setbyte(offs, val >> 24);=0A=
+  nvram_setbyte(offs + 1, val >> 16);=0A=
+  nvram_setbyte(offs + 2, val >> 8);=0A=
+  nvram_setbyte(offs + 3, val);=0A=
+}=0A=
+#endif=0A=
+/*=0A=
+ * calculate NVRAM checksum=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_calcsum(void)=0A=
+{=0A=
+  unsigned short sum =3D NV_MAGIC;=0A=
+  int     i;=0A=
+=0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i +=3D 2)=0A=
+    sum +=3D nvram_getshort(i);=0A=
+  return(sum);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * update the nvram checksum=0A=
+ */=0A=
+static void=0A=
+nvram_updatesum (void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_CSUM, nvram_calcsum());=0A=
+}=0A=
+=0A=
+/*=0A=
+ * test validity of nvram by checksumming it=0A=
+ */=0A=
+static int=0A=
+nvram_isvalid(void)=0A=
+{=0A=
+  static int  is_valid;=0A=
+=0A=
+  if (is_valid)=0A=
+    return(1);=0A=
+=0A=
+  if (nvram_getshort(NVOFF_MAGIC) !=3D NV_MAGIC)=0A=
+    nvram_initenv();=0A=
+  is_valid =3D 1;=0A=
+  return(1);=0A=
+}=0A=
+=0A=
+/* return nvram address of environment string */=0A=
+static int=0A=
+nvram_matchenv(char *s)=0A=
+{=0A=
+  int envsize, envp, n, i, varsize;=0A=
+  char *var;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  if (envsize > ENV_AVAIL)=0A=
+    return(0);     /* sanity */=0A=
+    =0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  if ((n =3D strlen (s)) > 255)=0A=
+    return(0);=0A=
+    =0A=
+  while (envsize > 0) {=0A=
+    varsize =3D nvram_getbyte(envp);=0A=
+    if (varsize =3D=3D 0 || (envp + varsize) > ENV_TOP)=0A=
+      return(0);   /* sanity */=0A=
+    for (i =3D envp + 1, var =3D s; i <=3D envp + n; i++, var++) {=0A=
+      char c1 =3D nvram_getbyte(i);=0A=
+      char c2 =3D *var;=0A=
+      if (islower(c1))=0A=
+        c1 =3D toupper(c1);=0A=
+      if (islower(c2))=0A=
+        c2 =3D toupper(c2);=0A=
+      if (c1 !=3D c2)=0A=
+        break;=0A=
+    }=0A=
+    if (i > envp + n) {       /* match so far */=0A=
+      if (n =3D=3D varsize - 1)   /* match on boolean */=0A=
+        return(envp);=0A=
+      if (nvram_getbyte(i) =3D=3D '=3D')  /* exact match on variable =
*/=0A=
+        return(envp);=0A=
+    }=0A=
+    envsize -=3D varsize;=0A=
+    envp +=3D varsize;=0A=
+  }=0A=
+  return(0);=0A=
+}=0A=
+=0A=
+static void nvram_initenv(void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_delenv(char *s)=0A=
+{=0A=
+  int nenvp, envp, envsize, nbytes;=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return;=0A=
+=0A=
+  nenvp =3D envp + nvram_getbyte(envp);=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  nbytes =3D envsize - (nenvp - ENV_BASE);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envsize - (nenvp - envp));=0A=
+  while (nbytes--) {=0A=
+    nvram_setbyte(envp, nvram_getbyte(nenvp));=0A=
+    envp++;=0A=
+    nenvp++;=0A=
+  }=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static int=0A=
+nvram_setenv(char *s, char *v)=0A=
+{=0A=
+  int ns, nv, total;=0A=
+  int envp;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return(-1);=0A=
+=0A=
+  nvram_delenv(s);=0A=
+  ns =3D strlen(s);=0A=
+  if (ns =3D=3D 0)=0A=
+    return (-1);=0A=
+  if (v && *v) {=0A=
+    nv =3D strlen(v);=0A=
+    total =3D ns + nv + 2;=0A=
+  }=0A=
+  else {=0A=
+    nv =3D 0;=0A=
+    total =3D ns + 1;=0A=
+  }=0A=
+  if (total > 255 || total > ENV_AVAIL - =
nvram_getshort(NVOFF_ENVSIZE))=0A=
+    return(-1);=0A=
+=0A=
+  envp =3D ENV_BASE + nvram_getshort(NVOFF_ENVSIZE);=0A=
+=0A=
+  nvram_setbyte(envp, (unsigned char) total); =0A=
+  envp++;=0A=
+=0A=
+  while (ns--) {=0A=
+    nvram_setbyte(envp, *s); =0A=
+    envp++; =0A=
+    s++;=0A=
+  }=0A=
+=0A=
+  if (nv) {=0A=
+    nvram_setbyte(envp, '=3D'); =0A=
+    envp++;=0A=
+    while (nv--) {=0A=
+      nvram_setbyte(envp, *v); =0A=
+      envp++; =0A=
+      v++;=0A=
+    }=0A=
+  }=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envp-ENV_BASE);=0A=
+  nvram_updatesum();=0A=
+  return 0;=0A=
+}=0A=
+=0A=
+static char *=0A=
+nvram_getenv(char *s)=0A=
+{=0A=
+  static char buf[256];   /* FIXME: this cannot be static */=0A=
+  int envp, ns, nbytes, i;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return((char *)0);=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return((char *)0);=0A=
+  ns =3D strlen(s);=0A=
+  if (nvram_getbyte(envp) =3D=3D ns + 1)  /* boolean */=0A=
+    buf[0] =3D '\0';=0A=
+  else {=0A=
+    nbytes =3D nvram_getbyte(envp) - (ns + 2);=0A=
+    envp +=3D ns + 2;=0A=
+    for (i =3D 0; i < nbytes; i++)=0A=
+      buf[i] =3D nvram_getbyte(envp++);=0A=
+    buf[i] =3D '\0';=0A=
+  }=0A=
+  return(buf);=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_unsetenv(char *s)=0A=
+{=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  nvram_delenv(s);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * apply func to each string in environment=0A=
+ */=0A=
+static void=0A=
+nvram_mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  int envsize, envp, n, i, seeneql;=0A=
+  char name[256], value[256];=0A=
+  char c, *s;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  while (envsize > 0) {=0A=
+    value[0] =3D '\0';=0A=
+    seeneql =3D 0;=0A=
+    s =3D name;=0A=
+    n =3D nvram_getbyte(envp);=0A=
+    for (i =3D envp + 1; i < envp + n; i++) {=0A=
+      c =3D nvram_getbyte(i);=0A=
+      if ((c =3D=3D '=3D') && !seeneql) {=0A=
+        *s =3D '\0';=0A=
+        s =3D value;=0A=
+        seeneql =3D 1;=0A=
+        continue;=0A=
+      }=0A=
+      *s++ =3D c;=0A=
+    }=0A=
+    *s =3D '\0';=0A=
+    (*func)(name, value);=0A=
+    envsize -=3D n;=0A=
+    envp +=3D n;=0A=
+  }=0A=
+}=0A=
+#if 0=0A=
+static unsigned int=0A=
+digit(char c)=0A=
+{=0A=
+  if ('0' <=3D c && c <=3D '9')=0A=
+    return (c - '0');=0A=
+  if ('A' <=3D c && c <=3D 'Z')=0A=
+    return (10 + c - 'A');=0A=
+  if ('a' <=3D c && c <=3D 'z')=0A=
+    return (10 + c - 'a');=0A=
+  return (~0);=0A=
+}=0A=
+#endif=0A=
+/*=0A=
+ * Wrappers to allow 'special' environment variables to get =
processed=0A=
+ */=0A=
+void=0A=
+setenv(char *e, char *v, int rewrite)=0A=
+{=0A=
+  if (nvram_getenv(e) && !rewrite)=0A=
+    return;=0A=
+    =0A=
+  nvram_setenv(e, v);=0A=
+}=0A=
+=0A=
+char *=0A=
+getenv(char *e)=0A=
+{=0A=
+  return(nvram_getenv(e));=0A=
+}=0A=
+=0A=
+void=0A=
+unsetenv(char *e)=0A=
+{=0A=
+  nvram_unsetenv(e);=0A=
+}=0A=
+=0A=
+void=0A=
+purgeenv()=0A=
+{=0A=
+  int i;=0A=
+  unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE);=0A=
+  =0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i++)=0A=
+    *nvramDataPointer++ =3D 0;=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+  nvram_setshort(NVOFF_CSUM, NV_MAGIC);=0A=
+}=0A=
+=0A=
+void=0A=
+mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  nvram_mapenv(func);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/nvram/nvram434.h =
idtlinux/arch/mips/idt-boards/rc32434/EB434/nvram/nvram434.h=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/nvram/nvram434.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/nvram/nvram434.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,58 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram definitions.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#ifndef _NVRAM_=0A=
+#define _NVRAM_=0A=
+#define NVOFFSET        0                 /* use all of NVRAM */=0A=
+=0A=
+/* Offsets to reserved locations */=0A=
+              /* size description */=0A=
+#define NVOFF_MAGIC     (NVOFFSET + 0)    /* 2 magic value */=0A=
+#define NVOFF_CSUM      (NVOFFSET + 2)    /* 2 NVRAM environment =
checksum */=0A=
+#define NVOFF_ENVSIZE   (NVOFFSET + 4)    /* 2 size of 'environment' =
*/=0A=
+#define NVOFF_TEST      (NVOFFSET + 5)    /* 1 cold start test byte =
*/=0A=
+#define NVOFF_ETHADDR   (NVOFFSET + 6)    /* 6 decoded ethernet =
address */=0A=
+#define NVOFF_UNUSED    (NVOFFSET + 12)   /* 0 current end of table =
*/=0A=
+=0A=
+#define NV_MAGIC        0xdeaf            /* nvram magic number */=0A=
+#define NV_RESERVED     32                /* number of reserved bytes =
*/=0A=
+=0A=
+#undef  NVOFF_ETHADDR=0A=
+#define NVOFF_ETHADDR   (NVOFFSET + NV_RESERVED - 6)=0A=
+=0A=
+/* number of bytes available for environment */=0A=
+#define ENV_BASE        (NVOFFSET + NV_RESERVED)=0A=
+#define ENV_TOP         TD_NVRAM_SIZE=0A=
+#define ENV_AVAIL       (ENV_TOP - ENV_BASE)=0A=
+=0A=
+#endif /* _NVRAM_ */=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/nvram/rtc.h =
idtlinux/arch/mips/idt-boards/rc32434/EB434/nvram/rtc.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/nvram/rtc.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/nvram/rtc.h	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,72 @@=0A=
+/**********************************************************************=
****
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     DS1553(Dallas Semiconductor) Real Time Clock and Non-Volatile =
RAM.
+ *
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)
+ *        =20
+ *  This program is free software; you can redistribute  it and/or =
modify it
+ *  under  the terms of  the GNU General  Public License as published =
by the
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License =
along
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ =
************************************************************************=
**
+ */
+
+
+#define RTCLOCK_BASE    0xBA000000
+
+/*
+ * To maintain endianess independence, make all accesses as 32-bit
+ * words with appropriate shifting.
+ */
+#define TD_NVRAM_SIZE 0x1FF0
+
+typedef struct td_clock {
+  unsigned char ram[TD_NVRAM_SIZE];
+  unsigned char flags;
+  unsigned char dummy;
+  unsigned char alarm_secs;
+  unsigned char alarm_mins;
+  unsigned char alarm_hours;
+  unsigned char alarm_date;
+  unsigned char interrupts;
+  unsigned char watchdog;
+  unsigned char century;
+  unsigned char secs;
+  unsigned char mins;
+  unsigned char hours;
+  unsigned char weekday;
+  unsigned char date;
+  unsigned char month;
+  unsigned char year;
+} RTC;
+
+#define rtc (*((volatile RTC *)RTCLOCK_BASE))
+
+/*
+ * Control register bit definitions
+ */
+#define TDC_ENA_READ      0x40
+#define TDC_DIS_READ      0xBF
+
+#define TDC_ENA_WRITE     0x80
+#define TDC_DIS_WRITE     0x7F
+
+#define TDC_RUN_OSC       0x80
+
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/prom.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/prom.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/prom.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/prom.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,142 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     prom interface routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/string.h>=0A=
+#include <linux/console.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <linux/bootmem.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serialP.h>=0A=
+#include <asm/serial.h>=0A=
+#include <linux/ioport.h>=0A=
+=0A=
+=0A=
+unsigned int idt_cpu_freq =3D CONFIG_IDT_BOARD_FREQ;=0A=
+EXPORT_SYMBOL(idt_cpu_freq);=0A=
+=0A=
+extern void setup_serial_port(void);=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+extern void mapenv(int (*func)(char *, char *));=0A=
+static int make_bootparm(char *name,char *val)=0A=
+{ =0A=
+/*=0A=
+ * The bootparameters are obtained from NVRAM and formatted here.=0A=
+ * For e.g.=0A=
+ *=0A=
+ *    netaddr=3D10.0.1.95=0A=
+ *    bootaddr=3D10.0.0.139=0A=
+ *    bootfile=3Dvmlinus=0A=
+ *    bootparm1=3Droot=3D/dev/nfs=0A=
+ *    bootparm2=3Dip=3D10.0.1.95=0A=
+ *=0A=
+ * is parsed to:=0A=
+ *=0A=
+ *      root=3D/dev/nfs ip=3D10.0.1.95=0A=
+ *=0A=
+ * in arcs_cmdline[].=0A=
+ */=0A=
+	if (strncmp(name, "bootparm", 8) =3D=3D 0) {=0A=
+		strcat(arcs_cmdline,val);=0A=
+		strcat(arcs_cmdline," ");=0A=
+	}=0A=
+	else if(strncmp(name, "HZ", 2) =3D=3D 0) {=0A=
+		idt_cpu_freq =3D simple_strtoul(val, 0, 10);=0A=
+		printk("CPU Clock at %d Hz (from HZ environment variable)\n",=0A=
+		       idt_cpu_freq);=0A=
+	}=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static void prom_init_cmdline(void)=0A=
+{ =0A=
+	memset(arcs_cmdline,0,sizeof(arcs_cmdline));=0A=
+	mapenv(&make_bootparm);=0A=
+}=0A=
+#else=0A=
+/* Kernel Boot parameters */=0A=
+//static unsigned char =
bootparm[]=3D"ip=3D157.165.29.36:157.165.29.18::255.255.0.0::eth0";=0A=
+static unsigned char bootparm[]=3D"console=3DttyS0,9600";=0A=
+#endif=0A=
+extern unsigned long mips_machgroup;=0A=
+extern unsigned long mips_machtype;=0A=
+=0A=
+/* IDT 79EB434/435 memory map -- we really should be auto sizing it =
*/=0A=
+=0A=
+#define RAM_FIRST       0x80000400  /* Leave room for interrupt =
vectors */=0A=
+#define RAM_SIZE        32*1024*1024=0A=
+#define RAM_END         (0x80000000 + RAM_SIZE)     =0A=
+struct resource rc32434_res_ram =3D {=0A=
+	"RAM",=0A=
+	0,=0A=
+	RAM_SIZE,=0A=
+	IORESOURCE_MEM=0A=
+};=0A=
+=0A=
+char * __init prom_getcmdline(void)=0A=
+{ =0A=
+	return &(arcs_cmdline[0]);=0A=
+}=0A=
+=0A=
+=0A=
+void __init prom_init(void)=0A=
+{=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+	/* set up command line */=0A=
+	prom_init_cmdline();=0A=
+#else=0A=
+	sprintf(arcs_cmdline,"%s",bootparm);=0A=
+#endif=0A=
+	=0A=
+	/* turn on the console */=0A=
+	=0A=
+	setup_serial_port();=0A=
+	/* set our arch type */=0A=
+	=0A=
+	mips_machgroup =3D MACH_GROUP_IDT;=0A=
+	mips_machtype =3D MACH_IDT_EB434;=0A=
+	=0A=
+	/*=0A=
+	 * give all RAM to boot allocator,=0A=
+	 * except where the kernel was loaded=0A=
+	 */=0A=
+	add_memory_region(0,=0A=
+			  rc32434_res_ram.end - rc32434_res_ram.start,=0A=
+			  BOOT_MEM_RAM);=0A=
+}=0A=
+=0A=
+void prom_free_prom_memory(void)=0A=
+{=0A=
+	printk("stubbed prom_free_prom_memory()\n");=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/reset.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/reset.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/reset.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/reset.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,47 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Reset EB434/435 board.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/irq.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <asm/reboot.h>=0A=
+#include <asm/addrspace.h>     /* for KSEG1ADDR() */=0A=
+=0A=
+void idt_reset(void)=0A=
+{=0A=
+	/* Reset*/=0A=
+	*(volatile u32 *)KSEG1ADDR(0x18008000) =3D 0x80000001;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/serial.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/serial.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/serial.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/serial.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,85 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Serial port initialisation.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/tty.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serial_core.h>=0A=
+=0A=
+#include <asm/time.h>=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/irq.h>=0A=
+#include <asm/serial.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32434/rc32434.h>=0A=
+extern int __init early_serial_setup(struct uart_port *port);=0A=
+=0A=
+#define BASE_BAUD (1843200 / 16)=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+extern int __init setup_serial_port(void)=0A=
+{=0A=
+	static struct uart_port serial_req[2];=0A=
+	=0A=
+	memset(serial_req, 0, sizeof(serial_req));=0A=
+	serial_req[0].type       =3D PORT_16550A;=0A=
+	serial_req[0].line       =3D 0;=0A=
+	serial_req[0].irq        =3D RC32434_UART0_IRQ;=0A=
+	serial_req[0].flags      =3D STD_COM_FLAGS;=0A=
+	serial_req[0].uartclk    =3D idt_cpu_freq;=0A=
+	serial_req[0].iotype     =3D SERIAL_IO_MEM;=0A=
+	serial_req[0].membase    =3D (char *) =
KSEG1ADDR(RC32434_UART0_BASE);=0A=
+	//  serial_req[0].fifosize   =3D 14;=0A=
+	serial_req[0].mapbase   =3D KSEG1ADDR(RC32434_UART0_BASE);=0A=
+	serial_req[0].regshift   =3D 2;=0A=
+	=0A=
+	serial_req[1].type       =3D PORT_16550A;=0A=
+	serial_req[1].line       =3D 1;=0A=
+	serial_req[1].irq        =3D EB434_UART1_IRQ;=0A=
+	serial_req[1].flags      =3D STD_COM_FLAGS;=0A=
+	serial_req[1].uartclk    =3D idt_cpu_freq;=0A=
+	serial_req[1].iotype     =3D SERIAL_IO_MEM;=0A=
+	serial_req[1].membase    =3D (char *)KSEG1ADDR(EB434_UART1_BASE);=0A=
+	//  serial_req[1].fifosize   =3D 14;=0A=
+	serial_req[1].regshift   =3D 2;=0A=
+	serial_req[1].mapbase   =3D KSEG1ADDR(EB434_UART1_BASE);=0A=
+	=0A=
+	early_serial_setup(&serial_req[0]);=0A=
+=0A=
+	early_serial_setup(&serial_req[1]);=0A=
+	=0A=
+	return(0);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/serial_gdb.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/serial_gdb.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/serial_gdb.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/serial_gdb.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,305 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *      EB434/435 specific polling driver for 16550 UART.=0A=
+ *=0A=
+ *  Copyright 2005 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
***=0A=
+ */=0A=
+=0A=
+#include <linux/serial_reg.h>=0A=
+=0A=
+/* turn this on to watch the debug protocol echoed on the console port =
*/=0A=
+#undef DEBUG_REMOTE_DEBUG=0A=
+=0A=
+/* set remote gdb baud rate at 115200 */=0A=
+=0A=
+#define GDB_BAUD 115200=0A=
+#define CONS_BAUD 9600=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+#define EXT_FREQ    24000000=0A=
+#define INT_FREQ    idt_cpu_freq=0A=
+=0A=
+#define EXT_PORT    0xb9800000u=0A=
+#define EXT_SHIFT   0=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define INT_PORT    0xb8058003u=0A=
+#else=0A=
+#define INT_PORT    0xb8058000u=0A=
+#endif=0A=
+#define INT_SHIFT   2=0A=
+=0A=
+#define INT_FCR     UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR | =
UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14=0A=
+#define EXT_FCR     UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR | =
UART_FCR_CLEAR_XMIT=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+  volatile unsigned char *base;=0A=
+  unsigned int shift;=0A=
+  unsigned int freq;=0A=
+  unsigned int fcr;=0A=
+} ser_port;=0A=
+=0A=
+ser_port ports[2] =3D =0A=
+{=0A=
+  { (volatile unsigned char *)INT_PORT, INT_SHIFT, 0, INT_FCR},=0A=
+  { (volatile unsigned char *)EXT_PORT, EXT_SHIFT, EXT_FREQ, =
EXT_FCR}=0A=
+};=0A=
+=0A=
+/* To swap EXT and INT UART as console / gdb change this defines  =
*/=0A=
+#define GDB_PORT    1=0A=
+#define CONS_PORT   0=0A=
+=0A=
+void reset_gdb_port(void);=0A=
+void cons_putc(char c);=0A=
+int port_getc(int port);=0A=
+void port_putc(int port, char c);=0A=
+=0A=
+int cons_getc(void)=0A=
+{=0A=
+	return port_getc(CONS_PORT);=0A=
+}=0A=
+=0A=
+void cons_putc(char c)=0A=
+{=0A=
+	port_putc(CONS_PORT, c);=0A=
+}=0A=
+=0A=
+void cons_puts(char *s)=0A=
+{=0A=
+	while(*s) {=0A=
+		if(*s =3D=3D '\n') cons_putc('\r');=0A=
+		cons_putc(*s);=0A=
+		s++;=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_do_putn(int n)=0A=
+{=0A=
+	if(n) {=0A=
+		cons_do_putn(n / 10);=0A=
+		cons_putc(n % 10 + '0');=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_putn(int n)=0A=
+{=0A=
+	if(n < 0) {=0A=
+		cons_putc('-');=0A=
+		n =3D -n;=0A=
+	}=0A=
+=0A=
+	if (n =3D=3D 0) {=0A=
+		cons_putc('0');=0A=
+	} else {=0A=
+		cons_do_putn(n);=0A=
+	}=0A=
+}=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+static enum {HUH, SENDING, GETTING} state;=0A=
+=0A=
+static void sent(int c)=0A=
+{=0A=
+	switch(state) {=0A=
+	case HUH:=0A=
+	case GETTING:=0A=
+		cons_puts("\nSNT ");=0A=
+		state =3D SENDING;=0A=
+		/* fall through */=0A=
+	case SENDING:=0A=
+		cons_putc(c);=0A=
+		break;=0A=
+	}       =0A=
+}=0A=
+=0A=
+static void got(int c)=0A=
+{=0A=
+	switch(state) {=0A=
+	case HUH:=0A=
+	case SENDING:=0A=
+		cons_puts("\nGOT ");=0A=
+		state =3D GETTING;=0A=
+		/* fall through */=0A=
+	case GETTING:=0A=
+		cons_putc(c);=0A=
+		break;=0A=
+	}       =0A=
+}=0A=
+#endif /* DEBUG_REMOTE_DEBUG */=0A=
+=0A=
+static int first =3D 1;=0A=
+=0A=
+int getDebugChar(void)=0A=
+{=0A=
+	int c;=0A=
+=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+	c =3D port_getc(GDB_PORT);=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	got(c);=0A=
+#endif=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p].base;=0A=
+	int s =3D ports[p].shift;=0A=
+	int c;=0A=
+=0A=
+	while((*(port + (UART_LSR << s)) & UART_LSR_DR) =3D=3D 0) {=0A=
+		continue;=0A=
+	}       	=0A=
+=0A=
+	c =3D *(port + (UART_RX << s));=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc_ready(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p].base;=0A=
+	int s =3D ports[p].shift;=0A=
+=0A=
+	return *(port + (UART_LSR << s)) & UART_LSR_DR;=0A=
+}=0A=
+=0A=
+int isDebugReady(void)=0A=
+{=0A=
+	return port_getc_ready(1);=0A=
+}=0A=
+=0A=
+void putDebugChar(char c)=0A=
+{=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	sent(c);=0A=
+#endif=0A=
+=0A=
+	port_putc(GDB_PORT, c);=0A=
+}=0A=
+=0A=
+#define OK_TO_XMT (UART_LSR_TEMT | UART_LSR_THRE)=0A=
+=0A=
+void port_putc(int p, char c)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p].base;=0A=
+	int s =3D ports[p].shift;=0A=
+	volatile unsigned char *lsr =3D port + (UART_LSR << s);=0A=
+=0A=
+	while((*lsr & OK_TO_XMT) !=3D OK_TO_XMT) {=0A=
+		continue;=0A=
+	}=0A=
+=0A=
+	*(port + (UART_TX << s)) =3D c;=0A=
+}=0A=
+=0A=
+void reset_gdb_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[GDB_PORT].base;=0A=
+	unsigned int s =3D ports[GDB_PORT].shift;=0A=
+	unsigned int DIVISOR;=0A=
+=0A=
+	if (ports[GDB_PORT].freq) =0A=
+	  DIVISOR =3D (ports[GDB_PORT].freq / 16 / GDB_BAUD);=0A=
+	else=0A=
+	  DIVISOR =3D (idt_cpu_freq / 16 / GDB_BAUD);=0A=
+=0A=
+	first =3D 0;=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	cons_puts("reset_gdb_port: initializing remote debug serial port =
(internal UART, ");=0A=
+	cons_putn(GDB_BAUD);=0A=
+	cons_puts("baud, MHz=3D");=0A=
+	cons_putn(idt_cpu_freq);=0A=
+	cons_puts(", divisor=3D");=0A=
+	cons_putn(DIVISOR);=0A=
+	cons_puts(")\n");=0A=
+#endif=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + (UART_CSR << s)) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + (UART_FCR << s)) =3D ports[GDB_PORT].fcr;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + (UART_LCR << s)) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+	*(port + (UART_DLL << s)) =3D DIVISOR;=0A=
+	*(port + (UART_DLM << s)) =3D DIVISOR >> 8;=0A=
+=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + (UART_LCR << s)) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + (UART_IER << s)) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + (UART_MCR << s)) =3D 0;=0A=
+}=0A=
+=0A=
+void reset_cons_port(void)=0A=
+{=0A=
+  volatile unsigned char *port =3D ports[CONS_PORT].base;=0A=
+  unsigned int s =3D ports[CONS_PORT].shift;=0A=
+  unsigned int DIVISOR;=0A=
+=0A=
+  if (ports[CONS_PORT].freq) =0A=
+    DIVISOR =3D (ports[CONS_PORT].freq / 16 / CONS_BAUD);=0A=
+  else=0A=
+    DIVISOR =3D (idt_cpu_freq / 16 / CONS_BAUD);=0A=
+=0A=
+  /* reset the port */=0A=
+  *(port + (UART_CSR << s)) =3D 0;=0A=
+=0A=
+  /* clear and enable the FIFOs */=0A=
+  *(port + (UART_FCR << s)) =3D ports[CONS_PORT].fcr;=0A=
+=0A=
+  /* set the baud rate */=0A=
+  *(port + (UART_LCR << s)) =3D UART_LCR_DLAB;         /* enable DLL, =
DLM registers */=0A=
+=0A=
+  *(port + (UART_DLL << s)) =3D DIVISOR;=0A=
+  *(port + (UART_DLM << s)) =3D DIVISOR >> 8;=0A=
+  /* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+  *(port + (UART_LCR << s)) =3D UART_LCR_STOP |        /* 2 stop bits =
*/=0A=
+    UART_LCR_WLEN8;                         /* 8 bit word length */=0A=
+        =0A=
+  /* leave interrupts off */=0A=
+  *(port + (UART_IER << s)) =3D 0;=0A=
+=0A=
+  /* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+  *(port + (UART_MCR << s)) =3D 0;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/setup.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/setup.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/setup.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/setup.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,166 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     setup routines for IDT EB434/435 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/pm.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/irq.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <asm/reboot.h>=0A=
+#include <asm/addrspace.h>     /* for KSEG1ADDR() */=0A=
+#include <asm/idt-boards/rc32434/rc32434.h>=0A=
+=0A=
+extern char * __init prom_getcmdline(void);=0A=
+=0A=
+extern void (*board_time_init)(void);=0A=
+extern void (*board_timer_setup)(struct irqaction *irq);=0A=
+extern void rc32434_time_init(void);=0A=
+extern void rc32434_timer_setup(struct irqaction *irq);=0A=
+extern void idt_reset(void);=0A=
+void idt_disp_str(char *s);=0A=
+=0A=
+#define epldMask ((volatile unsigned char *)0xB900000d)=0A=
+=0A=
+#define DIG_CLEAR ((volatile unsigned char *)0xB9000000)=0A=
+#define DIG0 ((volatile unsigned char *)0xB9000007)=0A=
+#define DIG1 ((volatile unsigned char *)0xB9000006)=0A=
+#define DIG2 ((volatile unsigned char *)0xB9000005)=0A=
+#define DIG3 ((volatile unsigned char *)0xB9000004)=0A=
+=0A=
+void idt_disp_char(int i, char c)=0A=
+{=0A=
+	switch(i) {=0A=
+	case 0: *DIG0 =3D c; break;=0A=
+	case 1: *DIG1 =3D c; break;=0A=
+	case 2: *DIG2 =3D c; break;=0A=
+	case 3: *DIG3 =3D c; break;=0A=
+	default: *DIG0 =3D '?'; break;=0A=
+	}=0A=
+}=0A=
+=0A=
+void idt_disp_str(char *s)=0A=
+{=0A=
+	if (s =3D=3D 0) {=0A=
+		*DIG_CLEAR;=0A=
+	} else {=0A=
+		int i;=0A=
+		for(i =3D 0; i < 4; i++) {=0A=
+			if(s[i]) idt_disp_char(i, s[i]);=0A=
+		}=0A=
+	}=0A=
+}=0A=
+=0A=
+=0A=
+static void idt_machine_restart(char *command)=0A=
+{=0A=
+	printk("idt_machine_restart: command=3D%s\n", command);=0A=
+	idt_reset();=0A=
+}=0A=
+=0A=
+static void idt_machine_halt(void)=0A=
+{=0A=
+	printk("idt_machine_halt:  halted\n");=0A=
+	for(;;) continue;=0A=
+}=0A=
+=0A=
+static void idt_machine_power_off(void)=0A=
+{=0A=
+	printk("idt_machine_power_off:  It is now safe to turn off the =
power\n");=0A=
+	for(;;) continue;=0A=
+}=0A=
+=0A=
+=0A=
+static int __init idt_setup(void)=0A=
+{=0A=
+	char* argptr;=0A=
+	=0A=
+	idt_disp_str("Unix");=0A=
+	=0A=
+	argptr =3D prom_getcmdline();=0A=
+#ifdef CONFIG_SERIAL_CONSOLE=0A=
+	if ((argptr =3D strstr(argptr, "console=3D")) =3D=3D NULL) {=0A=
+		argptr =3D prom_getcmdline();=0A=
+		strcat(argptr, " console=3DttyS0,9600");=0A=
+	}=0A=
+#endif=0A=
+	=0A=
+	board_time_init =3D rc32434_time_init;=0A=
+	=0A=
+	board_timer_setup =3D rc32434_timer_setup;=0A=
+	=0A=
+	_machine_restart =3D idt_machine_restart;=0A=
+	_machine_halt =3D idt_machine_halt;=0A=
+	pm_power_off =3D idt_machine_power_off;=0A=
+	set_io_port_base(KSEG1);=0A=
+	/* Enable PCI interrupts in EPLD Mask register */=0A=
+	*epldMask =3D 0x0;=0A=
+	*(epldMask + 1) =3D 0x0;=0A=
+	=0A=
+	write_c0_wired(0);=0A=
+	=0A=
+	return 0;=0A=
+	=0A=
+}=0A=
+=0A=
+//early_initcall(idt_setup);=0A=
+=0A=
+void __init plat_setup(void){=0A=
+  idt_setup();=0A=
+}=0A=
+=0A=
+=0A=
+int page_is_ram(unsigned long pagenr)=0A=
+{=0A=
+	return 1;=0A=
+}=0A=
+=0A=
+const char *get_system_type(void)=0A=
+{=0A=
+	return "MIPS IDT32434";=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/time.c =
idtlinux/arch/mips/idt-boards/rc32434/EB434/time.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32434/EB434/time.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32434/EB434/time.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,130 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     timer routines for IDT EB434/435 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/spinlock.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <linux/irq.h>=0A=
+#include <linux/timex.h>=0A=
+=0A=
+#include <linux/param.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/hardirq.h>=0A=
+=0A=
+=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/debug.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434.h>=0A=
+=0A=
+=0A=
+static unsigned long r4k_offset; /* Amount to incr compare reg each =
time */=0A=
+static unsigned long r4k_cur;    /* What counter should be at next =
timer irq */=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+#ifdef CONFIG_RTC_DS1553=0A=
+extern int rtc_1553_init(void);=0A=
+#endif=0A=
+=0A=
+/* =0A=
+ * Figure out the r4k offset, the amount to increment the compare=0A=
+ * register for each time tick. There is no RTC available.=0A=
+ *=0A=
+ * The RC32434 counts at half the CPU *core* speed.=0A=
+ */=0A=
+static unsigned long __init cal_r4koff(void)=0A=
+{=0A=
+	mips_hpt_frequency =3D idt_cpu_freq * IDT_CLOCK_MULT / 2;=0A=
+	return (mips_hpt_frequency / HZ);=0A=
+}=0A=
+=0A=
+void __init rc32434_time_init(void)=0A=
+{=0A=
+        unsigned int est_freq, flags;=0A=
+	=0A=
+	local_irq_save(flags);=0A=
+	=0A=
+	printk("calculating r4koff... ");=0A=
+	r4k_offset =3D cal_r4koff();=0A=
+	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);=0A=
+	=0A=
+	est_freq =3D 2*r4k_offset*HZ;	=0A=
+	est_freq +=3D 5000;    /* round */=0A=
+	est_freq -=3D est_freq%10000;=0A=
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000, =0A=
+	       (est_freq%1000000)*100/1000000);=0A=
+	local_irq_restore(flags);=0A=
+	=0A=
+}=0A=
+=0A=
+void __init rc32434_timer_setup(struct irqaction *irq)=0A=
+{=0A=
+	/* we are using the cpu counter for timer interrupts */=0A=
+	setup_irq(MIPS_CPU_TIMER_IRQ, irq);=0A=
+	=0A=
+	/* to generate the first timer interrupt */=0A=
+	r4k_cur =3D (read_c0_count() + r4k_offset);=0A=
+	write_c0_compare(r4k_cur);=0A=
+	=0A=
+}=0A=
+=0A=
+extern void idt_disp_char(int i,char c);=0A=
+=0A=
+asmlinkage void idt_timer_interrupt(int irq,struct pt_regs *regs)=0A=
+{=0A=
+#ifdef CONFIG_KGDB=0A=
+	void kgdb_check(void);=0A=
+#endif=0A=
+=0A=
+	static unsigned int timerCount =3D 0;=0A=
+	static int toggle =3D 0;=0A=
+	=0A=
+	irq_enter();=0A=
+	kstat_this_cpu.irqs[irq]++;=0A=
+	=0A=
+	if( (timerCount++ % HZ) =3D=3D 0)=0A=
+	{ =0A=
+		toggle ^=3D 1;=0A=
+		idt_disp_char(0,toggle ? 'u' :'U');=0A=
+	}=0A=
+	timer_interrupt(irq, NULL, regs);=0A=
+	irq_exit();=0A=
+=0A=
+#ifdef CONFIG_KGDB=0A=
+	kgdb_check();=0A=
+#endif=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/.config =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/.config=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/.config	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/.config	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,1026 @@=0A=
+#=0A=
+# Automatically generated make config: don't edit=0A=
+# Linux kernel version: 2.6.14=0A=
+# Tue Jan 31 16:33:33 2006=0A=
+#=0A=
+CONFIG_MIPS=3Dy=0A=
+=0A=
+#=0A=
+# Code maturity level options=0A=
+#=0A=
+CONFIG_EXPERIMENTAL=3Dy=0A=
+CONFIG_CLEAN_COMPILE=3Dy=0A=
+CONFIG_BROKEN_ON_SMP=3Dy=0A=
+CONFIG_INIT_ENV_ARG_LIMIT=3D32=0A=
+=0A=
+#=0A=
+# General setup=0A=
+#=0A=
+CONFIG_LOCALVERSION=3D""=0A=
+CONFIG_LOCALVERSION_AUTO=3Dy=0A=
+CONFIG_SWAP=3Dy=0A=
+CONFIG_SYSVIPC=3Dy=0A=
+# CONFIG_POSIX_MQUEUE is not set=0A=
+# CONFIG_BSD_PROCESS_ACCT is not set=0A=
+CONFIG_SYSCTL=3Dy=0A=
+# CONFIG_AUDIT is not set=0A=
+CONFIG_HOTPLUG=3Dy=0A=
+# CONFIG_KOBJECT_UEVENT is not set=0A=
+# CONFIG_IKCONFIG is not set=0A=
+CONFIG_INITRAMFS_SOURCE=3D"../initrd/stage/"=0A=
+CONFIG_INITRAMFS_ROOT_UID=3D0=0A=
+CONFIG_INITRAMFS_ROOT_GID=3D0=0A=
+CONFIG_EMBEDDED=3Dy=0A=
+CONFIG_KALLSYMS=3Dy=0A=
+CONFIG_KALLSYMS_EXTRA_PASS=3Dy=0A=
+CONFIG_PRINTK=3Dy=0A=
+CONFIG_BUG=3Dy=0A=
+CONFIG_BASE_FULL=3Dy=0A=
+CONFIG_FUTEX=3Dy=0A=
+CONFIG_EPOLL=3Dy=0A=
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set=0A=
+CONFIG_SHMEM=3Dy=0A=
+CONFIG_CC_ALIGN_FUNCTIONS=3D0=0A=
+CONFIG_CC_ALIGN_LABELS=3D0=0A=
+CONFIG_CC_ALIGN_LOOPS=3D0=0A=
+CONFIG_CC_ALIGN_JUMPS=3D0=0A=
+# CONFIG_TINY_SHMEM is not set=0A=
+CONFIG_BASE_SMALL=3D0=0A=
+=0A=
+#=0A=
+# Loadable module support=0A=
+#=0A=
+CONFIG_MODULES=3Dy=0A=
+CONFIG_MODULE_UNLOAD=3Dy=0A=
+# CONFIG_MODULE_FORCE_UNLOAD is not set=0A=
+CONFIG_OBSOLETE_MODPARM=3Dy=0A=
+CONFIG_MODVERSIONS=3Dy=0A=
+CONFIG_MODULE_SRCVERSION_ALL=3Dy=0A=
+# CONFIG_KMOD is not set=0A=
+=0A=
+#=0A=
+# Machine selection=0A=
+#=0A=
+CONFIG_IDT_BOARDS=3Dy=0A=
+CONFIG_IDT_EB438=3Dy=0A=
+# CONFIG_IDT_EB434 is not set=0A=
+CONFIG_IDT_BOARD_FREQ=3D150000000=0A=
+CONFIG_IDT_ZIMAGE_ADDR=3D0x88000000=0A=
+CONFIG_IDT_BOOT_NVRAM=3Dy=0A=
+# CONFIG_MIPS_MTX1 is not set=0A=
+# CONFIG_MIPS_BOSPORUS is not set=0A=
+# CONFIG_MIPS_PB1000 is not set=0A=
+# CONFIG_MIPS_PB1100 is not set=0A=
+# CONFIG_MIPS_PB1500 is not set=0A=
+# CONFIG_MIPS_PB1550 is not set=0A=
+# CONFIG_MIPS_PB1200 is not set=0A=
+# CONFIG_MIPS_DB1000 is not set=0A=
+# CONFIG_MIPS_DB1100 is not set=0A=
+# CONFIG_MIPS_DB1500 is not set=0A=
+# CONFIG_MIPS_DB1550 is not set=0A=
+# CONFIG_MIPS_DB1200 is not set=0A=
+# CONFIG_MIPS_MIRAGE is not set=0A=
+# CONFIG_MIPS_COBALT is not set=0A=
+# CONFIG_MACH_DECSTATION is not set=0A=
+# CONFIG_MIPS_EV64120 is not set=0A=
+# CONFIG_MIPS_EV96100 is not set=0A=
+# CONFIG_MIPS_IVR is not set=0A=
+# CONFIG_MIPS_ITE8172 is not set=0A=
+# CONFIG_MACH_JAZZ is not set=0A=
+# CONFIG_LASAT is not set=0A=
+# CONFIG_MIPS_ATLAS is not set=0A=
+# CONFIG_MIPS_MALTA is not set=0A=
+# CONFIG_MIPS_SEAD is not set=0A=
+# CONFIG_MIPS_SIM is not set=0A=
+# CONFIG_MOMENCO_JAGUAR_ATX is not set=0A=
+# CONFIG_MOMENCO_OCELOT is not set=0A=
+# CONFIG_MOMENCO_OCELOT_3 is not set=0A=
+# CONFIG_MOMENCO_OCELOT_C is not set=0A=
+# CONFIG_MOMENCO_OCELOT_G is not set=0A=
+# CONFIG_MIPS_XXS1500 is not set=0A=
+# CONFIG_PNX8550_V2PCI is not set=0A=
+# CONFIG_PNX8550_JBS is not set=0A=
+# CONFIG_DDB5074 is not set=0A=
+# CONFIG_DDB5476 is not set=0A=
+# CONFIG_DDB5477 is not set=0A=
+# CONFIG_MACH_VR41XX is not set=0A=
+# CONFIG_PMC_YOSEMITE is not set=0A=
+# CONFIG_QEMU is not set=0A=
+# CONFIG_SGI_IP22 is not set=0A=
+# CONFIG_SGI_IP27 is not set=0A=
+# CONFIG_SGI_IP32 is not set=0A=
+# CONFIG_SIBYTE_BIGSUR is not set=0A=
+# CONFIG_SIBYTE_SWARM is not set=0A=
+# CONFIG_SIBYTE_SENTOSA is not set=0A=
+# CONFIG_SIBYTE_RHONE is not set=0A=
+# CONFIG_SIBYTE_CARMEL is not set=0A=
+# CONFIG_SIBYTE_PTSWARM is not set=0A=
+# CONFIG_SIBYTE_LITTLESUR is not set=0A=
+# CONFIG_SIBYTE_CRHINE is not set=0A=
+# CONFIG_SIBYTE_CRHONE is not set=0A=
+# CONFIG_SNI_RM200_PCI is not set=0A=
+# CONFIG_TOSHIBA_JMR3927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4927 is not set=0A=
+# CONFIG_TOSHIBA_RBTX4938 is not set=0A=
+CONFIG_RWSEM_GENERIC_SPINLOCK=3Dy=0A=
+CONFIG_GENERIC_CALIBRATE_DELAY=3Dy=0A=
+CONFIG_DMA_NONCOHERENT=3Dy=0A=
+CONFIG_DMA_NEED_PCI_MAP_STATE=3Dy=0A=
+# CONFIG_CPU_BIG_ENDIAN is not set=0A=
+CONFIG_CPU_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=3Dy=0A=
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=3Dy=0A=
+CONFIG_IRQ_CPU=3Dy=0A=
+CONFIG_SWAP_IO_SPACE=3Dy=0A=
+CONFIG_BOOT_ELF32=3Dy=0A=
+CONFIG_MIPS_L1_CACHE_SHIFT=3D5=0A=
+=0A=
+#=0A=
+# CPU selection=0A=
+#=0A=
+CONFIG_CPU_MIPS32_R1=3Dy=0A=
+# CONFIG_CPU_MIPS32_R2 is not set=0A=
+# CONFIG_CPU_MIPS64_R1 is not set=0A=
+# CONFIG_CPU_MIPS64_R2 is not set=0A=
+# CONFIG_CPU_R3000 is not set=0A=
+# CONFIG_CPU_TX39XX is not set=0A=
+# CONFIG_CPU_VR41XX is not set=0A=
+# CONFIG_CPU_R4300 is not set=0A=
+# CONFIG_CPU_R4X00 is not set=0A=
+# CONFIG_CPU_TX49XX is not set=0A=
+# CONFIG_CPU_R5000 is not set=0A=
+# CONFIG_CPU_R5432 is not set=0A=
+# CONFIG_CPU_R6000 is not set=0A=
+# CONFIG_CPU_NEVADA is not set=0A=
+# CONFIG_CPU_R8000 is not set=0A=
+# CONFIG_CPU_R10000 is not set=0A=
+# CONFIG_CPU_RM7000 is not set=0A=
+# CONFIG_CPU_RM9000 is not set=0A=
+# CONFIG_CPU_SB1 is not set=0A=
+CONFIG_SYS_HAS_CPU_MIPS32_R1=3Dy=0A=
+CONFIG_SYS_HAS_CPU_R4X00=3Dy=0A=
+CONFIG_CPU_MIPS32=3Dy=0A=
+CONFIG_CPU_MIPSR1=3Dy=0A=
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=3Dy=0A=
+=0A=
+#=0A=
+# Kernel type=0A=
+#=0A=
+CONFIG_32BIT=3Dy=0A=
+# CONFIG_64BIT is not set=0A=
+CONFIG_PAGE_SIZE_4KB=3Dy=0A=
+# CONFIG_PAGE_SIZE_8KB is not set=0A=
+# CONFIG_PAGE_SIZE_16KB is not set=0A=
+# CONFIG_PAGE_SIZE_64KB is not set=0A=
+CONFIG_CPU_HAS_PREFETCH=3Dy=0A=
+CONFIG_MIPS_MT=3Dy=0A=
+# CONFIG_MIPS_MT_SMP is not set=0A=
+CONFIG_MIPS_VPE_LOADER=3Dy=0A=
+# CONFIG_MIPS_VPE_LOADER_TOM is not set=0A=
+# CONFIG_MIPS_VPE_APSP_API is not set=0A=
+# CONFIG_64BIT_PHYS_ADDR is not set=0A=
+# CONFIG_CPU_ADVANCED is not set=0A=
+CONFIG_CPU_HAS_LLSC=3Dy=0A=
+CONFIG_CPU_HAS_SYNC=3Dy=0A=
+CONFIG_GENERIC_HARDIRQS=3Dy=0A=
+CONFIG_GENERIC_IRQ_PROBE=3Dy=0A=
+CONFIG_ARCH_FLATMEM_ENABLE=3Dy=0A=
+CONFIG_SELECT_MEMORY_MODEL=3Dy=0A=
+CONFIG_FLATMEM_MANUAL=3Dy=0A=
+# CONFIG_DISCONTIGMEM_MANUAL is not set=0A=
+# CONFIG_SPARSEMEM_MANUAL is not set=0A=
+CONFIG_FLATMEM=3Dy=0A=
+CONFIG_FLAT_NODE_MEM_MAP=3Dy=0A=
+# CONFIG_SPARSEMEM_STATIC is not set=0A=
+CONFIG_PREEMPT_NONE=3Dy=0A=
+# CONFIG_PREEMPT_VOLUNTARY is not set=0A=
+# CONFIG_PREEMPT is not set=0A=
+=0A=
+#=0A=
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)=0A=
+#=0A=
+CONFIG_HW_HAS_PCI=3Dy=0A=
+CONFIG_PCI=3Dy=0A=
+CONFIG_PCI_LEGACY_PROC=3Dy=0A=
+CONFIG_MMU=3Dy=0A=
+=0A=
+#=0A=
+# PCCARD (PCMCIA/CardBus) support=0A=
+#=0A=
+# CONFIG_PCCARD is not set=0A=
+=0A=
+#=0A=
+# PCI Hotplug Support=0A=
+#=0A=
+# CONFIG_HOTPLUG_PCI is not set=0A=
+=0A=
+#=0A=
+# Executable file formats=0A=
+#=0A=
+CONFIG_BINFMT_ELF=3Dy=0A=
+# CONFIG_BINFMT_MISC is not set=0A=
+CONFIG_TRAD_SIGNALS=3Dy=0A=
+=0A=
+#=0A=
+# Networking=0A=
+#=0A=
+CONFIG_NET=3Dy=0A=
+=0A=
+#=0A=
+# Networking options=0A=
+#=0A=
+CONFIG_PACKET=3Dy=0A=
+CONFIG_PACKET_MMAP=3Dy=0A=
+CONFIG_UNIX=3Dy=0A=
+CONFIG_XFRM=3Dy=0A=
+CONFIG_XFRM_USER=3Dm=0A=
+CONFIG_NET_KEY=3Dy=0A=
+CONFIG_INET=3Dy=0A=
+CONFIG_IP_MULTICAST=3Dy=0A=
+CONFIG_IP_ADVANCED_ROUTER=3Dy=0A=
+CONFIG_ASK_IP_FIB_HASH=3Dy=0A=
+# CONFIG_IP_FIB_TRIE is not set=0A=
+CONFIG_IP_FIB_HASH=3Dy=0A=
+CONFIG_IP_MULTIPLE_TABLES=3Dy=0A=
+CONFIG_IP_ROUTE_FWMARK=3Dy=0A=
+CONFIG_IP_ROUTE_MULTIPATH=3Dy=0A=
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set=0A=
+CONFIG_IP_ROUTE_VERBOSE=3Dy=0A=
+CONFIG_IP_PNP=3Dy=0A=
+CONFIG_IP_PNP_DHCP=3Dy=0A=
+CONFIG_IP_PNP_BOOTP=3Dy=0A=
+# CONFIG_IP_PNP_RARP is not set=0A=
+# CONFIG_NET_IPIP is not set=0A=
+# CONFIG_NET_IPGRE is not set=0A=
+CONFIG_IP_MROUTE=3Dy=0A=
+CONFIG_IP_PIMSM_V1=3Dy=0A=
+CONFIG_IP_PIMSM_V2=3Dy=0A=
+# CONFIG_ARPD is not set=0A=
+CONFIG_SYN_COOKIES=3Dy=0A=
+CONFIG_INET_AH=3Dm=0A=
+CONFIG_INET_ESP=3Dm=0A=
+CONFIG_INET_IPCOMP=3Dm=0A=
+CONFIG_INET_TUNNEL=3Dm=0A=
+CONFIG_INET_DIAG=3Dy=0A=
+CONFIG_INET_TCP_DIAG=3Dy=0A=
+# CONFIG_TCP_CONG_ADVANCED is not set=0A=
+CONFIG_TCP_CONG_BIC=3Dy=0A=
+=0A=
+#=0A=
+# IP: Virtual Server Configuration=0A=
+#=0A=
+CONFIG_IP_VS=3Dm=0A=
+# CONFIG_IP_VS_DEBUG is not set=0A=
+CONFIG_IP_VS_TAB_BITS=3D12=0A=
+=0A=
+#=0A=
+# IPVS transport protocol load balancing support=0A=
+#=0A=
+CONFIG_IP_VS_PROTO_TCP=3Dy=0A=
+CONFIG_IP_VS_PROTO_UDP=3Dy=0A=
+CONFIG_IP_VS_PROTO_ESP=3Dy=0A=
+CONFIG_IP_VS_PROTO_AH=3Dy=0A=
+=0A=
+#=0A=
+# IPVS scheduler=0A=
+#=0A=
+CONFIG_IP_VS_RR=3Dm=0A=
+CONFIG_IP_VS_WRR=3Dm=0A=
+CONFIG_IP_VS_LC=3Dm=0A=
+CONFIG_IP_VS_WLC=3Dm=0A=
+CONFIG_IP_VS_LBLC=3Dm=0A=
+CONFIG_IP_VS_LBLCR=3Dm=0A=
+CONFIG_IP_VS_DH=3Dm=0A=
+CONFIG_IP_VS_SH=3Dm=0A=
+CONFIG_IP_VS_SED=3Dm=0A=
+CONFIG_IP_VS_NQ=3Dm=0A=
+=0A=
+#=0A=
+# IPVS application helper=0A=
+#=0A=
+CONFIG_IP_VS_FTP=3Dm=0A=
+# CONFIG_IPV6 is not set=0A=
+CONFIG_NETFILTER=3Dy=0A=
+# CONFIG_NETFILTER_DEBUG is not set=0A=
+CONFIG_NETFILTER_NETLINK=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_QUEUE=3Dm=0A=
+CONFIG_NETFILTER_NETLINK_LOG=3Dm=0A=
+=0A=
+#=0A=
+# IP: Netfilter Configuration=0A=
+#=0A=
+CONFIG_IP_NF_CONNTRACK=3Dm=0A=
+CONFIG_IP_NF_CT_ACCT=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_MARK=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_EVENTS=3Dy=0A=
+CONFIG_IP_NF_CONNTRACK_NETLINK=3Dm=0A=
+CONFIG_IP_NF_CT_PROTO_SCTP=3Dm=0A=
+CONFIG_IP_NF_FTP=3Dm=0A=
+CONFIG_IP_NF_IRC=3Dm=0A=
+# CONFIG_IP_NF_NETBIOS_NS is not set=0A=
+CONFIG_IP_NF_TFTP=3Dm=0A=
+CONFIG_IP_NF_AMANDA=3Dm=0A=
+CONFIG_IP_NF_PPTP=3Dm=0A=
+CONFIG_IP_NF_QUEUE=3Dm=0A=
+CONFIG_IP_NF_IPTABLES=3Dm=0A=
+CONFIG_IP_NF_MATCH_LIMIT=3Dm=0A=
+CONFIG_IP_NF_MATCH_IPRANGE=3Dm=0A=
+CONFIG_IP_NF_MATCH_MAC=3Dm=0A=
+CONFIG_IP_NF_MATCH_PKTTYPE=3Dm=0A=
+CONFIG_IP_NF_MATCH_MARK=3Dm=0A=
+CONFIG_IP_NF_MATCH_MULTIPORT=3Dm=0A=
+CONFIG_IP_NF_MATCH_TOS=3Dm=0A=
+CONFIG_IP_NF_MATCH_RECENT=3Dm=0A=
+CONFIG_IP_NF_MATCH_ECN=3Dm=0A=
+CONFIG_IP_NF_MATCH_DSCP=3Dm=0A=
+CONFIG_IP_NF_MATCH_AH_ESP=3Dm=0A=
+CONFIG_IP_NF_MATCH_LENGTH=3Dm=0A=
+CONFIG_IP_NF_MATCH_TTL=3Dm=0A=
+CONFIG_IP_NF_MATCH_TCPMSS=3Dm=0A=
+CONFIG_IP_NF_MATCH_HELPER=3Dm=0A=
+CONFIG_IP_NF_MATCH_STATE=3Dm=0A=
+CONFIG_IP_NF_MATCH_CONNTRACK=3Dm=0A=
+CONFIG_IP_NF_MATCH_OWNER=3Dm=0A=
+CONFIG_IP_NF_MATCH_ADDRTYPE=3Dm=0A=
+CONFIG_IP_NF_MATCH_REALM=3Dm=0A=
+CONFIG_IP_NF_MATCH_SCTP=3Dm=0A=
+CONFIG_IP_NF_MATCH_DCCP=3Dm=0A=
+CONFIG_IP_NF_MATCH_COMMENT=3Dm=0A=
+CONFIG_IP_NF_MATCH_CONNMARK=3Dm=0A=
+CONFIG_IP_NF_MATCH_CONNBYTES=3Dm=0A=
+CONFIG_IP_NF_MATCH_HASHLIMIT=3Dm=0A=
+CONFIG_IP_NF_MATCH_STRING=3Dm=0A=
+CONFIG_IP_NF_FILTER=3Dm=0A=
+CONFIG_IP_NF_TARGET_REJECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_LOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_ULOG=3Dm=0A=
+CONFIG_IP_NF_TARGET_TCPMSS=3Dm=0A=
+CONFIG_IP_NF_TARGET_NFQUEUE=3Dm=0A=
+CONFIG_IP_NF_NAT=3Dm=0A=
+CONFIG_IP_NF_NAT_NEEDED=3Dy=0A=
+CONFIG_IP_NF_TARGET_MASQUERADE=3Dm=0A=
+CONFIG_IP_NF_TARGET_REDIRECT=3Dm=0A=
+CONFIG_IP_NF_TARGET_NETMAP=3Dm=0A=
+CONFIG_IP_NF_TARGET_SAME=3Dm=0A=
+CONFIG_IP_NF_NAT_SNMP_BASIC=3Dm=0A=
+CONFIG_IP_NF_NAT_IRC=3Dm=0A=
+CONFIG_IP_NF_NAT_FTP=3Dm=0A=
+CONFIG_IP_NF_NAT_TFTP=3Dm=0A=
+CONFIG_IP_NF_NAT_AMANDA=3Dm=0A=
+CONFIG_IP_NF_NAT_PPTP=3Dm=0A=
+CONFIG_IP_NF_MANGLE=3Dm=0A=
+CONFIG_IP_NF_TARGET_TOS=3Dm=0A=
+CONFIG_IP_NF_TARGET_ECN=3Dm=0A=
+CONFIG_IP_NF_TARGET_DSCP=3Dm=0A=
+CONFIG_IP_NF_TARGET_MARK=3Dm=0A=
+CONFIG_IP_NF_TARGET_CLASSIFY=3Dm=0A=
+CONFIG_IP_NF_TARGET_TTL=3Dm=0A=
+CONFIG_IP_NF_TARGET_CONNMARK=3Dm=0A=
+CONFIG_IP_NF_TARGET_CLUSTERIP=3Dm=0A=
+CONFIG_IP_NF_RAW=3Dm=0A=
+CONFIG_IP_NF_TARGET_NOTRACK=3Dm=0A=
+CONFIG_IP_NF_ARPTABLES=3Dm=0A=
+CONFIG_IP_NF_ARPFILTER=3Dm=0A=
+CONFIG_IP_NF_ARP_MANGLE=3Dm=0A=
+=0A=
+#=0A=
+# DCCP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+# CONFIG_IP_DCCP is not set=0A=
+=0A=
+#=0A=
+# SCTP Configuration (EXPERIMENTAL)=0A=
+#=0A=
+CONFIG_IP_SCTP=3Dm=0A=
+# CONFIG_SCTP_DBG_MSG is not set=0A=
+# CONFIG_SCTP_DBG_OBJCNT is not set=0A=
+# CONFIG_SCTP_HMAC_NONE is not set=0A=
+# CONFIG_SCTP_HMAC_SHA1 is not set=0A=
+CONFIG_SCTP_HMAC_MD5=3Dy=0A=
+# CONFIG_ATM is not set=0A=
+# CONFIG_BRIDGE is not set=0A=
+# CONFIG_VLAN_8021Q is not set=0A=
+# CONFIG_DECNET is not set=0A=
+CONFIG_LLC=3Dm=0A=
+# CONFIG_LLC2 is not set=0A=
+# CONFIG_IPX is not set=0A=
+CONFIG_ATALK=3Dm=0A=
+CONFIG_DEV_APPLETALK=3Dy=0A=
+CONFIG_IPDDP=3Dm=0A=
+CONFIG_IPDDP_ENCAP=3Dy=0A=
+CONFIG_IPDDP_DECAP=3Dy=0A=
+# CONFIG_X25 is not set=0A=
+# CONFIG_LAPB is not set=0A=
+CONFIG_NET_DIVERT=3Dy=0A=
+# CONFIG_ECONET is not set=0A=
+# CONFIG_WAN_ROUTER is not set=0A=
+CONFIG_NET_SCHED=3Dy=0A=
+CONFIG_NET_SCH_CLK_JIFFIES=3Dy=0A=
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set=0A=
+# CONFIG_NET_SCH_CLK_CPU is not set=0A=
+CONFIG_NET_SCH_CBQ=3Dm=0A=
+CONFIG_NET_SCH_HTB=3Dm=0A=
+CONFIG_NET_SCH_HFSC=3Dm=0A=
+CONFIG_NET_SCH_PRIO=3Dm=0A=
+CONFIG_NET_SCH_RED=3Dm=0A=
+CONFIG_NET_SCH_SFQ=3Dm=0A=
+CONFIG_NET_SCH_TEQL=3Dm=0A=
+CONFIG_NET_SCH_TBF=3Dm=0A=
+CONFIG_NET_SCH_GRED=3Dm=0A=
+CONFIG_NET_SCH_DSMARK=3Dm=0A=
+CONFIG_NET_SCH_NETEM=3Dm=0A=
+CONFIG_NET_SCH_INGRESS=3Dm=0A=
+CONFIG_NET_QOS=3Dy=0A=
+CONFIG_NET_ESTIMATOR=3Dy=0A=
+CONFIG_NET_CLS=3Dy=0A=
+CONFIG_NET_CLS_BASIC=3Dm=0A=
+CONFIG_NET_CLS_TCINDEX=3Dm=0A=
+CONFIG_NET_CLS_ROUTE4=3Dm=0A=
+CONFIG_NET_CLS_ROUTE=3Dy=0A=
+CONFIG_NET_CLS_FW=3Dm=0A=
+CONFIG_NET_CLS_U32=3Dm=0A=
+# CONFIG_CLS_U32_PERF is not set=0A=
+CONFIG_NET_CLS_IND=3Dy=0A=
+# CONFIG_CLS_U32_MARK is not set=0A=
+# CONFIG_NET_CLS_RSVP is not set=0A=
+# CONFIG_NET_CLS_RSVP6 is not set=0A=
+# CONFIG_NET_EMATCH is not set=0A=
+# CONFIG_NET_CLS_ACT is not set=0A=
+CONFIG_NET_CLS_POLICE=3Dy=0A=
+=0A=
+#=0A=
+# Network testing=0A=
+#=0A=
+# CONFIG_NET_PKTGEN is not set=0A=
+# CONFIG_HAMRADIO is not set=0A=
+# CONFIG_IRDA is not set=0A=
+# CONFIG_BT is not set=0A=
+# CONFIG_IEEE80211 is not set=0A=
+=0A=
+#=0A=
+# Device Drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Generic Driver Options=0A=
+#=0A=
+CONFIG_STANDALONE=3Dy=0A=
+CONFIG_PREVENT_FIRMWARE_BUILD=3Dy=0A=
+# CONFIG_FW_LOADER is not set=0A=
+=0A=
+#=0A=
+# Connector - unified userspace <-> kernelspace linker=0A=
+#=0A=
+# CONFIG_CONNECTOR is not set=0A=
+=0A=
+#=0A=
+# Memory Technology Devices (MTD)=0A=
+#=0A=
+# CONFIG_MTD is not set=0A=
+=0A=
+#=0A=
+# Parallel port support=0A=
+#=0A=
+# CONFIG_PARPORT is not set=0A=
+=0A=
+#=0A=
+# Plug and Play support=0A=
+#=0A=
+=0A=
+#=0A=
+# Block devices=0A=
+#=0A=
+# CONFIG_BLK_CPQ_DA is not set=0A=
+# CONFIG_BLK_CPQ_CISS_DA is not set=0A=
+# CONFIG_BLK_DEV_DAC960 is not set=0A=
+# CONFIG_BLK_DEV_UMEM is not set=0A=
+# CONFIG_BLK_DEV_COW_COMMON is not set=0A=
+CONFIG_BLK_DEV_LOOP=3Dy=0A=
+CONFIG_BLK_DEV_CRYPTOLOOP=3Dm=0A=
+# CONFIG_BLK_DEV_NBD is not set=0A=
+# CONFIG_BLK_DEV_SX8 is not set=0A=
+CONFIG_BLK_DEV_RAM=3Dy=0A=
+CONFIG_BLK_DEV_RAM_COUNT=3D16=0A=
+CONFIG_BLK_DEV_RAM_SIZE=3D8192=0A=
+CONFIG_BLK_DEV_INITRD=3Dy=0A=
+# CONFIG_LBD is not set=0A=
+# CONFIG_CDROM_PKTCDVD is not set=0A=
+=0A=
+#=0A=
+# IO Schedulers=0A=
+#=0A=
+CONFIG_IOSCHED_NOOP=3Dy=0A=
+CONFIG_IOSCHED_AS=3Dy=0A=
+CONFIG_IOSCHED_DEADLINE=3Dy=0A=
+CONFIG_IOSCHED_CFQ=3Dy=0A=
+# CONFIG_ATA_OVER_ETH is not set=0A=
+=0A=
+#=0A=
+# ATA/ATAPI/MFM/RLL support=0A=
+#=0A=
+# CONFIG_IDE is not set=0A=
+=0A=
+#=0A=
+# SCSI device support=0A=
+#=0A=
+# CONFIG_RAID_ATTRS is not set=0A=
+# CONFIG_SCSI is not set=0A=
+=0A=
+#=0A=
+# Multi-device support (RAID and LVM)=0A=
+#=0A=
+# CONFIG_MD is not set=0A=
+=0A=
+#=0A=
+# Fusion MPT device support=0A=
+#=0A=
+# CONFIG_FUSION is not set=0A=
+=0A=
+#=0A=
+# IEEE 1394 (FireWire) support=0A=
+#=0A=
+# CONFIG_IEEE1394 is not set=0A=
+=0A=
+#=0A=
+# I2O device support=0A=
+#=0A=
+# CONFIG_I2O is not set=0A=
+=0A=
+#=0A=
+# Network device support=0A=
+#=0A=
+CONFIG_NETDEVICES=3Dy=0A=
+# CONFIG_DUMMY is not set=0A=
+# CONFIG_BONDING is not set=0A=
+# CONFIG_EQUALIZER is not set=0A=
+# CONFIG_TUN is not set=0A=
+=0A=
+#=0A=
+# ARCnet devices=0A=
+#=0A=
+# CONFIG_ARCNET is not set=0A=
+=0A=
+#=0A=
+# PHY device support=0A=
+#=0A=
+CONFIG_PHYLIB=3Dy=0A=
+CONFIG_PHYCONTROL=3Dy=0A=
+=0A=
+#=0A=
+# MII PHY device drivers=0A=
+#=0A=
+CONFIG_MARVELL_PHY=3Dm=0A=
+CONFIG_DAVICOM_PHY=3Dm=0A=
+CONFIG_QSEMI_PHY=3Dm=0A=
+CONFIG_LXT_PHY=3Dy=0A=
+CONFIG_CICADA_PHY=3Dm=0A=
+=0A=
+#=0A=
+# Ethernet (10 or 100Mbit)=0A=
+#=0A=
+CONFIG_NET_ETHERNET=3Dy=0A=
+CONFIG_MII=3Dy=0A=
+CONFIG_IDT_RC32438_ETH=3Dy=0A=
+# CONFIG_HAPPYMEAL is not set=0A=
+# CONFIG_SUNGEM is not set=0A=
+# CONFIG_CASSINI is not set=0A=
+# CONFIG_NET_VENDOR_3COM is not set=0A=
+=0A=
+#=0A=
+# Tulip family network device support=0A=
+#=0A=
+# CONFIG_NET_TULIP is not set=0A=
+# CONFIG_HP100 is not set=0A=
+CONFIG_NET_PCI=3Dy=0A=
+# CONFIG_PCNET32 is not set=0A=
+# CONFIG_AMD8111_ETH is not set=0A=
+# CONFIG_ADAPTEC_STARFIRE is not set=0A=
+# CONFIG_B44 is not set=0A=
+# CONFIG_FORCEDETH is not set=0A=
+# CONFIG_DGRS is not set=0A=
+# CONFIG_EEPRO100 is not set=0A=
+CONFIG_E100=3Dy=0A=
+# CONFIG_FEALNX is not set=0A=
+# CONFIG_NATSEMI is not set=0A=
+# CONFIG_NE2K_PCI is not set=0A=
+# CONFIG_8139CP is not set=0A=
+# CONFIG_8139TOO is not set=0A=
+# CONFIG_SIS900 is not set=0A=
+# CONFIG_EPIC100 is not set=0A=
+# CONFIG_SUNDANCE is not set=0A=
+# CONFIG_TLAN is not set=0A=
+# CONFIG_VIA_RHINE is not set=0A=
+# CONFIG_LAN_SAA9730 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (1000 Mbit)=0A=
+#=0A=
+# CONFIG_ACENIC is not set=0A=
+# CONFIG_DL2K is not set=0A=
+# CONFIG_E1000 is not set=0A=
+# CONFIG_NS83820 is not set=0A=
+# CONFIG_HAMACHI is not set=0A=
+# CONFIG_YELLOWFIN is not set=0A=
+# CONFIG_R8169 is not set=0A=
+# CONFIG_SIS190 is not set=0A=
+# CONFIG_SKGE is not set=0A=
+# CONFIG_SK98LIN is not set=0A=
+# CONFIG_VIA_VELOCITY is not set=0A=
+# CONFIG_TIGON3 is not set=0A=
+# CONFIG_BNX2 is not set=0A=
+=0A=
+#=0A=
+# Ethernet (10000 Mbit)=0A=
+#=0A=
+# CONFIG_CHELSIO_T1 is not set=0A=
+# CONFIG_IXGB is not set=0A=
+# CONFIG_S2IO is not set=0A=
+=0A=
+#=0A=
+# Token Ring devices=0A=
+#=0A=
+# CONFIG_TR is not set=0A=
+=0A=
+#=0A=
+# Wireless LAN (non-hamradio)=0A=
+#=0A=
+# CONFIG_NET_RADIO is not set=0A=
+=0A=
+#=0A=
+# Wan interfaces=0A=
+#=0A=
+# CONFIG_WAN is not set=0A=
+# CONFIG_FDDI is not set=0A=
+# CONFIG_HIPPI is not set=0A=
+# CONFIG_PPP is not set=0A=
+# CONFIG_SLIP is not set=0A=
+# CONFIG_SHAPER is not set=0A=
+# CONFIG_NETCONSOLE is not set=0A=
+# CONFIG_NETPOLL is not set=0A=
+# CONFIG_NET_POLL_CONTROLLER is not set=0A=
+=0A=
+#=0A=
+# ISDN subsystem=0A=
+#=0A=
+# CONFIG_ISDN is not set=0A=
+=0A=
+#=0A=
+# Telephony Support=0A=
+#=0A=
+# CONFIG_PHONE is not set=0A=
+=0A=
+#=0A=
+# Input device support=0A=
+#=0A=
+CONFIG_INPUT=3Dy=0A=
+=0A=
+#=0A=
+# Userland interfaces=0A=
+#=0A=
+# CONFIG_INPUT_MOUSEDEV is not set=0A=
+# CONFIG_INPUT_JOYDEV is not set=0A=
+# CONFIG_INPUT_TSDEV is not set=0A=
+# CONFIG_INPUT_EVDEV is not set=0A=
+# CONFIG_INPUT_EVBUG is not set=0A=
+=0A=
+#=0A=
+# Input Device Drivers=0A=
+#=0A=
+# CONFIG_INPUT_KEYBOARD is not set=0A=
+# CONFIG_INPUT_MOUSE is not set=0A=
+# CONFIG_INPUT_JOYSTICK is not set=0A=
+# CONFIG_INPUT_TOUCHSCREEN is not set=0A=
+# CONFIG_INPUT_MISC is not set=0A=
+=0A=
+#=0A=
+# Hardware I/O ports=0A=
+#=0A=
+# CONFIG_SERIO is not set=0A=
+# CONFIG_GAMEPORT is not set=0A=
+=0A=
+#=0A=
+# Character devices=0A=
+#=0A=
+CONFIG_VT=3Dy=0A=
+CONFIG_VT_CONSOLE=3Dy=0A=
+CONFIG_HW_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_NONSTANDARD is not set=0A=
+=0A=
+#=0A=
+# Serial drivers=0A=
+#=0A=
+CONFIG_SERIAL_8250=3Dy=0A=
+CONFIG_SERIAL_8250_CONSOLE=3Dy=0A=
+CONFIG_SERIAL_8250_NR_UARTS=3D4=0A=
+# CONFIG_SERIAL_8250_EXTENDED is not set=0A=
+=0A=
+#=0A=
+# Non-8250 serial port support=0A=
+#=0A=
+CONFIG_SERIAL_CORE=3Dy=0A=
+CONFIG_SERIAL_CORE_CONSOLE=3Dy=0A=
+# CONFIG_SERIAL_JSM is not set=0A=
+CONFIG_UNIX98_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTYS=3Dy=0A=
+CONFIG_LEGACY_PTY_COUNT=3D256=0A=
+=0A=
+#=0A=
+# IPMI=0A=
+#=0A=
+# CONFIG_IPMI_HANDLER is not set=0A=
+=0A=
+#=0A=
+# Watchdog Cards=0A=
+#=0A=
+# CONFIG_WATCHDOG is not set=0A=
+# CONFIG_RTC is not set=0A=
+# CONFIG_GEN_RTC is not set=0A=
+# CONFIG_DTLK is not set=0A=
+# CONFIG_R3964 is not set=0A=
+# CONFIG_APPLICOM is not set=0A=
+=0A=
+#=0A=
+# Ftape, the floppy tape device driver=0A=
+#=0A=
+# CONFIG_DRM is not set=0A=
+# CONFIG_RAW_DRIVER is not set=0A=
+=0A=
+#=0A=
+# TPM devices=0A=
+#=0A=
+# CONFIG_TCG_TPM is not set=0A=
+=0A=
+#=0A=
+# I2C support=0A=
+#=0A=
+# CONFIG_I2C is not set=0A=
+=0A=
+#=0A=
+# Dallas's 1-wire bus=0A=
+#=0A=
+# CONFIG_W1 is not set=0A=
+=0A=
+#=0A=
+# Hardware Monitoring support=0A=
+#=0A=
+# CONFIG_HWMON is not set=0A=
+# CONFIG_HWMON_VID is not set=0A=
+=0A=
+#=0A=
+# Misc devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia Capabilities Port drivers=0A=
+#=0A=
+=0A=
+#=0A=
+# Multimedia devices=0A=
+#=0A=
+# CONFIG_VIDEO_DEV is not set=0A=
+=0A=
+#=0A=
+# Digital Video Broadcasting Devices=0A=
+#=0A=
+# CONFIG_DVB is not set=0A=
+=0A=
+#=0A=
+# Graphics support=0A=
+#=0A=
+# CONFIG_FB is not set=0A=
+=0A=
+#=0A=
+# Console display driver support=0A=
+#=0A=
+# CONFIG_VGA_CONSOLE is not set=0A=
+CONFIG_DUMMY_CONSOLE=3Dy=0A=
+=0A=
+#=0A=
+# Sound=0A=
+#=0A=
+# CONFIG_SOUND is not set=0A=
+=0A=
+#=0A=
+# USB support=0A=
+#=0A=
+CONFIG_USB_ARCH_HAS_HCD=3Dy=0A=
+CONFIG_USB_ARCH_HAS_OHCI=3Dy=0A=
+# CONFIG_USB is not set=0A=
+=0A=
+#=0A=
+# USB Gadget Support=0A=
+#=0A=
+# CONFIG_USB_GADGET is not set=0A=
+=0A=
+#=0A=
+# MMC/SD Card support=0A=
+#=0A=
+# CONFIG_MMC is not set=0A=
+=0A=
+#=0A=
+# InfiniBand support=0A=
+#=0A=
+# CONFIG_INFINIBAND is not set=0A=
+=0A=
+#=0A=
+# SN Devices=0A=
+#=0A=
+=0A=
+#=0A=
+# File systems=0A=
+#=0A=
+CONFIG_EXT2_FS=3Dy=0A=
+# CONFIG_EXT2_FS_XATTR is not set=0A=
+# CONFIG_EXT2_FS_XIP is not set=0A=
+# CONFIG_EXT3_FS is not set=0A=
+# CONFIG_JBD is not set=0A=
+# CONFIG_REISERFS_FS is not set=0A=
+# CONFIG_JFS_FS is not set=0A=
+# CONFIG_FS_POSIX_ACL is not set=0A=
+# CONFIG_XFS_FS is not set=0A=
+# CONFIG_MINIX_FS is not set=0A=
+# CONFIG_ROMFS_FS is not set=0A=
+# CONFIG_INOTIFY is not set=0A=
+# CONFIG_QUOTA is not set=0A=
+# CONFIG_DNOTIFY is not set=0A=
+# CONFIG_AUTOFS_FS is not set=0A=
+# CONFIG_AUTOFS4_FS is not set=0A=
+# CONFIG_FUSE_FS is not set=0A=
+=0A=
+#=0A=
+# CD-ROM/DVD Filesystems=0A=
+#=0A=
+CONFIG_ISO9660_FS=3Dm=0A=
+CONFIG_JOLIET=3Dy=0A=
+CONFIG_ZISOFS=3Dy=0A=
+CONFIG_ZISOFS_FS=3Dm=0A=
+CONFIG_UDF_FS=3Dm=0A=
+CONFIG_UDF_NLS=3Dy=0A=
+=0A=
+#=0A=
+# DOS/FAT/NT Filesystems=0A=
+#=0A=
+CONFIG_FAT_FS=3Dm=0A=
+CONFIG_MSDOS_FS=3Dm=0A=
+CONFIG_VFAT_FS=3Dm=0A=
+CONFIG_FAT_DEFAULT_CODEPAGE=3D437=0A=
+CONFIG_FAT_DEFAULT_IOCHARSET=3D"iso8859-1"=0A=
+# CONFIG_NTFS_FS is not set=0A=
+=0A=
+#=0A=
+# Pseudo filesystems=0A=
+#=0A=
+CONFIG_PROC_FS=3Dy=0A=
+CONFIG_PROC_KCORE=3Dy=0A=
+CONFIG_SYSFS=3Dy=0A=
+# CONFIG_TMPFS is not set=0A=
+# CONFIG_HUGETLB_PAGE is not set=0A=
+CONFIG_RAMFS=3Dy=0A=
+CONFIG_RELAYFS_FS=3Dm=0A=
+=0A=
+#=0A=
+# Miscellaneous filesystems=0A=
+#=0A=
+# CONFIG_ADFS_FS is not set=0A=
+# CONFIG_AFFS_FS is not set=0A=
+# CONFIG_HFS_FS is not set=0A=
+# CONFIG_HFSPLUS_FS is not set=0A=
+# CONFIG_BEFS_FS is not set=0A=
+# CONFIG_BFS_FS is not set=0A=
+# CONFIG_EFS_FS is not set=0A=
+# CONFIG_CRAMFS is not set=0A=
+# CONFIG_VXFS_FS is not set=0A=
+# CONFIG_HPFS_FS is not set=0A=
+# CONFIG_QNX4FS_FS is not set=0A=
+# CONFIG_SYSV_FS is not set=0A=
+# CONFIG_UFS_FS is not set=0A=
+=0A=
+#=0A=
+# Network File Systems=0A=
+#=0A=
+# CONFIG_NFS_FS is not set=0A=
+# CONFIG_NFSD is not set=0A=
+# CONFIG_SMB_FS is not set=0A=
+# CONFIG_CIFS is not set=0A=
+# CONFIG_NCP_FS is not set=0A=
+# CONFIG_CODA_FS is not set=0A=
+# CONFIG_AFS_FS is not set=0A=
+# CONFIG_9P_FS is not set=0A=
+=0A=
+#=0A=
+# Partition Types=0A=
+#=0A=
+# CONFIG_PARTITION_ADVANCED is not set=0A=
+CONFIG_MSDOS_PARTITION=3Dy=0A=
+=0A=
+#=0A=
+# Native Language Support=0A=
+#=0A=
+CONFIG_NLS=3Dm=0A=
+CONFIG_NLS_DEFAULT=3D"iso8859-1"=0A=
+CONFIG_NLS_CODEPAGE_437=3Dm=0A=
+CONFIG_NLS_CODEPAGE_737=3Dm=0A=
+CONFIG_NLS_CODEPAGE_775=3Dm=0A=
+CONFIG_NLS_CODEPAGE_850=3Dm=0A=
+CONFIG_NLS_CODEPAGE_852=3Dm=0A=
+CONFIG_NLS_CODEPAGE_855=3Dm=0A=
+CONFIG_NLS_CODEPAGE_857=3Dm=0A=
+CONFIG_NLS_CODEPAGE_860=3Dm=0A=
+CONFIG_NLS_CODEPAGE_861=3Dm=0A=
+CONFIG_NLS_CODEPAGE_862=3Dm=0A=
+CONFIG_NLS_CODEPAGE_863=3Dm=0A=
+CONFIG_NLS_CODEPAGE_864=3Dm=0A=
+CONFIG_NLS_CODEPAGE_865=3Dm=0A=
+CONFIG_NLS_CODEPAGE_866=3Dm=0A=
+CONFIG_NLS_CODEPAGE_869=3Dm=0A=
+CONFIG_NLS_CODEPAGE_936=3Dm=0A=
+CONFIG_NLS_CODEPAGE_950=3Dm=0A=
+CONFIG_NLS_CODEPAGE_932=3Dm=0A=
+CONFIG_NLS_CODEPAGE_949=3Dm=0A=
+CONFIG_NLS_CODEPAGE_874=3Dm=0A=
+CONFIG_NLS_ISO8859_8=3Dm=0A=
+CONFIG_NLS_CODEPAGE_1250=3Dm=0A=
+CONFIG_NLS_CODEPAGE_1251=3Dm=0A=
+CONFIG_NLS_ASCII=3Dm=0A=
+CONFIG_NLS_ISO8859_1=3Dm=0A=
+CONFIG_NLS_ISO8859_2=3Dm=0A=
+CONFIG_NLS_ISO8859_3=3Dm=0A=
+CONFIG_NLS_ISO8859_4=3Dm=0A=
+CONFIG_NLS_ISO8859_5=3Dm=0A=
+CONFIG_NLS_ISO8859_6=3Dm=0A=
+CONFIG_NLS_ISO8859_7=3Dm=0A=
+CONFIG_NLS_ISO8859_9=3Dm=0A=
+CONFIG_NLS_ISO8859_13=3Dm=0A=
+CONFIG_NLS_ISO8859_14=3Dm=0A=
+CONFIG_NLS_ISO8859_15=3Dm=0A=
+CONFIG_NLS_KOI8_R=3Dm=0A=
+CONFIG_NLS_KOI8_U=3Dm=0A=
+CONFIG_NLS_UTF8=3Dm=0A=
+=0A=
+#=0A=
+# Profiling support=0A=
+#=0A=
+# CONFIG_PROFILING is not set=0A=
+=0A=
+#=0A=
+# Kernel hacking=0A=
+#=0A=
+# CONFIG_PRINTK_TIME is not set=0A=
+# CONFIG_DEBUG_KERNEL is not set=0A=
+CONFIG_LOG_BUF_SHIFT=3D14=0A=
+CONFIG_CROSSCOMPILE=3Dy=0A=
+CONFIG_CMDLINE=3D""=0A=
+=0A=
+#=0A=
+# Security options=0A=
+#=0A=
+# CONFIG_KEYS is not set=0A=
+# CONFIG_SECURITY is not set=0A=
+=0A=
+#=0A=
+# Cryptographic options=0A=
+#=0A=
+CONFIG_CRYPTO=3Dy=0A=
+CONFIG_CRYPTO_HMAC=3Dy=0A=
+# CONFIG_CRYPTO_NULL is not set=0A=
+# CONFIG_CRYPTO_MD4 is not set=0A=
+CONFIG_CRYPTO_MD5=3Dm=0A=
+CONFIG_CRYPTO_SHA1=3Dy=0A=
+CONFIG_CRYPTO_SHA256=3Dm=0A=
+CONFIG_CRYPTO_SHA512=3Dm=0A=
+CONFIG_CRYPTO_WP512=3Dm=0A=
+CONFIG_CRYPTO_TGR192=3Dm=0A=
+CONFIG_CRYPTO_DES=3Dm=0A=
+CONFIG_CRYPTO_BLOWFISH=3Dm=0A=
+CONFIG_CRYPTO_TWOFISH=3Dm=0A=
+CONFIG_CRYPTO_SERPENT=3Dm=0A=
+CONFIG_CRYPTO_AES=3Dm=0A=
+CONFIG_CRYPTO_CAST5=3Dm=0A=
+CONFIG_CRYPTO_CAST6=3Dm=0A=
+CONFIG_CRYPTO_TEA=3Dm=0A=
+CONFIG_CRYPTO_ARC4=3Dm=0A=
+CONFIG_CRYPTO_KHAZAD=3Dm=0A=
+CONFIG_CRYPTO_ANUBIS=3Dm=0A=
+CONFIG_CRYPTO_DEFLATE=3Dm=0A=
+CONFIG_CRYPTO_MICHAEL_MIC=3Dm=0A=
+CONFIG_CRYPTO_CRC32C=3Dm=0A=
+# CONFIG_CRYPTO_TEST is not set=0A=
+=0A=
+#=0A=
+# Hardware crypto devices=0A=
+#=0A=
+=0A=
+#=0A=
+# Library routines=0A=
+#=0A=
+# CONFIG_CRC_CCITT is not set=0A=
+CONFIG_CRC16=3Dy=0A=
+CONFIG_CRC32=3Dy=0A=
+CONFIG_LIBCRC32C=3Dy=0A=
+CONFIG_ZLIB_INFLATE=3Dm=0A=
+CONFIG_ZLIB_DEFLATE=3Dm=0A=
+CONFIG_TEXTSEARCH=3Dy=0A=
+CONFIG_TEXTSEARCH_KMP=3Dm=0A=
+CONFIG_TEXTSEARCH_BM=3Dm=0A=
+CONFIG_TEXTSEARCH_FSM=3Dm=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/csu_idt.S =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/csu_idt.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/csu_idt.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/csu_idt.S	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,414 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialization code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+=0A=
+#include "idthdr.h"=0A=
+#include "iregdef.h"=0A=
+#include "idtcpu.h"=0A=
+#include "s438ram.h"=0A=
+#include "s438.h"=0A=
+=0A=
+/*--------------------------------------------------------------=0A=
+** prom entry point table=0A=
+*-------------------------------------------------------------*/=0A=
+=0A=
+FRAME(start,sp,0,ra)=0A=
+	j idtstart        /* begin monitor from start       |00| */=0A=
+=0A=
+idtstart:=0A=
+=0A=
+  .set  noreorder=0A=
+/* ------ Alternate functions for GPIO pins =
--------------------------------*/=0A=
+/* Neb: only UART0, UART1 and mem_addr */=0A=
+	li    t0, GPIO_BASE=0A=
+	li    t1, 0x00f00303=0A=
+	sw    t1, 0x0(t0)=0A=
+      =0A=
+	mtc0  zero, C0_CAUSE=0A=
+        nop=0A=
+	li    v0, 0x0=0A=
+	or    v0, (SR_CU0 | SR_BEV)=0A=
+	mtc0  v0, C0_SR=0A=
+        nop=0A=
+	mfc0  v1, C0_CONFIG=0A=
+	nop=0A=
+	and   v1, ~(0x7)=0A=
+	ori   v1, 0x3=0A=
+	mtc0  v1, C0_CONFIG=0A=
+        nop=0A=
+        nop=0A=
+            =0A=
+/* ------------------- Disable WatchDog Timer =
----------------------------- */=0A=
+      li    t0, WTC_BASE=0A=
+      li    t1, 0x0=0A=
+      sw    t1, 0x3C(t0) /* WTC */=0A=
+=0A=
+/* ------------- Clear PCI Local Base Control registers =
------------------- */=0A=
+      li    t0, 0xb8080000=0A=
+      sw    zero, 0x18(t0)=0A=
+      sw    zero, 0x24(t0)=0A=
+      sw    zero, 0x30(t0)=0A=
+      sw    zero, 0x3c(t0)=0A=
+=0A=
+/* ------------------- Assert PCI reset =
----------------------------------- */=0A=
+      lw    t1, (t0)=0A=
+      andi  t2, t1, 0x1=0A=
+      beqz  t2, 2f=0A=
+            nop=0A=
+      andi  t2, t1, 0x3fe=0A=
+      sw    t2, (t0)=0A=
+      li    t2, 0x1000=0A=
+1:=0A=
+      addi  t2, -1=0A=
+      bnez  t2, 1b=0A=
+            nop=0A=
+2:=0A=
+      ori   t2, t1, 0x1=0A=
+      sw    t2, (t0)=0A=
+      lui   t2, 0x2=0A=
+rip:=0A=
+      lw    t1, 4(t0)=0A=
+      and   t1, t1, t2=0A=
+      bnez  t1, rip=0A=
+            nop=0A=
+=0A=
+/* ----------- Set Disable Write Transaction Merging on IPBus =
------------- */=0A=
+      lui   t0, 0xb804=0A=
+      li    t1, 0x8=0A=
+      sw    t1, 0x4054(t0)=0A=
+=0A=
+/* ------------------- Setup Device Controller =
---------------------------- */=0A=
+      li    t0, DEV_CTL_BASE      /* load 2 base address registers' =
base    */=0A=
+      lui   t2, 0xB800=0A=
+      lw    t1, 0x8004(t2)        /* get BCV                           =
     */=0A=
+      li    t2, 0x80              /* check width of boot device 8/16 =
bit    */=0A=
+      and   t1, t1, t2=0A=
+      bnez  t1, 1f                =0A=
+            nop=0A=
+    /* 8 bit device - boot from PROM - CS1 is FLASH                    =
     */=0A=
+      li    t1, DEV_PROM_CTRL     /* device0 control parameter         =
     */=0A=
+      sw    t1, 0x8(t0)           /* set the control register  CS0     =
     */=0A=
+      li    t1, DEV_PROM_TC       /* device0 timing config parameter   =
     */=0A=
+      sw    t1, 0xC(t0)=0A=
+      li    t1, DEV1_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x10(t0)=0A=
+      li    t1, DEV_FLASH_MASK    /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x14(t0) =0A=
+      li    t1, DEV_FLASH_CTRL    /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x18(t0)=0A=
+      li    t1, DEV_FLASH_TC      /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x1C(t0) =0A=
+      b     2f                    =0A=
+            nop=0A=
+1:=0A=
+    /* 16 bit device - boot from FLASH - CS1 is PROM                   =
     */=0A=
+      li    t1, DEV_FLASH_CTRL    /* device0 control parameter         =
     */=0A=
+      sw    t1, 0x8(t0)           /* set the control register  CS0     =
     */=0A=
+      li    t1, DEV_FLASH_TC      /* device0 timing config parameter   =
     */=0A=
+      sw    t1, 0xC(t0)=0A=
+      li    t1, DEV1_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x10(t0)=0A=
+      li    t1, DEV_PROM_MASK     /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x14(t0) =0A=
+      li    t1, DEV_PROM_CTRL     /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x18(t0)=0A=
+      li    t1, DEV_PROM_TC       /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x1C(t0) =0A=
+2:=0A=
+      li    t1, DEV2_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x20(t0)=0A=
+      li    t1, DEV2_MASK         /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x24(t0) =0A=
+      li    t1, DEV2_CTRL         /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x28(t0)=0A=
+      li    t1, DEV2_TC           /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x2C(t0) =0A=
+=0A=
+      li    t1, DEV3_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x30(t0)=0A=
+      li    t1, DEV3_MASK         /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x34(t0) =0A=
+      li    t1, DEV3_CTRL         /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x38(t0)=0A=
+      li    t1, DEV3_TC           /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x3C(t0) =0A=
+=0A=
+      li    t1, DEV4_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x40(t0)=0A=
+      li    t1, DEV4_MASK         /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x44(t0) =0A=
+      li    t1, DEV4_CTRL         /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x48(t0)=0A=
+      li    t1, DEV4_TC           /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x4C(t0) =0A=
+=0A=
+      li    t1, DEV5_BASE         /* set the device base register for =
CS1   */=0A=
+      sw    t1, 0x50(t0)=0A=
+      li    t1, DEV5_MASK         /* set the device mask register for =
CS1   */=0A=
+      sw    t1, 0x54(t0) =0A=
+      li    t1, DEV5_CTRL         /* set the device control register =
for CS1*/=0A=
+      sw    t1, 0x58(t0)=0A=
+      li    t1, DEV5_TC           /* set the device timing register =
for CS1 */=0A=
+      sw    t1, 0x5C(t0) =0A=
+=0A=
+#if MEMCFG !=3D SRAM_ONLY=0A=
+=0A=
+/* ------------- INITIALIZE DDR SDRAM CONTROLLER =
---------------------------*/=0A=
+=0A=
+      li    t1, 0x0               /* Add 200 microseconds of delay =
*/=0A=
+      li    t2, DELAY_200USEC=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+=0A=
+/*-------------- Initialize DDR Base and Mask Registers =
--------------------*/=0A=
+=0A=
+      li    t0, DDRBASE=0A=
+=0A=
+  /* Load the DDRC, reset  Refresh Enable */=0A=
+      li    t1, DDRC_VAL_AT_INIT=0A=
+      sw    t1, 0x10(t0)=0A=
+      =0A=
+      sw    zero, 0x4(t0)=0A=
+      sw    zero, 0xc(t0)=0A=
+      sw    zero, 0x18(t0)=0A=
+=0A=
+  /* Store DDR0BASE */=0A=
+      li    t1, DDR0_BASE_VAL=0A=
+      sw    t1, 0x0(t0)=0A=
+=0A=
+  /* Store DDR0MASK */=0A=
+      li    t1, DDR0_MASK_VAL=0A=
+      sw    t1, 0x4(t0)=0A=
+=0A=
+  /* Store DDR1BASE */=0A=
+      li    t1, DDR1_BASE_VAL=0A=
+      sw    t1, 0x8(t0)=0A=
+=0A=
+  /* Load DDR1MASK to disable DDR CS1 */=0A=
+      li    t1, DDR1_MASK_VAL=0A=
+      sw    t1, 0x0C(t0)=0A=
+=0A=
+  /* Store DDR0ABASE */=0A=
+      li    t1, DDR0_BASE_VAL=0A=
+      sw    t1, 0x14(t0)=0A=
+=0A=
+  /* Load DDR0AMASK to disable alternate Mapping */=0A=
+      li    t1, DDR0_AMASK_VAL=0A=
+      sw    t1, 0x18(t0)=0A=
+=0A=
+      li    t1, DDR_CUST_NOP      /* Write to DDR Custom transaction =
register */=0A=
+      sw    t1, 0x20(t0)=0A=
+=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR0_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Add 200 microseconds of delay */=0A=
+      li    t1, 0x0=0A=
+      li    t2, DELAY_200USEC=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+            =0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_CUST_PRECHARGE=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate A10 high to pre-charge both the banks */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_PRECHARGE_OFFSET | DDR0_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_LD_EMODE_REG=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate EMODE register contents on A15-A2 */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_EMODE_VAL | DDR0_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_LD_MODE_REG=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate Mode register contents on the address bus A15-A2  */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_DLL_RES_MODE_VAL | DDR0_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Delay of  1.6 microseconds ~ 300 delay iteration value */=0A=
+      li    t1, 0x0=0A=
+      li    t2, 500=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+=0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_CUST_PRECHARGE=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate A10 high to pre-charge both the banks */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_PRECHARGE_OFFSET | DDR0_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Implements 9 cycles of Auto refresh allowing =0A=
+     sufficient margin for stability*/=0A=
+      li    t4, 9=0A=
+      li    t3, 0=0A=
+1:=0A=
+      li    t1, DDR_CUST_REFRESH=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Read it back to flush CPU write buffers */=0A=
+      lw    t1, 0x20(t0)=0A=
+=0A=
+  /* Access DDR */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR0_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+      add   t3, 1=0A=
+      bne   t3, t4, 1b=0A=
+            nop=0A=
+=0A=
+  /* Register t0 carries pointer to the DDR_BASE: 0xB8018000 */=0A=
+      li    t1, DDR_LD_MODE_REG=0A=
+      sw    t1, 0x20(t0)    /* Write to DDR Custom transaction =
register */=0A=
+=0A=
+  /* Generate Mode Register contents on the address bus A12-A0 */=0A=
+      li    t2, DATA_PATTERN=0A=
+      li    t1, 0xA0000000 | DDR_DLL_MODE_VAL | DDR0_BASE_VAL=0A=
+      sw    t2, 0x0(t1)=0A=
+=0A=
+  /* Initialize the refresh timer with fast refresh count */=0A=
+      li    t0, RCOUNT=0A=
+      li    t1, DDR_REF_CMP_FAST=0A=
+      =0A=
+  /* Set the RCOMPARE register */=0A=
+      sw    t1, 0x4(t0)=0A=
+=0A=
+  /* Enable the Refresh timer */=0A=
+      li    t1, 0x1           /* CE set to enabled the  Refresh =
counter */=0A=
+      sw    t1, 0x8(t0)=0A=
+=0A=
+  /* Enable RE-refresh enable in the DDRC register */=0A=
+      li    t0, DDRBASE=0A=
+      li    t1, DDRC_VAL_NORMAL=0A=
+      sw    t1, 0x10(t0)=0A=
+=0A=
+  /* Add 200 microseconds of delay */=0A=
+      li    t1, 0x0=0A=
+      li    t2, DELAY_200USEC=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+=0A=
+      li    t0, RCOUNT=0A=
+=0A=
+  /* Find Refresh Timer Compare value value based on revision - Check =
for IP7 */=0A=
+      li    t2, 0x1=0A=
+      mtc0  t2, C0_COMPARE=0A=
+      mtc0  zero, C0_COUNT=0A=
+            nop=0A=
+            nop=0A=
+      mfc0  t1, C0_CAUSE=0A=
+            nop=0A=
+      li    t3, DDR_REF_CMP_VAL_ZB=0A=
+      andi  t1, 0x8000=0A=
+      bnez  t1, acacia_zb=0A=
+            nop=0A=
+      li    t3, DDR_REF_CMP_VAL=0A=
+acacia_zb:=0A=
+=0A=
+  /* Disable the refresh counter before changing the compare value =
*/=0A=
+      li    t1, 0x0=0A=
+      sw    t1, 0x8(t0)=0A=
+=0A=
+  /* Set the RCOMPARE register */=0A=
+      sw    t3, 0x4(t0)=0A=
+=0A=
+  /* Enable the Refresh timer */=0A=
+      li    t1, 0x1           /* CE set to enabled the  Refresh =
counter */=0A=
+      sw    t1, 0x8(t0)=0A=
+=0A=
+  /* Add 200 microseconds of delay */=0A=
+      li    t1, 0x0=0A=
+      li    t2, DELAY_200USEC=0A=
+1:=0A=
+      add   t1, 1=0A=
+      bne   t1, t2, 1b=0A=
+            nop=0A=
+=0A=
+#endif=0A=
+	li    t0, 0xa0000000=0A=
+	li    t1, 0xa0100000=0A=
+1:=0A=
+	sw    zero, 0x00(t0)=0A=
+	sw    zero, 0x04(t0)=0A=
+	sw    zero, 0x08(t0)=0A=
+	sw    zero, 0x0c(t0)=0A=
+	addiu t0, 16=0A=
+	nop=0A=
+	blt   t0, t1, 1b=0A=
+	nop=0A=
+	nop=0A=
+	nop=0A=
+3:=0A=
+	mfc0  t0, C0_SR=0A=
+	nop=0A=
+	nop=0A=
+	and   t0, ~SR_BEV=0A=
+	mtc0  t0, C0_SR=0A=
+	nop=0A=
+	nop=0A=
+4:=0A=
+=0A=
+/* Jump to zImage startup */=0A=
+	=0A=
+	la     k0, zstartup=0A=
+	j      k0=0A=
+	nop=0A=
+	nop=0A=
+=0A=
+ENDFRAME(start)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/head.S =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/head.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/head.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/head.S	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,126 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Board initialisation code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/threads.h>=0A=
+=0A=
+#include <asm/asm.h>=0A=
+#include <asm/cacheops.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/asm-offsets.h>=0A=
+#include <asm/cachectl.h>=0A=
+#include <asm/regdef.h>=0A=
+=0A=
+#define IndexInvalidate_I       0x00=0A=
+=0A=
+	.set noreorder=0A=
+	.cprestore=0A=
+	LEAF(zstartup)=0A=
+zstartup:=0A=
+=0A=
+        la      sp, .stack=0A=
+	move	s0, a0=0A=
+	move	s1, a1=0A=
+	move	s2, a2=0A=
+	move	s3, a3=0A=
+=0A=
+	/* Clear BSS */=0A=
+	/* Note: when zImage is in ROM, _edata and _bss point to=0A=
+	 * ROM space even when using -Tbss on the linker command line;=0A=
+	 * maybe ld.script needs to be corrected.=0A=
+	 */=0A=
+	la	a0, .stack=0A=
+	la	a2, _end=0A=
+1:	sw	zero, 0(a0)=0A=
+	bne	a2, a0, 1b=0A=
+	addu	a0, 4=0A=
+=0A=
+	/* flush the I-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80004000  # end address (16KB I-Cache)=0A=
+	subu	k1, 128=0A=
+=0A=
+2:=0A=
+	.set mips3=0A=
+	cache   IndexInvalidate_I, 0(k0)=0A=
+	cache   IndexInvalidate_I, 16(k0)=0A=
+	cache   IndexInvalidate_I, 32(k0)=0A=
+	cache   IndexInvalidate_I, 48(k0)=0A=
+	cache   IndexInvalidate_I, 64(k0)=0A=
+	cache   IndexInvalidate_I, 80(k0)=0A=
+	cache   IndexInvalidate_I, 96(k0)=0A=
+	cache   IndexInvalidate_I, 112(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 2b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+=0A=
+	/* flush the D-Cache */=0A=
+	li	k0, 0x80000000  # start address=0A=
+	li	k1, 0x80004000  # end address (16KB I-Cache)=0A=
+	subu	k1, 128=0A=
+=0A=
+2:=0A=
+	.set mips3=0A=
+	cache   Index_Writeback_Inv_D, 0(k0)=0A=
+	cache   Index_Writeback_Inv_D, 16(k0)=0A=
+	cache   Index_Writeback_Inv_D, 32(k0)=0A=
+	cache   Index_Writeback_Inv_D, 48(k0)=0A=
+	cache   Index_Writeback_Inv_D, 64(k0)=0A=
+	cache   Index_Writeback_Inv_D, 80(k0)=0A=
+	cache   Index_Writeback_Inv_D, 96(k0)=0A=
+	cache   Index_Writeback_Inv_D, 112(k0)=0A=
+	.set mips0=0A=
+=0A=
+	bne	k0, k1, 2b=0A=
+	addu	k0, k0, 128=0A=
+	/* done */=0A=
+=0A=
+	la	ra, 3f=0A=
+	la	k0, decompress_kernel=0A=
+	jr	k0=0A=
+	nop=0A=
+3:=0A=
+=0A=
+	move	a0, s0=0A=
+	move	a1, s1=0A=
+	move	a2, s2=0A=
+	move	a3, s3=0A=
+	li	k0, KERNEL_ENTRY=0A=
+	jr	k0=0A=
+	nop=0A=
+4:=0A=
+	b 4b=0A=
+	END(zstartup)=0A=
+=0A=
+	.bss=0A=
+	.fill 0x2000=0A=
+	EXPORT(.stack)=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/idtcpu.h =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/idtcpu.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/idtcpu.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/idtcpu.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,335 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#if !defined(__IDTCPU_H__)=0A=
+#define __IDTCPU_H__=0A=
+/*=0A=
+** memory configuration and mapping=0A=
+*/=0A=
+#define K0BASE		0x80000000=0A=
+#define K0SIZE		0x20000000=0A=
+#define K1BASE		0xa0000000=0A=
+#define K1SIZE		0x20000000=0A=
+#define K2BASE		0xc0000000=0A=
+#if defined(CPU_R32364)=0A=
+#define K2SIZE		0x40000000=0A=
+#define ICEBASE		0xff000000=0A=
+#define ICESIZE		0x01000000=0A=
+#elif defined(CPU_R32438)=0A=
+#define K2SIZE		0x20000000=0A=
+#define K3BASE		0xe0000000=0A=
+#define K3SIZE    0x20000000=0A=
+#define ICEBASE		0xff200000=0A=
+#define ICESIZE		0x00200000=0A=
+#endif=0A=
+=0A=
+#define KUBASE		0=0A=
+#define KUSIZE		0x80000000=0A=
+=0A=
+/*=0A=
+** Exception Vectors=0A=
+*/=0A=
+=0A=
+#define	T_VEC	(K0BASE + 0x000)			/* tlbmiss vector */=0A=
+#define X_VEC	(K0BASE + 0x080)			/* xtlbmiss vector */=0A=
+#define C_VEC	(K1BASE + 0x100)			/* cache error vector */=0A=
+#define E_VEC	(K0BASE + 0x180)			/* exception vector */=0A=
+#define I_VEC	(K0BASE + 0X200)			/* interrupt vector */=0A=
+#define	R_VEC	(K1BASE + 0x1fc00000)	/* reset vector */=0A=
+=0A=
+/*=0A=
+** Address conversion macros=0A=
+*/=0A=
+#ifdef CLANGUAGE=0A=
+#define	CAST(as) (as)=0A=
+#else=0A=
+#define	CAST(as)=0A=
+#endif=0A=
+=0A=
+#define	K0_TO_K1(x)		(CAST(unsigned)(x) | 0xA0000000)	/* kseg0 to =
kseg1 */=0A=
+#define	K1_TO_K0(x)		(CAST(unsigned)(x) & 0x9FFFFFFF)	/* kseg1 to =
kseg0 */=0A=
+#define	K0_TO_PHYS(x)	(CAST(unsigned)(x) & 0x1FFFFFFF)	/* kseg0 to =
physical */=0A=
+#define	K1_TO_PHYS(x)	(CAST(unsigned)(x) & 0x1FFFFFFF)	/* kseg1 to =
physical */=0A=
+#define	PHYS_TO_K0(x)	(CAST(unsigned)(x) | 0x80000000)	/* physical to =
kseg0 */=0A=
+#define	PHYS_TO_K1(x)	(CAST(unsigned)(x) | 0xA0000000)	/* physical to =
kseg1 */=0A=
+=0A=
+#if defined(CPU_R32364)             /* Includes RC32332, RC32334 */=0A=
+#define	CFG_ICE					0x80000000	/* ICE detect */=0A=
+#define	CFG_ECMASK			0x70000000	/* System Clock Ratio */=0A=
+#define	CFG_ECBY2				0x00000000 	/* divide by 2 */=0A=
+#define	CFG_ECBY3				0x10000000 	/* divide by 3 */=0A=
+#define	CFG_ECBY4				0x20000000 	/* divide by 4 */=0A=
+#define	CFG_BE					0x00008000	/* Big Endian */=0A=
+#define	CFG_ICMASK			0x00000e00	/* Instruction cache size */=0A=
+#define	CFG_ICSHIFT			9=0A=
+#define	CFG_DCMASK			0x000001c0	/* Data cache size */=0A=
+#define	CFG_DCSHIFT			6=0A=
+#define	CFG_IB					0x00000020	/* Instruction cache line size */=0A=
+#define	CFG_DB					0x00000010	/* Data cache line size */=0A=
+#define	CFG_K0MASK			0x00000007	/* KSEG0 coherency algorithm */=0A=
+#elif defined(CPU_R32438)=0A=
+#define	CFG_MM					0x00060000  /* write buffer Merge Mode */=0A=
+#define CFG_BM					0x00010000  /* Burst Mode */=0A=
+#define	CFG_BE					0x00008000	/* Big Endian */=0A=
+#define	CFG_K0MASK			0x00000007	/* KSEG0 coherency algorithm */=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * Primary cache mode=0A=
+ */=0A=
+#if defined(CPU_R32364)=0A=
+#define CFG_C_NCHRNT_WT_NWA			0=0A=
+#define CFG_C_NCHRNT_WT					1=0A=
+#define CFG_C_UNCACHED					2=0A=
+#define CFG_C_NCHRNT_WB					3=0A=
+=0A=
+/* Cache Operations */=0A=
+#define Index_Invalidate_I      0x0         /* 0       0 */=0A=
+#define Index_Writeback_Inv_D   0x1         /* 0       1 */=0A=
+#define Index_Invalidate_SI     0x2         /* 0       2 */=0A=
+#define Index_Writeback_Inv_SD  0x3         /* 0       3 */=0A=
+#define Index_Load_Tag_I        0x4         /* 1       0 */=0A=
+#define Index_Load_Tag_D        0x5         /* 1       1 */=0A=
+#define Index_Load_Tag_SI       0x6         /* 1       2 */=0A=
+#define Index_Load_Tag_SD       0x7         /* 1       3 */=0A=
+#define Index_Store_Tag_I       0x8         /* 2       0 */=0A=
+#define Index_Store_Tag_D       0x9         /* 2       1 */=0A=
+#define Index_Store_Tag_SI      0xA         /* 2       2 */=0A=
+#define Index_Store_Tag_SD      0xB         /* 2       3 */=0A=
+#define Create_Dirty_Exc_D      0xD         /* 3       1 */=0A=
+#define Create_Dirty_Exc_SD     0xF         /* 3       3 */=0A=
+#define Hit_Invalidate_I        0x10        /* 4       0 */=0A=
+#define Hit_Invalidate_D        0x11        /* 4       1 */=0A=
+#define Hit_Invalidate_SI       0x12        /* 4       2 */=0A=
+#define Hit_Invalidate_SD       0x13        /* 4       3 */=0A=
+#define Hit_Writeback_Inv_D     0x15        /* 5       1 */=0A=
+#define Hit_Writeback_Inv_SD    0x17        /* 5       3 */=0A=
+#define Fill_I                  0x14        /* 5       0 */=0A=
+#define Hit_Writeback_D         0x19        /* 6       1 */=0A=
+#define Hit_Writeback_SD        0x1B        /* 6       3 */=0A=
+#define Hit_Writeback_I         0x18        /* 6       0 */=0A=
+#define Hit_Set_Virtual_SI      0x1E        /* 7       2 */=0A=
+#define Hit_Set_Virtual_SD      0x1F        /* 7       3 */=0A=
+#define CFG_EW32        				0x00040000      /* 32 bit */=0A=
+#elif defined(CPU_R32438)=0A=
+#define CFG_C_UNCACHED					2=0A=
+#define CFG_C_NCHRNT_WB					3=0A=
+=0A=
+/* Cache Operations */=0A=
+#define Index_Invalidate_I      0x0         /* 0       0 */=0A=
+#define Index_Invalidate_D      0x1         /* 0       0 */=0A=
+#define Index_Load_Tag_I        0x4         /* 1       0 */=0A=
+#define Index_Load_Tag_D        0x5         /* 1       1 */=0A=
+#define Index_Store_Tag_I       0x8         /* 2       0 */=0A=
+#define Index_Store_Tag_D       0x9         /* 2       1 */=0A=
+#define Hit_Invalidate_I        0x10        /* 4       0 */=0A=
+#define Hit_Invalidate_D        0x11        /* 4       1 */=0A=
+#define Fill_I                  0x14        /* 5       0 */=0A=
+#define Fetch_Lock_I						0x1C        /* 7       0 */=0A=
+#define Fetch_Lock_D						0x1D        /* 7       1 */=0A=
+#define CFG_EW32        				0x00040000      /* 32 bit */=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** TLB resource defines=0A=
+*/=0A=
+=0A=
+#define	N_TLB_ENTRIES				16=0A=
+#define	TLBHI_VPN2MASK			0xffffe000=0A=
+#define	TLBHI_PIDMASK				0x000000ff=0A=
+#define	TLBHI_NPID					256=0A=
+=0A=
+#define	TLBLO_PFNMASK				0x03ffffc0=0A=
+#define	TLBLO_PFNSHIFT			6=0A=
+#define	TLBLO_D							0x00000004	/* writeable */=0A=
+#define	TLBLO_V							0x00000002	/* valid bit */=0A=
+#define	TLBLO_G							0x00000001	/* global access bit */=0A=
+#define	TLBLO_CMASK					0x00000038	/* cache algorithm mask */=0A=
+#define	TLBLO_CSHIFT				3=0A=
+=0A=
+#define	TLBLO_UNCACHED			(CFG_C_UNCACHED << TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WT_NWA	(CFG_C_NCHRNT_WT_NWA << TLBLO_CSHIFT)=0A=
+#if defined(CPU_R32364)=0A=
+#define	TLBLO_NCHRNT_WT			(CFG_C_NCHRNT_WT << TLBLO_CSHIFT)=0A=
+#define	TLBLO_NCHRNT_WB			(CFG_C_NCHRNT_WB << TLBLO_CSHIFT)=0A=
+#endif=0A=
+=0A=
+#define	TLBINX_PROBE				0x80000000=0A=
+#define	TLBINX_INXMASK			0x0000003f=0A=
+=0A=
+#define	TLBRAND_RANDMASK		0x0000003f=0A=
+=0A=
+#define	TLBCTXT_BASEMASK		0xff800000=0A=
+#define	TLBCTXT_BASESHIFT		23=0A=
+=0A=
+#define	TLBCTXT_VPN2MASK		0x007ffff0=0A=
+#define	TLBCTXT_VPN2SHIFT		4=0A=
+=0A=
+#define	TLBPGMASK_MASK			0x01ffe000=0A=
+=0A=
+#define	SR_CUMASK				0xf0000000	/* coproc usable bits */=0A=
+#define	SR_CU3					0x80000000	/* Coprocessor 3 usable */=0A=
+#define	SR_CU2					0x40000000	/* Coprocessor 2 usable */=0A=
+#define	SR_CU1					0x20000000	/* Coprocessor 1 usable */=0A=
+#define	SR_CU0					0x10000000	/* Coprocessor 0 usable */=0A=
+=0A=
+/* #define	SR_PE						0x00100000*/  /* cache parity error */=0A=
+=0A=
+#if defined(CPU_R32364)=0A=
+#define	SR_RE						0X02000000	/* Reverse Endianness */=0A=
+#define	SR_DL						0x01000000	/* Data Cache Locking */=0A=
+#define	SR_IL						0x00800000	/* Instruction Cache Locking */=0A=
+=0A=
+#define	SR_BEV					0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_SR						0x00100000	/* Soft reset */=0A=
+#define	SR_CH						0x00040000	/* Cache hit */=0A=
+#define	SR_CE						0x00020000	/* Use cache ECC  */=0A=
+#define	SR_DE						0x00010000	/* Disable cache exceptions */=0A=
+=0A=
+#elif defined(CPU_R32438)=0A=
+#define	SR_RP						0X08000000	/* Reduced Power mode */=0A=
+=0A=
+#define	SR_RE						0X02000000	/* Reverse Endianness */=0A=
+=0A=
+#define	SR_BEV					0x00400000	/* Use boot exception vectors */=0A=
+#define	SR_TS						0X00200000	/* TLB Shutdown */=0A=
+#define	SR_SR						0x00100000	/* Soft reset */=0A=
+#define	SR_NMI					0X00080000	/* NMI */=0A=
+#endif=0A=
+/*=0A=
+**	status register interrupt masks and bits=0A=
+*/=0A=
+=0A=
+#define	SR_IMASK				0x0000ff00	/* Interrupt mask */=0A=
+#define	SR_IMASK8				0x00000000	/* mask level 8 */=0A=
+#define	SR_IMASK7				0x00008000	/* mask level 7 */=0A=
+#define	SR_IMASK6				0x0000c000	/* mask level 6 */=0A=
+#define	SR_IMASK5				0x0000e000	/* mask level 5 */=0A=
+#define	SR_IMASK4				0x0000f000	/* mask level 4 */=0A=
+#define	SR_IMASK3				0x0000f800	/* mask level 3 */=0A=
+#define	SR_IMASK2				0x0000fc00	/* mask level 2 */=0A=
+#define	SR_IMASK1				0x0000fe00	/* mask level 1 */=0A=
+#define	SR_IMASK0				0x0000ff00	/* mask level 0 */=0A=
+=0A=
+#define	SR_IMASKSHIFT		8=0A=
+=0A=
+#define	SR_IBIT8				0x00008000	/* bit level 8 */=0A=
+#define	SR_IBIT7				0x00004000	/* bit level 7 */=0A=
+#define	SR_IBIT6				0x00002000	/* bit level 6 */=0A=
+#define	SR_IBIT5				0x00001000	/* bit level 5 */=0A=
+#define	SR_IBIT4				0x00000800	/* bit level 4 */=0A=
+#define	SR_IBIT3				0x00000400	/* bit level 3 */=0A=
+#define	SR_IBIT2				0x00000200	/* bit level 2 */=0A=
+#define	SR_IBIT1				0x00000100	/* bit level 1 */=0A=
+=0A=
+#define	SR_KSMASK				0x00000016	/* Kernel mode mask */=0A=
+#define	SR_KSUSER				0x00000000	/* User Mode */=0A=
+#define	SR_KSKERNEL			0x00000016	/* Kernel Mode */=0A=
+=0A=
+#define	SR_ERL					0x00000004	/* Error level */=0A=
+#define	SR_EXL					0x00000002	/* Exception level */=0A=
+#define	SR_IE						0x00000001	/* Interrupts enabled */=0A=
+#define	NOT_SR_IEC      0xfffffffe  /* assembler problem with li =
~SR_IEC */=0A=
+=0A=
+/*=0A=
+ * Cause Register=0A=
+ */=0A=
+#define	CAUSE_BD				0x80000000	/* Branch delay slot */=0A=
+#define	CAUSE_CEMASK		0x30000000	/* coprocessor error */=0A=
+#define	CAUSE_CESHIFT		28=0A=
+#if defined(CPU_R32364)=0A=
+#define	CAUSE_IPE				0x04000000	/* Imprecise exception */=0A=
+#define	CAUSE_DW				0x02000000	/* Data watch */=0A=
+#define	CAUSE_IW				0x01000000	/* Instruction watch */=0A=
+#elif defined(CPU_R32438)=0A=
+#define CAUSE_IV			 	0x00800000	/* Interrupt Vector location */=0A=
+#define CAUSE_WP			 	0x00400000	/* Watch Exception deferred */=0A=
+#endif=0A=
+=0A=
+#define	CAUSE_IPMASK		0x0000FF00	/* Pending interrupt mask */=0A=
+#define	CAUSE_IPSHIFT		8=0A=
+=0A=
+/* Notice: Watch Exception if Exc. Code is 23 is not included in the =
mask=0A=
+ *	   for R32364.=0A=
+ */=0A=
+#define	CAUSE_EXCMASK		0x0000003C	/* Cause code bits */=0A=
+#define	CAUSE_EXCSHIFT	2=0A=
+=0A=
+#ifndef XDS=0A=
+/*=0A=
+**  Coprocessor 0 registers=0A=
+*/=0A=
+#define	C0_INX					$0		/* tlb index */=0A=
+#define	C0_RANDOM				$1=0A=
+#define	C0_TLBLO0				$2		/* tlb entry low 0 */=0A=
+#define	C0_TLBLO1				$3		/* tlb entry low 1 */=0A=
+#define	C0_CTXT					$4		/* tlb context */=0A=
+#define	C0_PAGEMASK			$5		/* tlb page mask */=0A=
+#define	C0_WIRED				$6		/* number of wired tlb entries */=0A=
+=0A=
+#define	C0_BADVADDR			$8		/* bad virtual address */=0A=
+#define	C0_COUNT				$9		/* timer count */=0A=
+#define	C0_TLBHI				$10		/* tlb entry hi */=0A=
+#define	C0_COMPARE			$11		/* timer comparator  */=0A=
+#define	C0_SR						$12		/* status register */=0A=
+#define	C0_CAUSE				$13		/* exception cause */=0A=
+#define	C0_EPC					$14		/* exception pc */=0A=
+#define	C0_PRID					$15		/* revision identifier */=0A=
+#define	C0_CONFIG				$16		/* configuration register */=0A=
+=0A=
+#if defined(CPU_R32364)=0A=
+#define	C0_IWATCH				$18		/* Instr brk pt Virtual add. */=0A=
+#define	C0_DWATCH				$19		/* Data brk pt Virtual add. */=0A=
+=0A=
+#define	C0_IEPC					$22		/* Imprecise Exception pc */=0A=
+#define	C0_DEPC					$23		/* Debug Exception pc */=0A=
+#define	C0_DEBUG				$24		/* Debug control/status reg */=0A=
+=0A=
+#define	C0_ECC					$26		/* primary cache Parity control */=0A=
+#define	C0_CACHEERR			$27		/* cache error status */=0A=
+#define	C0_TAGLO				$28		/* cache tag lo */=0A=
+#define	C0_ERRPC				$30		/* cache error pc */=0A=
+#elif defined(CPU_R32438)=0A=
+#define	C0_WATCHLO			$18		/* Watchpoint address (low) */=0A=
+#define	C0_WATCHHI			$19		/* Watchpoint address (high) */=0A=
+=0A=
+#define	C0_DEBUG				$23		/* Debug control/status reg */=0A=
+#define	C0_DEPC					$24		/* Debug Exception pc */=0A=
+=0A=
+#define	C0_ERRCTL				$26		/* Cache Error Control */=0A=
+#define	C0_TAGLO				$28		/* Cache Tag Lo */=0A=
+#define	C0_ERRPC				$30		/* Cache Error PC */=0A=
+#define C0_DESAVE				$31		/* Debug scratchpad reg. */=0A=
+#endif =0A=
+=0A=
+#endif=0A=
+#endif /* defined(__IDTCPU_H__) */=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/idthdr.h =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/idthdr.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/idthdr.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/idthdr.h	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,53 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Some macros. Though they are already defined else where in the =
linux=0A=
+ *   tree, they are once again declared here for the ease of syncing =
up with=0A=
+ *    IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef XDS=0A=
+=0A=
+#define	FRAME(name,frm_reg,offset,ret_reg)	\=0A=
+	.globl	name;				\=0A=
+	.ent	name;				\=0A=
+name:;						\=0A=
+	.frame	frm_reg,offset,ret_reg=0A=
+=0A=
+#define ENDFRAME(name) 	.end name=0A=
+=0A=
+#else=0A=
+=0A=
+#define FRAME(name,frm_reg,offset,ret_reg)      \=0A=
+name:=0A=
+=0A=
+#define ENDFRAME(name)=0A=
+=0A=
+#endif=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/image.lds.in =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/image.lds.in=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/image.lds.in	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/image.lds.in	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D IMSTART;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32438/EB438/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D BSS_START;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/iregdef.h =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/iregdef.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/iregdef.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/iregdef.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,274 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT CPU register definitions. Though the registers are already =
defined=0A=
+ *   under asm directory, they are once again declared here for the =
ease of=0A=
+ *   syncing up with IDT bootloader code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifdef CLANGUAGE=0A=
+struct ireg_desc {=0A=
+	char 	*ptr_field_name;	/* field name   */=0A=
+	short	num_digits;				/* number ofdigits to display */=0A=
+	short	num_spaces;				/* number of spaces to follow */=0A=
+	reg_t	fld_mask;					/* mask to extract value of field */=0A=
+	int	fld_shift;					/* shift amount to position field */=0A=
+  short    cpu;=0A=
+	char *CONST *ptr_enum_list;	/* ptr to an enumeration list */=0A=
+	  };=0A=
+=0A=
+/*=0A=
+** reg_name - structure that gives the reg. name, alt. reg name=0A=
+**		the reg index for fetching the value, the number=0A=
+**		of spaces req. so a tabular display will align=0A=
+**		a pointer to a structure defining the fields if=0A=
+**		required and a flag for the output type.=0A=
+*/=0A=
+struct reg_name {=0A=
+	char	*register_name;=0A=
+	char	*alt_reg_name;=0A=
+	short	reg_index;=0A=
+	short	space_pad;=0A=
+	CONST struct ireg_desc *ptr_reg_desc_flds;=0A=
+	unsigned char format_type;=0A=
+	unsigned char print_type;=0A=
+	short   reg_group;=0A=
+  short    cpu;=0A=
+	  };=0A=
+=0A=
+/* print format specifiers */=0A=
+#define PRT_HEX		0=0A=
+#define PRT_SGL 	1=0A=
+#define PRT_DBL 	2=0A=
+=0A=
+/* register group classifiers */=0A=
+#define GRP_CPU		0x0001=0A=
+#define GRP_FPR		0x0002=0A=
+#define GRP_FPS		0x0004=0A=
+#define GRP_FPD		0x0008=0A=
+#define GRP_CP0		0x0010=0A=
+#define GRP_CP0R	0x0020=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** register names=0A=
+*/=0A=
+#define r0		$0=0A=
+#define r1		$1=0A=
+#define r2		$2=0A=
+#define r3		$3=0A=
+#define r4		$4=0A=
+#define r5		$5=0A=
+#define r6		$6=0A=
+#define r7		$7=0A=
+#define r8		$8=0A=
+#define r9		$9=0A=
+#define r10		$10=0A=
+#define r11		$11=0A=
+#define r12		$12=0A=
+#define r13		$13=0A=
+#define r14		$14=0A=
+#define r15		$15=0A=
+#define r16		$16=0A=
+#define r17		$17=0A=
+#define r18		$18=0A=
+#define r19		$19=0A=
+#define r20		$20=0A=
+#define r21		$21=0A=
+#define r22		$22=0A=
+#define r23		$23=0A=
+#define r24		$24=0A=
+#define r25		$25=0A=
+#define r26		$26=0A=
+#define r27		$27=0A=
+#define r28		$28=0A=
+#define r29		$29=0A=
+#define r30		$30=0A=
+#define r31		$31=0A=
+=0A=
+#define zero	$0		/* wired zero */=0A=
+#define AT		$at		/* assembler temp */=0A=
+#define v0		$2		/* return value */=0A=
+#define v1		$3=0A=
+#define a0		$4		/* argument registers a0-a3 */=0A=
+#define a1		$5=0A=
+#define a2		$6=0A=
+#define a3		$7=0A=
+#define t0		$8		/* caller saved  t0-t9 */=0A=
+#define t1		$9=0A=
+#define t2		$10=0A=
+#define t3		$11=0A=
+#define t4		$12=0A=
+#define t5		$13=0A=
+#define t6		$14=0A=
+#define t7		$15=0A=
+#define s0		$16		/* callee saved s0-s8 */=0A=
+#define s1		$17=0A=
+#define s2		$18=0A=
+#define s3		$19=0A=
+#define s4		$20=0A=
+#define s5		$21=0A=
+#define s6		$22=0A=
+#define s7		$23=0A=
+#define t8		$24=0A=
+#define t9		$25=0A=
+#define k0		$26		/* kernel usage */=0A=
+#define k1		$27		/* kernel usage */=0A=
+#define gp		$28		/* sdata pointer */=0A=
+#define sp		$29		/* stack pointer */=0A=
+#define s8		$30		/* yet another saved reg for the callee */=0A=
+#define fp		$30		/* frame pointer - this is being phased out by MIPS =
*/=0A=
+#define ra		$31		/* return address */=0A=
+=0A=
+/*=0A=
+** relative position of registers in save reg area=0A=
+*/=0A=
+#define	R_R0		0=0A=
+#define	R_R1		1=0A=
+#define	R_R2		2=0A=
+#define	R_R3		3=0A=
+#define	R_R4		4=0A=
+#define	R_R5		5=0A=
+#define	R_R6		6=0A=
+#define	R_R7		7=0A=
+#define	R_R8		8=0A=
+#define	R_R9		9=0A=
+#define	R_R10		10=0A=
+#define	R_R11		11=0A=
+#define	R_R12		12=0A=
+#define	R_R13		13=0A=
+#define	R_R14		14=0A=
+#define	R_R15		15=0A=
+#define	R_R16		16=0A=
+#define	R_R17		17=0A=
+#define	R_R18		18=0A=
+#define	R_R19		19=0A=
+#define	R_R20		20=0A=
+#define	R_R21		21=0A=
+#define	R_R22		22=0A=
+#define	R_R23		23=0A=
+#define	R_R24		24=0A=
+#define	R_R25		25=0A=
+#define	R_R26		26=0A=
+#define	R_R27		27=0A=
+#define	R_R28		28=0A=
+#define	R_R29		29=0A=
+#define	R_R30		30=0A=
+#define	R_R31		31=0A=
+#define NCLIENTREGS	32=0A=
+#define	R_EPC				32=0A=
+#define	R_MDHI			33=0A=
+#define	R_MDLO		  34=0A=
+#define	R_SR				35=0A=
+#define	R_CAUSE			36=0A=
+#define	R_TLBHI			37=0A=
+#define	R_TLBLO0		38=0A=
+#define	R_BADVADDR	39=0A=
+#define	R_INX				40=0A=
+#define	R_RAND			41=0A=
+#define	R_CTXT			42=0A=
+#define	R_EXCTYPE		43=0A=
+#define R_MODE			44=0A=
+#define R_PRID			45=0A=
+#define R_TLBLO1		46=0A=
+#define R_PAGEMASK	47=0A=
+#define R_WIRED			48=0A=
+#define R_COUNT			49=0A=
+#define R_COMPARE		50=0A=
+#define R_CONFIG		51=0A=
+#if defined(CPU_R32438)=0A=
+#define R_WATCHLO   52=0A=
+#define R_WATCHHI   53=0A=
+#elif defined(CPU_R32364)=0A=
+#define R_IWATCH    52=0A=
+#define R_DWATCH    53=0A=
+#define R_ECC				54=0A=
+#define R_CACHEERR	55=0A=
+#endif=0A=
+#define R_TAGLO			56=0A=
+#define R_TAGHI			57=0A=
+#define R_ERRPC			58=0A=
+=0A=
+#define NREGS			  59=0A=
+=0A=
+#if __mips >=3D 3=0A=
+=0A=
+#define R_SZ		8=0A=
+#ifndef CLANGUAGE=0A=
+#define sreg		sd=0A=
+#define lreg		ld=0A=
+#define rmfc0		mfc0=0A=
+#define rmtc0		mtc0=0A=
+#endif=0A=
+=0A=
+#else=0A=
+=0A=
+#define R_SZ		4=0A=
+#ifndef CLANGUAGE=0A=
+#define sreg		sw=0A=
+#define lreg		lw=0A=
+#define rmfc0		mfc0=0A=
+#define rmtc0		mtc0=0A=
+#endif=0A=
+=0A=
+#endif=0A=
+=0A=
+/*=0A=
+** For those who like to think in terms of the compiler names for the =
regs=0A=
+*/=0A=
+#define	R_ZERO	R_R0=0A=
+#define	R_AT		R_R1=0A=
+#define	R_V0		R_R2=0A=
+#define	R_V1		R_R3=0A=
+#define	R_A0		R_R4=0A=
+#define	R_A1		R_R5=0A=
+#define	R_A2		R_R6=0A=
+#define	R_A3		R_R7=0A=
+#define	R_T0		R_R8=0A=
+#define	R_T1		R_R9=0A=
+#define	R_T2		R_R10=0A=
+#define	R_T3		R_R11=0A=
+#define	R_T4		R_R12=0A=
+#define	R_T5		R_R13=0A=
+#define	R_T6		R_R14=0A=
+#define	R_T7		R_R15=0A=
+#define	R_S0		R_R16=0A=
+#define	R_S1		R_R17=0A=
+#define	R_S2		R_R18=0A=
+#define	R_S3		R_R19=0A=
+#define	R_S4		R_R20=0A=
+#define	R_S5		R_R21=0A=
+#define	R_S6		R_R22=0A=
+#define	R_S7		R_R23=0A=
+#define	R_T8		R_R24=0A=
+#define	R_T9		R_R25=0A=
+#define	R_K0		R_R26=0A=
+#define	R_K1		R_R27=0A=
+#define	R_GP		R_R28=0A=
+#define	R_SP		R_R29=0A=
+#define	R_FP		R_R30=0A=
+#define	R_RA		R_R31=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/Makefile =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/Makefile	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,136 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile create a compressed zImage or Rommable rImage=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+#######################################################################=
########=0A=
+# The following is taken from IDT/Sim Makefile=0A=
+#######################################################################=
######=0A=
+TARGET=3D438=0A=
+TARGETDIR=3DS438=0A=
+MHZ=3D100000000=0A=
+=0A=
+#=0A=
+# following refers to memory type in use in eval board and if more =
than one=0A=
+# then the order is implied.  These are values for the switch =
MEMCFG.=0A=
+#=0A=
+SRAM_ONLY=3D1=0A=
+SDRAM_ONLY=3D2=0A=
+SRAM_N_SDRAM=3D3=0A=
+SDRAM_N_SRAM=3D4=0A=
+=0A=
+# following refers to size of the DRAM space.=0A=
+# These are values for the switch DRAMSZ.=0A=
+=0A=
+MB32=3D1=0A=
+MB64=3D2=0A=
+MB128=3D3=0A=
+MB32SO=3D4=0A=
+=0A=
+MACH=3D -DEB438 -DS438 -DCPU_R32438 -DMIPSEL -DINET =
-DMEMCFG=3D$(SDRAM_ONLY) -DDRAMSZ=3D$(MB64) -DIDTSIM -DMHZ=3D$(MHZ) =
-DNVRAM_RTC -DUSE_SPI=0A=
+COMMSWITCHES =3D $(MACH)=0A=
+#***************** END IDT/Sim Makefile =
##################################### =0A=
+ZDEBUG=3D1=0A=
+export ZDEBUG=0A=
+=0A=
+# working space for gunzip:=0A=
+FREE_RAM      :=3D 0x80C00000=0A=
+END_RAM       :=3D 0x80E00000=0A=
+=0A=
+KERNELCONFIG  :=3D $(TOPDIR)/.config=0A=
+include $(KERNELCONFIG)=0A=
+=0A=
+SIZE =3D $(CROSS_COMPILE)size=0A=
+=0A=
+O_FORMAT =3D $(shell $(OBJDUMP) -i | head -2 | grep elf32)=0A=
+=0A=
+SYSTEM	      :=3D $(TOPDIR)/vmlinux=0A=
+ZBSS          :=3D 0x800A0000=0A=
+=0A=
+ZIMSTART      :=3D $(CONFIG_IDT_ZIMAGE_ADDR)=0A=
+RIMSTART      :=3D 0x9FC00000=0A=
+=0A=
+LOADADDR      :=3D 0x$(shell $(NM) $(SYSTEM) | grep "A _text" |cut -f1 =
-d' ')=0A=
+KERNEL_ENTRY  :=3D $(shell $(OBJDUMP) -f $(SYSTEM) | sed -n -e =
's/^start address //p')=0A=
+=0A=
+#######################################################################=
#############=0A=
+ZIMFLAGS        =3D s/IMSTART/$(ZIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+RIMFLAGS        =3D s/IMSTART/$(RIMSTART)/;s/BSS_START/$(ZBSS)/=0A=
+CFLAGS	:=3D -fno-pic -nostdinc -G 0 -mno-abicalls -fno-pic -pipe =
-I$(TOPDIR)/include=0A=
+AFLAGS	:=3D -D__ASSEMBLY__ $(CFLAGS)=0A=
+=0A=
+#######################################################################=
#############=0A=
+OBJECTS=3D $(obj)/piggy.o $(obj)/head.o $(obj)/misc.o=0A=
+ifneq ($(ZDEBUG),0)=0A=
+OBJECTS +=3D $(obj)/uart16550.o=0A=
+endif=0A=
+=0A=
+$(obj)/zImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(ZIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/rImage.lds: $(obj)/image.lds.in $(KERNELCONFIG)=0A=
+	@sed "$(RIMFLAGS)" < $< > $@=0A=
+=0A=
+$(obj)/piggy.o: $(SYSTEM) $(obj)/Makefile=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(SYSTEM) =
$(SYSTEM).bin=0A=
+	gzip -f -9 < $(SYSTEM).bin > $(SYSTEM).gz=0A=
+	echo "O_FORMAT:  " $(O_FORMAT); =0A=
+	$(LD) -r -b binary --oformat $(O_FORMAT) -o $(obj)/piggy.o =
$(SYSTEM).gz=0A=
+	rm -f $(SYSTEM).bin $(SYSTEM).gz=0A=
+=0A=
+$(obj)/head.o: $(obj)/head.S $(SYSTEM) $(obj)/Makefile=0A=
+	$(CC) $(AFLAGS) -DKERNEL_ENTRY=3D$(KERNEL_ENTRY) -c $(obj)/head.S -o =
$(obj)/head.o=0A=
+=0A=
+$(obj)/misc.o: $(obj)/misc.c $(obj)/Makefile=0A=
+	$(CC) $(CFLAGS) -DLOADADDR=3D$(LOADADDR) -DFREE_RAM=3D$(FREE_RAM) =
-DEND_RAM=3D$(END_RAM) \=0A=
+		-c $< -DZDEBUG=3D$(ZDEBUG) -o $(obj)/misc.o=0A=
+=0A=
+$(obj)/uart16550.o: $(obj)/uart16550.c $(KERNELCONFIG)=0A=
+	$(CC) $(CFLAGS) -c $< -o $(obj)/uart16550.o=0A=
+=0A=
+$(obj)/csu_idt.o: $(obj)/csu_idt.S Makefile $(SYSTEM)=0A=
+	$(CC) $(AFLAGS) $(COMMSWITCHES) -c $< -o $(obj)/csu_idt.o=0A=
+=0A=
+zImage: $(obj)/zImage.lds $(SYSTEM) $(OBJECTS)=0A=
+	$(LD) -T$(obj)/zImage.lds -o $(TOPDIR)/zImage $(OBJECTS)=0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/zImage =
$(TOPDIR)/zImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/zImage.bin $(TOPDIR)/zImage.prm=0A=
+	$(SIZE) $(TOPDIR)/zImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/zImage.size=0A=
+	rm -f *.o=0A=
+=0A=
+rImage: $(obj)/rImage.lds $(SYSTEM) $(OBJECTS) $(obj)/csu_idt.o=0A=
+	echo $(TOPDRIR)=0A=
+	@rm -f $(TOPDIR)/*.prm=0A=
+	$(LD) -T$(obj)/rImage.lds -o $(TOPDIR)/rImage $(obj)/csu_idt.o =
$(OBJECTS) =0A=
+	$(OBJCOPY) -S -O binary -R .note -R .comment $(TOPDIR)/rImage =
$(TOPDIR)/rImage.bin=0A=
+	$(OBJCOPY) -I binary -S -O srec --srec-forceS3 --srec-len=3D32 =
--change-start=3D0x00000000 \=0A=
+		 $(TOPDIR)/rImage.bin $(TOPDIR)/rImage.prm=0A=
+	$(SIZE) $(TOPDIR)/rImage |awk -F" " '{ print $$4 "\t" $$5 }' > =
$(TOPDIR)/rImage.size=0A=
+	rm -f *.o=0A=
+clean:=0A=
+	rm -f *.o $(TOPDIR)/zImage* $(TOPDIR)/rImage* $(TOPDIR)/*.prm =
$(TOPDIR)/rImage.size $(TOPDIR)/zImage.size=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/misc.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/misc.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/misc.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/misc.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,339 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Code to un-compress linux image=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/types.h>=0A=
+=0A=
+/*=0A=
+ * gzip declarations=0A=
+ */=0A=
+#define OF(args)  args=0A=
+#define STATIC static=0A=
+#define memzero(s, n)     memset ((s), 0, (n))=0A=
+typedef unsigned char uch;=0A=
+typedef unsigned short ush;=0A=
+typedef unsigned long ulg;=0A=
+#define WSIZE 0x8000		/* Window size must be at least 32k, */=0A=
+				/* and a power of two */=0A=
+static uch *inbuf;		/* input buffer */=0A=
+static uch window[WSIZE];	/* Sliding window buffer */=0A=
+=0A=
+/* gzip flag byte */=0A=
+#define ASCII_FLAG   0x01	/* bit 0 set: file probably ASCII text */=0A=
+#define CONTINUATION 0x02	/* bit 1 set: continuation of multi-part =
gzip file */=0A=
+#define EXTRA_FIELD  0x04	/* bit 2 set: extra field present */=0A=
+#define ORIG_NAME    0x08	/* bit 3 set: original file name present =
*/=0A=
+#define COMMENT      0x10	/* bit 4 set: file comment present */=0A=
+#define ENCRYPTED    0x20	/* bit 5 set: file is encrypted */=0A=
+#define RESERVED     0xC0	/* bit 6,7:   reserved */=0A=
+=0A=
+=0A=
+static unsigned insize;	/* valid bytes in inbuf */=0A=
+static unsigned inptr;	/* index of next byte to be processed in inbuf =
*/=0A=
+static unsigned outcnt;	/* bytes in output buffer */=0A=
+=0A=
+void variable_init(void);=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *);=0A=
+extern void putc_init(void);=0A=
+extern void putc(unsigned char c);=0A=
+#endif=0A=
+static int fill_inbuf(void);=0A=
+static void flush_window(void);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+extern char input_data[];=0A=
+=0A=
+extern char input_data_end[];=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void int2hex(unsigned long val)=0A=
+{=0A=
+        unsigned char buf[10];=0A=
+        int i;=0A=
+        for (i =3D 7;  i >=3D 0;  i--)=0A=
+        {=0A=
+                buf[i] =3D "0123456789ABCDEF"[val & 0x0F];=0A=
+                val >>=3D 4;=0A=
+        }=0A=
+        buf[8] =3D '\0';=0A=
+        puts(buf);=0A=
+}=0A=
+#endif=0A=
+=0A=
+static unsigned long byte_count;=0A=
+=0A=
+int get_byte(void)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	static int printCnt;=0A=
+#endif=0A=
+	unsigned char c =3D (inptr < insize ? inbuf[inptr++] : =
fill_inbuf());=0A=
+	byte_count++;=0A=
+=0A=
+#if ZDEBUG > 1=0A=
+	if (printCnt++ < 32)=0A=
+	{=0A=
+	  puts("byte count =3D ");=0A=
+	  int2hex(byte_count);=0A=
+	  puts(" byte val =3D ");=0A=
+	  int2hex(c);=0A=
+	  puts("\n");=0A=
+	}=0A=
+#endif=0A=
+	return c;=0A=
+}=0A=
+=0A=
+/* Diagnostic functions */=0A=
+#ifdef DEBUG=0A=
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}=0A=
+#  define Trace(x) fprintf x=0A=
+#  define Tracev(x) {if (verbose) fprintf x ;}=0A=
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}=0A=
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}=0A=
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}=0A=
+#else=0A=
+#  define Assert(cond,msg)=0A=
+#  define Trace(x)=0A=
+#  define Tracev(x)=0A=
+#  define Tracevv(x)=0A=
+#  define Tracec(c,x)=0A=
+#  define Tracecv(c,x)=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * This is set up by the setup-routine at boot-time=0A=
+ */=0A=
+=0A=
+static long bytes_out;=0A=
+static uch *output_data;=0A=
+static unsigned long output_ptr;=0A=
+=0A=
+=0A=
+static void *malloc(int size);=0A=
+static void free(void *where);=0A=
+static void error(char *m);=0A=
+static void gzip_mark(void **);=0A=
+static void gzip_release(void **);=0A=
+=0A=
+static unsigned long free_mem_ptr;=0A=
+static unsigned long free_mem_end_ptr;=0A=
+=0A=
+#include "../../../../../../lib/inflate.c"=0A=
+=0A=
+static void *malloc(int size)=0A=
+{=0A=
+	void *p;=0A=
+=0A=
+	if (size < 0)=0A=
+		error("Malloc error\n");=0A=
+	if (free_mem_ptr <=3D 0) error("Memory error\n");=0A=
+=0A=
+	free_mem_ptr =3D (free_mem_ptr + 3) & ~3;	/* Align */=0A=
+=0A=
+	p =3D (void *) free_mem_ptr;=0A=
+	free_mem_ptr +=3D size;=0A=
+=0A=
+	if (free_mem_ptr >=3D free_mem_end_ptr)=0A=
+		error("\nOut of memory\n");=0A=
+=0A=
+	return p;=0A=
+}=0A=
+=0A=
+static void free(void *where)=0A=
+{				/* Don't care */=0A=
+}=0A=
+=0A=
+static void gzip_mark(void **ptr)=0A=
+{=0A=
+	*ptr =3D (void *) free_mem_ptr;=0A=
+}=0A=
+=0A=
+static void gzip_release(void **ptr)=0A=
+{=0A=
+	free_mem_ptr =3D (long) *ptr;=0A=
+}=0A=
+#if ZDEBUG > 0=0A=
+static void puts(const char *s)=0A=
+{=0A=
+	while (*s) {=0A=
+		if (*s =3D=3D 10)=0A=
+			putc(13);=0A=
+		putc(*s++);=0A=
+	}=0A=
+}=0A=
+#endif=0A=
+void *memset(void *s, int c, size_t n)=0A=
+{=0A=
+	int i;=0A=
+	char *ss =3D (char *) s;=0A=
+=0A=
+	for (i =3D 0; i < n; i++)=0A=
+		ss[i] =3D c;=0A=
+	return s;=0A=
+}=0A=
+=0A=
+void *memcpy(void *__dest, __const void *__src, size_t __n)=0A=
+{=0A=
+	int i;=0A=
+	char *d =3D (char *) __dest, *s =3D (char *) __src;=0A=
+=0A=
+	for (i =3D 0; i < __n; i++)=0A=
+		d[i] =3D s[i];=0A=
+	return __dest;=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Fill the input buffer. This is called only when the buffer is =
empty=0A=
+ * and at least one byte is really needed.=0A=
+ */=0A=
+static int fill_inbuf(void)=0A=
+{=0A=
+	if (insize !=3D 0) {=0A=
+		error("ran out of input data\n");=0A=
+	}=0A=
+=0A=
+	inbuf =3D input_data;=0A=
+	insize =3D &input_data_end[0] - &input_data[0];=0A=
+	inptr =3D 1;=0A=
+	return inbuf[0];=0A=
+}=0A=
+=0A=
+/* =
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=0A=
+ * Write the output window window[0..outcnt-1] and update crc and =
bytes_out.=0A=
+ * (Used for the decompressed data only.)=0A=
+ */=0A=
+static void flush_window(void)=0A=
+{=0A=
+	ulg c =3D crc;		/* temporary variable */=0A=
+	unsigned n;=0A=
+	uch *in, *out, ch;=0A=
+=0A=
+	in =3D window;=0A=
+	out =3D &output_data[output_ptr];=0A=
+	for (n =3D 0; n < outcnt; n++) {=0A=
+		ch =3D *out++ =3D *in++;=0A=
+		c =3D crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);=0A=
+	}=0A=
+	crc =3D c;=0A=
+	bytes_out +=3D (ulg) outcnt;=0A=
+	output_ptr +=3D (ulg) outcnt;=0A=
+	outcnt =3D 0;=0A=
+}=0A=
+=0A=
+#if ZDEBUG > 0=0A=
+void check_mem(void)=0A=
+{=0A=
+	int i;=0A=
+=0A=
+	puts("\ncplens =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplens[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\ncplext =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(cplext[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\nborder =3D ");=0A=
+	for (i =3D 0; i < 10; i++) {=0A=
+		int2hex(border[i]);=0A=
+		puts(" ");=0A=
+	}=0A=
+	puts("\n");=0A=
+}=0A=
+#endif=0A=
+static void error(char *x)=0A=
+{=0A=
+#if ZDEBUG > 1=0A=
+	check_mem();=0A=
+	puts("\n\n");=0A=
+	puts(x);=0A=
+	puts("byte_count =3D ");=0A=
+	int2hex(byte_count);=0A=
+	puts("\n");=0A=
+	puts("\n\n -- Error. System halted");=0A=
+#endif=0A=
+	while (1);		/* Halt */=0A=
+}=0A=
+=0A=
+void variable_init(void)=0A=
+{=0A=
+	byte_count =3D 0;=0A=
+	output_data =3D (char *) LOADADDR;=0A=
+	free_mem_ptr =3D FREE_RAM;=0A=
+	free_mem_end_ptr =3D END_RAM;=0A=
+#if ZDEBUG > 1=0A=
+	puts("output_data      0x");=0A=
+	int2hex((unsigned long)output_data); puts("\n");=0A=
+	puts("free_mem_ptr     0x");=0A=
+	int2hex(free_mem_ptr); puts("\n");=0A=
+	puts("free_mem_end_ptr 0x");=0A=
+	int2hex(free_mem_end_ptr); puts("\n");=0A=
+	puts("input_data       0x");=0A=
+	int2hex((unsigned long)input_data); puts("\n");=0A=
+#endif=0A=
+}=0A=
+=0A=
+int decompress_kernel(void)=0A=
+{=0A=
+#if ZDEBUG > 0=0A=
+  putc_init();=0A=
+#if ZDEBUG > 2=0A=
+  check_mem();=0A=
+#endif=0A=
+#endif=0A=
+=0A=
+  variable_init();=0A=
+=0A=
+  makecrc();=0A=
+#if ZDEBUG > 0=0A=
+  puts("\n");=0A=
+  puts("Uncompressing Linux... \n");=0A=
+#endif=0A=
+  gunzip();		// ...see inflate.c=0A=
+#if ZDEBUG > 0=0A=
+  puts("Ok, booting the kernel.\n");=0A=
+#endif=0A=
+=0A=
+#if ZDEBUG > 1=0A=
+ {=0A=
+  unsigned long *p =3D (unsigned long *)LOADADDR;=0A=
+  int2hex(p[0]); puts("\n");=0A=
+  int2hex(p[1]); puts("\n");=0A=
+  int2hex(p[2]); puts("\n");=0A=
+  int2hex(p[3]); puts("\n");=0A=
+ }=0A=
+#endif=0A=
+=0A=
+  return 0;=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/rImage.lds =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/rImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/rImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/rImage.lds	=
2006-03-09 16:25:49.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x9FC00000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32438/EB438/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/s438.h =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/s438.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/s438.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/s438.h	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,137 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Some useful macros.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S438__=0A=
+#define __S438__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+=0A=
+/*=0A=
+** following defines simple and uniform to save and restore context=0A=
+** when enrtering and leaving as assemblu language program when =
memory=0A=
+** and registers are both premiunm.=0A=
+*/=0A=
+#define SAVE_CNTXT  \=0A=
+  subu  sp, 64;     \=0A=
+  sw    t0, 60(sp); \=0A=
+  sw    t1, 56(sp); \=0A=
+  sw    t2, 52(sp); \=0A=
+  sw    t3, 48(sp); \=0A=
+  sw    t4, 44(sp); \=0A=
+  sw    t5, 40(sp); \=0A=
+  sw    t6, 36(sp); \=0A=
+  sw    t7, 32(sp); \=0A=
+  sw    t8, 28(sp); \=0A=
+  sw    t9, 24(sp); \=0A=
+  sw    a0, 20(sp); \=0A=
+  sw    a1, 16(sp); \=0A=
+  sw    a2, 12(sp); \=0A=
+  sw    a3,  8(sp); \=0A=
+  sw    ra,  4(sp)=0A=
+=0A=
+#define RSTR_CNTXT  \=0A=
+  lw    t0, 60(sp); \=0A=
+  lw    t1, 56(sp); \=0A=
+  lw    t2, 52(sp); \=0A=
+  lw    t3, 48(sp); \=0A=
+  lw    t4, 44(sp); \=0A=
+  lw    t5, 40(sp); \=0A=
+  lw    t6, 36(sp); \=0A=
+  lw    t7, 32(sp); \=0A=
+  lw    t8, 28(sp); \=0A=
+  lw    t9, 24(sp); \=0A=
+  lw    a0, 20(sp); \=0A=
+  lw    a1, 16(sp); \=0A=
+  lw    a2, 12(sp); \=0A=
+  lw    a3,  8(sp); \=0A=
+  lw    ra,  4(sp); \=0A=
+  add   sp, 64=0A=
+=0A=
+/*=0A=
+** Following define is to specify a maximum value for a software=0A=
+** busy wait counter.=0A=
+*/=0A=
+/*=0A=
+#define LP_CNT_100NS  1000      =0A=
+#define LP_CNT_3S     1000000   =0A=
+*/=0A=
+=0A=
+/*=0A=
+** Following are other common timer definitions.=0A=
+*/=0A=
+#define DDRBASE           PHYS_TO_K1(0x18018000)=0A=
+#define TIMER_BASE        PHYS_TO_K1(0x18028000)  =0A=
+#define WTC_BASE          PHYS_TO_K1(0x18030000)  =0A=
+#define INTERRUPT_BASE    PHYS_TO_K1(0x18038000)=0A=
+#define GPIO_BASE         PHYS_TO_K1(0x18048000)=0A=
+=0A=
+#define TIMEOUT_COUNT     0x00000FFF=0A=
+#define ENABLE_TIMER      0x1=0A=
+#define DISABLE_TIMER     0x0=0A=
+#define BIG_VALUE         0xFFFFFFFF=0A=
+=0A=
+/*=0A=
+** following few lines define a macro DISPLAY=0A=
+** which is used to write a set of 4 characters=0A=
+** onto the EB438 LED.=0A=
+*/=0A=
+=0A=
+#ifndef LED_BASE=0A=
+=0A=
+#define LED_BASE    PHYS_TO_K1(0x0C040000)=0A=
+#define LED_DIGIT0  0x3=0A=
+#define LED_DIGIT1  0x2=0A=
+#define LED_DIGIT2  0x1=0A=
+#define LED_DIGIT3  0x0=0A=
+#define LED_CLEAR   -0x40000=0A=
+=0A=
+#endif=0A=
+=0A=
+#define DISPLAY(d0, d1, d2, d3)     \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        lb    t7, LED_CLEAR(t6)               ;\=0A=
+              nop                             ;\=0A=
+        li    t7, (d0) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT0(t6)              ;\=0A=
+        li    t7, (d1) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT1(t6)              ;\=0A=
+        li    t7, (d2) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT2(t6)              ;\=0A=
+        li    t7, (d3) & 0xff                 ;\=0A=
+        sb    t7, LED_DIGIT3(t6)=0A=
+=0A=
+#define LEDCLEAR()              \=0A=
+        li    t6, LED_BASE                    ;\=0A=
+        lb    t7, LED_CLEAR(t6)               ;\=0A=
+              nop=0A=
+=0A=
+#define DESTRUCTIVE     1=0A=
+#define NONDESTRUCTIVE  0=0A=
+=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/s438ram.h =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/s438ram.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/s438ram.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/s438ram.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,140 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IDT EB438 DDR setup values.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __S438RAM__=0A=
+#define __S438RAM__=0A=
+/******************************** D E F I N E S =
*******************************/=0A=
+=0A=
+#define SRAM_ONLY     1=0A=
+#define SDRAM_ONLY    2=0A=
+#define SRAM_N_SDRAM  3=0A=
+#define SDRAM_N_SRAM  4=0A=
+=0A=
+#define MB32      1=0A=
+#define MB64      2=0A=
+#define MB128     3=0A=
+=0A=
+#define DEV_CTL_BASE        PHYS_TO_K1(0x18010000)  /* device =
controller regs */=0A=
+#define DDR_CTL_BASE        PHYS_TO_K1(0x18018010)  /* DDR controller =
regs */=0A=
+=0A=
+#define DEV1_BASE           0x08000000=0A=
+#define DEV_PROM_MASK       0xFFF00000=0A=
+#define DEV_PROM_CTRL       0x04108324=0A=
+#define DEV_PROM_TC         0x00000000=0A=
+#define DEV_FLASH_MASK      0xFFE00000=0A=
+#define DEV_FLASH_CTRL      0x04108325=0A=
+#define DEV_FLASH_TC        0x00000000=0A=
+=0A=
+#define DEV2_BASE           0x0C000000=0A=
+#define DEV2_MASK           0xFC000000=0A=
+#define DEV2_CTRL           0x04108324              /* 8-bit devices =
*/=0A=
+#define DEV2_TC             0x00000000=0A=
+=0A=
+#if MEMCFG =3D=3D SRAM_ONLY || MEMCFG =3D=3D SRAM_N_SDRAM=0A=
+#define DEV3_BASE           0x00000000=0A=
+#define DEV3_MASK           0xFC000000=0A=
+#define DEV3_CTRL           0x04108325              /* 16-bit devices =
*/=0A=
+#define DEV3_TC             0x00000000=0A=
+#else=0A=
+#define DEV3_BASE           0x10000000=0A=
+#define DEV3_MASK           0xFC000000=0A=
+#define DEV3_CTRL           0x04108325              /* 16-bit devices =
*/=0A=
+#define DEV3_TC             0x00000000=0A=
+#endif=0A=
+=0A=
+#define DEV4_BASE           0x00000000=0A=
+#define DEV4_MASK           0x00000000=0A=
+#define DEV4_CTRL           0x0FFFFFF4              /* ?-bit devices =
*/=0A=
+#define DEV4_TC             0x00001FFF=0A=
+=0A=
+#define DEV5_BASE           0x00000000=0A=
+#define DEV5_MASK           0x00000000=0A=
+#define DEV5_CTRL           0x0FFFFFF4              /* ?-bit devices =
*/=0A=
+#define DEV5_TC             0x00001FFF=0A=
+=0A=
+#define DATA_PATTERN        0xA5A5A5A5=0A=
+#define RCOUNT              PHYS_TO_K1(0x18028024)=0A=
+=0A=
+#if DRAMSZ =3D=3D MB64=0A=
+=0A=
+#if MEMCFG =3D=3D SDRAM_ONLY || MEMCFG =3D=3D SDRAM_N_SRAM=0A=
+#define DDR0_BASE_VAL       0x00000000=0A=
+#define DDR0_MASK_VAL       0xFC000000=0A=
+#define DDR1_BASE_VAL       0x04000000=0A=
+#define DDR1_MASK_VAL       0x00000000=0A=
+#define DDR0_ABASE_VAL      0x08000000=0A=
+#define DDR0_AMASK_VAL      0x00000000=0A=
+#elif MEMCFG =3D=3D SRAM_N_SDRAM=0A=
+#define DDR0_BASE_VAL       0x04000000=0A=
+#define DDR0_MASK_VAL       0xFC000000=0A=
+#define DDR1_BASE_VAL       0x08000000=0A=
+#define DDR1_MASK_VAL       0x00000000=0A=
+#define DDR0_ABASE_VAL      0x00000000=0A=
+#define DDR0_AMASK_VAL      0x00000000=0A=
+#elif MEMCFG =3D=3D SRAM_ONLY=0A=
+#define DDR0_BASE_VAL       0x00000000=0A=
+#define DDR0_MASK_VAL       0x00000000=0A=
+#define DDR1_BASE_VAL       0x00000000=0A=
+#define DDR1_MASK_VAL       0x00000000=0A=
+#define DDR0_ABASE_VAL      0x00000000=0A=
+#define DDR0_AMASK_VAL      0x00000000=0A=
+#else=0A=
+illegal value for MEMCFG=0A=
+#endif=0A=
+=0A=
+#define DDRC_VAL_NORMAL       0x82984940 /* 0xA32A4980 */=0A=
+#define DDRC_VAL_AT_INIT      0x02984940 /* 0x232A4980 */=0A=
+=0A=
+#define DDR_REF_CMP_FAST      0x00000080 /* was 0x00000100 */=0A=
+#define DDR_REF_CMP_VAL       0x00000080 /* was 0x0000040e */=0A=
+#define DDR_REF_CMP_VAL_ZB    0x0000040E=0A=
+=0A=
+#define DDR_CUST_NOP          0x0000003F=0A=
+#define DDR_CUST_PRECHARGE    0x00000033=0A=
+#define DDR_CUST_REFRESH      0x00000027=0A=
+#define DDR_LD_MODE_REG       0x00000023=0A=
+#define DDR_LD_EMODE_REG      0x00000063=0A=
+=0A=
+/* =0A=
+ * All generated addresses for DDR init during custom transactions are =
shifted=0A=
+ * by two address lines - see spec for used DDR chip=0A=
+ */=0A=
+#define DDR_PRECHARGE_OFFSET  0x00001000  /* 0x0400 - 9-bit page*/=0A=
+#define DDR_EMODE_VAL         0x00000000  /* 0x0000 */=0A=
+#define DDR_DLL_RES_MODE_VAL  0x00000584  /* 0x0161 - Reset DLL, CL2.5 =
*/=0A=
+#define DDR_DLL_MODE_VAL      0x00000184  /* 0x0061 - CL2.5 */=0A=
+=0A=
+#define DELAY_200USEC         25000       /* not exactly */=0A=
+=0A=
+#else=0A=
+#error "unrecognized dram size"=0A=
+#endif=0A=
+=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/uart16550.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/uart16550.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/uart16550.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/uart16550.c	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,177 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   UART code.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+=0A=
+#define RC32438_REG_BASE   0xb8000000=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32438_UART0_BASE (RC32438_REG_BASE + 0x50003)=0A=
+#else=0A=
+#define RC32438_UART0_BASE (RC32438_REG_BASE + 0x50000)=0A=
+#endif=0A=
+=0A=
+#define BASE		   RC32438_UART0_BASE=0A=
+=0A=
+#define MAX_BAUD		(CONFIG_IDT_BOARD_FREQ / 16)=0A=
+#define REG_OFFSET		0x4=0A=
+=0A=
+/* =3D=3D=3D CONFIG =3D=3D=3D */=0A=
+=0A=
+/*=0A=
+ * #define BASE			0xb2001000=0A=
+ * #define MAX_BAUD		1152000=0A=
+ * #define REG_OFFSET		0x10=0A=
+ */=0A=
+#if (!defined(BASE) || !defined(MAX_BAUD) || !defined(REG_OFFSET))=0A=
+#error You must define BASE, MAX_BAUD and REG_OFFSET in the =
Makefile.=0A=
+#endif=0A=
+=0A=
+#ifndef INIT_SERIAL_PORT=0A=
+#define INIT_SERIAL_PORT	1=0A=
+#endif=0A=
+=0A=
+#ifndef DEFAULT_BAUD=0A=
+//#define DEFAULT_BAUD		UART16550_BAUD_115200=0A=
+#define DEFAULT_BAUD		UART16550_BAUD_9600=0A=
+#endif=0A=
+#ifndef DEFAULT_PARITY=0A=
+#define DEFAULT_PARITY		UART16550_PARITY_NONE=0A=
+#endif=0A=
+#ifndef DEFAULT_DATA=0A=
+#define DEFAULT_DATA		UART16550_DATA_8BIT=0A=
+#endif=0A=
+#ifndef DEFAULT_STOP=0A=
+#define DEFAULT_STOP		UART16550_STOP_1BIT=0A=
+#endif=0A=
+=0A=
+/* =3D=3D=3D END OF CONFIG =3D=3D=3D */=0A=
+=0A=
+typedef         unsigned char uint8;=0A=
+typedef         unsigned int  uint32;=0A=
+=0A=
+#define         UART16550_BAUD_2400             2400=0A=
+#define         UART16550_BAUD_4800             4800=0A=
+#define         UART16550_BAUD_9600             9600=0A=
+#define         UART16550_BAUD_19200            19200=0A=
+#define         UART16550_BAUD_38400            38400=0A=
+#define         UART16550_BAUD_57600            57600=0A=
+#define         UART16550_BAUD_115200           115200=0A=
+=0A=
+#define         UART16550_PARITY_NONE           0=0A=
+#define         UART16550_PARITY_ODD            0x08=0A=
+#define         UART16550_PARITY_EVEN           0x18=0A=
+#define         UART16550_PARITY_MARK           0x28=0A=
+#define         UART16550_PARITY_SPACE          0x38=0A=
+=0A=
+#define         UART16550_DATA_5BIT             0x0=0A=
+#define         UART16550_DATA_6BIT             0x1=0A=
+#define         UART16550_DATA_7BIT             0x2=0A=
+#define         UART16550_DATA_8BIT             0x3=0A=
+=0A=
+#define         UART16550_STOP_1BIT             0x0=0A=
+#define         UART16550_STOP_2BIT             0x4=0A=
+=0A=
+/* register offset */=0A=
+#define		OFS_RCV_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_TRANS_HOLD		(0*REG_OFFSET)=0A=
+#define		OFS_SEND_BUFFER		(0*REG_OFFSET)=0A=
+#define		OFS_INTR_ENABLE		(1*REG_OFFSET)=0A=
+#define		OFS_INTR_ID		(2*REG_OFFSET)=0A=
+#define		OFS_DATA_FORMAT		(3*REG_OFFSET)=0A=
+#define		OFS_LINE_CONTROL	(3*REG_OFFSET)=0A=
+#define		OFS_MODEM_CONTROL	(4*REG_OFFSET)=0A=
+#define		OFS_RS232_OUTPUT	(4*REG_OFFSET)=0A=
+#define		OFS_LINE_STATUS		(5*REG_OFFSET)=0A=
+#define		OFS_MODEM_STATUS	(6*REG_OFFSET)=0A=
+#define		OFS_RS232_INPUT		(6*REG_OFFSET)=0A=
+#define		OFS_SCRATCH_PAD		(7*REG_OFFSET)=0A=
+=0A=
+#define		OFS_DIVISOR_LSB		(0*REG_OFFSET)=0A=
+#define		OFS_DIVISOR_MSB		(1*REG_OFFSET)=0A=
+=0A=
+#define		UART16550_READ(y)    (*((volatile uint8*)(BASE + y)))=0A=
+#define		UART16550_WRITE(y, z)  ((*((volatile uint8*)(BASE + y))) =3D =
z)=0A=
+=0A=
+static void Uart16550Init(uint32 baud, uint8 data, uint8 parity, uint8 =
stop)=0A=
+{=0A=
+	/* disable interrupts */=0A=
+	UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	UART16550_WRITE(OFS_INTR_ENABLE, 0);=0A=
+=0A=
+	/* set up baud rate */=0A=
+	{=0A=
+		uint32 divisor;=0A=
+=0A=
+		/* set DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x80);=0A=
+=0A=
+		/* set divisor */=0A=
+		divisor =3D MAX_BAUD / baud;=0A=
+		UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);=0A=
+		UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00)>>8);=0A=
+=0A=
+		/* clear DIAB bit */=0A=
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x0);=0A=
+	}=0A=
+=0A=
+	/* set data format */=0A=
+	UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);=0A=
+}=0A=
+=0A=
+=0A=
+void=0A=
+putc_init(void)=0A=
+{=0A=
+#if INIT_SERIAL_PORT=0A=
+	Uart16550Init(DEFAULT_BAUD, DEFAULT_DATA, DEFAULT_PARITY, =
DEFAULT_STOP);=0A=
+#endif=0A=
+}=0A=
+=0A=
+void=0A=
+putc(unsigned char c)=0A=
+{=0A=
+	while ((UART16550_READ(OFS_LINE_STATUS) &0x20) =3D=3D 0);=0A=
+	UART16550_WRITE(OFS_SEND_BUFFER, c);=0A=
+}=0A=
+=0A=
+#if 0=0A=
+unsigned char=0A=
+getc(void)=0A=
+{=0A=
+	while((UART16550_READ(OFS_LINE_STATUS) & 0x1) =3D=3D 0);=0A=
+	return UART16550_READ(OFS_RCV_BUFFER);=0A=
+}=0A=
+=0A=
+int=0A=
+tstc(void)=0A=
+{=0A=
+	return((UART16550_READ(OFS_LINE_STATUS) & 0x01) !=3D 0);=0A=
+}=0A=
+#endif=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/zImage.lds =
idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/zImage.lds=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/boot/zImage.lds	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/boot/zImage.lds	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,31 @@=0A=
+OUTPUT_ARCH(mips)=0A=
+ENTRY(zstartup)=0A=
+SECTIONS=0A=
+{=0A=
+  /* Read-only sections, merged into text segment: */=0A=
+  . =3D 0x88000000;=0A=
+  .init          : { *(.init)		} =3D0=0A=
+  .text      :=0A=
+  {=0A=
+    _ftext =3D . ;=0A=
+    *(.text)=0A=
+    *(.rodata)=0A=
+    *(.rodata1)=0A=
+   . =3D ALIGN(4096);=0A=
+    input_data =3D .;=0A=
+    arch/mips/idt-boards/rc32438/EB438/boot/piggy.o=0A=
+    input_data_end =3D .;=0A=
+   . =3D ALIGN(4096);=0A=
+    *(.gnu.warning)=0A=
+  } =3D0=0A=
+=0A=
+  .reginfo : { *(.reginfo) }=0A=
+=0A=
+   . =3D 0x800A0000;=0A=
+  __bss_start =3D .;=0A=
+  .bss       :=0A=
+  {=0A=
+   *(.bss)=0A=
+  _end =3D . ;=0A=
+  }=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/idtIRQ.S =
idtlinux/arch/mips/idt-boards/rc32438/EB438/idtIRQ.S=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/idtIRQ.S	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/idtIRQ.S	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,72 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Intterrupt dispatcher code for IDT boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>				=0A=
+#include <asm/asm.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/regdef.h>=0A=
+#include <asm/stackframe.h>=0A=
+=0A=
+	.text=0A=
+	.set	noreorder=0A=
+	.set	noat=0A=
+	.align	5=0A=
+	NESTED(idtIRQ, PT_SIZE, sp)=0A=
+	SAVE_ALL=0A=
+	CLI=0A=
+=0A=
+	.set	at=0A=
+	.set	noreorder=0A=
+=0A=
+	mfc0    t0, CP0_CAUSE=0A=
+	move	a1, sp=0A=
+								  =0A=
+	/* check for r4k counter/timer IRQ. */=0A=
+=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+	andi    t1, t0, CAUSEF_IP2=0A=
+#else	=0A=
+	andi    t1, t0, CAUSEF_IP7=0A=
+#endif	=0A=
+	beqz    t1, 1f=0A=
+	nop=0A=
+=0A=
+	jal     idt_timer_interrupt=0A=
+	li	a0, 7=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+1:=0A=
+	jal	rc32438_irqdispatch=0A=
+	move	a0, t0=0A=
+	j	ret_from_irq=0A=
+	nop=0A=
+=0A=
+	END(idtIRQ)=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/irq.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/irq.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/irq.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/irq.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,264 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Interrupt routines for IDT EB438 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/errno.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/signal.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/timex.h>=0A=
+#include <linux/slab.h>=0A=
+#include <linux/random.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_gpio.h>=0A=
+=0A=
+#include <asm/irq.h>=0A=
+=0A=
+#undef DEBUG_IRQ=0A=
+#ifdef DEBUG_IRQ=0A=
+/* note: prints function name for you */=0A=
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## =
args)=0A=
+#else=0A=
+#define DPRINTK(fmt, args...)=0A=
+#endif=0A=
+=0A=
+extern asmlinkage void idtIRQ(void);=0A=
+static unsigned int startup_irq(unsigned int irq);=0A=
+static void end_irq(unsigned int irq_nr);=0A=
+static void mask_and_ack_irq(unsigned int irq_nr);=0A=
+static void rc32438_enable_irq(unsigned int irq_nr);=0A=
+static void rc32438_disable_irq(unsigned int irq_nr);=0A=
+=0A=
+extern void __init init_generic_irq(void);=0A=
+=0A=
+typedef struct {=0A=
+  u32 mask;=0A=
+  volatile u32 *base_addr;=0A=
+} intr_group_t;=0A=
+=0A=
+static const intr_group_t intr_group[NUM_INTR_GROUPS] =3D {=0A=
+  { 0x0000efff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 0 * IC_GROUP_OFFSET) =
},=0A=
+  { 0x00001fff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 1 * IC_GROUP_OFFSET) =
},=0A=
+  { 0x00000007, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 2 * IC_GROUP_OFFSET) =
},=0A=
+  { 0x0003ffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 3 * IC_GROUP_OFFSET) =
},=0A=
+  { 0xffffffff, (u32 *)KSEG1ADDR(IC_GROUP0_PEND + 4 * IC_GROUP_OFFSET) =
}=0A=
+};=0A=
+=0A=
+#define READ_PEND(base) (*(base))=0A=
+#define READ_MASK(base) (*(base + 2))=0A=
+#define WRITE_MASK(base, val) (*(base + 2) =3D (val))=0A=
+=0A=
+static inline int irq_to_group(unsigned int irq_nr)=0A=
+{=0A=
+  return ((irq_nr - GROUP0_IRQ_BASE) >> 5);=0A=
+}=0A=
+=0A=
+static inline int group_to_ip(unsigned int group)=0A=
+{=0A=
+  return group + 2;=0A=
+}=0A=
+=0A=
+static inline void enable_local_irq(unsigned int ip)=0A=
+{=0A=
+  int ipnum =3D 0x100 << ip;=0A=
+  clear_c0_cause(ipnum);=0A=
+  set_c0_status(ipnum);=0A=
+}=0A=
+=0A=
+static inline void disable_local_irq(unsigned int ip)=0A=
+{=0A=
+  int ipnum =3D 0x100 << ip;=0A=
+  clear_c0_status(ipnum);=0A=
+}=0A=
+=0A=
+static inline void ack_local_irq(unsigned int ip)=0A=
+{=0A=
+  int ipnum =3D 0x100 << ip;=0A=
+  clear_c0_cause(ipnum);=0A=
+}=0A=
+static void rc32438_enable_irq(unsigned int irq_nr)=0A=
+{=0A=
+  int           ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+  unsigned int  group, intr_bit;=0A=
+  volatile unsigned int  *addr;=0A=
+  if (ip < 0)=0A=
+    {=0A=
+      enable_local_irq(irq_nr);=0A=
+    }=0A=
+  else=0A=
+    {=0A=
+  // calculate group=0A=
+  group =3D ip >> 5;=0A=
+    =0A=
+  // calc interrupt bit within group=0A=
+  ip -=3D (group << 5);=0A=
+  intr_bit =3D 1 << ip;=0A=
+    =0A=
+  // first enable the IP mapped to this IRQ=0A=
+  enable_local_irq(group_to_ip(group));=0A=
+    =0A=
+  addr =3D intr_group[group].base_addr;=0A=
+  // unmask intr within group=0A=
+  WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);=0A=
+    }=0A=
+}=0A=
+=0A=
+static void rc32438_disable_irq(unsigned int irq_nr)=0A=
+{=0A=
+  int           ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+  unsigned int  group, intr_bit, mask;=0A=
+  volatile unsigned int  *addr;=0A=
+=0A=
+  // calculate group=0A=
+  group =3D ip >> 5;=0A=
+=0A=
+  // calc interrupt bit within group=0A=
+  ip -=3D group << 5;=0A=
+  intr_bit =3D 1 << ip;=0A=
+    =0A=
+  addr =3D intr_group[group].base_addr;=0A=
+  // mask intr within group=0A=
+  mask =3D READ_MASK(addr);=0A=
+  mask |=3D intr_bit;=0A=
+  WRITE_MASK(addr, mask);=0A=
+    =0A=
+  /*=0A=
+    if there are no more interrupts enabled in this=0A=
+    group, disable corresponding IP=0A=
+  */=0A=
+  if (mask =3D=3D intr_group[group].mask)=0A=
+    disable_local_irq(group_to_ip(group));=0A=
+}=0A=
+static unsigned int startup_irq(unsigned int irq_nr)=0A=
+{=0A=
+  rc32438_enable_irq(irq_nr);=0A=
+  return 0; =0A=
+}=0A=
+=0A=
+static void shutdown_irq(unsigned int irq_nr)=0A=
+{=0A=
+  rc32438_disable_irq(irq_nr);=0A=
+  return;=0A=
+}=0A=
+=0A=
+static void mask_and_ack_irq(unsigned int irq_nr)=0A=
+{=0A=
+  rc32438_disable_irq(irq_nr);=0A=
+  ack_local_irq(group_to_ip(irq_to_group(irq_nr)));=0A=
+}=0A=
+=0A=
+static void end_irq(unsigned int irq_nr)=0A=
+{=0A=
+=0A=
+  int ip =3D irq_nr - GROUP0_IRQ_BASE;=0A=
+  unsigned int intr_bit, group;=0A=
+  volatile unsigned int *addr;=0A=
+=0A=
+  if (!(irq_desc[irq_nr].status & (IRQ_DISABLED | IRQ_INPROGRESS))) =
{=0A=
+    if (irq_nr =3D=3D GROUP4_IRQ_BASE + 27)=0A=
+      gpio->gpioistat =3D 0xf7ffffff;=0A=
+      =0A=
+    group =3D ip >> 5;=0A=
+=0A=
+    // calc interrupt bit within group=0A=
+    ip -=3D (group << 5);=0A=
+    intr_bit =3D 1 << ip;=0A=
+    =0A=
+    // first enable the IP mapped to this IRQ=0A=
+    enable_local_irq(group_to_ip(group));=0A=
+  =0A=
+    addr =3D intr_group[group].base_addr;=0A=
+    // unmask intr within group=0A=
+    WRITE_MASK(addr, READ_MASK(addr) & ~intr_bit);=0A=
+  } =0A=
+  else {=0A=
+    printk("warning: end_irq %d did not enable (%x)\n", =0A=
+	   irq_nr, irq_desc[irq_nr].status);=0A=
+  }=0A=
+}=0A=
+=0A=
+static struct hw_interrupt_type rc32438_irq_type =3D {=0A=
+  .typename =3D "IDT438",=0A=
+  .startup  =3D startup_irq,=0A=
+  .shutdown =3D shutdown_irq,=0A=
+  .enable   =3D rc32438_enable_irq,=0A=
+  .disable  =3D rc32438_disable_irq,=0A=
+  .ack      =3D mask_and_ack_irq,=0A=
+  .end      =3D end_irq,=0A=
+};=0A=
+=0A=
+void __init arch_init_irq(void)=0A=
+{=0A=
+  int i;=0A=
+  printk("Initializing IRQ's: %d out of %d\n", RC32438_NR_IRQS, =
NR_IRQS);  =0A=
+  memset(irq_desc, 0, sizeof(irq_desc));=0A=
+  set_except_vector(0, idtIRQ);=0A=
+  =0A=
+  for (i =3D 0; i < RC32438_NR_IRQS; i++) {=0A=
+    irq_desc[i].status =3D IRQ_DISABLED;=0A=
+    irq_desc[i].action =3D NULL;=0A=
+    irq_desc[i].depth =3D 1;=0A=
+    irq_desc[i].handler =3D &rc32438_irq_type;=0A=
+    spin_lock_init(&irq_desc[i].lock);=0A=
+  }=0A=
+}=0A=
+=0A=
+/* Main Interrupt dispatcher */=0A=
+void rc32438_irqdispatch(unsigned long cp0_cause, struct pt_regs =
*regs)=0A=
+{=0A=
+  unsigned int ip, pend, group;=0A=
+  volatile unsigned int *addr;=0A=
+=0A=
+  if ((ip =3D (cp0_cause & 0x7c00))) {=0A=
+    group =3D 21 - rc32438_clz(ip);=0A=
+=0A=
+    addr =3D intr_group[group].base_addr;=0A=
+=0A=
+    pend =3D READ_PEND(addr);=0A=
+    pend &=3D ~READ_MASK(addr); // only unmasked interrupts=0A=
+    pend =3D 39 - rc32438_clz(pend);=0A=
+    do_IRQ((group << 5) + pend, regs);=0A=
+    return;=0A=
+  } =0A=
+  else=0A=
+    return;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/Makefile =
idtlinux/arch/mips/idt-boards/rc32438/EB438/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/Makefile	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,42 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for IDT EB438 board BSP=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+# =0A=
+# =0A=
+#######################################################################=
########=0A=
+=0A=
+=0A=
+.S.s:=0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:=0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+obj-y	 :=3D irq.o prom.o time.o setup.o idtIRQ.o reset.o=0A=
+obj-$(CONFIG_KGDB)			+=3D serial_gdb.o=0A=
+obj-$(CONFIG_SERIAL_8250) 		+=3D serial.o=0A=
+subdir-$(CONFIG_IDT_BOOT_NVRAM)		+=3D nvram=0A=
+obj-$(CONFIG_IDT_BOOT_NVRAM)    	+=3D nvram/built-in.o=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram/Makefile =
idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram/Makefile	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram/Makefile	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,42 @@=0A=
+#######################################################################=
########=0A=
+#=0A=
+#  BRIEF MODULE DESCRIPTION=0A=
+#     Makefile for IDT EB438 nvram access routines=0A=
+#=0A=
+#  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+#=0A=
+#  This program is free software; you can redistribute  it and/or =
modify it=0A=
+#  under  the terms of  the GNU General  Public License as published =
by the=0A=
+#  Free Software Foundation;  either version 2 of the  License, or (at =
your=0A=
+#  option) any later version.=0A=
+#=0A=
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+#=0A=
+#   You should have received a copy of the  GNU General Public License =
along=0A=
+#   with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+#   675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+#=0A=
+#######################################################################=
########=0A=
+=0A=
+.S.s:   =0A=
+	$(CPP) $(CFLAGS) $< -o $*.s=0A=
+.S.o:   =0A=
+	$(CC) $(CFLAGS) -c $< -o $*.o=0A=
+=0A=
+obj-y   :=3D nvram438.o=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram/nvram438.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram/nvram438.c=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram/nvram438.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram/nvram438.c	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,356 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram interface routines.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+  =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/string.h>=0A=
+#include "nvram438.h"=0A=
+#include "rtc.h"=0A=
+#define  NVRAM_BASE RTCLOCK_BASE=0A=
+=0A=
+extern void setenv (char *e, char *v, int rewrite);=0A=
+extern void unsetenv (char *e);=0A=
+extern void mapenv (int (*func)(char *, char *));=0A=
+extern char *getenv (char *s);=0A=
+extern void purgeenv(void);=0A=
+=0A=
+static void nvram_initenv(void);=0A=
+=0A=
+static unsigned char=0A=
+nvram_getbyte(int offs)=0A=
+{=0A=
+  return(*((unsigned char*)(NVRAM_BASE + offs)));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setbyte(int offs, unsigned char val)=0A=
+{=0A=
+  unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE + =
offs);=0A=
+=0A=
+  *nvramDataPointer =3D val;=0A=
+}=0A=
+=0A=
+static unsigned short=0A=
+nvram_getshort(int offs)=0A=
+{=0A=
+  return((nvram_getbyte(offs) << 8) | nvram_getbyte(offs + 1));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setshort(int offs, unsigned short val)=0A=
+{=0A=
+  nvram_setbyte(offs, (unsigned char)((val >> 8) & 0xff));=0A=
+  nvram_setbyte(offs + 1, (unsigned char)(val & 0xff));=0A=
+}=0A=
+/*=0A=
+ * calculate NVRAM checksum=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_calcsum(void)=0A=
+{=0A=
+  unsigned short sum =3D NV_MAGIC;=0A=
+  int     i;=0A=
+=0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i +=3D 2)=0A=
+    sum +=3D nvram_getshort(i);=0A=
+  return(sum);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * update the nvram checksum=0A=
+ */=0A=
+static void=0A=
+nvram_updatesum (void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_CSUM, nvram_calcsum());=0A=
+}=0A=
+=0A=
+/*=0A=
+ * test validity of nvram by checksumming it=0A=
+ */=0A=
+static int=0A=
+nvram_isvalid(void)=0A=
+{=0A=
+  static int  is_valid;=0A=
+=0A=
+  if (is_valid)=0A=
+    return(1);=0A=
+=0A=
+  if (nvram_getshort(NVOFF_MAGIC) !=3D NV_MAGIC)=0A=
+    nvram_initenv();=0A=
+  is_valid =3D 1;=0A=
+  return(1);=0A=
+}=0A=
+=0A=
+/* return nvram address of environment string */=0A=
+static int=0A=
+nvram_matchenv(char *s)=0A=
+{=0A=
+  int envsize, envp, n, i, varsize;=0A=
+  char *var;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  if (envsize > ENV_AVAIL)=0A=
+    return(0);     /* sanity */=0A=
+    =0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  if ((n =3D strlen (s)) > 255)=0A=
+    return(0);=0A=
+    =0A=
+  while (envsize > 0) {=0A=
+    varsize =3D nvram_getbyte(envp);=0A=
+    if (varsize =3D=3D 0 || (envp + varsize) > ENV_TOP)=0A=
+      return(0);   /* sanity */=0A=
+    for (i =3D envp + 1, var =3D s; i <=3D envp + n; i++, var++) {=0A=
+      char c1 =3D nvram_getbyte(i);=0A=
+      char c2 =3D *var;=0A=
+      if (islower(c1))=0A=
+        c1 =3D toupper(c1);=0A=
+      if (islower(c2))=0A=
+        c2 =3D toupper(c2);=0A=
+      if (c1 !=3D c2)=0A=
+        break;=0A=
+    }=0A=
+    if (i > envp + n) {       /* match so far */=0A=
+      if (n =3D=3D varsize - 1)   /* match on boolean */=0A=
+        return(envp);=0A=
+      if (nvram_getbyte(i) =3D=3D '=3D')  /* exact match on variable =
*/=0A=
+        return(envp);=0A=
+    }=0A=
+    envsize -=3D varsize;=0A=
+    envp +=3D varsize;=0A=
+  }=0A=
+  return(0);=0A=
+}=0A=
+=0A=
+static void nvram_initenv(void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_delenv(char *s)=0A=
+{=0A=
+  int nenvp, envp, envsize, nbytes;=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return;=0A=
+=0A=
+  nenvp =3D envp + nvram_getbyte(envp);=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  nbytes =3D envsize - (nenvp - ENV_BASE);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envsize - (nenvp - envp));=0A=
+  while (nbytes--) {=0A=
+    nvram_setbyte(envp, nvram_getbyte(nenvp));=0A=
+    envp++;=0A=
+    nenvp++;=0A=
+  }=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static int=0A=
+nvram_setenv(char *s, char *v)=0A=
+{=0A=
+  int ns, nv, total;=0A=
+  int envp;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return(-1);=0A=
+=0A=
+  nvram_delenv(s);=0A=
+  ns =3D strlen(s);=0A=
+  if (ns =3D=3D 0)=0A=
+    return (-1);=0A=
+  if (v && *v) {=0A=
+    nv =3D strlen(v);=0A=
+    total =3D ns + nv + 2;=0A=
+  }=0A=
+  else {=0A=
+    nv =3D 0;=0A=
+    total =3D ns + 1;=0A=
+  }=0A=
+  if (total > 255 || total > ENV_AVAIL - =
nvram_getshort(NVOFF_ENVSIZE))=0A=
+    return(-1);=0A=
+=0A=
+  envp =3D ENV_BASE + nvram_getshort(NVOFF_ENVSIZE);=0A=
+=0A=
+  nvram_setbyte(envp, (unsigned char) total); =0A=
+  envp++;=0A=
+=0A=
+  while (ns--) {=0A=
+    nvram_setbyte(envp, *s); =0A=
+    envp++; =0A=
+    s++;=0A=
+  }=0A=
+=0A=
+  if (nv) {=0A=
+    nvram_setbyte(envp, '=3D'); =0A=
+    envp++;=0A=
+    while (nv--) {=0A=
+      nvram_setbyte(envp, *v); =0A=
+      envp++; =0A=
+      v++;=0A=
+    }=0A=
+  }=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envp-ENV_BASE);=0A=
+  nvram_updatesum();=0A=
+  return 0;=0A=
+}=0A=
+=0A=
+static char *=0A=
+nvram_getenv(char *s)=0A=
+{=0A=
+  static char buf[256];   /* FIXME: this cannot be static */=0A=
+  int envp, ns, nbytes, i;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return((char *)0);=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return((char *)0);=0A=
+  ns =3D strlen(s);=0A=
+  if (nvram_getbyte(envp) =3D=3D ns + 1)  /* boolean */=0A=
+    buf[0] =3D '\0';=0A=
+  else {=0A=
+    nbytes =3D nvram_getbyte(envp) - (ns + 2);=0A=
+    envp +=3D ns + 2;=0A=
+    for (i =3D 0; i < nbytes; i++)=0A=
+      buf[i] =3D nvram_getbyte(envp++);=0A=
+    buf[i] =3D '\0';=0A=
+  }=0A=
+  return(buf);=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_unsetenv(char *s)=0A=
+{=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  nvram_delenv(s);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * apply func to each string in environment=0A=
+ */=0A=
+static void=0A=
+nvram_mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  int envsize, envp, n, i, seeneql;=0A=
+  char name[256], value[256];=0A=
+  char c, *s;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  while (envsize > 0) {=0A=
+    value[0] =3D '\0';=0A=
+    seeneql =3D 0;=0A=
+    s =3D name;=0A=
+    n =3D nvram_getbyte(envp);=0A=
+    for (i =3D envp + 1; i < envp + n; i++) {=0A=
+      c =3D nvram_getbyte(i);=0A=
+      if ((c =3D=3D '=3D') && !seeneql) {=0A=
+        *s =3D '\0';=0A=
+        s =3D value;=0A=
+        seeneql =3D 1;=0A=
+        continue;=0A=
+      }=0A=
+      *s++ =3D c;=0A=
+    }=0A=
+    *s =3D '\0';=0A=
+    (*func)(name, value);=0A=
+    envsize -=3D n;=0A=
+    envp +=3D n;=0A=
+  }=0A=
+}=0A=
+#if 0=0A=
+static unsigned int=0A=
+digit(char c)=0A=
+{=0A=
+  if ('0' <=3D c && c <=3D '9')=0A=
+    return (c - '0');=0A=
+  if ('A' <=3D c && c <=3D 'Z')=0A=
+    return (10 + c - 'A');=0A=
+  if ('a' <=3D c && c <=3D 'z')=0A=
+    return (10 + c - 'a');=0A=
+  return (~0);=0A=
+}=0A=
+#endif=0A=
+/*=0A=
+ * Wrappers to allow 'special' environment variables to get =
processed=0A=
+ */=0A=
+void=0A=
+setenv(char *e, char *v, int rewrite)=0A=
+{=0A=
+  if (nvram_getenv(e) && !rewrite)=0A=
+    return;=0A=
+    =0A=
+  nvram_setenv(e, v);=0A=
+}=0A=
+=0A=
+char *=0A=
+getenv(char *e)=0A=
+{=0A=
+  return(nvram_getenv(e));=0A=
+}=0A=
+=0A=
+void=0A=
+unsetenv(char *e)=0A=
+{=0A=
+  nvram_unsetenv(e);=0A=
+}=0A=
+=0A=
+void=0A=
+purgeenv()=0A=
+{=0A=
+  int i;=0A=
+  unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE);=0A=
+  =0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i++)=0A=
+    *nvramDataPointer++ =3D 0;=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+  nvram_setshort(NVOFF_CSUM, NV_MAGIC);=0A=
+}=0A=
+=0A=
+void=0A=
+mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  nvram_mapenv(func);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram/nvram438.h =
idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram/nvram438.h=0A=
--- =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram/nvram438.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram/nvram438.h	=
2006-03-09 16:25:50.000000000 -0800=0A=
@@ -0,0 +1,57 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     nvram definitions.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_EB438_NVRAM_H__=0A=
+#define __IDT_EB438_NVRAM_H__=0A=
+#define NVOFFSET        0                 /* use all of NVRAM */=0A=
+=0A=
+/* Offsets to reserved locations */=0A=
+              /* size description */=0A=
+#define NVOFF_MAGIC     (NVOFFSET + 0)    /* 2 magic value */=0A=
+#define NVOFF_CSUM      (NVOFFSET + 2)    /* 2 NVRAM environment =
checksum */=0A=
+#define NVOFF_ENVSIZE   (NVOFFSET + 4)    /* 2 size of 'environment' =
*/=0A=
+#define NVOFF_TEST      (NVOFFSET + 5)    /* 1 cold start test byte =
*/=0A=
+#define NVOFF_ETHADDR   (NVOFFSET + 6)    /* 6 decoded ethernet =
address */=0A=
+#define NVOFF_UNUSED    (NVOFFSET + 12)   /* 0 current end of table =
*/=0A=
+=0A=
+#define NV_MAGIC        0xdeaf            /* nvram magic number */=0A=
+#define NV_RESERVED     32                /* number of reserved bytes =
*/=0A=
+=0A=
+#undef  NVOFF_ETHADDR=0A=
+#define NVOFF_ETHADDR   (NVOFFSET + NV_RESERVED - 6)=0A=
+=0A=
+/* number of bytes available for environment */=0A=
+#define ENV_BASE        (NVOFFSET + NV_RESERVED)=0A=
+#define ENV_TOP         TD_NVRAM_SIZE=0A=
+#define ENV_AVAIL       (ENV_TOP - ENV_BASE)=0A=
+=0A=
+#endif //__IDT_EB438_NVRAM_H__=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram/rtc.h =
idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram/rtc.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram/rtc.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram/rtc.h	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,74 @@=0A=
+/**********************************************************************=
****
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     DS1553(Dallas Semiconductor) Real Time Clock and Non-Volatile =
RAM.
+ *
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)
+ *        =20
+ *  This program is free software; you can redistribute  it and/or =
modify it
+ *  under  the terms of  the GNU General  Public License as published =
by the
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIR=
ECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License =
along
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ =
************************************************************************=
**
+ */
+
+#ifndef __IDT_EB438_RTC_H__
+#define __IDT_EB438_RTC_H__
+#define RTCLOCK_BASE    0xAC080000
+
+/*
+ * To maintain endianess independence, make all accesses as 32-bit
+ * words with appropriate shifting.
+ */
+#define TD_NVRAM_SIZE 0x2000
+
+typedef struct td_clock {
+  unsigned char ram[0x1FF0];
+  unsigned char flags;
+  unsigned char dummy;
+  unsigned char alarm_secs;
+  unsigned char alarm_mins;
+  unsigned char alarm_hours;
+  unsigned char alarm_date;
+  unsigned char interrupts;
+  unsigned char watchdog;
+  unsigned char century;
+  unsigned char secs;
+  unsigned char mins;
+  unsigned char hours;
+  unsigned char weekday;
+  unsigned char date;
+  unsigned char month;
+  unsigned char year;
+} RTC;
+
+#define rtc (*((volatile RTC *)RTCLOCK_BASE))
+
+/*
+ * Control register bit definitions
+ */
+#define TDC_ENA_READ      0x40
+#define TDC_DIS_READ      0xbf
+
+#define TDC_ENA_WRITE     0x80
+#define TDC_DIS_WRITE     0x7f
+
+#define TDC_RUN_OSC       0x80
+
+#endif //__IDT_EB438_RTC_H__
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram438.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram438.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram438.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram438.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,348 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Routines to access the NVRAM on IDT EB438 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/string.h>=0A=
+#include <linux/ctype.h>=0A=
+=0A=
+#include "nvram438.h"=0A=
+#include "rtc.h"=0A=
+#define  NVRAM_BASE RTCLOCK_BASE=0A=
+=0A=
+extern void setenv (char *e, char *v, int rewrite);=0A=
+extern void unsetenv (char *e);=0A=
+extern void mapenv (int (*func)(char *, char *));=0A=
+extern char *getenv (char *s);=0A=
+extern void purgeenv(void);=0A=
+=0A=
+static void nvram_initenv(void);=0A=
+=0A=
+static unsigned char=0A=
+nvram_getbyte(int offs)=0A=
+{=0A=
+  return(*((unsigned char*)(NVRAM_BASE + offs)));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setbyte(int offs, unsigned char val)=0A=
+{=0A=
+  unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE + =
offs);=0A=
+=0A=
+  *nvramDataPointer =3D val;=0A=
+}=0A=
+=0A=
+/*=0A=
+ * BigEndian!=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_getshort(int offs)=0A=
+{=0A=
+  return((nvram_getbyte(offs) << 8) | nvram_getbyte(offs + 1));=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_setshort(int offs, unsigned short val)=0A=
+{=0A=
+  nvram_setbyte(offs, (unsigned char)((val >> 8) & 0xff));=0A=
+  nvram_setbyte(offs + 1, (unsigned char)(val & 0xff));=0A=
+}=0A=
+/*=0A=
+ * calculate NVRAM checksum=0A=
+ */=0A=
+static unsigned short=0A=
+nvram_calcsum(void)=0A=
+{=0A=
+  unsigned short sum =3D NV_MAGIC;=0A=
+  int     i;=0A=
+=0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i +=3D 2)=0A=
+    sum +=3D nvram_getshort(i);=0A=
+  return(sum);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * update the nvram checksum=0A=
+ */=0A=
+static void=0A=
+nvram_updatesum (void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_CSUM, nvram_calcsum());=0A=
+}=0A=
+=0A=
+/*=0A=
+ * test validity of nvram by checksumming it=0A=
+ */=0A=
+static int=0A=
+nvram_isvalid(void)=0A=
+{=0A=
+  static int  is_valid;=0A=
+=0A=
+  if (is_valid)=0A=
+    return(1);=0A=
+=0A=
+  if (nvram_getshort(NVOFF_MAGIC) !=3D NV_MAGIC)=0A=
+    nvram_initenv();=0A=
+  is_valid =3D 1;=0A=
+  return(1);=0A=
+}=0A=
+=0A=
+/* return nvram address of environment string */=0A=
+static int=0A=
+nvram_matchenv(char *s)=0A=
+{=0A=
+  int envsize, envp, n, i, varsize;=0A=
+  char *var;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  if (envsize > ENV_AVAIL)=0A=
+    return(0);     /* sanity */=0A=
+    =0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  if ((n =3D strlen (s)) > 255)=0A=
+    return(0);=0A=
+    =0A=
+  while (envsize > 0) {=0A=
+    varsize =3D nvram_getbyte(envp);=0A=
+    if (varsize =3D=3D 0 || (envp + varsize) > ENV_TOP)=0A=
+      return(0);   /* sanity */=0A=
+    for (i =3D envp + 1, var =3D s; i <=3D envp + n; i++, var++) {=0A=
+      char c1 =3D nvram_getbyte(i);=0A=
+      char c2 =3D *var;=0A=
+      if (islower(c1))=0A=
+        c1 =3D toupper(c1);=0A=
+      if (islower(c2))=0A=
+        c2 =3D toupper(c2);=0A=
+      if (c1 !=3D c2)=0A=
+        break;=0A=
+    }=0A=
+    if (i > envp + n) {       /* match so far */=0A=
+      if (n =3D=3D varsize - 1)   /* match on boolean */=0A=
+        return(envp);=0A=
+      if (nvram_getbyte(i) =3D=3D '=3D')  /* exact match on variable =
*/=0A=
+        return(envp);=0A=
+    }=0A=
+    envsize -=3D varsize;=0A=
+    envp +=3D varsize;=0A=
+  }=0A=
+  return(0);=0A=
+}=0A=
+=0A=
+static void nvram_initenv(void)=0A=
+{=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_delenv(char *s)=0A=
+{=0A=
+  int nenvp, envp, envsize, nbytes;=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return;=0A=
+=0A=
+  nenvp =3D envp + nvram_getbyte(envp);=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  nbytes =3D envsize - (nenvp - ENV_BASE);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envsize - (nenvp - envp));=0A=
+  while (nbytes--) {=0A=
+    nvram_setbyte(envp, nvram_getbyte(nenvp));=0A=
+    envp++;=0A=
+    nenvp++;=0A=
+  }=0A=
+  nvram_updatesum();=0A=
+}=0A=
+=0A=
+static int=0A=
+nvram_setenv(char *s, char *v)=0A=
+{=0A=
+  int ns, nv, total;=0A=
+  int envp;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return(-1);=0A=
+=0A=
+  nvram_delenv(s);=0A=
+  ns =3D strlen(s);=0A=
+  if (ns =3D=3D 0)=0A=
+    return (-1);=0A=
+  if (v && *v) {=0A=
+    nv =3D strlen(v);=0A=
+    total =3D ns + nv + 2;=0A=
+  }=0A=
+  else {=0A=
+    nv =3D 0;=0A=
+    total =3D ns + 1;=0A=
+  }=0A=
+  if (total > 255 || total > ENV_AVAIL - =
nvram_getshort(NVOFF_ENVSIZE))=0A=
+    return(-1);=0A=
+=0A=
+  envp =3D ENV_BASE + nvram_getshort(NVOFF_ENVSIZE);=0A=
+=0A=
+  nvram_setbyte(envp, (unsigned char) total); =0A=
+  envp++;=0A=
+=0A=
+  while (ns--) {=0A=
+    nvram_setbyte(envp, *s); =0A=
+    envp++; =0A=
+    s++;=0A=
+  }=0A=
+=0A=
+  if (nv) {=0A=
+    nvram_setbyte(envp, '=3D'); =0A=
+    envp++;=0A=
+    while (nv--) {=0A=
+      nvram_setbyte(envp, *v); =0A=
+      envp++; =0A=
+      v++;=0A=
+    }=0A=
+  }=0A=
+  nvram_setshort(NVOFF_ENVSIZE, envp-ENV_BASE);=0A=
+  nvram_updatesum();=0A=
+  return 0;=0A=
+}=0A=
+=0A=
+static char *=0A=
+nvram_getenv(char *s)=0A=
+{=0A=
+  static char buf[256];   /* FIXME: this cannot be static */=0A=
+  int envp, ns, nbytes, i;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return((char *)0);=0A=
+=0A=
+  envp =3D nvram_matchenv(s);=0A=
+  if (envp =3D=3D 0)=0A=
+    return((char *)0);=0A=
+  ns =3D strlen(s);=0A=
+  if (nvram_getbyte(envp) =3D=3D ns + 1)  /* boolean */=0A=
+    buf[0] =3D '\0';=0A=
+  else {=0A=
+    nbytes =3D nvram_getbyte(envp) - (ns + 2);=0A=
+    envp +=3D ns + 2;=0A=
+    for (i =3D 0; i < nbytes; i++)=0A=
+      buf[i] =3D nvram_getbyte(envp++);=0A=
+    buf[i] =3D '\0';=0A=
+  }=0A=
+  return(buf);=0A=
+}=0A=
+=0A=
+static void=0A=
+nvram_unsetenv(char *s)=0A=
+{=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  nvram_delenv(s);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * apply func to each string in environment=0A=
+ */=0A=
+static void=0A=
+nvram_mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  int envsize, envp, n, i, seeneql;=0A=
+  char name[256], value[256];=0A=
+  char c, *s;=0A=
+=0A=
+  if (!nvram_isvalid())=0A=
+    return;=0A=
+=0A=
+  envsize =3D nvram_getshort(NVOFF_ENVSIZE);=0A=
+  envp =3D ENV_BASE;=0A=
+=0A=
+  while (envsize > 0) {=0A=
+    value[0] =3D '\0';=0A=
+    seeneql =3D 0;=0A=
+    s =3D name;=0A=
+    n =3D nvram_getbyte(envp);=0A=
+    for (i =3D envp + 1; i < envp + n; i++) {=0A=
+      c =3D nvram_getbyte(i);=0A=
+      if ((c =3D=3D '=3D') && !seeneql) {=0A=
+        *s =3D '\0';=0A=
+        s =3D value;=0A=
+        seeneql =3D 1;=0A=
+        continue;=0A=
+      }=0A=
+      *s++ =3D c;=0A=
+    }=0A=
+    *s =3D '\0';=0A=
+    (*func)(name, value);=0A=
+    envsize -=3D n;=0A=
+    envp +=3D n;=0A=
+  }=0A=
+}=0A=
+/*=0A=
+ * Wrappers to allow 'special' environment variables to get =
processed=0A=
+ */=0A=
+void=0A=
+setenv(char *e, char *v, int rewrite)=0A=
+{=0A=
+  if (nvram_getenv(e) && !rewrite)=0A=
+    return;=0A=
+    =0A=
+  nvram_setenv(e, v);=0A=
+}=0A=
+=0A=
+char *=0A=
+getenv(char *e)=0A=
+{=0A=
+  return(nvram_getenv(e));=0A=
+}=0A=
+=0A=
+void=0A=
+unsetenv(char *e)=0A=
+{=0A=
+  nvram_unsetenv(e);=0A=
+}=0A=
+=0A=
+void=0A=
+purgeenv()=0A=
+{=0A=
+  int i;=0A=
+  unsigned char* nvramDataPointer =3D (unsigned char*)(NVRAM_BASE);=0A=
+  =0A=
+  for (i =3D ENV_BASE; i < ENV_TOP; i++)=0A=
+    *nvramDataPointer++ =3D 0;=0A=
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);=0A=
+  nvram_setshort(NVOFF_ENVSIZE, 0);=0A=
+  nvram_setshort(NVOFF_CSUM, NV_MAGIC);=0A=
+}=0A=
+=0A=
+void=0A=
+mapenv(int (*func)(char *, char *))=0A=
+{=0A=
+  nvram_mapenv(func);=0A=
+}=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram438.h =
idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram438.h=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/nvram438.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/nvram438.h	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,54 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Definitions for NVRAM on IDT EB438 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#define NVOFFSET        0                 /* use all of NVRAM */=0A=
+=0A=
+/* Offsets to reserved locations */=0A=
+              /* size description */=0A=
+#define NVOFF_MAGIC     (NVOFFSET + 0)    /* 2 magic value */=0A=
+#define NVOFF_CSUM      (NVOFFSET + 2)    /* 2 NVRAM environment =
checksum */=0A=
+#define NVOFF_ENVSIZE   (NVOFFSET + 4)    /* 2 size of 'environment' =
*/=0A=
+#define NVOFF_TEST      (NVOFFSET + 5)    /* 1 cold start test byte =
*/=0A=
+#define NVOFF_ETHADDR   (NVOFFSET + 6)    /* 6 decoded ethernet =
address */=0A=
+#define NVOFF_UNUSED    (NVOFFSET + 12)   /* 0 current end of table =
*/=0A=
+=0A=
+#define NV_MAGIC        0xdeaf            /* nvram magic number */=0A=
+#define NV_RESERVED     32                /* number of reserved bytes =
*/=0A=
+=0A=
+#undef  NVOFF_ETHADDR=0A=
+#define NVOFF_ETHADDR   (NVOFFSET + NV_RESERVED - 6)=0A=
+=0A=
+/* number of bytes available for environment */=0A=
+#define ENV_BASE        (NVOFFSET + NV_RESERVED)=0A=
+#define ENV_TOP         TD_NVRAM_SIZE=0A=
+#define ENV_AVAIL       (ENV_TOP - ENV_BASE)=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/prom.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/prom.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/prom.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/prom.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,138 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     prom interface routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/string.h>=0A=
+#include <linux/console.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <linux/bootmem.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serialP.h>=0A=
+#include <asm/serial.h>=0A=
+#include <linux/ioport.h>=0A=
+=0A=
+unsigned int idt_cpu_freq =3D CONFIG_IDT_BOARD_FREQ;=0A=
+EXPORT_SYMBOL(idt_cpu_freq);=0A=
+=0A=
+extern void setup_serial_port(void);=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+extern void mapenv(int (*func)(char *, char *));=0A=
+static int make_bootparm(char *name,char *val)=0A=
+{ =0A=
+/*=0A=
+ * The bootparameters are obtained from NVRAM and formatted here.=0A=
+ * For e.g.=0A=
+ *=0A=
+ *    netaddr=3D10.0.1.95=0A=
+ *    bootaddr=3D10.0.0.139=0A=
+ *    bootfile=3Dvmlinus=0A=
+ *    bootparm1=3Droot=3D/dev/nfs=0A=
+ *    bootparm2=3Dip=3D10.0.1.95=0A=
+ *=0A=
+ * is parsed to:=0A=
+ *=0A=
+ *      root=3D/dev/nfs ip=3D10.0.1.95=0A=
+ *=0A=
+ * in arcs_cmdline[].=0A=
+ */=0A=
+  if (strncmp(name, "bootparm", 8) =3D=3D 0) {=0A=
+    strcat(arcs_cmdline,val);=0A=
+    strcat(arcs_cmdline," ");=0A=
+  }=0A=
+  else if(strncmp(name, "HZ", 2) =3D=3D 0) {=0A=
+    idt_cpu_freq =3D simple_strtoul(val, 0, 10);=0A=
+    printk("CPU Clock at %d Hz (from HZ environment variable)\n",=0A=
+           idt_cpu_freq);=0A=
+  }=0A=
+  return 0;=0A=
+}=0A=
+static void prom_init_cmdline(void)=0A=
+{ =0A=
+  memset(arcs_cmdline,0,sizeof(arcs_cmdline));=0A=
+  mapenv(&make_bootparm);=0A=
+}=0A=
+#else=0A=
+/* Kernel Boot parameters */=0A=
+//static unsigned char =
bootparm[]=3D"ip=3D157.165.29.36:157.165.29.18::255.255.0.0::eth0";=0A=
+static unsigned char bootparm[]=3D"console=3DttyS0,9600";=0A=
+#endif=0A=
+extern unsigned long mips_machgroup;=0A=
+extern unsigned long mips_machtype;=0A=
+=0A=
+/* IDT 79EB438 memory map -- we really should be auto sizing it */=0A=
+=0A=
+#define RAM_FIRST       0x80000400  /* Leave room for interrupt =
vectors */=0A=
+#define RAM_SIZE        60*1024*1024=0A=
+#define RAM_END         (0x80000000 + RAM_SIZE)     =0A=
+struct resource rc32438_res_ram =3D {=0A=
+	"RAM",=0A=
+	0,=0A=
+	RAM_SIZE,=0A=
+	IORESOURCE_MEM=0A=
+};=0A=
+=0A=
+char * __init prom_getcmdline(void)=0A=
+{ =0A=
+  return &(arcs_cmdline[0]);=0A=
+}=0A=
+=0A=
+=0A=
+void __init prom_init(void)=0A=
+{=0A=
+#ifdef CONFIG_IDT_BOOT_NVRAM=0A=
+	/* set up command line */=0A=
+	prom_init_cmdline();=0A=
+#else=0A=
+	sprintf(arcs_cmdline,"%s",bootparm);=0A=
+#endif=0A=
+=0A=
+	/* set our arch type */=0A=
+=0A=
+	setup_serial_port();=0A=
+=0A=
+	mips_machgroup =3D MACH_GROUP_IDT;=0A=
+	mips_machtype =3D MACH_IDT_EB438;=0A=
+=0A=
+	/*=0A=
+	 * give all RAM to boot allocator,=0A=
+	 * except where the kernel was loaded=0A=
+	 */=0A=
+	add_memory_region(0,=0A=
+			  rc32438_res_ram.end - rc32438_res_ram.start,=0A=
+			  BOOT_MEM_RAM);=0A=
+}=0A=
+=0A=
+void prom_free_prom_memory(void)=0A=
+{=0A=
+	printk("stubbed prom_free_prom_memory()\n");=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/reset.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/reset.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/reset.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/reset.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,64 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Reset EB438 board.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/irq.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <asm/reboot.h>=0A=
+#include <asm/addrspace.h>    =0A=
+=0A=
+extern void (*flush_cache_all)(void);=0A=
+=0A=
+void idt_reset(void)=0A=
+{=0A=
+=0A=
+  set_c0_status((ST0_BEV | ST0_ERL));=0A=
+  set_c0_config(CONF_CM_UNCACHED);=0A=
+  flush_cache_all();=0A=
+  write_c0_wired(0);=0A=
+=0A=
+  /* Errata item #13 */=0A=
+=0A=
+  *((volatile u32 *)KSEG1ADDR(0x18080000)) =3D 0x0;=0A=
+  *((volatile u32 *)KSEG1ADDR(0x18080018)) =3D 0x0;=0A=
+  *((volatile u32 *)KSEG1ADDR(0x18080024)) =3D 0x0;=0A=
+  *((volatile u32 *)KSEG1ADDR(0x18080030)) =3D 0x0;=0A=
+  *((volatile u32 *)KSEG1ADDR(0x1808003c)) =3D 0x0;=0A=
+=0A=
+  /* Reset*/=0A=
+  *((volatile u32 *)KSEG1ADDR(0x18008000)) =3D 0x80000001;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/serial.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/serial.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/serial.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/serial.c	2006-03-09 =
16:25:49.000000000 -0800=0A=
@@ -0,0 +1,84 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Serial port initialisation.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/tty.h>=0A=
+#include <linux/serial.h>=0A=
+#include <linux/serial_core.h>=0A=
+=0A=
+#include <asm/time.h>=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/irq.h>=0A=
+#include <asm/serial.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32438/rc32438.h>=0A=
+extern int __init early_serial_setup(struct uart_port *port);=0A=
+=0A=
+#define BASE_BAUD (1843200 / 16)=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+extern int __init setup_serial_port(void)=0A=
+{=0A=
+  static struct uart_port serial_req[2];=0A=
+=0A=
+  memset(serial_req, 0, sizeof(serial_req));=0A=
+  serial_req[0].type       =3D PORT_16550A;=0A=
+  serial_req[0].line       =3D 0;=0A=
+  serial_req[0].irq        =3D RC32438_UART0_IRQ;=0A=
+  serial_req[0].flags      =3D STD_COM_FLAGS;=0A=
+  serial_req[0].uartclk    =3D idt_cpu_freq;=0A=
+  serial_req[0].iotype     =3D SERIAL_IO_MEM;=0A=
+  serial_req[0].membase    =3D (char *) =
KSEG1ADDR(RC32438_UART0_BASE);=0A=
+=0A=
+  serial_req[0].mapbase   =3D KSEG1ADDR(RC32438_UART0_BASE);=0A=
+  serial_req[0].regshift   =3D 2;=0A=
+=0A=
+  serial_req[1].type       =3D PORT_16550A;=0A=
+  serial_req[1].line       =3D 1;=0A=
+  serial_req[1].irq        =3D RC32438_UART1_IRQ;=0A=
+  serial_req[1].flags      =3D STD_COM_FLAGS;=0A=
+  serial_req[1].uartclk    =3D idt_cpu_freq;=0A=
+  serial_req[1].iotype     =3D SERIAL_IO_MEM;=0A=
+  serial_req[1].membase    =3D (char *) =
KSEG1ADDR(RC32438_UART1_BASE);=0A=
+=0A=
+  serial_req[1].regshift   =3D 2;=0A=
+  serial_req[1].mapbase   =3D KSEG1ADDR(RC32438_UART1_BASE);=0A=
+=0A=
+  early_serial_setup(&serial_req[0]);=0A=
+  early_serial_setup(&serial_req[1]);=0A=
+=0A=
+  return(0);=0A=
+}=0A=
+//early_initcall(setup_serial_port);=0A=
diff -uNr =
linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/serial_gdb.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/serial_gdb.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/serial_gdb.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/serial_gdb.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,272 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *      EB438 specific polling driver for 16550 UART.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
***=0A=
+ */=0A=
+=0A=
+#include <linux/serial_reg.h>=0A=
+=0A=
+/* set remote gdb baud rate at 115200 */=0A=
+=0A=
+#define GDB_BAUD 115200=0A=
+#define CONS_BAUD 9600=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+=0A=
+/* turn this on to watch the debug protocol echoed on the console port =
*/=0A=
+#undef DEBUG_REMOTE_DEBUG=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define CONS_PORT 0xb8050003u=0A=
+#define GDB_PORT  0xb8050023u=0A=
+#else=0A=
+#define CONS_PORT 0xb8050000u=0A=
+#define GDB_PORT  0xb8050020u=0A=
+#endif=0A=
+           =0A=
+volatile unsigned char *ports[2] =3D {=0A=
+	(volatile unsigned char *)CONS_PORT,=0A=
+	(volatile unsigned char *)GDB_PORT=0A=
+};=0A=
+=0A=
+=0A=
+void reset_gdb_port(void);=0A=
+void cons_putc(char c);=0A=
+int port_getc(int port);=0A=
+void port_putc(int port, char c);=0A=
+=0A=
+int cons_getc(void)=0A=
+{=0A=
+	return port_getc(0);=0A=
+}=0A=
+=0A=
+void cons_putc(char c)=0A=
+{=0A=
+	port_putc(0, c);=0A=
+}=0A=
+=0A=
+void cons_puts(char *s)=0A=
+{=0A=
+	while(*s) {=0A=
+		if(*s =3D=3D '\n') cons_putc('\r');=0A=
+		cons_putc(*s);=0A=
+		s++;=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_do_putn(int n)=0A=
+{=0A=
+	if(n) {=0A=
+		cons_do_putn(n / 10);=0A=
+		cons_putc(n % 10 + '0');=0A=
+	}=0A=
+}=0A=
+=0A=
+void cons_putn(int n)=0A=
+{=0A=
+	if(n < 0) {=0A=
+		cons_putc('-');=0A=
+		n =3D -n;=0A=
+	}=0A=
+=0A=
+	if (n =3D=3D 0) {=0A=
+		cons_putc('0');=0A=
+	} else {=0A=
+		cons_do_putn(n);=0A=
+	}=0A=
+}=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+static enum {HUH, SENDING, GETTING} state;=0A=
+=0A=
+static void sent(int c)=0A=
+{=0A=
+	switch(state) {=0A=
+	case HUH:=0A=
+	case GETTING:=0A=
+		cons_puts("\nSNT ");=0A=
+		state =3D SENDING;=0A=
+		/* fall through */=0A=
+	case SENDING:=0A=
+		cons_putc(c);=0A=
+		break;=0A=
+	}       =0A=
+}=0A=
+=0A=
+static void got(int c)=0A=
+{=0A=
+	switch(state) {=0A=
+	case HUH:=0A=
+	case SENDING:=0A=
+		cons_puts("\nGOT ");=0A=
+		state =3D GETTING;=0A=
+		/* fall through */=0A=
+	case GETTING:=0A=
+		cons_putc(c);=0A=
+		break;=0A=
+	}       =0A=
+}=0A=
+#endif /* DEBUG_REMOTE_DEBUG */=0A=
+=0A=
+static int first =3D 1;=0A=
+=0A=
+int getDebugChar(void)=0A=
+{=0A=
+	int c;=0A=
+=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+	c =3D port_getc(1);=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	got(c);=0A=
+#endif=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+	int c;=0A=
+=0A=
+	while((*(port + UART_LSR * 4) & UART_LSR_DR) =3D=3D 0) {=0A=
+		continue;=0A=
+	}       	=0A=
+=0A=
+	c =3D *(port + UART_RX * 4);=0A=
+=0A=
+	return c;=0A=
+}=0A=
+=0A=
+int port_getc_ready(int p)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+=0A=
+	return *(port + UART_LSR * 4) & UART_LSR_DR;=0A=
+}=0A=
+=0A=
+int isDebugReady(void)=0A=
+{=0A=
+	return port_getc_ready(1);=0A=
+}=0A=
+=0A=
+void putDebugChar(char c)=0A=
+{=0A=
+	if(first) reset_gdb_port();=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	sent(c);=0A=
+#endif=0A=
+=0A=
+	port_putc(1, c);=0A=
+}=0A=
+=0A=
+#define OK_TO_XMT (UART_LSR_TEMT | UART_LSR_THRE)=0A=
+=0A=
+void port_putc(int p, char c)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[p];=0A=
+	volatile unsigned char *lsr =3D port + UART_LSR * 4;=0A=
+=0A=
+	while((*lsr & OK_TO_XMT) !=3D OK_TO_XMT) {=0A=
+		continue;=0A=
+	}=0A=
+=0A=
+	*(port + UART_TX * 4) =3D c;=0A=
+}=0A=
+=0A=
+void reset_gdb_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[1];=0A=
+	unsigned int DIVISOR =3D (idt_cpu_freq / 16 / GDB_BAUD);=0A=
+=0A=
+	first =3D 0;=0A=
+=0A=
+#ifdef DEBUG_REMOTE_DEBUG=0A=
+	cons_puts("reset_gdb_port: initializing remote debug serial port =
(internal UART 1, ");=0A=
+	cons_putn(GDB_BAUD);=0A=
+	cons_puts("baud, MHz=3D");=0A=
+	cons_putn(idt_cpu_freq);=0A=
+	cons_puts(", divisor=3D");=0A=
+	cons_putn(DIVISOR);=0A=
+	cons_puts(")\n");=0A=
+#endif=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + UART_CSR * 4) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + UART_FCR * 4) =3D UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR =
| =0A=
+		UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+	*(port + UART_DLL * 4) =3D DIVISOR;=0A=
+	*(port + UART_DLM * 4) =3D DIVISOR >> 8;=0A=
+=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + UART_IER * 4) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + UART_MCR * 4) =3D 0;=0A=
+}=0A=
+=0A=
+void reset_cons_port(void)=0A=
+{=0A=
+	volatile unsigned char *port =3D ports[0];=0A=
+	  unsigned int DIVISOR =3D (idt_cpu_freq / 16 / CONS_BAUD);=0A=
+=0A=
+	/* reset the port */=0A=
+	*(port + UART_CSR * 4) =3D 0;=0A=
+=0A=
+	/* clear and enable the FIFOs */=0A=
+	*(port + UART_FCR * 4) =3D UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR =
| =0A=
+		UART_FCR_CLEAR_XMIT | UART_FCR_TRIGGER_14;=0A=
+=0A=
+	/* set the baud rate */=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_DLAB;		/* enable DLL, DLM =
registers */=0A=
+=0A=
+	*(port + UART_DLL * 4) =3D DIVISOR;=0A=
+	*(port + UART_DLM * 4) =3D DIVISOR >> 8;=0A=
+	/* set the line control stuff and disable DLL, DLM regs */=0A=
+=0A=
+	*(port + UART_LCR * 4) =3D UART_LCR_STOP | 	/* 2 stop bits */=0A=
+		UART_LCR_WLEN8;				/* 8 bit word length */=0A=
+	=0A=
+	/* leave interrupts off */=0A=
+	*(port + UART_IER * 4) =3D 0;=0A=
+=0A=
+	/* the modem controls don't leave the chip on this port, so leave =
them alone */=0A=
+	*(port + UART_MCR * 4) =3D 0;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/setup.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/setup.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/setup.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/setup.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,172 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     setup routines for IDT EB438 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/pm.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/irq.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/io.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <asm/reboot.h>=0A=
+#include <asm/addrspace.h>    =0A=
+#include <asm/idt-boards/rc32438/rc32438.h>=0A=
+=0A=
+extern char * __init prom_getcmdline(void);=0A=
+=0A=
+extern void (*board_time_init)(void);=0A=
+extern void (*board_timer_setup)(struct irqaction *irq);=0A=
+extern void rc32438_time_init(void);=0A=
+extern void rc32438_timer_setup(struct irqaction *irq);=0A=
+#ifdef CONFIG_RTC_DS1553=0A=
+extern unsigned long (*rtc_get_time)(void);=0A=
+extern int (*rtc_set_time)(unsigned long);=0A=
+extern unsigned long rtc_ds1553_get_time(void);=0A=
+extern int rtc_ds1553_set_time(unsigned long t);=0A=
+#endif  =0A=
+extern void idt_reset(void);=0A=
+void idt_disp_str(char *s);=0A=
+=0A=
+#define DIG_CLEAR ((volatile unsigned char *)0xAC000000)=0A=
+#define DIG0 ((volatile unsigned char *)0xAC040003)=0A=
+#define DIG1 ((volatile unsigned char *)0xAC040002)=0A=
+#define DIG2 ((volatile unsigned char *)0xAC040001)=0A=
+#define DIG3 ((volatile unsigned char *)0xAC040000)=0A=
+=0A=
+void idt_disp_char(int i, char c)=0A=
+{=0A=
+  switch(i) {=0A=
+  case 0: *DIG0 =3D c; break;=0A=
+  case 1: *DIG1 =3D c; break;=0A=
+  case 2: *DIG2 =3D c; break;=0A=
+  case 3: *DIG3 =3D c; break;=0A=
+  default: *DIG0 =3D '?'; break;=0A=
+  }=0A=
+}=0A=
+=0A=
+void idt_disp_str(char *s)=0A=
+{=0A=
+  if(s =3D=3D 0) {=0A=
+    char c;=0A=
+    c =3D *DIG_CLEAR;=0A=
+  } else {=0A=
+    int i;=0A=
+    for(i =3D 0; i < 4; i++) {=0A=
+      if(s[i]) idt_disp_char(i, s[i]);=0A=
+    }=0A=
+  }=0A=
+}=0A=
+=0A=
+=0A=
+static void idt_machine_restart(char *command)=0A=
+{=0A=
+  printk("idt_machine_restart: command=3D%s\n", command);=0A=
+  =0A=
+  idt_reset();=0A=
+}=0A=
+=0A=
+static void idt_machine_halt(void)=0A=
+{=0A=
+  printk("idt_machine_halt:  halted\n");=0A=
+  for(;;) continue;=0A=
+}=0A=
+=0A=
+static void idt_machine_power_off(void)=0A=
+{=0A=
+  printk("idt_machine_power_off:  It is now safe to turn off the =
power\n");=0A=
+  for(;;) continue;=0A=
+}=0A=
+static int __init idt_setup(void)=0A=
+{=0A=
+  char* argptr;=0A=
+  =0A=
+  idt_disp_str("unix");=0A=
+  =0A=
+  argptr =3D prom_getcmdline();=0A=
+=0A=
+#ifdef CONFIG_SERIAL_CONSOLE=0A=
+  if ((argptr =3D strstr(argptr, "console=3D")) =3D=3D NULL) {=0A=
+    argptr =3D prom_getcmdline();=0A=
+    strcat(argptr, " console=3DttyS0,9600");=0A=
+  }=0A=
+#endif=0A=
+=0A=
+=0A=
+  board_time_init =3D rc32438_time_init;=0A=
+  board_timer_setup =3D rc32438_timer_setup;=0A=
+=0A=
+  =0A=
+#ifdef CONFIG_RTC_DS1553=0A=
+  rtc_get_time =3D rtc_ds1553_get_time;=0A=
+  rtc_set_time =3D rtc_ds1553_set_time;=0A=
+=0A=
+#endif  =0A=
+  _machine_restart =3D idt_machine_restart;=0A=
+  _machine_halt =3D idt_machine_halt;=0A=
+  pm_power_off =3D idt_machine_power_off;=0A=
+  set_io_port_base(KSEG1);=0A=
+  write_c0_wired(0);=0A=
+  return 0;=0A=
+  =0A=
+}=0A=
+=0A=
+//early_initcall(idt_setup);=0A=
+=0A=
+void __init plat_setup(void){=0A=
+  idt_setup();=0A=
+}=0A=
+=0A=
+int page_is_ram(unsigned long pagenr)=0A=
+{=0A=
+  return 1;=0A=
+}=0A=
+=0A=
+const char *get_system_type(void)=0A=
+{=0A=
+  return "MIPS IDT32438";=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/time.c =
idtlinux/arch/mips/idt-boards/rc32438/EB438/time.c=0A=
--- linux-2.6.16-rc5/arch/mips/idt-boards/rc32438/EB438/time.c	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/idt-boards/rc32438/EB438/time.c	2006-03-09 =
16:25:50.000000000 -0800=0A=
@@ -0,0 +1,174 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     timer routines for IDT EB438 boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/kernel_stat.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/spinlock.h>=0A=
+#include <linux/mc146818rtc.h>=0A=
+#include <linux/irq.h>=0A=
+#include <linux/timex.h>=0A=
+=0A=
+#include <linux/param.h>=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/hardirq.h>=0A=
+=0A=
+=0A=
+#include <asm/mipsregs.h>=0A=
+#include <asm/ptrace.h>=0A=
+#include <asm/debug.h>=0A=
+#include <asm/time.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438.h>=0A=
+#include  <asm/idt-boards/rc32438/rc32438_timer.h>=0A=
+=0A=
+static unsigned long r4k_offset;=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+#if defined(CONFIG_IDT_79EB438) && defined(CONFIG_MIPS_RTC)=0A=
+extern void rtc_ds1553_init(void);=0A=
+#endif=0A=
+=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA  =0A=
+/* how many counter cycles in a jiffy */=0A=
+static unsigned long cycles_per_jiffy;=0A=
+/* expirelo is the count value for next CPU timer interrupt */=0A=
+static unsigned int expirelo;=0A=
+=0A=
+=0A=
+static void idt_timer_ack(void)=0A=
+{=0A=
+	unsigned int count ;=0A=
+        count =3D idttimer->tim[0].count;=0A=
+        idttimer->tim[0].compare =3D (count + cycles_per_jiffy);=0A=
+        idttimer->tim[0].ctc =3D  0x1;=0A=
+}=0A=
+=0A=
+static unsigned int idt_hpt_read(void)=0A=
+{=0A=
+	return idttimer->tim[0].count;=0A=
+}=0A=
+=0A=
+=0A=
+static void idt_hpt_timer_init(unsigned int count)=0A=
+{=0A=
+        count =3D idttimer->tim[0].count - count;=0A=
+        expirelo =3D (count / cycles_per_jiffy + 1) * =
cycles_per_jiffy;=0A=
+        idttimer->tim[0].count =3D (expirelo - cycles_per_jiffy);=0A=
+        idttimer->tim[0].compare =3D expirelo;=0A=
+        idttimer->tim[0].count =3D count;=0A=
+}=0A=
+#endif=0A=
+=0A=
+static unsigned long __init cal_r4koff(void)=0A=
+{=0A=
+	mips_hpt_frequency =3D idt_cpu_freq * IDT_CLOCK_MULT / 2;=0A=
+	return (mips_hpt_frequency / HZ);=0A=
+}=0A=
+=0A=
+void __init rc32438_time_init(void)=0A=
+{=0A=
+        unsigned int est_freq, flags;=0A=
+=0A=
+	local_irq_save(flags);=0A=
+=0A=
+	printk("calculating r4koff... ");=0A=
+	r4k_offset =3D cal_r4koff();=0A=
+	printk("%08lx(%d)\n", r4k_offset, (int) r4k_offset);=0A=
+=0A=
+	est_freq =3D 2*r4k_offset*HZ;	=0A=
+	est_freq +=3D 5000;    /* round */=0A=
+	est_freq -=3D est_freq%10000;=0A=
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000, =0A=
+	       (est_freq%1000000)*100/1000000);=0A=
+=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+	printk("Enabling workaround for ZA part.\n");=0A=
+	cycles_per_jiffy =3D (mips_hpt_frequency + HZ / 2) / HZ;=0A=
+	mips_hpt_read =3D idt_hpt_read;=0A=
+	mips_hpt_init =3D idt_hpt_timer_init;=0A=
+	mips_timer_ack =3D idt_timer_ack;=0A=
+#endif	=0A=
+#if defined(CONFIG_IDT_79EB438) && defined(CONFIG_MIPS_RTC)=0A=
+	rtc_ds1553_init();=0A=
+#endif=0A=
+	local_irq_restore(flags);=0A=
+=0A=
+}=0A=
+=0A=
+void __init rc32438_timer_setup(struct irqaction *irq)=0A=
+{=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+        setup_irq(8, irq);=0A=
+        idttimer->tim[0].count =3D 0;=0A=
+        idttimer->tim[0].compare =3D cycles_per_jiffy;=0A=
+        idttimer->tim[0].ctc =3D 0x1;=0A=
+#else=0A=
+	static unsigned long r4k_cur; =0A=
+	setup_irq(MIPS_CPU_TIMER_IRQ, irq);=0A=
+  =0A=
+	/* to generate the first timer interrupt */=0A=
+	r4k_cur =3D (read_c0_count() + r4k_offset);=0A=
+	write_c0_compare(r4k_cur);=0A=
+#endif=0A=
+  =0A=
+}=0A=
+=0A=
+extern void idt_disp_char(int i,char c);=0A=
+=0A=
+asmlinkage void idt_timer_interrupt(int irq,struct pt_regs *regs)=0A=
+{=0A=
+#ifdef CONFIG_KGDB=0A=
+	void kgdb_check(void);=0A=
+#endif=0A=
+=0A=
+	static unsigned int timerCount =3D 0;=0A=
+	static int toggle =3D 0;=0A=
+=0A=
+	irq_enter();=0A=
+	kstat_this_cpu.irqs[irq]++;=0A=
+=0A=
+	if( (timerCount++ % HZ) =3D=3D 0)=0A=
+	{ =0A=
+		toggle ^=3D 1;=0A=
+		idt_disp_char(0,toggle ? 'u' :'U');=0A=
+	}=0A=
+	timer_interrupt(irq, NULL, regs);=0A=
+=0A=
+	irq_exit();=0A=
+=0A=
+#ifdef CONFIG_KGDB=0A=
+	kgdb_check();=0A=
+#endif=0A=
+}=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/Kconfig =
idtlinux/arch/mips/Kconfig=0A=
--- linux-2.6.16-rc5/arch/mips/Kconfig	2006-02-27 02:56:56.000000000 =
-0800=0A=
+++ idtlinux/arch/mips/Kconfig	2006-03-09 16:25:51.000000000 -0800=0A=
@@ -210,6 +210,15 @@=0A=
 	  located at <http://www.globespan.net/>. Say Y here if you wish =
to=0A=
 	  build a kernel for this platform.=0A=
 =0A=
+config IDT_BOARDS=0A=
+        bool "Support for IDT evaluation boards"=0A=
+        help=0A=
+         IDT evaluation boards for the Interprise family of Integrated =
Processors=0A=
+         based on the 4KC and RC32300 MIPS Core.=0A=
+	 =0A=
+	 More information can be found at =
<http://www.idt.com/?catID=3D58532>=0A=
+=0A=
+=0A=
 config MIPS_ITE8172=0A=
 	bool "Support for ITE 8172G board"=0A=
 	select DMA_NONCOHERENT=0A=
@@ -787,6 +796,8 @@=0A=
 source "arch/mips/tx4938/Kconfig"=0A=
 source "arch/mips/vr41xx/Kconfig"=0A=
 source "arch/mips/philips/pnx8550/common/Kconfig"=0A=
+source "arch/mips/idt-boards/Kconfig"=0A=
+=0A=
 =0A=
 endmenu=0A=
 =0A=
@@ -1119,6 +1130,13 @@=0A=
 	  might be a safe bet.  If the resulting kernel does not work,=0A=
 	  try to recompile with R3000.=0A=
 =0A=
+config CPU_RC32300=0A=
+        bool "RC32300"=0A=
+	select CPU_HAS_PREFETCH=0A=
+	select CPU_SUPPORTS_32BIT_KERNEL=0A=
+        help=0A=
+          IDT Chronus core=0A=
+=0A=
 config CPU_TX39XX=0A=
 	bool "R39XX"=0A=
 	depends on SYS_HAS_CPU_TX39XX=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/kernel/cpu-probe.c =
idtlinux/arch/mips/kernel/cpu-probe.c=0A=
--- linux-2.6.16-rc5/arch/mips/kernel/cpu-probe.c	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/arch/mips/kernel/cpu-probe.c	2006-03-09 16:25:44.000000000 =
-0800=0A=
@@ -113,6 +113,7 @@=0A=
 	case CPU_RM7000:=0A=
 	case CPU_RM9000:=0A=
 	case CPU_TX49XX:=0A=
+	case CPU_RC32300:=0A=
 	case CPU_4KC:=0A=
 	case CPU_4KEC:=0A=
 	case CPU_4KSC:=0A=
@@ -221,6 +222,18 @@=0A=
 			c->options |=3D MIPS_CPU_FPU;=0A=
 		c->tlbsize =3D 64;=0A=
 		break;=0A=
+=0A=
+	case PRID_IMP_RC32334:=0A=
+	case PRID_IMP_RC32355:  =0A=
+                c->cputype =3D CPU_RC32300;=0A=
+		c->isa_level =3D MIPS_CPU_ISA_II;=0A=
+		c->options =3D R4K_OPTS | MIPS_CPU_DIVEC | MIPS_CPU_WATCH | =
MIPS_CPU_LLSC;=0A=
+		c->tlbsize =3D 16;=0A=
+		c->icache.ways =3D 2;=0A=
+		c->dcache.ways =3D 2;=0A=
+		c->scache.flags =3D MIPS_CACHE_NOT_PRESENT;=0A=
+		break;=0A=
+=0A=
 	case PRID_IMP_R4000:=0A=
 		if (read_c0_config() & CONF_SC) {=0A=
 			if ((c->processor_id & 0xff) >=3D PRID_REV_R4400)=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/kernel/Makefile =
idtlinux/arch/mips/kernel/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/kernel/Makefile	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/arch/mips/kernel/Makefile	2006-03-09 16:25:44.000000000 =
-0800=0A=
@@ -16,6 +16,7 @@=0A=
 obj-$(CONFIG_CPU_R3000)		+=3D r2300_fpu.o r2300_switch.o=0A=
 obj-$(CONFIG_CPU_TX39XX)	+=3D r2300_fpu.o r2300_switch.o=0A=
 obj-$(CONFIG_CPU_TX49XX)	+=3D r4k_fpu.o r4k_switch.o=0A=
+obj-$(CONFIG_CPU_RC32300)       +=3D r4k_fpu.o r4k_switch.o=0A=
 obj-$(CONFIG_CPU_R4000)		+=3D r4k_fpu.o r4k_switch.o=0A=
 obj-$(CONFIG_CPU_VR41XX)	+=3D r4k_fpu.o r4k_switch.o=0A=
 obj-$(CONFIG_CPU_R4300)		+=3D r4k_fpu.o r4k_switch.o=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/lib-32/Makefile =
idtlinux/arch/mips/lib-32/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/lib-32/Makefile	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/arch/mips/lib-32/Makefile	2006-03-09 16:25:44.000000000 =
-0800=0A=
@@ -9,6 +9,7 @@=0A=
 obj-$(CONFIG_CPU_NEVADA)	+=3D dump_tlb.o=0A=
 obj-$(CONFIG_CPU_R10000)	+=3D dump_tlb.o=0A=
 obj-$(CONFIG_CPU_R3000)		+=3D r3k_dump_tlb.o=0A=
+obj-$(CONFIG_CPU_RC32300)       +=3D dump_tlb.o=0A=
 obj-$(CONFIG_CPU_R4300)		+=3D dump_tlb.o=0A=
 obj-$(CONFIG_CPU_R4X00)		+=3D dump_tlb.o=0A=
 obj-$(CONFIG_CPU_R5000)		+=3D dump_tlb.o=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/Makefile =
idtlinux/arch/mips/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/Makefile	2006-02-27 02:56:56.000000000 =
-0800=0A=
+++ idtlinux/arch/mips/Makefile	2006-03-09 16:25:53.000000000 -0800=0A=
@@ -200,6 +200,11 @@=0A=
 			-Wa,--trap=0A=
 CHECKFLAGS-$(CONFIG_CPU_TX49XX)	+=3D -D_MIPS_ISA=3D_MIPS_ISA_MIPS3=0A=
 =0A=
+cflags-$(CONFIG_CPU_RC32300)	+=3D \=0A=
+			$(call set_gccflags,mips2,mips2,mips2) \=0A=
+			-Wa,--trap=0A=
+CHECKFLAGS-$(CONFIG_CPU_RC32300)	+=3D -D_MIPS_ISA=3D_MIPS_ISA_MIPS2=0A=
+=0A=
 cflags-$(CONFIG_CPU_MIPS32_R1)	+=3D \=0A=
 			$(call set_gccflags,mips32,mips32,r4600,mips3,mips2) \=0A=
 			-Wa,--trap=0A=
@@ -739,6 +744,51 @@=0A=
 core-$(CONFIG_TOSHIBA_RBTX4938) +=3D arch/mips/tx4938/common/=0A=
 load-$(CONFIG_TOSHIBA_RBTX4938) +=3D 0xffffffff80100000=0A=
 =0A=
+=0A=
+=0A=
+=0A=
+#=0A=
+# IDT EB438 board=0A=
+#=0A=
+core-$(CONFIG_IDT_EB438)	+=3D arch/mips/idt-boards/rc32438/EB438/=0A=
+cflags-$(CONFIG_IDT_EB438)	+=3D -Iinclude/asm-mips/mach-idt=0A=
+load-$(CONFIG_IDT_EB438)	+=3D 0x80100000=0A=
+=0A=
+#=0A=
+# IDT EB434/435 board=0A=
+#=0A=
+core-$(CONFIG_IDT_EB434)	+=3D arch/mips/idt-boards/rc32434/EB434/=0A=
+cflags-$(CONFIG_IDT_EB434)	+=3D -Iinclude/asm-mips/mach-idt=0A=
+load-$(CONFIG_IDT_EB434)	+=3D 0x80100000=0A=
+=0A=
+#=0A=
+# IDT EB365/336 board=0A=
+#=0A=
+core-$(CONFIG_IDT_EB365)        +=3D =
arch/mips/idt-boards/rc32300/EB365/=0A=
+cflags-$(CONFIG_IDT_EB365)      +=3D -Iinclude/asm-mips/mach-idt=0A=
+load-$(CONFIG_IDT_EB365)        +=3D 0x80100000=0A=
+=0A=
+#=0A=
+# IDT EB355 board=0A=
+#=0A=
+core-$(CONFIG_IDT_EB355)	+=3D arch/mips/idt-boards/rc32300/EB355/=0A=
+cflags-$(CONFIG_IDT_EB355)	+=3D -Iinclude/asm-mips/mach-idt=0A=
+load-$(CONFIG_IDT_EB355)	+=3D 0x80100000=0A=
+=0A=
+#=0A=
+# IDT S334 board=0A=
+#=0A=
+core-$(CONFIG_IDT_S334)		+=3D arch/mips/idt-boards/rc32300/S334/=0A=
+cflags-$(CONFIG_IDT_S334)	+=3D -Iinclude/asm-mips/mach-idt=0A=
+load-$(CONFIG_IDT_S334)		+=3D 0x80100000=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
 cflags-y			+=3D -Iinclude/asm-mips/mach-generic=0A=
 drivers-$(CONFIG_PCI)		+=3D arch/mips/pci/=0A=
 =0A=
@@ -794,6 +844,27 @@=0A=
 vmlinux.32: vmlinux=0A=
 	$(OBJCOPY) -O $(32bit-bfd) $(OBJCOPYFLAGS) $< $@=0A=
 =0A=
+ifdef CONFIG_IDT_BOARDS=0A=
+zImage rImage: vmlinux $(TOPDIR)/.config=0A=
+ifdef CONFIG_IDT_EB438=0A=
+	$(Q)$(MAKE) $(build)=3Darch/mips/idt-boards/rc32438/EB438/boot $@=0A=
+endif=0A=
+=0A=
+ifdef CONFIG_IDT_EB434=0A=
+	$(Q)$(MAKE) $(build)=3Darch/mips/idt-boards/rc32434/EB434/boot $@=0A=
+endif=0A=
+ifdef CONFIG_IDT_EB365=0A=
+	$(Q)$(MAKE) $(build)=3Darch/mips/idt-boards/rc32300/EB365/boot $@=0A=
+endif=0A=
+ifdef CONFIG_IDT_EB355=0A=
+	$(Q)$(MAKE) $(build)=3Darch/mips/idt-boards/rc32300/EB355/boot $@=0A=
+endif=0A=
+=0A=
+ifdef CONFIG_IDT_S334=0A=
+	$(Q)$(MAKE) $(build)=3Darch/mips/idt-boards/rc32300/S334/boot $@=0A=
+endif=0A=
+endif=0A=
+=0A=
 #=0A=
 # The 64-bit ELF tools are pretty broken so at this time we generate =
64-bit=0A=
 # ELF files from 32-bit files by conversion.=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/mm/c-r4k.c =
idtlinux/arch/mips/mm/c-r4k.c=0A=
--- linux-2.6.16-rc5/arch/mips/mm/c-r4k.c	2006-02-27 02:56:56.000000000 =
-0800=0A=
+++ idtlinux/arch/mips/mm/c-r4k.c	2006-03-09 16:25:53.000000000 =
-0800=0A=
@@ -732,6 +732,20 @@=0A=
 	unsigned int lsize;=0A=
 =0A=
 	switch (c->cputype) {=0A=
+	case CPU_RC32300:=0A=
+	        icache_size =3D 1 << (9 + ((config & CONF_IC) >> 9));=0A=
+                c->icache.linesz =3D 16 << ((config & CONF_IB) >> =
5);=0A=
+                c->icache.ways =3D 2;=0A=
+                c->icache.waybit =3D ffs(icache_size/2) - 1;=0A=
+=0A=
+                dcache_size =3D 1 << (9 + ((config & CONF_DC) >> =
6));=0A=
+                c->dcache.linesz =3D 16 << ((config & CONF_DB) >> =
4);=0A=
+                c->dcache.ways =3D 2;=0A=
+                c->dcache.waybit =3D 12;=0A=
+=0A=
+                c->options |=3D MIPS_CPU_CACHE_CDEX_P;=0A=
+                break;=0A=
+=0A=
 	case CPU_R4600:			/* QED style two way caches? */=0A=
 	case CPU_R4700:=0A=
 	case CPU_R5000:=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/mm/Makefile =
idtlinux/arch/mips/mm/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/mm/Makefile	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/arch/mips/mm/Makefile	2006-03-09 16:25:53.000000000 =
-0800=0A=
@@ -26,6 +26,7 @@=0A=
 obj-$(CONFIG_CPU_TX39XX)	+=3D c-tx39.o pg-r4k.o tlb-r3k.o=0A=
 obj-$(CONFIG_CPU_TX49XX)	+=3D c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o=0A=
 obj-$(CONFIG_CPU_VR41XX)	+=3D c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o=0A=
+obj-$(CONFIG_CPU_RC32300)	+=3D c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o=0A=
 =0A=
 obj-$(CONFIG_IP22_CPU_SCACHE)	+=3D sc-ip22.o=0A=
 obj-$(CONFIG_R5000_CPU_SCACHE)  +=3D sc-r5k.o=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/mm/tlbex.c =
idtlinux/arch/mips/mm/tlbex.c=0A=
--- linux-2.6.16-rc5/arch/mips/mm/tlbex.c	2006-02-27 02:56:56.000000000 =
-0800=0A=
+++ idtlinux/arch/mips/mm/tlbex.c	2006-03-09 16:25:52.000000000 =
-0800=0A=
@@ -818,6 +818,7 @@=0A=
 	case CPU_R4400PC:=0A=
 	case CPU_R4400SC:=0A=
 	case CPU_R4400MC:=0A=
+	case CPU_RC32300:  =0A=
 		/*=0A=
 		 * This branch uses up a mtc0 hazard nop slot and saves=0A=
 		 * two nops after the tlbw instruction.=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/fixup-rc32334.c =
idtlinux/arch/mips/pci/fixup-rc32334.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/fixup-rc32334.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/fixup-rc32334.c	2006-03-09 =
16:25:52.000000000 -0800=0A=
@@ -0,0 +1,102 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     PCI fixups for IDT S334 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/pci.h>=0A=
+=0A=
+#include <asm/mipsregs.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32334.h>=0A=
+=0A=
+extern void rc32300_ack_irq(unsigned int irq_nr);=0A=
+=0A=
+void __init pcibios_fixup_resources(struct pci_dev *dev)=0A=
+{=0A=
+}=0A=
+=0A=
+extern void __init pcibios_fixup(void)=0A=
+{=0A=
+	// ack any bus errors=0A=
+	=0A=
+	rc32300_ack_irq(GROUP4_IRQ_BASE+4); // ack timer 4 rollover intr=0A=
+	rc32300_ack_irq(GROUP4_IRQ_BASE+5); // ack timer 5 rollover intr=0A=
+	rc32300_ack_irq(GROUP1_IRQ_BASE);   // ack bus error intr=0A=
+	=0A=
+	/*=0A=
+	 * Enable CPU and IP Bus Error exceptions, and disable WatchDog.=0A=
+	 */=0A=
+	rc32300_writel(0x18, CPU_IP_BUSERR_CNTL);=0A=
+}=0A=
+=0A=
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)=0A=
+{=0A=
+	=0A=
+	if (dev->bus->number !=3D 0) {=0A=
+		return 0;=0A=
+	}=0A=
+	=0A=
+	slot =3D PCI_SLOT(dev->devfn);=0A=
+	dev->irq =3D 0;=0A=
+	=0A=
+	if (slot > 0 && slot <=3D 4) {=0A=
+		unsigned char pin;=0A=
+		pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);=0A=
+		=0A=
+		switch (pin) {=0A=
+		case 1: /* pin A */=0A=
+			dev->irq =3D RC32334_PCI_INTA_IRQ;=0A=
+			break;=0A=
+		case 2: /* pin B */=0A=
+			dev->irq =3D RC32334_PCI_INTB_IRQ;=0A=
+			break;=0A=
+		case 3: /* pin C */=0A=
+			dev->irq =3D RC32334_PCI_INTC_IRQ;=0A=
+			break;=0A=
+		case 4: /* pin D */=0A=
+			dev->irq =3D RC32334_PCI_INTD_IRQ;=0A=
+			break;=0A=
+		default:=0A=
+			dev->irq =3D 0xff;=0A=
+			break;=0A=
+		}=0A=
+#ifdef DEBUG=0A=
+		printk("irq fixup: slot %d, pin %d, irq %d\n",=0A=
+		       slot, pin, dev->irq);=0A=
+#endif=0A=
+		pci_write_config_byte(dev, PCI_INTERRUPT_LINE,=0A=
+				      dev->irq);=0A=
+	}=0A=
+	return(dev->irq);=0A=
+}=0A=
+struct pci_fixup pcibios_fixups[] =3D {=0A=
+	{0}=0A=
+};=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/fixup-rc32365.c =
idtlinux/arch/mips/pci/fixup-rc32365.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/fixup-rc32365.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/fixup-rc32365.c	2006-03-09 =
16:25:52.000000000 -0800=0A=
@@ -0,0 +1,124 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     PCI fixups for IDT EB365 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/types.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32365.h>=0A=
+=0A=
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)=0A=
+{=0A=
+=0A=
+    if (dev->bus->number !=3D 0) {=0A=
+      return 0;=0A=
+    }=0A=
+    =0A=
+    slot =3D PCI_SLOT(dev->devfn);=0A=
+    dev->irq =3D 0;=0A=
+=0A=
+    if (slot >=3D 2 && slot <=3D 4) {=0A=
+      pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);=0A=
+      switch (slot) {=0A=
+      case 2: /* first SLOT*/=0A=
+	switch (pin) {=0A=
+	case 1: /* INTA*/=0A=
+	  dev->irq =3D RC32365_PCI_INTB_IRQ;=0A=
+	  break;=0A=
+	case 2: /* INTB */=0A=
+	  dev->irq =3D RC32365_PCI_INTC_IRQ;=0A=
+	  break;=0A=
+	case 3: /* INTC */=0A=
+	  dev->irq =3D RC32365_PCI_INTD_IRQ;=0A=
+	  break;=0A=
+	case 4: /* INTD */=0A=
+	  dev->irq =3D RC32365_PCI_INTA_IRQ;=0A=
+	  break;=0A=
+	default:=0A=
+	  dev->irq =3D 0xff; =0A=
+	  break;=0A=
+	}=0A=
+	break;=0A=
+	=0A=
+      case 3: /* second SLOT */=0A=
+	switch (pin) {=0A=
+	case 1: /* INTA*/=0A=
+	  dev->irq =3D RC32365_PCI_INTC_IRQ;=0A=
+	  break;=0A=
+	case 2: /* INTB */=0A=
+	  dev->irq =3D RC32365_PCI_INTD_IRQ;=0A=
+	  break;=0A=
+	case 3: /* INTC */=0A=
+	  dev->irq =3D RC32365_PCI_INTA_IRQ;=0A=
+	  break;=0A=
+	case 4: /* INTD */=0A=
+	  dev->irq =3D RC32365_PCI_INTB_IRQ;=0A=
+	  break;=0A=
+	default:=0A=
+	  dev->irq =3D 0xff; =0A=
+	  break;=0A=
+	}=0A=
+	break;=0A=
+	=0A=
+      case 4: /* miniPCI SLOT */=0A=
+	switch (pin) {=0A=
+	case 1: /* INTA*/=0A=
+	  dev->irq =3D RC32365_PCI_INTA_IRQ;=0A=
+	  break;=0A=
+	case 2: /* INTB */=0A=
+	  dev->irq =3D RC32365_PCI_INTB_IRQ;=0A=
+	  break;=0A=
+	case 3: /* INTC */=0A=
+	  dev->irq =3D RC32365_PCI_INTC_IRQ;=0A=
+	  break;=0A=
+	case 4: /* INTD */=0A=
+	  dev->irq =3D RC32365_PCI_INTD_IRQ;=0A=
+	  break;=0A=
+	default:=0A=
+	  dev->irq =3D 0xff; =0A=
+	  break;=0A=
+	}=0A=
+	break;=0A=
+      =0A=
+#ifdef DEBUG=0A=
+      printk("irq fixup: slot %d, pin %d, irq %d\n",=0A=
+	     slot, pin, dev->irq);=0A=
+#endif=0A=
+      pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);=0A=
+      }=0A=
+    }=0A=
+    return(dev->irq);=0A=
+}=0A=
+struct pci_fixup pcibios_fixups[] __initdata  =3D {=0A=
+  {0}=0A=
+};=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/fixup-rc32434.c =
idtlinux/arch/mips/pci/fixup-rc32434.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/fixup-rc32434.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/fixup-rc32434.c	2006-03-09 =
16:25:51.000000000 -0800=0A=
@@ -0,0 +1,93 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     PCI fixups for IDT EB434/435 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434_pci.h> =0A=
+=0A=
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)=0A=
+{=0A=
+	=0A=
+	if (dev->bus->number !=3D 0) {=0A=
+		return 0;=0A=
+	}=0A=
+	=0A=
+	slot =3D PCI_SLOT(dev->devfn);=0A=
+	dev->irq =3D 0;=0A=
+	=0A=
+	if (slot > 0 && slot <=3D 5) {=0A=
+		unsigned char pin;=0A=
+		pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);=0A=
+		=0A=
+		switch (pin) {=0A=
+		case 1: /* INTA*/=0A=
+			dev->irq =3D GROUP4_IRQ_BASE + 11;=0A=
+			break;=0A=
+		case 2: /* INTB */=0A=
+			dev->irq =3D GROUP4_IRQ_BASE + 11;=0A=
+			break;=0A=
+		case 3: /* INTC */=0A=
+			dev->irq =3D GROUP4_IRQ_BASE + 11;=0A=
+			break;=0A=
+		case 4: /* INTD */=0A=
+			dev->irq =3D GROUP4_IRQ_BASE + 11;=0A=
+			break;=0A=
+		default:=0A=
+			dev->irq =3D 0xff; =0A=
+			break;=0A=
+		}=0A=
+#ifdef DEBUG=0A=
+		printk("irq fixup: slot %d, pin %d, irq %d\n",=0A=
+		       slot, pin, dev->irq);=0A=
+#endif=0A=
+		pci_write_config_byte(dev, PCI_INTERRUPT_LINE,dev->irq);=0A=
+	}=0A=
+	return (dev->irq);=0A=
+}=0A=
+=0A=
+struct pci_fixup pcibios_fixups[] =3D {=0A=
+	{0}=0A=
+};=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/fixup-rc32438.c =
idtlinux/arch/mips/pci/fixup-rc32438.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/fixup-rc32438.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/fixup-rc32438.c	2006-03-09 =
16:25:51.000000000 -0800=0A=
@@ -0,0 +1,84 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     PCI fixups for IDT EB438 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32438/rc32438.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_pci.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_pci_v.h>=0A=
+=0A=
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)=0A=
+{=0A=
+=0A=
+  if (dev->bus->number !=3D 0) {=0A=
+    return 0;=0A=
+  }=0A=
+=0A=
+  slot =3D PCI_SLOT(dev->devfn);=0A=
+  dev->irq =3D 0;=0A=
+=0A=
+  if (slot > 0 && slot <=3D 5) {=0A=
+    unsigned char pin;=0A=
+    pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);=0A=
+=0A=
+    switch (pin) {=0A=
+    case 1: /* INTA*/=0A=
+      dev->irq =3D GROUP4_IRQ_BASE + 27;=0A=
+      break;=0A=
+    case 2: /* INTB */=0A=
+      dev->irq =3D GROUP4_IRQ_BASE + 27;=0A=
+      break;=0A=
+    case 3: /* INTC */=0A=
+      dev->irq =3D GROUP4_IRQ_BASE + 27;=0A=
+      break;=0A=
+    case 4: /* INTD */=0A=
+      dev->irq =3D GROUP4_IRQ_BASE + 27;=0A=
+      break;=0A=
+    default:=0A=
+      dev->irq =3D 0xff; =0A=
+      break;=0A=
+    }=0A=
+#ifdef DEBUG=0A=
+    printk("irq fixup: slot %d, pin %d, irq %d\n",=0A=
+	   slot, pin, dev->irq);=0A=
+#endif=0A=
+    pci_write_config_byte(dev, PCI_INTERRUPT_LINE,dev->irq);=0A=
+  }=0A=
+  return (dev->irq);=0A=
+}=0A=
+=0A=
+struct pci_fixup pcibios_fixups[] =3D {=0A=
+  {0}=0A=
+};=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/Makefile =
idtlinux/arch/mips/pci/Makefile=0A=
--- linux-2.6.16-rc5/arch/mips/pci/Makefile	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/Makefile	2006-03-09 16:25:52.000000000 =
-0800=0A=
@@ -57,3 +57,8 @@=0A=
 obj-$(CONFIG_TOSHIBA_RBTX4938)	+=3D fixup-tx4938.o ops-tx4938.o=0A=
 obj-$(CONFIG_VICTOR_MPC30X)	+=3D fixup-mpc30x.o=0A=
 obj-$(CONFIG_ZAO_CAPCELLA)	+=3D fixup-capcella.o=0A=
+=0A=
+obj-$(CONFIG_IDT_EB438)         +=3D pci-rc32438.o ops-rc32438.o =
fixup-rc32438.o=0A=
+obj-$(CONFIG_IDT_EB434)         +=3D pci-rc32434.o ops-rc32434.o =
fixup-rc32434.o=0A=
+obj-$(CONFIG_IDT_EB365)         +=3D pci-rc32365.o ops-rc32365.o =
fixup-rc32365.o=0A=
+obj-$(CONFIG_IDT_S334)          +=3D pci-rc32334.o ops-rc32334.o =
fixup-rc32334.o=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/ops-rc32334.c =
idtlinux/arch/mips/pci/ops-rc32334.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/ops-rc32334.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/ops-rc32334.c	2006-03-09 16:25:51.000000000 =
-0800=0A=
@@ -0,0 +1,184 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     pci_ops for IDT S334 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32334.h>=0A=
+=0A=
+#define PCI_ACCESS_READ  0=0A=
+#define PCI_ACCESS_WRITE 1=0A=
+=0A=
+#define PCI_CFG_SET(slot,func,off) \=0A=
+        rc32300_writel((0x80000000 | ((slot)<<11) | ((func)<<8) | =
(off)), \=0A=
+                       PCI_CFG_CNTL)=0A=
+=0A=
+static int config_access(unsigned char access_type, struct pci_bus =
*bus,=0A=
+                         unsigned int devfn, unsigned char where,=0A=
+                         u32 * data)=0A=
+{=0A=
+	/* =0A=
+	 * config cycles are on 4 byte boundary only=0A=
+	 */=0A=
+	unsigned int slot =3D PCI_SLOT(devfn);=0A=
+	u8 func =3D PCI_FUNC(devfn);=0A=
+	=0A=
+	if ( slot <2 || slot > 4) {=0A=
+		*data =3D 0xFFFFFFFF;=0A=
+		return PCIBIOS_DEVICE_NOT_FOUND;=0A=
+	}=0A=
+	=0A=
+	/* Setup address */=0A=
+	PCI_CFG_SET(slot, func, where);=0A=
+	rc32300_sync();=0A=
+	=0A=
+	if (access_type =3D=3D PCI_ACCESS_WRITE)=0A=
+		rc32300_writel(*data, PCI_CFG_DATA);=0A=
+	else=0A=
+		*data =3D rc32300_readl(PCI_CFG_DATA);=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+/*=0A=
+ * We can't address 8 and 16 bit words directly.  Instead we have =
to=0A=
+ * read/write a 32bit word and mask/modify the data we actually =
want.=0A=
+ */=0A=
+static int read_config_byte(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                            int where, u8 * val)=0A=
+{=0A=
+	u32 data;=0A=
+	int ret;=0A=
+	=0A=
+	ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, &data);=0A=
+	*val =3D (data >> ((where & 3) << 3)) & 0xff;=0A=
+	return ret;=0A=
+}=0A=
+=0A=
+static int read_config_word(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                            int where, u16 * val)=0A=
+{=0A=
+	u32 data;=0A=
+	int ret;=0A=
+	=0A=
+	ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, &data);=0A=
+	*val =3D (data >> ((where & 3) << 3)) & 0xffff;=0A=
+	return ret;=0A=
+}=0A=
+=0A=
+static int read_config_dword(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                             int where, u32 * val)=0A=
+{=0A=
+	int ret;=0A=
+	=0A=
+	ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, val);=0A=
+	return ret;=0A=
+}=0A=
+static int write_config_byte(struct pci_bus *bus, unsigned int devfn, =
int where,=0A=
+                  u8 val)=0A=
+{=0A=
+	u32 data =3D 0;=0A=
+	=0A=
+	if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))=0A=
+		return -1;=0A=
+	=0A=
+	data =3D (data & ~(0xff << ((where & 3) << 3))) |=0A=
+		(val << ((where & 3) << 3));=0A=
+	=0A=
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))=0A=
+		return -1;=0A=
+	=0A=
+	return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+static int write_config_word(struct pci_bus *bus, unsigned int devfn, =
int where,=0A=
+                  u16 val)=0A=
+{=0A=
+	u32 data =3D 0;=0A=
+	=0A=
+	if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))=0A=
+		return -1;=0A=
+	=0A=
+	data =3D (data & ~(0xffff << ((where & 3) << 3))) |=0A=
+		(val << ((where & 3) << 3));=0A=
+	=0A=
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))=0A=
+		return -1;=0A=
+	=0A=
+	=0A=
+	return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+static int write_config_dword(struct pci_bus *bus, unsigned int devfn, =
int where,=0A=
+                   u32 val)=0A=
+{=0A=
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))=0A=
+		return -1;=0A=
+	=0A=
+	return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+=0A=
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn,=0A=
+			   int where, int size, u32 * val)=0A=
+{=0A=
+	switch (size) {=0A=
+	case 1: =0A=
+		return read_config_byte(bus, devfn, where, (u8 *) val);=0A=
+	case 2: =0A=
+		return read_config_word(bus, devfn, where, (u16 *) val);=0A=
+	default:=0A=
+		return read_config_dword(bus, devfn, where, val);=0A=
+	}=0A=
+}=0A=
+=0A=
+static int pci_config_write(struct pci_bus *bus, unsigned int =
devfn,=0A=
+			    int where, int size, u32 val)=0A=
+{=0A=
+	switch (size) {=0A=
+	case 1: =0A=
+		return write_config_byte(bus, devfn, where, (u8) val);=0A=
+	case 2: =0A=
+		return write_config_word(bus, devfn, where, (u16) val);=0A=
+	default:=0A=
+		return write_config_dword(bus, devfn, where, val);=0A=
+	}=0A=
+}=0A=
+=0A=
+struct pci_ops rc32334_pci_ops =3D {=0A=
+	.read =3D  pci_config_read,=0A=
+	.write =3D pci_config_write,=0A=
+};=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/ops-rc32365.c =
idtlinux/arch/mips/pci/ops-rc32365.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/ops-rc32365.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/ops-rc32365.c	2006-03-09 16:25:52.000000000 =
-0800=0A=
@@ -0,0 +1,189 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     pci_ops for IDT EB365 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32365_pci.h>=0A=
+#include <asm/idt-boards/rc32300/rc32365_pci_v.h>=0A=
+=0A=
+#define PCI_ACCESS_READ  0=0A=
+#define PCI_ACCESS_WRITE 1=0A=
+=0A=
+#define PCI_CFG_SET(slot,func,off) \=0A=
+	(rc32365_pci->pcicfga =3D (0x80000000 | ((slot) << 11) | \=0A=
+			    ((func) << 8) | (off)))=0A=
+static int config_access(unsigned char access_type, struct pci_bus =
*bus,=0A=
+                         unsigned int devfn, unsigned char where,=0A=
+                         u32 * data)=0A=
+{=0A=
+  /* =0A=
+   * config cycles are on 4 byte boundary only=0A=
+   */=0A=
+  unsigned int slot =3D PCI_SLOT(devfn);=0A=
+  u8 func =3D PCI_FUNC(devfn);=0A=
+=0A=
+  if (slot < 2 || slot > 5) {=0A=
+    *data =3D 0xFFFFFFFF;=0A=
+    return -1;=0A=
+  }=0A=
+  /* Setup address */=0A=
+  PCI_CFG_SET(slot, func, where);=0A=
+  rc32300_sync();=0A=
+  =0A=
+  if (access_type =3D=3D PCI_ACCESS_WRITE)=0A=
+    rc32365_pci->pcicfgd =3D *data;=0A=
+  =0A=
+  else=0A=
+    *data =3D rc32365_pci->pcicfgd;=0A=
+  =0A=
+  rc32300_sync();=0A=
+=0A=
+  /*=0A=
+   * Revisit: check for master or target abort.=0A=
+   */=0A=
+  return 0;=0A=
+}=0A=
+=0A=
+/*=0A=
+ * We can't address 8 and 16 bit words directly.  Instead we have =
to=0A=
+ * read/write a 32bit word and mask/modify the data we actually =
want.=0A=
+ */=0A=
+static int read_config_byte(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                            int where, u8 * val)=0A=
+{=0A=
+  u32 data;=0A=
+  int ret;=0A=
+=0A=
+  ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, &data);=0A=
+  *val =3D (data >> ((where & 3) << 3)) & 0xff;=0A=
+  return ret;=0A=
+}=0A=
+=0A=
+static int read_config_word(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                            int where, u16 * val)=0A=
+{=0A=
+  u32 data;=0A=
+  int ret;=0A=
+=0A=
+  ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, &data);=0A=
+  *val =3D (data >> ((where & 3) << 3)) & 0xffff;=0A=
+  return ret;=0A=
+}=0A=
+=0A=
+static int read_config_dword(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                             int where, u32 * val)=0A=
+{=0A=
+  int ret;=0A=
+=0A=
+  ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, val);=0A=
+  return ret;=0A=
+}=0A=
+static int=0A=
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                  u8 val)=0A=
+{=0A=
+  u32 data =3D 0;=0A=
+=0A=
+  if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))=0A=
+    return -1;=0A=
+=0A=
+  data =3D (data & ~(0xff << ((where & 3) << 3))) |=0A=
+    (val << ((where & 3) << 3));=0A=
+=0A=
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))=0A=
+    return -1;=0A=
+=0A=
+  return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+static int=0A=
+write_config_word(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                  u16 val)=0A=
+{=0A=
+  u32 data =3D 0;=0A=
+=0A=
+  if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))=0A=
+    return -1;=0A=
+=0A=
+  data =3D (data & ~(0xffff << ((where & 3) << 3))) |=0A=
+    (val << ((where & 3) << 3));=0A=
+=0A=
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))=0A=
+    return -1;=0A=
+=0A=
+=0A=
+  return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+static int=0A=
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                   u32 val)=0A=
+{=0A=
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))=0A=
+    return -1;=0A=
+=0A=
+  return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+=0A=
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn,=0A=
+                       int where, int size, u32 * val)=0A=
+{=0A=
+   switch (size) {=0A=
+  case 1: =0A=
+   return read_config_byte(bus, devfn, where, (u8 *) val);=0A=
+  case 2: =0A=
+    return read_config_word(bus, devfn, where, (u16 *) val);=0A=
+  default:=0A=
+    return read_config_dword(bus, devfn, where, val);=0A=
+  }=0A=
+}=0A=
+=0A=
+static int pci_config_write(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                        int where, int size, u32 val)=0A=
+{=0A=
+  switch (size) {=0A=
+  case 1: =0A=
+    return write_config_byte(bus, devfn, where, (u8) val);=0A=
+  case 2: =0A=
+    return write_config_word(bus, devfn, where, (u16) val);=0A=
+  default:=0A=
+    return write_config_dword(bus, devfn, where, val);=0A=
+  }=0A=
+}=0A=
+=0A=
+struct pci_ops rc32365_pci_ops =3D {=0A=
+  .read =3D  pci_config_read,=0A=
+  .write =3D pci_config_write,=0A=
+};=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/ops-rc32434.c =
idtlinux/arch/mips/pci/ops-rc32434.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/ops-rc32434.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/ops-rc32434.c	2006-03-09 16:25:51.000000000 =
-0800=0A=
@@ -0,0 +1,196 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     pci_ops for IDT EB434/435 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32434/rc32434.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434_pci.h>=0A=
+=0A=
+#define PCI_ACCESS_READ  0=0A=
+#define PCI_ACCESS_WRITE 1=0A=
+=0A=
+=0A=
+#define PCI_CFG_SET(slot,func,off) \=0A=
+	(rc32434_pci->pcicfga =3D (0x80000000 | ((slot)<<11) | \=0A=
+			    ((func)<<8) | (off)))=0A=
+=0A=
+static int config_access(unsigned char access_type, struct pci_bus =
*bus,=0A=
+                         unsigned int devfn, unsigned char where,=0A=
+                         u32 * data)=0A=
+{ =0A=
+	/*=0A=
+	 * config cycles are on 4 byte boundary only=0A=
+	 */=0A=
+	unsigned int slot =3D PCI_SLOT(devfn);=0A=
+	u8 func =3D PCI_FUNC(devfn);=0A=
+	=0A=
+	if (slot < 2 || slot > 5) {=0A=
+		*data =3D 0xFFFFFFFF;=0A=
+		return -1;=0A=
+	}=0A=
+	/* Setup address */=0A=
+	PCI_CFG_SET(slot, func, where);=0A=
+	rc32434_sync();=0A=
+	=0A=
+	if (access_type =3D=3D PCI_ACCESS_WRITE)=0A=
+		rc32434_pci->pcicfgd =3D *data;=0A=
+	=0A=
+	else=0A=
+		*data =3D rc32434_pci->pcicfgd;=0A=
+	=0A=
+	rc32434_sync();=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * We can't address 8 and 16 bit words directly.  Instead we have =
to=0A=
+ * read/write a 32bit word and mask/modify the data we actually =
want.=0A=
+ */=0A=
+static int read_config_byte(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                            int where, u8 * val)=0A=
+{=0A=
+	u32 data;=0A=
+	int ret;=0A=
+	=0A=
+	ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, &data);=0A=
+	*val =3D (data >> ((where & 3) << 3)) & 0xff;=0A=
+	return ret;=0A=
+}=0A=
+=0A=
+static int read_config_word(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                            int where, u16 * val)=0A=
+{=0A=
+	u32 data;=0A=
+	int ret;=0A=
+	=0A=
+	ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, &data);=0A=
+	*val =3D (data >> ((where & 3) << 3)) & 0xffff;=0A=
+	return ret;=0A=
+}=0A=
+=0A=
+static int read_config_dword(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                             int where, u32 * val)=0A=
+{=0A=
+	int ret;=0A=
+	=0A=
+	ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, val);=0A=
+	return ret;=0A=
+}=0A=
+=0A=
+static int=0A=
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                  u8 val)=0A=
+{=0A=
+	u32 data =3D 0;=0A=
+	=0A=
+	if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))=0A=
+		return -1;=0A=
+	=0A=
+	data =3D (data & ~(0xff << ((where & 3) << 3))) |=0A=
+		(val << ((where & 3) << 3));=0A=
+	=0A=
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))=0A=
+		return -1;=0A=
+	=0A=
+	return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+=0A=
+=0A=
+static int=0A=
+write_config_word(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                  u16 val)=0A=
+{=0A=
+	u32 data =3D 0;=0A=
+	=0A=
+	if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))=0A=
+		return -1;=0A=
+	=0A=
+	data =3D (data & ~(0xffff << ((where & 3) << 3))) |=0A=
+		(val << ((where & 3) << 3));=0A=
+	=0A=
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))=0A=
+		return -1;=0A=
+	=0A=
+	=0A=
+	return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+=0A=
+=0A=
+static int =0A=
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                   u32 val)=0A=
+{=0A=
+	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))=0A=
+		return -1;=0A=
+	=0A=
+	return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+=0A=
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn,=0A=
+			   int where, int size, u32 * val)=0A=
+{=0A=
+	switch (size) {=0A=
+	case 1: =0A=
+		return read_config_byte(bus, devfn, where, (u8 *) val);=0A=
+	case 2: =0A=
+		return read_config_word(bus, devfn, where, (u16 *) val);=0A=
+	default:=0A=
+		return read_config_dword(bus, devfn, where, val);=0A=
+	}=0A=
+}=0A=
+=0A=
+static int pci_config_write(struct pci_bus *bus, unsigned int =
devfn,=0A=
+			    int where, int size, u32 val)=0A=
+{=0A=
+	switch (size) {=0A=
+	case 1: =0A=
+		return write_config_byte(bus, devfn, where, (u8) val);=0A=
+	case 2: =0A=
+		return write_config_word(bus, devfn, where, (u16) val);=0A=
+	default:=0A=
+		return write_config_dword(bus, devfn, where, val);=0A=
+	}=0A=
+}=0A=
+=0A=
+struct pci_ops rc32434_pci_ops =3D {=0A=
+	.read =3D  pci_config_read,=0A=
+	.write =3D pci_config_write,=0A=
+};=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/ops-rc32438.c =
idtlinux/arch/mips/pci/ops-rc32438.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/ops-rc32438.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/ops-rc32438.c	2006-03-09 16:25:52.000000000 =
-0800=0A=
@@ -0,0 +1,195 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     pci_ops for IDT EB438 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32438/rc32438.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_pci.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_pci_v.h>=0A=
+=0A=
+#define PCI_ACCESS_READ  0=0A=
+#define PCI_ACCESS_WRITE 1=0A=
+=0A=
+=0A=
+#define PCI_CFG_SET(slot,func,off) \=0A=
+	(rc32438_pci->pcicfga =3D (0x80000000 | ((slot)<<11) | \=0A=
+			    ((func)<<8) | (off)))=0A=
+=0A=
+static int config_access(unsigned char access_type, struct pci_bus =
*bus,=0A=
+                         unsigned int devfn, unsigned char where,=0A=
+                         u32 * data)=0A=
+{ =0A=
+  /*=0A=
+   * config cycles are on 4 byte boundary only=0A=
+   */=0A=
+  unsigned int slot =3D PCI_SLOT(devfn);=0A=
+  u8 func =3D PCI_FUNC(devfn);=0A=
+=0A=
+  if (slot < 2 || slot > 5) {=0A=
+    *data =3D 0xFFFFFFFF;=0A=
+    return -1;=0A=
+  }=0A=
+  /* Setup address */=0A=
+  PCI_CFG_SET(slot, func, where);=0A=
+  rc32438_sync();=0A=
+=0A=
+  if (access_type =3D=3D PCI_ACCESS_WRITE)=0A=
+    rc32438_pci->pcicfgd =3D *data;=0A=
+=0A=
+  else=0A=
+    *data =3D rc32438_pci->pcicfgd;=0A=
+=0A=
+  rc32438_sync();=0A=
+=0A=
+  /*=0A=
+   * Revisit: check for master or target abort.=0A=
+   */=0A=
+  return 0;=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * We can't address 8 and 16 bit words directly.  Instead we have =
to=0A=
+ * read/write a 32bit word and mask/modify the data we actually =
want.=0A=
+ */=0A=
+static int read_config_byte(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                            int where, u8 * val)=0A=
+{=0A=
+  u32 data;=0A=
+  int ret;=0A=
+=0A=
+  ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, &data);=0A=
+  *val =3D (data >> ((where & 3) << 3)) & 0xff;=0A=
+  return ret;=0A=
+}=0A=
+=0A=
+static int read_config_word(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                            int where, u16 * val)=0A=
+{=0A=
+  u32 data;=0A=
+  int ret;=0A=
+=0A=
+  ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, &data);=0A=
+  *val =3D (data >> ((where & 3) << 3)) & 0xffff;=0A=
+  return ret;=0A=
+}=0A=
+=0A=
+static int read_config_dword(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                             int where, u32 * val)=0A=
+{=0A=
+  int ret;=0A=
+=0A=
+  ret =3D config_access(PCI_ACCESS_READ, bus, devfn, where, val);=0A=
+  return ret;=0A=
+}=0A=
+static int=0A=
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                  u8 val)=0A=
+{=0A=
+  u32 data =3D 0;=0A=
+=0A=
+  if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))=0A=
+    return -1;=0A=
+=0A=
+  data =3D (data & ~(0xff << ((where & 3) << 3))) |=0A=
+    (val << ((where & 3) << 3));=0A=
+=0A=
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))=0A=
+    return -1;=0A=
+=0A=
+  return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+static int=0A=
+write_config_word(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                  u16 val)=0A=
+{=0A=
+  u32 data =3D 0;=0A=
+=0A=
+  if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))=0A=
+    return -1;=0A=
+=0A=
+  data =3D (data & ~(0xffff << ((where & 3) << 3))) |=0A=
+    (val << ((where & 3) << 3));=0A=
+=0A=
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))=0A=
+    return -1;=0A=
+=0A=
+=0A=
+  return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+static int=0A=
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int =
where,=0A=
+                   u32 val)=0A=
+{=0A=
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))=0A=
+    return -1;=0A=
+=0A=
+  return PCIBIOS_SUCCESSFUL;=0A=
+}=0A=
+=0A=
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn,=0A=
+                       int where, int size, u32 * val)=0A=
+{=0A=
+   switch (size) {=0A=
+  case 1: =0A=
+   return read_config_byte(bus, devfn, where, (u8 *) val);=0A=
+  case 2: =0A=
+    return read_config_word(bus, devfn, where, (u16 *) val);=0A=
+  default:=0A=
+    return read_config_dword(bus, devfn, where, val);=0A=
+  }=0A=
+}=0A=
+=0A=
+static int pci_config_write(struct pci_bus *bus, unsigned int =
devfn,=0A=
+                        int where, int size, u32 val)=0A=
+{=0A=
+  switch (size) {=0A=
+  case 1: =0A=
+    return write_config_byte(bus, devfn, where, (u8) val);=0A=
+  case 2: =0A=
+    return write_config_word(bus, devfn, where, (u16) val);=0A=
+  default:=0A=
+    return write_config_dword(bus, devfn, where, val);=0A=
+  }=0A=
+}=0A=
+=0A=
+struct pci_ops rc32438_pci_ops =3D {=0A=
+  .read =3D  pci_config_read,=0A=
+  .write =3D pci_config_write,=0A=
+};=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/pci-rc32334.c =
idtlinux/arch/mips/pci/pci-rc32334.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/pci-rc32334.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/pci-rc32334.c	2006-03-09 16:25:52.000000000 =
-0800=0A=
@@ -0,0 +1,195 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     PCI initialization for IDT S334 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/delay.h>=0A=
+=0A=
+#include <asm/cpu.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32334.h>=0A=
+=0A=
+#define PCI_DEVICE_ID_IDT_RC32334       0x0204=0A=
+#define PCI_DEVICE_ID_IDT_79S334        0x0134=0A=
+#undef DEBUG=0A=
+#ifdef DEBUG=0A=
+#define DBG(x...) printk(x)=0A=
+#else=0A=
+#define DBG(x...)=0A=
+#endif=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define SWAP_BIT 1=0A=
+#else=0A=
+#define SWAP_BIT 0=0A=
+#endif=0A=
+=0A=
+struct resource rc32334_res_pci_mem1 =3D {=0A=
+	.name =3D "PCI Mem1",=0A=
+	.start =3D 0x40000000,=0A=
+	.end =3D 0x5FFFFFFF,=0A=
+	.flags =3D IORESOURCE_MEM,=0A=
+};=0A=
+=0A=
+struct resource rc32334_res_pci_io1 =3D {=0A=
+	.name =3D "PCI I/O1",=0A=
+	.start =3D 0x18800000,=0A=
+	.end =3D 0x188FFFFF,=0A=
+	.flags =3D IORESOURCE_IO,=0A=
+};=0A=
+=0A=
+extern struct pci_ops rc32334_pci_ops;=0A=
+struct pci_controller rc32334_controller =3D {=0A=
+	.pci_ops =3D &rc32334_pci_ops,=0A=
+	.mem_resource =3D &rc32334_res_pci_mem1,=0A=
+	.io_resource =3D &rc32334_res_pci_io1,=0A=
+	.mem_offset     =3D 0x00000000UL,=0A=
+	.io_offset      =3D 0x00000000UL,=0A=
+};=0A=
+=0A=
+static void local_config_write(u8 where, u32 data)=0A=
+{=0A=
+=0A=
+	rc32300_writel((0x80000000 | (where)), PCI_CFG_CNTL);=0A=
+	rc32300_sync();=0A=
+	rc32300_writel(data, PCI_CFG_DATA);=0A=
+}=0A=
+=0A=
+static int __init rc32334_pcibridge_init(void)=0A=
+{=0A=
+  =0A=
+	printk("Initializing PCI\n");=0A=
+	=0A=
+	ioport_resource.start =3D rc32334_res_pci_io1.start;=0A=
+	ioport_resource.end =3D rc32334_res_pci_io1.end;=0A=
+/*=0A=
+	iomem_resource.start =3D rc32334_res_pci_mem1.start;=0A=
+	iomem_resource.end =3D rc32334_res_pci_mem1.end;=0A=
+*/=0A=
+	=0A=
+	/* allow writes to bridge config space */=0A=
+	rc32300_writel(4, PCI_ARBITRATION);=0A=
+	=0A=
+	local_config_write(PCI_VENDOR_ID, =0A=
+			   PCI_VENDOR_ID_IDT | (PCI_DEVICE_ID_IDT_RC32334 << 16));=0A=
+	local_config_write(PCI_COMMAND,  =0A=
+			   PCI_COMMAND_IO | PCI_COMMAND_MEMORY |=0A=
+			   PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE |=0A=
+			   PCI_COMMAND_PARITY | PCI_COMMAND_SERR |=0A=
+			   ((PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK |=0A=
+			     PCI_STATUS_DEVSEL_MEDIUM) << 16));=0A=
+	local_config_write(PCI_CLASS_REVISION, 0x06800001);=0A=
+	local_config_write(PCI_CACHE_LINE_SIZE, 0x0000ff04);=0A=
+	local_config_write(PCI_BASE_ADDRESS_0, 0);    // mem bar=0A=
+	local_config_write(PCI_BASE_ADDRESS_1, 0);    // reserved bar=0A=
+	local_config_write(PCI_BASE_ADDRESS_2,=0A=
+			   0 | PCI_BASE_ADDRESS_SPACE_IO);  // I/O bar=0A=
+	local_config_write(PCI_BASE_ADDRESS_3, 0);    // reserved bar=0A=
+	local_config_write(PCI_BASE_ADDRESS_4, 0);    // reserved bar=0A=
+	local_config_write(PCI_BASE_ADDRESS_5, 0);    // reserved bar=0A=
+	local_config_write(PCI_CARDBUS_CIS, 0);       // reserved=0A=
+	local_config_write(PCI_SUBSYSTEM_VENDOR_ID,=0A=
+			   PCI_VENDOR_ID_IDT | (PCI_DEVICE_ID_IDT_79S334 << 16));=0A=
+	local_config_write(PCI_ROM_ADDRESS, 0);       // reserved=0A=
+	local_config_write(PCI_CAPABILITY_LIST, 0);   // reserved=0A=
+	local_config_write(PCI_CAPABILITY_LIST+4, 0); // reserved=0A=
+	=0A=
+	local_config_write(PCI_INTERRUPT_LINE, 0x38080101);=0A=
+	/* retry timeout, trdy timeout */=0A=
+	local_config_write(PCI_INTERRUPT_LINE+4, 0x00008080);=0A=
+	=0A=
+	rc32300_writel(0x00000000, PCI_CFG_CNTL);=0A=
+	=0A=
+	/*=0A=
+	 * CPU -> PCI address translation. Make CPU physical and=0A=
+	 * PCI bus addresses the same.=0A=
+	 */=0A=
+	=0A=
+	/*=0A=
+	 * Note!=0A=
+	 *=0A=
+	 * Contrary to the RC32334 documentation, the behavior of=0A=
+	 * the PCI byte-swapping bits appears to be the following:=0A=
+	 *=0A=
+	 *   when cpu is in LE: 0 =3D don't swap, 1 =3D swap=0A=
+	 *   when cpu is in BE: 1 =3D don't swap, 0 =3D swap=0A=
+	 *=0A=
+	 * This is true both when the cpu/DMA accesses PCI device=0A=
+	 * memory/io, and when a PCI bus master accesses system memory.=0A=
+	 *=0A=
+	 * Furthermore, byte-swapping doesn't even seem to work=0A=
+	 * correctly when it is enabled.=0A=
+	 *=0A=
+	 * The solution to all this is to disable h/w byte-swapping,=0A=
+	 * use s/w swapping (CONFIG_SWAP_IO_SPACE) for the in/out/read/=0A=
+	 * write macros (which takes care of device accesses by cpu/dma)=0A=
+	 * and hope that drivers swap device data in memory (which takes=0A=
+	 * care of memory accesses by bus-masters).=0A=
+	 *=0A=
+	 * Finally, despite the above workaround, there are still=0A=
+	 * PCI h/w problems on the 79S334A. PCI bus timeouts and=0A=
+	 * system/parity errors have been encountered.=0A=
+	 */=0A=
+	=0A=
+	/* mem space 1 */=0A=
+	rc32300_writel(rc32334_res_pci_mem1.start | SWAP_BIT, =
PCI_MEM1_BASE);=0A=
+	=0A=
+	/* i/o space */=0A=
+	rc32300_writel(rc32334_res_pci_io1.start | SWAP_BIT, =
PCI_IO1_BASE);=0A=
+	=0A=
+	/* use internal arbiter, 0=3Dround robin, 1=3Dfixed */=0A=
+	rc32300_writel(0, PCI_ARBITRATION);=0A=
+	=0A=
+	/*=0A=
+	 * PCI -> CPU accesses=0A=
+	 *=0A=
+	 * Let PCI see system memory at 0x00000000 physical=0A=
+	 */=0A=
+	=0A=
+	rc32300_writel(0x0 | SWAP_BIT, PCI_CPU_MEM1_BASE); /* mem space */=0A=
+	rc32300_writel(0x0 | SWAP_BIT, PCI_CPU_IO_BASE);   /* i/o space */=0A=
+	=0A=
+	register_pci_controller(&rc32334_controller);=0A=
+	=0A=
+	rc32300_sync();   =0A=
+	return 0;=0A=
+}=0A=
+arch_initcall(rc32334_pcibridge_init);=0A=
+=0A=
+/* Do platform specific device initialization at pci_enable_device() =
time */=0A=
+int pcibios_plat_dev_init(struct pci_dev *dev)=0A=
+{=0A=
+        return 0;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/pci-rc32365.c =
idtlinux/arch/mips/pci/pci-rc32365.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/pci-rc32365.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/pci-rc32365.c	2006-03-09 16:25:52.000000000 =
-0800=0A=
@@ -0,0 +1,379 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     PCI initialization for IDT EB365 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/types.h>=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include <asm/idt-boards/rc32300/rc32365_pci.h> =0A=
+#include <asm/idt-boards/rc32300/rc32365_pci_v.h> =0A=
+#include <asm/idt-boards/rc32300/rc32365_dma_v.h> =0A=
+#include <linux/byteorder/swab.h>=0A=
+#include <linux/interrupt.h>=0A=
+=0A=
+/* define an unsigned array for the PCI registers */=0A=
+static unsigned int cedarCnfgRegs[25] =3D {=0A=
+  CEDAR_CNFG1,  CEDAR_CNFG2,  CEDAR_CNFG3,  CEDAR_CNFG4,	=0A=
+  CEDAR_CNFG5,  CEDAR_CNFG6,  CEDAR_CNFG7,  CEDAR_CNFG8,=0A=
+  CEDAR_CNFG9,  CEDAR_CNFG10, CEDAR_CNFG11, CEDAR_CNFG12,=0A=
+  CEDAR_CNFG13,	CEDAR_CNFG14, CEDAR_CNFG15, CEDAR_CNFG16,=0A=
+  CEDAR_CNFG17,	CEDAR_CNFG18, CEDAR_CNFG19, CEDAR_CNFG20,=0A=
+  CEDAR_CNFG21,	CEDAR_CNFG22, CEDAR_CNFG23, CEDAR_CNFG24=0A=
+};=0A=
+=0A=
+=0A=
+static struct resource rc32365_res_pci_mem1;=0A=
+static struct resource rc32365_res_pci_io1;=0A=
+=0A=
+static struct resource rc32365_res_pci_mem1 =3D {=0A=
+  .name =3D "PCI MEM1",=0A=
+  .start =3D 0x50000000,=0A=
+  .end =3D 0x5FFFFFFF,=0A=
+  .flags =3D IORESOURCE_MEM,=0A=
+};=0A=
+static struct resource rc32365_res_pci_io1 =3D {=0A=
+  .name =3D "PCI I/O1",=0A=
+  .start =3D 0x18800000,=0A=
+  .end =3D 0x188FFFFF,=0A=
+  .flags =3D IORESOURCE_IO,=0A=
+};=0A=
+=0A=
+extern struct pci_ops rc32365_pci_ops;=0A=
+static struct pci_controller rc32365_controller =3D {=0A=
+  .pci_ops =3D &rc32365_pci_ops,=0A=
+  .mem_resource =3D &rc32365_res_pci_mem1,=0A=
+  .io_resource =3D &rc32365_res_pci_io1,=0A=
+  .mem_offset     =3D 0x00000000UL,=0A=
+  .io_offset      =3D 0x00000000UL,=0A=
+};=0A=
+=0A=
+static __init int rc32365_pcibridge_init(void)=0A=
+{=0A=
+  =0A=
+  unsigned int pciConfigAddr;/*used for writing pci config values =
*/=0A=
+  int	     loopCount    ;/*used for the loop */=0A=
+  unsigned int pcicValue, pcicData =3D 0;=0A=
+  unsigned int dummyRead, pciCntlVal;=0A=
+=0A=
+  printk("Initialising PCI.\n");=0A=
+  ioport_resource.start =3D rc32365_res_pci_io1.start;=0A=
+  ioport_resource.end =3D rc32365_res_pci_io1.end;=0A=
+/*=0A=
+  iomem_resource.start =3D rc32365_res_pci_mem1.start;=0A=
+  iomem_resource.end =3D rc32365_res_pci_mem1.end;=0A=
+*/=0A=
+=0A=
+  /* Disable the IP bus error for PCI scaning */=0A=
+  pciCntlVal=3Drc32365_pci->pcic;=0A=
+  pciCntlVal &=3D 0xFFFFFF7;=0A=
+  rc32365_pci->pcic =3D pciCntlVal;=0A=
+=0A=
+  pcicValue =3D rc32365_pci->pcic;=0A=
+  pcicValue =3D (pcicValue >> PCIM_SHFT) & PCIM_BIT_LEN;=0A=
+  if (!((pcicValue =3D=3D PCIM_H_EA) ||=0A=
+	(pcicValue =3D=3D PCIM_H_IA_FIX) ||=0A=
+	(pcicValue =3D=3D PCIM_H_IA_RR))) {=0A=
+    /* Not in Host Mode, return ERROR */=0A=
+    return -1 ;=0A=
+  }=0A=
+  =0A=
+  /* Enables the Idle Grant mode, Arbiter Parking */=0A=
+  pcicData |=3D (PCIC_igm_m | PCIC_eap_m | PCIC_en_m);=0A=
+  rc32365_pci->pcic =3D pcicData; /* Enable the PCI bus Interface =
*/=0A=
+  /* Zero out the PCI status & PCI Status Mask */=0A=
+  for (;;)=0A=
+    {=0A=
+      pcicData =3D rc32365_pci->pcis;=0A=
+      if (!(pcicData & PCIS_rip_m))=0A=
+	break;=0A=
+    }=0A=
+  =0A=
+  rc32365_pci->pcis =3D 0;=0A=
+  rc32365_pci->pcism =3D 0xFFFFFFFF;=0A=
+  /* Zero out the PCI decoupled registers */=0A=
+  rc32365_pci->pcidac=3D0; /* disable PCI decoupled accesses at =
initialization */=0A=
+  rc32365_pci->pcidas=3D0; /* clear the status */=0A=
+  rc32365_pci->pcidasm=3D0x0000007F; /* Mask all the interrupts */=0A=
+  /* Mask PCI Messaging Interrupts */=0A=
+  rc32365_pci_msg->pciiic =3D 0;=0A=
+  rc32365_pci_msg->pciiim =3D 0xFFFFFFFF;=0A=
+  rc32365_pci_msg->pciioic =3D 0;=0A=
+  rc32365_pci_msg->pciioim =3D 0;=0A=
+  =0A=
+  /* Setup PCILB0 as Memory Window */=0A=
+  rc32365_pci->pcilba[0].a =3D (unsigned int)(PCI_ADDR_START);=0A=
+  =0A=
+  /* setup the PCI map address as same as the local address */=0A=
+  =0A=
+  rc32365_pci->pcilba[0].m =3D (unsigned int)(PCI_ADDR_START);=0A=
+  =0A=
+  /* Setup PCILBA0 as MEM */=0A=
+#ifdef __MIPSEB__=0A=
+  rc32365_pci->pcilba[0].c =3D (((SIZE_16MB & 0x1f) << PCILBAC_size_b) =
| PCILBAC_sb_m);=0A=
+#else=0A=
+  rc32365_pci->pcilba[0].c =3D ((SIZE_16MB & 0x1f) << =
PCILBAC_size_b);=0A=
+#endif=0A=
+  dummyRead =3D rc32365_pci->pcilba[0].c; /* flush the CPU write =
Buffers */=0A=
+=0A=
+  =0A=
+  rc32365_pci->pcilba[1].a =3D 0x60000000;=0A=
+  =0A=
+  rc32365_pci->pcilba[1].m =3D 0x60000000;=0A=
+  /* setup PCILBA1 as MEM */=0A=
+#ifdef __MIPSEB__=0A=
+  rc32365_pci->pcilba[1].c =3D (((SIZE_256MB & 0x1f) << =
PCILBAC_size_b) | PCILBAC_sb_m);=0A=
+#else=0A=
+  rc32365_pci->pcilba[1].c =3D ((SIZE_256MB & 0x1f) << =
PCILBAC_size_b);=0A=
+#endif=0A=
+  dummyRead =3D rc32365_pci->pcilba[1].c; /* flush the CPU write =
Buffers */=0A=
+=0A=
+  rc32365_pci->pcilba[2].a =3D 0x18C00000;=0A=
+  =0A=
+  rc32365_pci->pcilba[2].m =3D 0x18FFFFFF;=0A=
+  /* setup PCILBA2 as MEM */=0A=
+#ifdef __MIPSEB__=0A=
+  rc32365_pci->pcilba[2].c =3D (((SIZE_4MB & 0x1f) << PCILBAC_size_b)  =
| PCILBAC_sb_m);=0A=
+#else=0A=
+  rc32365_pci->pcilba[2].c =3D ((SIZE_4MB & 0x1f) << =
PCILBAC_size_b);=0A=
+#endif    =0A=
+  dummyRead =3D rc32365_pci->pcilba[2].c; /* flush the CPU write =
Buffers */=0A=
+    =0A=
+  rc32365_pci->pcilba[3].a =3D 0x18800000;=0A=
+  =0A=
+  rc32365_pci->pcilba[3].m =3D 0x18800000;=0A=
+=0A=
+  /* Setup PCILBA3 as IO Window */=0A=
+#ifdef __MIPSEB__=0A=
+  rc32365_pci->pcilba[3].c =3D ((((SIZE_1MB & 0x1ff) << =
PCILBAC_size_b) | PCILBAC_msi_m)  | PCILBAC_sb_m);=0A=
+#else=0A=
+  rc32365_pci->pcilba[3].c =3D (((SIZE_1MB & 0x1ff) << PCILBAC_size_b) =
|PCILBAC_msi_m);=0A=
+#endif=0A=
+  dummyRead =3D rc32365_pci->pcilba[2].c; /* flush the CPU write =
Buffers */=0A=
+  =0A=
+  pciConfigAddr =3D (unsigned int)(0x80000004);=0A=
+  for (loopCount =3D 0; loopCount < 24; loopCount++) {=0A=
+    rc32365_pci->pcicfga =3D pciConfigAddr;=0A=
+    dummyRead =3D rc32365_pci->pcicfga;=0A=
+    if (loopCount =3D=3D 16 && cedar_za =3D=3D 0) /* CEDAR_CNFG17 =
*/=0A=
+      rc32365_pci->pcicfgd =3D cedarCnfgRegs[loopCount] | PCIPBAC_pp_m =
| (PCIPBAC_mr_readMult_v << PCIPBAC_mr_b) | PCIPBAC_mrl_m | =
PCIPBAC_mrm_m;=0A=
+    else=0A=
+      rc32365_pci->pcicfgd =3D cedarCnfgRegs[loopCount];=0A=
+    dummyRead =3D rc32365_pci->pcicfgd;=0A=
+    pciConfigAddr +=3D 4;=0A=
+  }=0A=
+  rc32365_pci->pcitc =3D (unsigned int)((PCITC_RTIMER_VAL & 0xff) << =
PCITC_rtimer_b) |=0A=
+    ((PCITC_DTIMER_VAL & 0xff) << PCITC_dtimer_b);=0A=
+  =0A=
+  pciCntlVal =3D rc32365_pci->pcic;=0A=
+  pciCntlVal &=3D ~(PCIC_tnr_m);=0A=
+  rc32365_pci->pcic =3D pciCntlVal;=0A=
+  pciCntlVal =3D rc32365_pci->pcic;=0A=
+  =0A=
+  register_pci_controller(&rc32365_controller);=0A=
+=0A=
+  rc32300_sync();   =0A=
+  return 0;=0A=
+}=0A=
+arch_initcall(rc32365_pcibridge_init);=0A=
+=0A=
+/* Do platform specific device initialization at pci_enable_device() =
time */=0A=
+int pcibios_plat_dev_init(struct pci_dev *dev)=0A=
+{=0A=
+        return 0;=0A=
+}=0A=
+=0A=
+unsigned char rc32365_pci_inb(unsigned long port, int slow)=0A=
+{=0A=
+	if (cedar_za) {=0A=
+		volatile DMA_Chan_t pci_dma_regs =3D =
(DMA_Chan_t)(DMA0_VirtualAddress + DMACH_pciToMem * =
DMA_CHAN_OFFSET);=0A=
+		volatile struct DMAD_s desc;=0A=
+		DMAD_t pdesc =3D (DMAD_t)KSEG1ADDR(&desc);=0A=
+		u32 data;=0A=
+		volatile u32 *pdata =3D (u32 *)KSEG1ADDR(&data);=0A=
+		unsigned long flags;=0A=
+=0A=
+		*pdata =3D 0;=0A=
+		pdesc->control =3D 0x01c00001;=0A=
+		pdesc->ca      =3D CPHYSADDR(pdata);=0A=
+		pdesc->devcs   =3D port;=0A=
+		pdesc->link    =3D 0;=0A=
+=0A=
+		local_irq_save(flags);=0A=
+		while (pci_dma_regs->dmac & DMAC_run_m);=0A=
+=0A=
+		pci_dma_regs->dmas =3D 0;=0A=
+		pci_dma_regs->dmandptr =3D 0;=0A=
+		pci_dma_regs->dmadptr =3D CPHYSADDR(pdesc);=0A=
+=0A=
+		while (!pci_dma_regs->dmas);=0A=
+		local_irq_restore(flags);=0A=
+=0A=
+		if (slow) SLOW_DOWN_IO;=0A=
+=0A=
+		return (unsigned char)(*pdata >> 24);=0A=
+	}=0A=
+	else if (slow)=0A=
+	  SLOW_DOWN_IO;=0A=
+	else=0A=
+		return (inb(port));=0A=
+}=0A=
+=0A=
+void rc32365_pci_outb(unsigned char val, unsigned long port, int =
slow)=0A=
+{=0A=
+	if (cedar_za) {=0A=
+		volatile DMA_Chan_t pci_dma_regs =3D =
(DMA_Chan_t)(DMA0_VirtualAddress + DMACH_memToPci * =
DMA_CHAN_OFFSET);=0A=
+		volatile struct DMAD_s desc;=0A=
+		DMAD_t pdesc =3D (DMAD_t)KSEG1ADDR(&desc);=0A=
+		u32 data;=0A=
+		volatile u32 *pdata =3D (u32 *)KSEG1ADDR(&data);=0A=
+		unsigned long flags;=0A=
+=0A=
+		*pdata =3D val << 24;=0A=
+		pdesc->control =3D 0x01c00001;=0A=
+		pdesc->ca      =3D CPHYSADDR(pdata);=0A=
+		pdesc->devcs   =3D port;=0A=
+		pdesc->link    =3D 0;=0A=
+=0A=
+		local_irq_save(flags);=0A=
+		while (pci_dma_regs->dmac & DMAC_run_m);=0A=
+=0A=
+		pci_dma_regs->dmas =3D 0;=0A=
+		pci_dma_regs->dmandptr =3D 0;=0A=
+		pci_dma_regs->dmadptr =3D CPHYSADDR(pdesc);=0A=
+=0A=
+		while (!pci_dma_regs->dmas);=0A=
+		local_irq_restore(flags);=0A=
+=0A=
+		if (slow) SLOW_DOWN_IO;=0A=
+	}=0A=
+	else if (slow)=0A=
+	  SLOW_DOWN_IO;=0A=
+	else=0A=
+	  outb(val, port);=0A=
+}=0A=
+=0A=
+unsigned short rc32365_pci_inw(unsigned long port, int slow)=0A=
+{=0A=
+	if (cedar_za) {=0A=
+		volatile DMA_Chan_t pci_dma_regs =3D =
(DMA_Chan_t)(DMA0_VirtualAddress + DMACH_pciToMem * =
DMA_CHAN_OFFSET);=0A=
+		volatile struct DMAD_s desc;=0A=
+		DMAD_t pdesc =3D (DMAD_t)KSEG1ADDR(&desc);=0A=
+		u32 data;=0A=
+		volatile u32 *pdata =3D (u32 *)KSEG1ADDR(&data);=0A=
+		unsigned long flags;=0A=
+=0A=
+		*pdata =3D 0;=0A=
+		pdesc->control =3D 0x01c00002;=0A=
+		pdesc->ca      =3D CPHYSADDR(pdata);=0A=
+		pdesc->devcs   =3D port;=0A=
+		pdesc->link    =3D 0;=0A=
+=0A=
+		local_irq_save(flags);=0A=
+		while (pci_dma_regs->dmac & DMAC_run_m);=0A=
+=0A=
+		pci_dma_regs->dmas =3D 0;=0A=
+		pci_dma_regs->dmandptr =3D 0;=0A=
+		pci_dma_regs->dmadptr =3D CPHYSADDR(pdesc);=0A=
+=0A=
+		while (!pci_dma_regs->dmas);=0A=
+		local_irq_restore(flags);=0A=
+=0A=
+		if (slow) SLOW_DOWN_IO;=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+		return (unsigned short)(*pdata >> 16);=0A=
+#else=0A=
+		return (unsigned short)((*pdata >> 24) | ((*pdata >> 8) & =
0x0000ff00));=0A=
+#endif=0A=
+	}=0A=
+	else=0A=
+	{=0A=
+		unsigned short	val;=0A=
+		if (slow)=0A=
+			val =3D (inw_p(port));=0A=
+		else=0A=
+			val =3D (inw(port));=0A=
+#ifdef __MIPSEB__=0A=
+		val =3D swab16(val);=0A=
+#endif=0A=
+		return val;=0A=
+	}=0A=
+}=0A=
+=0A=
+void rc32365_pci_outw(unsigned short val, unsigned long port, int =
slow)=0A=
+{=0A=
+	if (cedar_za) {=0A=
+		volatile DMA_Chan_t pci_dma_regs =3D =
(DMA_Chan_t)(DMA0_VirtualAddress + DMACH_memToPci * =
DMA_CHAN_OFFSET);=0A=
+		volatile struct DMAD_s desc;=0A=
+		DMAD_t pdesc =3D (DMAD_t)KSEG1ADDR(&desc);=0A=
+		u32 data;=0A=
+		volatile u32 *pdata =3D (u32 *)KSEG1ADDR(&data);=0A=
+		unsigned long flags;=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+		*pdata =3D (val << 16);=0A=
+#else=0A=
+		*pdata =3D (val << 24) | ((val << 8) & 0x00ff0000);=0A=
+#endif=0A=
+		pdesc->control =3D 0x01c00002;=0A=
+		pdesc->ca      =3D CPHYSADDR(pdata);=0A=
+		pdesc->devcs   =3D port;=0A=
+		pdesc->link    =3D 0;=0A=
+=0A=
+		local_irq_save(flags);=0A=
+		while (pci_dma_regs->dmac & DMAC_run_m);=0A=
+=0A=
+		pci_dma_regs->dmas =3D 0;=0A=
+		pci_dma_regs->dmandptr =3D 0;=0A=
+		pci_dma_regs->dmadptr =3D CPHYSADDR(pdesc);=0A=
+=0A=
+		while (!pci_dma_regs->dmas);=0A=
+		local_irq_restore(flags);=0A=
+=0A=
+		if (slow) SLOW_DOWN_IO;=0A=
+	}=0A=
+	else=0A=
+	{=0A=
+#ifdef __MIPSEB__=0A=
+		val =3D swab16(val);=0A=
+#endif=0A=
+		if (slow)=0A=
+			outw_p(val, port);=0A=
+		else=0A=
+			outw(val, port);=0A=
+	}=0A=
+}=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/pci-rc32434.c =
idtlinux/arch/mips/pci/pci-rc32434.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/pci-rc32434.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/pci-rc32434.c	2006-03-09 16:25:52.000000000 =
-0800=0A=
@@ -0,0 +1,212 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     PCI initialization for IDT EB434/435 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434_pci.h> =0A=
+=0A=
+#define PCI_ACCESS_READ  0=0A=
+#define PCI_ACCESS_WRITE 1=0A=
+=0A=
+#undef DEBUG=0A=
+#ifdef DEBUG=0A=
+#define DBG(x...) printk(x)=0A=
+#else=0A=
+#define DBG(x...)=0A=
+#endif=0A=
+/* define an unsigned array for the PCI registers */=0A=
+unsigned int korinaCnfgRegs[25] =3D {=0A=
+	KORINA_CNFG1,	 KORINA_CNFG2,  KORINA_CNFG3,  KORINA_CNFG4,=0A=
+	KORINA_CNFG5,	 KORINA_CNFG6,  KORINA_CNFG7,  KORINA_CNFG8,=0A=
+	KORINA_CNFG9,	 KORINA_CNFG10, KORINA_CNFG11, KORINA_CNFG12,=0A=
+	KORINA_CNFG13, KORINA_CNFG14, KORINA_CNFG15, KORINA_CNFG16,=0A=
+	KORINA_CNFG17, KORINA_CNFG18, KORINA_CNFG19, KORINA_CNFG20,=0A=
+	KORINA_CNFG21, KORINA_CNFG22, KORINA_CNFG23, KORINA_CNFG24=0A=
+};=0A=
+static struct resource rc32434_res_pci_mem1 =3D {=0A=
+	.name =3D "PCI MEM1",=0A=
+	.start =3D 0x50000000,=0A=
+	.end =3D 0x5FFFFFFF,=0A=
+	.flags =3D IORESOURCE_MEM,=0A=
+};=0A=
+static struct resource rc32434_res_pci_io1 =3D {=0A=
+	.name =3D "PCI I/O1",=0A=
+	.start =3D 0x18800000,=0A=
+	.end =3D 0x188FFFFF,=0A=
+	.flags =3D IORESOURCE_IO,=0A=
+};=0A=
+=0A=
+extern struct pci_ops rc32434_pci_ops;=0A=
+=0A=
+struct pci_controller rc32434_controller =3D {=0A=
+	.pci_ops =3D &rc32434_pci_ops,=0A=
+	.mem_resource =3D &rc32434_res_pci_mem1,=0A=
+	.io_resource =3D &rc32434_res_pci_io1,=0A=
+	.mem_offset     =3D 0x00000000UL,=0A=
+	.io_offset      =3D 0x00000000UL,=0A=
+};=0A=
+=0A=
+static int __init rc32434_pcibridge_init(void)=0A=
+{=0A=
+	=0A=
+	unsigned int pciConfigAddr =3D 0;/*used for writing pci config values =
*/=0A=
+	int	     loopCount=3D0    ;/*used for the loop */=0A=
+	=0A=
+	unsigned int pcicValue, pcicData=3D0;=0A=
+	unsigned int dummyRead, pciCntlVal =3D 0;=0A=
+	printk("PCI: Initializing PCI\n");=0A=
+	=0A=
+	/* Disable the IP bus error for PCI scaning */=0A=
+	pciCntlVal=3Drc32434_pci->pcic;=0A=
+	pciCntlVal &=3D 0xFFFFFF7;=0A=
+	rc32434_pci->pcic =3D pciCntlVal;=0A=
+	=0A=
+	ioport_resource.start =3D rc32434_res_pci_io1.start;=0A=
+	ioport_resource.end =3D rc32434_res_pci_io1.end;=0A=
+/*=0A=
+	iomem_resource.start =3D rc32434_res_pci_mem1.start;=0A=
+	iomem_resource.end =3D rc32434_res_pci_mem1.end;=0A=
+*/=0A=
+	=0A=
+	pcicValue =3D rc32434_pci->pcic;=0A=
+	pcicValue =3D (pcicValue >> PCIM_SHFT) & PCIM_BIT_LEN;=0A=
+	if (!((pcicValue =3D=3D PCIM_H_EA) ||=0A=
+	      (pcicValue =3D=3D PCIM_H_IA_FIX) ||=0A=
+	      (pcicValue =3D=3D PCIM_H_IA_RR))) {=0A=
+		/* Not in Host Mode, return ERROR */=0A=
+		return -1;=0A=
+	}=0A=
+	=0A=
+	/* Enables the Idle Grant mode, Arbiter Parking */=0A=
+	pcicData |=3D(PCIC_igm_m|PCIC_eap_m|PCIC_en_m);=0A=
+	rc32434_pci->pcic =3D pcicData; /* Enable the PCI bus Interface */=0A=
+	/* Zero out the PCI status & PCI Status Mask */=0A=
+	for(;;) {=0A=
+		pcicData =3D rc32434_pci->pcis;=0A=
+		if (!(pcicData & PCIS_rip_m))=0A=
+			break;=0A=
+	}=0A=
+	=0A=
+	rc32434_pci->pcis =3D 0;=0A=
+	rc32434_pci->pcism =3D 0xFFFFFFFF;=0A=
+	/* Zero out the PCI decoupled registers */=0A=
+	rc32434_pci->pcidac=3D0; /* disable PCI decoupled accesses at =
initialization */=0A=
+	rc32434_pci->pcidas=3D0; /* clear the status */=0A=
+	rc32434_pci->pcidasm=3D0x0000007F; /* Mask all the interrupts */=0A=
+	/* Mask PCI Messaging Interrupts */=0A=
+	rc32434_pci_msg->pciiic =3D 0;=0A=
+	rc32434_pci_msg->pciiim =3D 0xFFFFFFFF;=0A=
+	rc32434_pci_msg->pciioic =3D 0;=0A=
+	rc32434_pci_msg->pciioim =3D 0;=0A=
+	=0A=
+	/* Setup PCILB0 as Memory Window */=0A=
+	rc32434_pci->pcilba[0].a =3D (unsigned int) (PCI_ADDR_START);=0A=
+	=0A=
+	/* setup the PCI map address as same as the local address */=0A=
+	=0A=
+	rc32434_pci->pcilba[0].m =3D (unsigned int) (PCI_ADDR_START);=0A=
+	=0A=
+	/* Setup PCILBA1 as MEM */=0A=
+#ifdef __MIPSEB__=0A=
+	rc32434_pci->pcilba[0].c =3D ( ((SIZE_16MB & 0x1f) << PCILBAC_size_b) =
| PCILBAC_sb_m);=0A=
+#else=0A=
+	rc32434_pci->pcilba[0].c =3D ( ((SIZE_16MB & 0x1f) << =
PCILBAC_size_b));=0A=
+#endif=0A=
+	dummyRead =3D rc32434_pci->pcilba[0].c; /* flush the CPU write =
Buffers */=0A=
+	=0A=
+	rc32434_pci->pcilba[1].a =3D 0x60000000;=0A=
+	=0A=
+	rc32434_pci->pcilba[1].m =3D 0x60000000;=0A=
+	/* setup PCILBA2 as IO Window*/=0A=
+#ifdef __MIPSEB__=0A=
+	rc32434_pci->pcilba[1].c =3D ( ((SIZE_256MB & 0x1f) << =
PCILBAC_size_b) |  PCILBAC_sb_m);=0A=
+#else=0A=
+	rc32434_pci->pcilba[1].c =3D ((SIZE_256MB & 0x1f) << =
PCILBAC_size_b);=0A=
+#endif=0A=
+	dummyRead =3D rc32434_pci->pcilba[1].c; /* flush the CPU write =
Buffers */=0A=
+	rc32434_pci->pcilba[2].a =3D 0x18C00000;=0A=
+	=0A=
+	rc32434_pci->pcilba[2].m =3D 0x18FFFFFF;=0A=
+	/* setup PCILBA2 as IO Window*/=0A=
+#ifdef __MIPSEB__=0A=
+	rc32434_pci->pcilba[2].c =3D ( ((SIZE_4MB & 0x1f) << PCILBAC_size_b)  =
|  PCILBAC_sb_m);=0A=
+#else=0A=
+	rc32434_pci->pcilba[2].c =3D ((SIZE_4MB & 0x1f) << =
PCILBAC_size_b);=0A=
+#endif  =0A=
+	=0A=
+	dummyRead =3D rc32434_pci->pcilba[2].c; /* flush the CPU write =
Buffers */=0A=
+	=0A=
+	=0A=
+	rc32434_pci->pcilba[3].a =3D 0x18800000;=0A=
+	=0A=
+	rc32434_pci->pcilba[3].m =3D 0x18800000;=0A=
+	/* Setup PCILBA3 as IO Window */=0A=
+	=0A=
+#ifdef __MIPSEB__=0A=
+	rc32434_pci->pcilba[3].c =3D ( (((SIZE_1MB & 0x1ff) << =
PCILBAC_size_b) | PCILBAC_msi_m)   |  PCILBAC_sb_m);=0A=
+#else=0A=
+	rc32434_pci->pcilba[3].c =3D (((SIZE_1MB & 0x1ff) << PCILBAC_size_b) =
| PCILBAC_msi_m);=0A=
+#endif=0A=
+	dummyRead =3D rc32434_pci->pcilba[2].c; /* flush the CPU write =
Buffers */=0A=
+	=0A=
+	pciConfigAddr =3D (unsigned int)(0x80000004);=0A=
+	for(loopCount =3D 0; loopCount < 24; loopCount++){=0A=
+		rc32434_pci->pcicfga =3D pciConfigAddr;=0A=
+		dummyRead =3D rc32434_pci->pcicfga;=0A=
+		rc32434_pci->pcicfgd =3D korinaCnfgRegs[loopCount];=0A=
+		dummyRead=3Drc32434_pci->pcicfgd;=0A=
+		pciConfigAddr +=3D 4;=0A=
+	}=0A=
+	rc32434_pci->pcitc=3D(unsigned int)((PCITC_RTIMER_VAL&0xff) << =
PCITC_rtimer_b) |=0A=
+		((PCITC_DTIMER_VAL&0xff)<<PCITC_dtimer_b);=0A=
+	=0A=
+	pciCntlVal =3D rc32434_pci->pcic;=0A=
+	pciCntlVal &=3D ~(PCIC_tnr_m);=0A=
+	rc32434_pci->pcic =3D pciCntlVal;=0A=
+	pciCntlVal =3D rc32434_pci->pcic;=0A=
+	=0A=
+	register_pci_controller(&rc32434_controller);=0A=
+	=0A=
+	rc32434_sync();  =0A=
+	return 0;=0A=
+}=0A=
+=0A=
+arch_initcall(rc32434_pcibridge_init);=0A=
+=0A=
+/* Do platform specific device initialization at pci_enable_device() =
time */=0A=
+int pcibios_plat_dev_init(struct pci_dev *dev)=0A=
+{=0A=
+        return 0;=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/arch/mips/pci/pci-rc32438.c =
idtlinux/arch/mips/pci/pci-rc32438.c=0A=
--- linux-2.6.16-rc5/arch/mips/pci/pci-rc32438.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/arch/mips/pci/pci-rc32438.c	2006-03-09 16:25:51.000000000 =
-0800=0A=
@@ -0,0 +1,344 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     PCI initialization for IDT EB438 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/init.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_pci.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_pci_v.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_dma_v.h>=0A=
+#include <linux/interrupt.h>=0A=
+=0A=
+#define PCI_ACCESS_READ  0=0A=
+#define PCI_ACCESS_WRITE 1=0A=
+=0A=
+/* define an unsigned array for the PCI registers */=0A=
+unsigned int acaciaCnfgRegs[25] =3D {=0A=
+  ACACIA_CNFG1,	 ACACIA_CNFG2,  ACACIA_CNFG3,  ACACIA_CNFG4,=0A=
+  ACACIA_CNFG5,	 ACACIA_CNFG6,  ACACIA_CNFG7,  ACACIA_CNFG8,=0A=
+  ACACIA_CNFG9,	 ACACIA_CNFG10, ACACIA_CNFG11, ACACIA_CNFG12,=0A=
+  ACACIA_CNFG13, ACACIA_CNFG14, ACACIA_CNFG15, ACACIA_CNFG16,=0A=
+  ACACIA_CNFG17, ACACIA_CNFG18, ACACIA_CNFG19, ACACIA_CNFG20,=0A=
+  ACACIA_CNFG21, ACACIA_CNFG22, ACACIA_CNFG23, ACACIA_CNFG24=0A=
+};=0A=
+static struct resource rc32438_res_pci_mem1 =3D {=0A=
+  .name =3D "PCI MEM1",=0A=
+  .start =3D 0x50000000,=0A=
+  .end =3D 0x5FFFFFFF,=0A=
+  .flags =3D IORESOURCE_MEM,=0A=
+};=0A=
+static struct resource rc32438_res_pci_io1 =3D {=0A=
+  .name =3D "PCI I/O1",=0A=
+  .start =3D 0x18800000,=0A=
+  .end =3D 0x188FFFFF,=0A=
+  .flags =3D IORESOURCE_IO,=0A=
+};=0A=
+=0A=
+extern struct pci_ops rc32438_pci_ops;=0A=
+=0A=
+struct pci_controller rc32438_controller =3D {=0A=
+  .pci_ops =3D &rc32438_pci_ops,=0A=
+  .mem_resource =3D &rc32438_res_pci_mem1,=0A=
+  .io_resource =3D &rc32438_res_pci_io1,=0A=
+  .mem_offset     =3D 0x00000000UL,=0A=
+  .io_offset      =3D 0x00000000UL,=0A=
+};=0A=
+=0A=
+static int __init rc32438_pcibridge_init(void)=0A=
+{=0A=
+=0A=
+  unsigned int pciConfigAddr =3D 0;/*used for writing pci config =
values */=0A=
+  int	     loopCount=3D0    ;/*used for the loop */=0A=
+=0A=
+  unsigned int pcicValue, pcicData=3D0;=0A=
+  unsigned int dummyRead, pciCntlVal =3D 0;=0A=
+  printk("PCI: Initializing PCI\n");=0A=
+=0A=
+  /* Disable the IP bus error for PCI scaning */=0A=
+  pciCntlVal=3Drc32438_pci->pcic;=0A=
+  pciCntlVal &=3D 0xFFFFFF7;=0A=
+  rc32438_pci->pcic =3D pciCntlVal;=0A=
+=0A=
+  ioport_resource.start =3D rc32438_res_pci_io1.start;=0A=
+  ioport_resource.end =3D rc32438_res_pci_io1.end;=0A=
+/*=0A=
+  iomem_resource.start =3D rc32438_res_pci_mem1.start;=0A=
+  iomem_resource.end =3D rc32438_res_pci_mem1.end;=0A=
+*/=0A=
+=0A=
+  pcicValue =3D rc32438_pci->pcic;=0A=
+  pcicValue =3D (pcicValue >> PCIM_SHFT) & PCIM_BIT_LEN;=0A=
+  if (!((pcicValue =3D=3D PCIM_H_EA) ||=0A=
+	(pcicValue =3D=3D PCIM_H_IA_FIX) ||=0A=
+	(pcicValue =3D=3D PCIM_H_IA_RR))) {=0A=
+    /* Not in Host Mode, return ERROR */=0A=
+    return -1;=0A=
+  }=0A=
+=0A=
+  /* Enables the Idle Grant mode, Arbiter Parking */=0A=
+  pcicData |=3D(PCIC_igm_m|PCIC_eap_m|PCIC_en_m);=0A=
+  rc32438_pci->pcic =3D pcicData; /* Enable the PCI bus Interface =
*/=0A=
+  /* Zero out the PCI status & PCI Status Mask */=0A=
+  for(;;)=0A=
+    {=0A=
+      pcicData =3D rc32438_pci->pcis;=0A=
+      if (!(pcicData & PCIS_rip_m))=0A=
+	break;=0A=
+    }=0A=
+=0A=
+  rc32438_pci->pcis =3D 0;=0A=
+  rc32438_pci->pcism =3D 0xFFFFFFFF;=0A=
+  /* Zero out the PCI decoupled registers */=0A=
+  rc32438_pci->pcidac=3D0; /* disable PCI decoupled accesses at =
initialization */=0A=
+  rc32438_pci->pcidas=3D0; /* clear the status */=0A=
+  rc32438_pci->pcidasm=3D0x0000007F; /* Mask all the interrupts */=0A=
+  /* Mask PCI Messaging Interrupts */=0A=
+  rc32438_pci_msg->pciiic =3D 0;=0A=
+  rc32438_pci_msg->pciiim =3D 0xFFFFFFFF;=0A=
+  rc32438_pci_msg->pciioic =3D 0;=0A=
+  rc32438_pci_msg->pciioim =3D 0;=0A=
+=0A=
+  /* Setup PCILB0 as Memory Window */=0A=
+  rc32438_pci->pcilba[0].a =3D (unsigned int) (PCI_ADDR_START);=0A=
+=0A=
+  /* setup the PCI map address as same as the local address */=0A=
+=0A=
+  rc32438_pci->pcilba[0].m =3D (unsigned int) (PCI_ADDR_START);=0A=
+=0A=
+  /* Setup PCILBA1 as MEM */=0A=
+#ifdef __MIPSEB__=0A=
+  rc32438_pci->pcilba[0].c =3D ( ((SIZE_16MB & 0x1f) << =
PCILBAC_size_b) | PCILBAC_sb_m);=0A=
+#else=0A=
+  rc32438_pci->pcilba[0].c =3D ( ((SIZE_16MB & 0x1f) << =
PCILBAC_size_b));=0A=
+#endif=0A=
+  dummyRead =3D rc32438_pci->pcilba[0].c; /* flush the CPU write =
Buffers */=0A=
+=0A=
+  rc32438_pci->pcilba[1].a =3D 0x60000000;=0A=
+  =0A=
+  rc32438_pci->pcilba[1].m =3D 0x60000000;=0A=
+  /* setup PCILBA2 as IO Window*/=0A=
+#ifdef __MIPSEB__=0A=
+  rc32438_pci->pcilba[1].c =3D ( ((SIZE_256MB & 0x1f) << =
PCILBAC_size_b) |  PCILBAC_sb_m);=0A=
+#else=0A=
+  rc32438_pci->pcilba[1].c =3D ((SIZE_256MB & 0x1f) << =
PCILBAC_size_b);=0A=
+#endif=0A=
+  dummyRead =3D rc32438_pci->pcilba[1].c; /* flush the CPU write =
Buffers */=0A=
+  rc32438_pci->pcilba[2].a =3D 0x18C00000;=0A=
+    =0A=
+  rc32438_pci->pcilba[2].m =3D 0x18FFFFFF;=0A=
+  /* setup PCILBA2 as IO Window*/=0A=
+#ifdef __MIPSEB__=0A=
+  rc32438_pci->pcilba[2].c =3D ( ((SIZE_4MB & 0x1f) << PCILBAC_size_b) =
 |  PCILBAC_sb_m);=0A=
+#else=0A=
+  rc32438_pci->pcilba[2].c =3D ((SIZE_4MB & 0x1f) << =
PCILBAC_size_b);=0A=
+#endif  =0A=
+  =0A=
+  dummyRead =3D rc32438_pci->pcilba[2].c; /* flush the CPU write =
Buffers */=0A=
+=0A=
+=0A=
+  rc32438_pci->pcilba[3].a =3D 0x18800000;=0A=
+=0A=
+  rc32438_pci->pcilba[3].m =3D 0x18800000;=0A=
+  /* Setup PCILBA3 as IO Window */=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+  rc32438_pci->pcilba[3].c =3D ( (((SIZE_1MB & 0x1ff) << =
PCILBAC_size_b) | PCILBAC_msi_m)   |  PCILBAC_sb_m);=0A=
+#else=0A=
+  rc32438_pci->pcilba[3].c =3D (((SIZE_1MB & 0x1ff) << PCILBAC_size_b) =
| PCILBAC_msi_m);=0A=
+#endif=0A=
+  dummyRead =3D rc32438_pci->pcilba[2].c; /* flush the CPU write =
Buffers */=0A=
+=0A=
+  pciConfigAddr=3D(unsigned int)(0x80000004);=0A=
+  for(loopCount=3D0;loopCount<24;loopCount++){=0A=
+    rc32438_pci->pcicfga=3DpciConfigAddr;=0A=
+    dummyRead=3Drc32438_pci->pcicfga;=0A=
+    rc32438_pci->pcicfgd =3D acaciaCnfgRegs[loopCount];=0A=
+    dummyRead=3Drc32438_pci->pcicfgd;=0A=
+    pciConfigAddr +=3D 4;=0A=
+  }=0A=
+  rc32438_pci->pcitc=3D(unsigned int)((PCITC_RTIMER_VAL&0xff) << =
PCITC_rtimer_b) |=0A=
+    ((PCITC_DTIMER_VAL&0xff)<<PCITC_dtimer_b);=0A=
+=0A=
+  pciCntlVal=3Drc32438_pci->pcic;=0A=
+  pciCntlVal &=3D~(PCIC_tnr_m);=0A=
+  rc32438_pci->pcic =3D pciCntlVal;=0A=
+  pciCntlVal=3Drc32438_pci->pcic;=0A=
+=0A=
+  register_pci_controller(&rc32438_controller);=0A=
+=0A=
+  rc32438_sync();  =0A=
+  return 0;=0A=
+}=0A=
+arch_initcall(rc32438_pcibridge_init);=0A=
+=0A=
+/* Do platform specific device initialization at pci_enable_device() =
time */=0A=
+int pcibios_plat_dev_init(struct pci_dev *dev)=0A=
+{=0A=
+        return 0;=0A=
+}=0A=
+=0A=
+unsigned char rc32438_pci_inb(unsigned long port, int slow)=0A=
+{=0A=
+	volatile DMA_Chan_t pci_dma_regs =3D (DMA_Chan_t)(DMA0_VirtualAddress =
+ DMACH_pciToMem * DMA_CHAN_OFFSET);=0A=
+	volatile struct DMAD_s desc;=0A=
+	DMAD_t pdesc =3D (DMAD_t)KSEG1ADDR(&desc);=0A=
+	u32 data;=0A=
+	volatile u32 *pdata =3D (u32 *)KSEG1ADDR(&data);=0A=
+	unsigned long flags;=0A=
+=0A=
+	*pdata =3D 0;=0A=
+	pdesc->control =3D 0x01c00001;=0A=
+	pdesc->ca      =3D CPHYSADDR(pdata);=0A=
+	pdesc->devcs   =3D port;=0A=
+	pdesc->link    =3D 0;=0A=
+=0A=
+	local_irq_save(flags);=0A=
+	while (pci_dma_regs->dmac & DMAC_run_m);=0A=
+=0A=
+	pci_dma_regs->dmas =3D 0;=0A=
+	pci_dma_regs->dmandptr =3D 0;=0A=
+	pci_dma_regs->dmadptr =3D CPHYSADDR(pdesc);=0A=
+=0A=
+	while (!pci_dma_regs->dmas);=0A=
+	local_irq_restore(flags);=0A=
+=0A=
+	if (slow) SLOW_DOWN_IO;=0A=
+=0A=
+#if defined(__MIPSEB__)=0A=
+	return (unsigned char)(*pdata >> 24);=0A=
+#else=0A=
+	return (unsigned char)(*pdata);=0A=
+#endif=0A=
+}=0A=
+=0A=
+void rc32438_pci_outb(unsigned char val, unsigned long port, int =
slow)=0A=
+{=0A=
+	volatile DMA_Chan_t pci_dma_regs =3D (DMA_Chan_t)(DMA0_VirtualAddress =
+ DMACH_memToPci * DMA_CHAN_OFFSET);=0A=
+	volatile struct DMAD_s desc;=0A=
+	DMAD_t pdesc =3D (DMAD_t)KSEG1ADDR(&desc);=0A=
+	u32 data;=0A=
+	volatile u32 *pdata =3D (u32 *)KSEG1ADDR(&data);=0A=
+	unsigned long flags;=0A=
+=0A=
+#if defined(__MIPSEB__)=0A=
+	*pdata =3D val << 24;=0A=
+#else=0A=
+	*pdata =3D val;=0A=
+#endif=0A=
+	pdesc->control =3D 0x01c00001;=0A=
+	pdesc->ca      =3D CPHYSADDR(pdata);=0A=
+	pdesc->devcs   =3D port;=0A=
+	pdesc->link    =3D 0;=0A=
+=0A=
+	local_irq_save(flags);=0A=
+	while (pci_dma_regs->dmac & DMAC_run_m);=0A=
+=0A=
+	pci_dma_regs->dmas =3D 0;=0A=
+	pci_dma_regs->dmandptr =3D 0;=0A=
+	pci_dma_regs->dmadptr =3D CPHYSADDR(pdesc);=0A=
+=0A=
+	while (!pci_dma_regs->dmas);=0A=
+	local_irq_restore(flags);=0A=
+=0A=
+	if (slow) SLOW_DOWN_IO;=0A=
+}=0A=
+=0A=
+unsigned short rc32438_pci_inw(unsigned long port, int slow)=0A=
+{=0A=
+	volatile DMA_Chan_t pci_dma_regs =3D (DMA_Chan_t)(DMA0_VirtualAddress =
+ DMACH_pciToMem * DMA_CHAN_OFFSET);=0A=
+	volatile struct DMAD_s desc;=0A=
+	DMAD_t pdesc =3D (DMAD_t)KSEG1ADDR(&desc);=0A=
+	u32 data;=0A=
+	volatile u32 *pdata =3D (u32 *)KSEG1ADDR(&data);=0A=
+	unsigned long flags;=0A=
+=0A=
+	*pdata =3D 0;=0A=
+	pdesc->control =3D 0x01c00002;=0A=
+	pdesc->ca      =3D CPHYSADDR(pdata);=0A=
+	pdesc->devcs   =3D port;=0A=
+	pdesc->link    =3D 0;=0A=
+=0A=
+	local_irq_save(flags);=0A=
+	while (pci_dma_regs->dmac & DMAC_run_m);=0A=
+=0A=
+	pci_dma_regs->dmas =3D 0;=0A=
+	pci_dma_regs->dmandptr =3D 0;=0A=
+	pci_dma_regs->dmadptr =3D CPHYSADDR(pdesc);=0A=
+=0A=
+	while (!pci_dma_regs->dmas);=0A=
+	local_irq_restore(flags);=0A=
+=0A=
+	if (slow) SLOW_DOWN_IO;=0A=
+=0A=
+#if defined(__MIPSEB__)=0A=
+//	return (unsigned short)((*pdata >> 24) | ((*pdata >> 8) & 0x0000ff00=
));=0A=
+	return (unsigned short)(*pdata >> 16);=0A=
+#else=0A=
+	return (unsigned short)(*pdata);=0A=
+#endif=0A=
+}=0A=
+=0A=
+void rc32438_pci_outw(unsigned short val, unsigned long port, int =
slow)=0A=
+{=0A=
+	volatile DMA_Chan_t pci_dma_regs =3D (DMA_Chan_t)(DMA0_VirtualAddress =
+ DMACH_memToPci * DMA_CHAN_OFFSET);=0A=
+	volatile struct DMAD_s desc;=0A=
+	DMAD_t pdesc =3D (DMAD_t)KSEG1ADDR(&desc);=0A=
+	u32 data;=0A=
+	volatile u32 *pdata =3D (u32 *)KSEG1ADDR(&data);=0A=
+	unsigned long flags;=0A=
+=0A=
+#if defined(__MIPSEB__)=0A=
+//	*pdata =3D (val << 24) | ((val << 8) & 0x00ff0000);=0A=
+	*pdata =3D (val << 16);=0A=
+#else=0A=
+	*pdata =3D val;=0A=
+#endif=0A=
+	pdesc->control =3D 0x01c00002;=0A=
+	pdesc->ca      =3D CPHYSADDR(pdata);=0A=
+	pdesc->devcs   =3D port;=0A=
+	pdesc->link    =3D 0;=0A=
+=0A=
+	local_irq_save(flags);=0A=
+	while (pci_dma_regs->dmac & DMAC_run_m);=0A=
+=0A=
+	pci_dma_regs->dmas =3D 0;=0A=
+	pci_dma_regs->dmandptr =3D 0;=0A=
+	pci_dma_regs->dmadptr =3D CPHYSADDR(pdesc);=0A=
+=0A=
+	while (!pci_dma_regs->dmas);=0A=
+	local_irq_restore(flags);=0A=
+=0A=
+	if (slow) SLOW_DOWN_IO;=0A=
+}=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/Documentation/mips/IDT_RC32xxx.README =
idtlinux/Documentation/mips/IDT_RC32xxx.README=0A=
--- linux-2.6.16-rc5/Documentation/mips/IDT_RC32xxx.README	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/Documentation/mips/IDT_RC32xxx.README	2006-03-09 =
16:26:00.000000000 -0800=0A=
@@ -0,0 +1,78 @@=0A=
+README for arch/mips/idt-boards directory and sub directories=0A=
+=0A=
+Rakesh Tiwari, rtiwari@idt.com=0A=
+03/08, 2006=0A=
+=0A=
+=0A=
+1. ABOUT=0A=
+----------=0A=
+This file contains information about IDT Evaluation Boards based =0A=
+on the Interprise family of Integrated Processors.=0A=
+=0A=
+=0A=
+2. PROCESSOR AND EVALUATION BOARD=0A=
+--------------------------------=0A=
+=0A=
+IDT's Interprise family consists of the following MIPS based =
processors.=0A=
+=0A=
+Core 	Processor	Eval Board   	PCI   ETHERNET	DEFAULT_CONFIG*=0A=
+-----	---------	-----------	---   --------	----------------=0A=
+4KC    	RC32438		EB438		yes	yes	rc32438_defconfig=0A=
+4KC    	RC32434/435	EB434/EB435	yes	yes	rc32434_defconfig=0A=
+RC32300	RC32365/336	EB365/EB336	yes	yes	rc32365_defconfig=0A=
+RC32300	RC32355		EB355		no	yes	rc32355_defconfig=0A=
+RC32300 RC32334		S334		yes	no	rc32334_defconfig=0A=
+=0A=
+*All default configurations are located in ~arch/mips/configs/ =
directory.=0A=
+=0A=
+=0A=
+3. LINUX BOOT MODE SUPPORT=0A=
+--------------------------=0A=
+All the evaluation boards support the following boot mode=0A=
+=0A=
+	a. Initramfs=0A=
+	b. NFS=0A=
+	c. Flash Boot (make zImage, required bootloader)=0A=
+	d. Self-Boot  (make rImage, doesn't need additional bootloader)=0A=
+=0A=
+=0A=
+4. I2C DRIVERS=0A=
+--------------=0A=
+Some boards supports I2C interface and the drivers=0A=
+can be found in the ~driver/i2c/busses/i2c_rc32xxx.x=0A=
+=0A=
+=0A=
+5. ETHERNET DRIVERS=0A=
+-------------------=0A=
+The processors on-board Ethernet interface drivers are located=0A=
+in ~drivers/net/rc32xxx.x=0A=
+=0A=
+=0A=
+6. ADDITIONAL INFORMATION=0A=
+-------------------------=0A=
+Additional information regarding IDT Interprise Processors and=0A=
+Evaluation boards can be obtained from=0A=
+=0A=
+Website: http://www.idt.com/?catID=3D58532=0A=
+Email: rischelp@idt.com=0A=
+=0A=
+=0A=
+=0A=
+7. ACKNOWLEDGEMENTS=0A=
+--------------------=0A=
+The following people have been involved in the development/testing=0A=
+of Linux on IDT development boards. Many thanks to all of them..=0A=
+=0A=
+Nebojsa Bjegovic=0A=
+Haofeng Kou=0A=
+Bernard Maruthanayagam=0A=
+Sadik Pallathu=0A=
+Kiran Rao=0A=
+Steve Shih=0A=
+Harpinder Singh=0A=
+Adisak Srinakarin=0A=
+Rakesh Tiwari=0A=
+Brandon Wong=0A=
+Calvin Young =0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/i2c/busses/i2c-rc32355.c =
idtlinux/drivers/i2c/busses/i2c-rc32355.c=0A=
--- linux-2.6.16-rc5/drivers/i2c/busses/i2c-rc32355.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/i2c/busses/i2c-rc32355.c	2006-03-09 =
16:26:13.000000000 -0800=0A=
@@ -0,0 +1,335 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     I2C driver for IDT EB355 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/module.h>=0A=
+#include <linux/config.h>=0A=
+#include <linux/version.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/delay.h>=0A=
+#include <linux/i2c.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/timer.h>=0A=
+#include <linux/spinlock.h>=0A=
+#include <linux/completion.h>=0A=
+#include <linux/devfs_fs_kernel.h>=0A=
+#include <linux/i2c-dev.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+#include "i2c-rc32xxx.h"=0A=
+=0A=
+MODULE_AUTHOR("idt");=0A=
+MODULE_DESCRIPTION("I2C driver for IDT's 79RC32355 board");=0A=
+MODULE_LICENSE("GPL");=0A=
+=0A=
+=0A=
+static i2c_rc32xxx_iface 	*iface;=0A=
+static struct resource		*region;=0A=
+=0A=
+=0A=
+static u32 i2c_rc32xxx_func(struct i2c_adapter *adapter)=0A=
+{=0A=
+	return I2C_FUNC_I2C;=0A=
+}=0A=
+=0A=
+static void i2c_rc32xxx_master(void)=0A=
+{=0A=
+  	u32	i2cms =3D i2c->i2cms;=0A=
+=0A=
+	if (!(i2cms & I2CMS_D))=0A=
+		return;=0A=
+=0A=
+	iface->d_ints++;=0A=
+=0A=
+  	if (i2cms & I2CMS_LA) =0A=
+	{=0A=
+		iface->la_ints++;=0A=
+    		printk ("\nI2C Master LA Detected!\n");=0A=
+  	}=0A=
+=0A=
+  	if (i2cms & I2CMS_ERR) =0A=
+	{=0A=
+		iface->err_ints++;=0A=
+    		printk("\nI2C Master ERR Detected!\n");=0A=
+  	}=0A=
+=0A=
+  	switch (iface->state) =0A=
+	{=0A=
+    		case I2C_STATE_IDLE:=0A=
+    		// No need to do anything...=0A=
+      			break;=0A=
+=0A=
+		case I2C_STATE_START:=0A=
+    		// DONE sending START, begin sending address=0A=
+      			i2c->i2cdo =3D I2CDO_DATA(iface->addr);=0A=
+      			i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+			iface->state =3D I2C_STATE_ADDR;=0A=
+      			break;=0A=
+=0A=
+		case I2C_STATE_ADDR:=0A=
+    		// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    		// (Because SDA is driven low)=0A=
+			if (i2cms & I2CMS_NA)=0A=
+				iface->num_naks++;=0A=
+			else=0A=
+				iface->num_acks++;=0A=
+=0A=
+      			// If No Slave ACknowledged the Address byte or=0A=
+		  	// Data Length is zero, then skip Write / Read Stage=0A=
+			if ((i2cms & I2CMS_NA) || !iface->len)=0A=
+			{=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+          				iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+  					// No STOP desired, so go to IDLE and set global variable=0A=
+          				iface->state =3D I2C_STATE_IDLE;=0A=
+        			}=0A=
+        			break;=0A=
+			}=0A=
+=0A=
+			iface->len--;=0A=
+			if (iface->xfer =3D=3D I2C_XFER_WRITE) =0A=
+			{=0A=
+		  		// DONE sending address, now send data=0A=
+		        	i2c->i2cdo =3D  I2CDO_DATA(*(iface->buf++));=0A=
+		        	i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+		        	iface->state =3D I2C_STATE_WRITE_DATA;=0A=
+		        	iface->tx_bytes++;=0A=
+		      	}=0A=
+		      	else =0A=
+			{=0A=
+		  		// DONE sending address, now read data=0A=
+				if (iface->len > 0)=0A=
+		    			// Read Another Data Byte (And ACK)=0A=
+		          		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RDACK);=0A=
+				else=0A=
+		    			// Almost done reading data, now send RD (not RDACK!)=0A=
+		          		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RD);=0A=
+		        	iface->state =3D I2C_STATE_READ_DATA;=0A=
+		      	}=0A=
+		      	break;=0A=
+			=0A=
+	    	case I2C_STATE_WRITE_DATA:=0A=
+    			// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    			// (Because SDA is driven low)=0A=
+      			if (i2cms & I2CMS_NA)=0A=
+        			iface->num_naks++;=0A=
+      			else=0A=
+        			iface->num_acks++;=0A=
+=0A=
+      			if (iface->len-- > 0) =0A=
+			{=0A=
+				// Send next data byte=0A=
+		        	i2c->i2cdo =3D  I2CDO_DATA(*(iface->buf++));=0A=
+				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+				iface->tx_bytes++;=0A=
+      			}=0A=
+      			else =0A=
+			{=0A=
+  				// done sending data, now send STOP if desired.=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+					i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+					iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+					// No STOP desired, so go to IDLE and set global variable=0A=
+					iface->state =3D I2C_STATE_IDLE;=0A=
+        			}=0A=
+      			}=0A=
+			break;=0A=
+			 =0A=
+		case I2C_STATE_READ_DATA:=0A=
+    			// Write Incoming Read data to buffer=0A=
+			*iface->buf++ =3D I2CDI_DATA(i2c->i2cdi);=0A=
+      			iface->rx_bytes++;=0A=
+=0A=
+    			// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    			// (Because SDA is driven low)=0A=
+      			if (i2cms & I2CMS_NA)=0A=
+        			iface->num_naks++;=0A=
+      			else=0A=
+        			iface->num_acks++;=0A=
+				=0A=
+			if (iface->len > 0)=0A=
+			{=0A=
+        			if (iface->len-- > 1) =0A=
+				{=0A=
+					// Read Another Data Byte (And ACK)=0A=
+					i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RDACK);=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+      					// Almost done reading data, now send RD (not RDACK!)=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RD);=0A=
+        			}=0A=
+			}=0A=
+      			else=0A=
+			{=0A=
+				// done sending data, now send STOP if desired.=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+          				iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+	  				// No STOP desired, so go to IDLE and set global variable=0A=
+	          			iface->state =3D I2C_STATE_IDLE;=0A=
+	        		}=0A=
+      			}=0A=
+      			break;=0A=
+=0A=
+    		case I2C_STATE_STOP:=0A=
+    			// Done with packet, set global variable, write NOP command, =
and go to idle=0A=
+      			i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_NOP);=0A=
+      			iface->state =3D I2C_STATE_IDLE;=0A=
+      			break;=0A=
+		=0A=
+    		default:=0A=
+      			printk ("\nErr in Default\n");=0A=
+      			break;=0A=
+  	}=0A=
+}=0A=
+=0A=
+static int i2c_rc32xxx_xfer(struct i2c_adapter *adap, struct i2c_msg =
*msg, int num)=0A=
+{=0A=
+	int	i;=0A=
+=0A=
+	for (i =3D 0; i < num; i++, msg++) =0A=
+	{=0A=
+		if (msg->flags & I2C_M_TEN) =0A=
+		{=0A=
+			printk(KERN_ERR "i2c-rc32355: 10 bits addr not supported!\n");=0A=
+			break;=0A=
+		}=0A=
+=0A=
+		if (msg->flags & I2C_M_RD)=0A=
+		{=0A=
+			iface->xfer =3D I2C_XFER_READ;=0A=
+			iface->addr =3D I2CDO_ADDR(I2C_SLAVE_ADDR) | I2CDO_RD;=0A=
+		}=0A=
+		else=0A=
+		{=0A=
+			iface->xfer =3D I2C_XFER_WRITE;=0A=
+			iface->addr =3D I2CDO_ADDR(I2C_SLAVE_ADDR);=0A=
+		}=0A=
+		iface->len =3D msg->len;=0A=
+		iface->buf =3D msg->buf;=0A=
+		iface->stop =3D TRUE;=0A=
+=0A=
+		// Update Master State=0A=
+		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_START);=0A=
+		iface->state =3D I2C_STATE_START;=0A=
+=0A=
+	  	while (iface->state !=3D I2C_STATE_IDLE) =0A=
+		{=0A=
+			if (i2c->i2cms & I2CMS_D)=0A=
+				i2c_rc32xxx_master();=0A=
+	 	}=0A=
+	}=0A=
+=0A=
+	return i;=0A=
+}=0A=
+=0A=
+int __init i2c_rc32355_init(void)=0A=
+{=0A=
+	int	rc;=0A=
+=0A=
+	printk("i2c-rc32355: loading driver module\n");=0A=
+=0A=
+	region =3D request_region(I2C_BASE, I2C_REGION, "rc32355-i2c IO");=0A=
+	=0A=
+	iface =3D (i2c_rc32xxx_iface *)kmalloc(sizeof(i2c_rc32xxx_iface), =
GFP_KERNEL);=0A=
+	if (!iface) =0A=
+	{=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+		printk(KERN_ERR "i2c-rc32355: can't allocate inteface!\n");=0A=
+		return -ENOMEM;=0A=
+	}=0A=
+	memset(iface, 0, sizeof(i2c_rc32xxx_iface));=0A=
+=0A=
+	iface->algo.functionality =3D i2c_rc32xxx_func;=0A=
+	iface->algo.master_xfer =3D i2c_rc32xxx_xfer;=0A=
+=0A=
+	sprintf(iface->adap.name, "%s", "RC32355 I2C");=0A=
+	iface->adap.algo =3D &iface->algo;=0A=
+	i2c_set_adapdata(&iface->adap, iface);=0A=
+=0A=
+	rc =3D i2c_add_adapter(&iface->adap);=0A=
+	if (rc)=0A=
+	{=0A=
+		kfree(iface);=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+		printk(KERN_ERR "i2c-rc32355: can't add adapter!\n");=0A=
+		return rc;=0A=
+	}=0A=
+	=0A=
+	iface->state =3D I2C_STATE_IDLE;=0A=
+=0A=
+    	// Initialize master interface=0A=
+  	i2c->i2cc =3D I2CC_MEN;=0A=
+  	i2c->i2ccp =3D  I2CCP_DIV(I2C_PRESCALER);=0A=
+	i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_NOP);=0A=
+  	i2c->i2cmsm =3D I2CMS_MASK;=0A=
+  	i2c->i2cssm =3D I2CSS_MASK;=0A=
+=0A=
+	// Enable GPIO Alternate Function for csn[4]=0A=
+	rc355_gpiofunc |=3D RC355_GPIOFUNC_ALT_CSN4;=0A=
+=0A=
+	// Enable GPIO pins for I2C Bus (Alternte Functions)=0A=
+	rc355_gpiofunc |=3D RC355_GPIOFUNC_I2C_PINS;=0A=
+=0A=
+	return rc;=0A=
+}=0A=
+=0A=
+void __exit i2c_rc32355_exit(void)=0A=
+{=0A=
+	printk("i2c-rc32355: unloading driver module\n");=0A=
+=0A=
+	i2c_del_adapter(&iface->adap);=0A=
+	kfree(iface);		=0A=
+	if (region)=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+}=0A=
+=0A=
+=0A=
+module_init(i2c_rc32355_init);=0A=
+module_exit(i2c_rc32355_exit);=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/i2c/busses/i2c-rc32434.c =
idtlinux/drivers/i2c/busses/i2c-rc32434.c=0A=
--- linux-2.6.16-rc5/drivers/i2c/busses/i2c-rc32434.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/i2c/busses/i2c-rc32434.c	2006-03-09 =
16:26:13.000000000 -0800=0A=
@@ -0,0 +1,330 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     I2C driver for IDT EB434 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#include <linux/module.h>=0A=
+#include <linux/config.h>=0A=
+#include <linux/version.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/delay.h>=0A=
+#include <linux/i2c.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/timer.h>=0A=
+#include <linux/spinlock.h>=0A=
+#include <linux/completion.h>=0A=
+#include <linux/devfs_fs_kernel.h>=0A=
+#include <linux/i2c-dev.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+#include "i2c-rc32xxx.h"=0A=
+=0A=
+MODULE_AUTHOR("idt");=0A=
+MODULE_DESCRIPTION("I2C driver for IDT's 79RC32434/435 board");=0A=
+MODULE_LICENSE("GPL");=0A=
+=0A=
+=0A=
+static i2c_rc32xxx_iface 	*iface;=0A=
+static struct resource 		*region;=0A=
+=0A=
+=0A=
+static u32 i2c_rc32xxx_func(struct i2c_adapter *adapter)=0A=
+{=0A=
+	return I2C_FUNC_I2C;=0A=
+}=0A=
+=0A=
+static void i2c_rc32xxx_master(void)=0A=
+{=0A=
+  	u32	i2cms =3D i2c->i2cms;=0A=
+=0A=
+	if (!(i2cms & I2CMS_D))=0A=
+		return;=0A=
+=0A=
+	iface->d_ints++;=0A=
+=0A=
+  	if (i2cms & I2CMS_LA) =0A=
+	{=0A=
+		iface->la_ints++;=0A=
+    		printk ("\nI2C Master LA Detected!\n");=0A=
+  	}=0A=
+=0A=
+  	if (i2cms & I2CMS_ERR) =0A=
+	{=0A=
+		iface->err_ints++;=0A=
+    		printk("\nI2C Master ERR Detected!\n");=0A=
+  	}=0A=
+=0A=
+  	switch (iface->state) =0A=
+	{=0A=
+    		case I2C_STATE_IDLE:=0A=
+    		// No need to do anything...=0A=
+      			break;=0A=
+=0A=
+		case I2C_STATE_START:=0A=
+    		// DONE sending START, begin sending address=0A=
+      			i2c->i2cdo =3D I2CDO_DATA(iface->addr);=0A=
+      			i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+			iface->state =3D I2C_STATE_ADDR;=0A=
+      			break;=0A=
+=0A=
+		case I2C_STATE_ADDR:=0A=
+    		// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    		// (Because SDA is driven low)=0A=
+			if (i2cms & I2CMS_NA)=0A=
+				iface->num_naks++;=0A=
+			else=0A=
+				iface->num_acks++;=0A=
+=0A=
+      			// If No Slave ACknowledged the Address byte or=0A=
+		  	// Data Length is zero, then skip Write / Read Stage=0A=
+			if ((i2cms & I2CMS_NA) || !iface->len)=0A=
+			{=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+          				iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+  					// No STOP desired, so go to IDLE and set global variable=0A=
+          				iface->state =3D I2C_STATE_IDLE;=0A=
+        			}=0A=
+        			break;=0A=
+			}=0A=
+=0A=
+			iface->len--;=0A=
+			if (iface->xfer =3D=3D I2C_XFER_WRITE) =0A=
+			{=0A=
+		  		// DONE sending address, now send data=0A=
+		        	i2c->i2cdo =3D  I2CDO_DATA(*(iface->buf++));=0A=
+		        	i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+		        	iface->state =3D I2C_STATE_WRITE_DATA;=0A=
+		        	iface->tx_bytes++;=0A=
+		      	}=0A=
+		      	else =0A=
+			{=0A=
+		  		// DONE sending address, now read data=0A=
+				if (iface->len > 0)=0A=
+		    			// Read Another Data Byte (And ACK)=0A=
+		          		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RDACK);=0A=
+				else=0A=
+		    			// Almost done reading data, now send RD (not RDACK!)=0A=
+		          		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RD);=0A=
+		        	iface->state =3D I2C_STATE_READ_DATA;=0A=
+		      	}=0A=
+		      	break;=0A=
+			=0A=
+	    	case I2C_STATE_WRITE_DATA:=0A=
+    			// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    			// (Because SDA is driven low)=0A=
+      			if (i2cms & I2CMS_NA)=0A=
+        			iface->num_naks++;=0A=
+      			else=0A=
+        			iface->num_acks++;=0A=
+=0A=
+      			if (iface->len-- > 0) =0A=
+			{=0A=
+				// Send next data byte=0A=
+		        	i2c->i2cdo =3D  I2CDO_DATA(*(iface->buf++));=0A=
+				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+				iface->tx_bytes++;=0A=
+      			}=0A=
+      			else =0A=
+			{=0A=
+  				// done sending data, now send STOP if desired.=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+					i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+					iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+					// No STOP desired, so go to IDLE and set global variable=0A=
+					iface->state =3D I2C_STATE_IDLE;=0A=
+        			}=0A=
+      			}=0A=
+			break;=0A=
+			 =0A=
+		case I2C_STATE_READ_DATA:=0A=
+    			// Write Incoming Read data to buffer=0A=
+			*iface->buf++ =3D I2CDI_DATA(i2c->i2cdi);=0A=
+      			iface->rx_bytes++;=0A=
+=0A=
+    			// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    			// (Because SDA is driven low)=0A=
+      			if (i2cms & I2CMS_NA)=0A=
+        			iface->num_naks++;=0A=
+      			else=0A=
+        			iface->num_acks++;=0A=
+				=0A=
+			if (iface->len > 0)=0A=
+			{=0A=
+        			if (iface->len-- > 1) =0A=
+				{=0A=
+					// Read Another Data Byte (And ACK)=0A=
+					i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RDACK);=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+      					// Almost done reading data, now send RD (not RDACK!)=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RD);=0A=
+        			}=0A=
+			}=0A=
+      			else=0A=
+			{=0A=
+				// done sending data, now send STOP if desired.=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+          				iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+	  				// No STOP desired, so go to IDLE and set global variable=0A=
+	          			iface->state =3D I2C_STATE_IDLE;=0A=
+	        		}=0A=
+      			}=0A=
+      			break;=0A=
+=0A=
+    		case I2C_STATE_STOP:=0A=
+    			// Done with packet, set global variable, write NOP command, =
and go to idle=0A=
+      			i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_NOP);=0A=
+      			iface->state =3D I2C_STATE_IDLE;=0A=
+      			break;=0A=
+		=0A=
+    		default:=0A=
+      			printk ("\nErr in Default\n");=0A=
+      			break;=0A=
+  	}=0A=
+}=0A=
+=0A=
+static int i2c_rc32xxx_xfer(struct i2c_adapter *adap, struct i2c_msg =
*msg, int num)=0A=
+{=0A=
+	int	i;=0A=
+=0A=
+	for (i =3D 0; i < num; i++, msg++) =0A=
+	{=0A=
+		if (msg->flags & I2C_M_TEN) =0A=
+		{=0A=
+			printk(KERN_ERR "i2c-rc32434: 10 bits addr not supported!\n");=0A=
+			break;=0A=
+		}=0A=
+=0A=
+		if (msg->flags & I2C_M_RD)=0A=
+		{=0A=
+			iface->xfer =3D I2C_XFER_READ;=0A=
+			iface->addr =3D I2CDO_ADDR(I2C_SLAVE_ADDR) | I2CDO_RD;=0A=
+		}=0A=
+		else=0A=
+		{=0A=
+			iface->xfer =3D I2C_XFER_WRITE;=0A=
+			iface->addr =3D I2CDO_ADDR(I2C_SLAVE_ADDR);=0A=
+		}=0A=
+		iface->len =3D msg->len;=0A=
+		iface->buf =3D msg->buf;=0A=
+		iface->stop =3D TRUE;=0A=
+=0A=
+		// Update Master State=0A=
+		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_START);=0A=
+		iface->state =3D I2C_STATE_START;=0A=
+=0A=
+	  	while (iface->state !=3D I2C_STATE_IDLE) =0A=
+		{=0A=
+			if (i2c->i2cms & I2CMS_D)=0A=
+				i2c_rc32xxx_master();=0A=
+	 	}=0A=
+	}=0A=
+=0A=
+	return i;=0A=
+}=0A=
+=0A=
+int __init i2c_rc32434_init(void)=0A=
+{=0A=
+	int	rc;=0A=
+=0A=
+	printk("i2c-rc32434: loading driver module\n");=0A=
+=0A=
+	region =3D request_region(I2C_BASE, I2C_REGION, "rc32434-i2c IO");=0A=
+	=0A=
+	iface =3D (i2c_rc32xxx_iface *)kmalloc(sizeof(i2c_rc32xxx_iface), =
GFP_KERNEL);=0A=
+	if (!iface) =0A=
+	{=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+		printk(KERN_ERR "i2c-rc32434: can't allocate inteface!\n");=0A=
+		return -ENOMEM;=0A=
+	}=0A=
+	memset(iface, 0, sizeof(i2c_rc32xxx_iface));=0A=
+=0A=
+	iface->algo.functionality =3D i2c_rc32xxx_func;=0A=
+	iface->algo.master_xfer =3D i2c_rc32xxx_xfer;=0A=
+=0A=
+	sprintf(iface->adap.name, "%s", "RC32434 I2C");=0A=
+	iface->adap.algo =3D &iface->algo;=0A=
+	i2c_set_adapdata(&iface->adap, iface);=0A=
+=0A=
+	rc =3D i2c_add_adapter(&iface->adap);=0A=
+	if (rc)=0A=
+	{=0A=
+		kfree(iface);=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+		printk(KERN_ERR "i2c-rc32434: can't add adapter!\n");=0A=
+		return rc;=0A=
+	}=0A=
+	=0A=
+	iface->state =3D I2C_STATE_IDLE;=0A=
+=0A=
+    	// Initialize master interface=0A=
+  	i2c->i2cc =3D I2CC_MEN;=0A=
+  	i2c->i2ccp =3D  I2CCP_DIV(I2C_PRESCALER);=0A=
+	i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_NOP);=0A=
+  	i2c->i2cmsm =3D I2CMS_MASK;=0A=
+  	i2c->i2cssm =3D I2CSS_MASK;=0A=
+=0A=
+	return rc;=0A=
+}=0A=
+=0A=
+void __exit i2c_rc32434_exit(void)=0A=
+{=0A=
+	printk("i2c-rc32434: unloading driver module\n");=0A=
+=0A=
+	i2c_del_adapter(&iface->adap);=0A=
+	kfree(iface);		=0A=
+	if (region)=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+}=0A=
+=0A=
+=0A=
+module_init(i2c_rc32434_init);=0A=
+module_exit(i2c_rc32434_exit);=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/i2c/busses/i2c-rc32438.c =
idtlinux/drivers/i2c/busses/i2c-rc32438.c=0A=
--- linux-2.6.16-rc5/drivers/i2c/busses/i2c-rc32438.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/i2c/busses/i2c-rc32438.c	2006-03-09 =
16:26:13.000000000 -0800=0A=
@@ -0,0 +1,331 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     I2C driver IDT EB434 board=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+=0A=
+#include <linux/module.h>=0A=
+#include <linux/config.h>=0A=
+#include <linux/version.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/pci.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/delay.h>=0A=
+#include <linux/i2c.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/mm.h>=0A=
+#include <linux/timer.h>=0A=
+#include <linux/spinlock.h>=0A=
+#include <linux/completion.h>=0A=
+#include <linux/devfs_fs_kernel.h>=0A=
+#include <linux/i2c-dev.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+#include "i2c-rc32xxx.h"=0A=
+=0A=
+MODULE_AUTHOR("idt");=0A=
+MODULE_DESCRIPTION("I2C driver for IDT's 79RC32438 board");=0A=
+MODULE_LICENSE("GPL");=0A=
+=0A=
+=0A=
+static i2c_rc32xxx_iface 	*iface;=0A=
+static struct resource 		*region;=0A=
+=0A=
+=0A=
+static u32 i2c_rc32xxx_func(struct i2c_adapter *adapter)=0A=
+{=0A=
+	return I2C_FUNC_I2C;=0A=
+}=0A=
+=0A=
+static void i2c_rc32xxx_master(void)=0A=
+{=0A=
+  	u32	i2cms =3D i2c->i2cms;=0A=
+=0A=
+	if (!(i2cms & I2CMS_D))=0A=
+		return;=0A=
+=0A=
+	iface->d_ints++;=0A=
+=0A=
+  	if (i2cms & I2CMS_LA) =0A=
+	{=0A=
+		iface->la_ints++;=0A=
+    		printk ("\nI2C Master LA Detected!\n");=0A=
+  	}=0A=
+=0A=
+  	if (i2cms & I2CMS_ERR) =0A=
+	{=0A=
+		iface->err_ints++;=0A=
+    		printk("\nI2C Master ERR Detected!\n");=0A=
+  	}=0A=
+=0A=
+  	switch (iface->state) =0A=
+	{=0A=
+    		case I2C_STATE_IDLE:=0A=
+    		// No need to do anything...=0A=
+      			break;=0A=
+=0A=
+		case I2C_STATE_START:=0A=
+    		// DONE sending START, begin sending address=0A=
+      			i2c->i2cdo =3D I2CDO_DATA(iface->addr);=0A=
+      			i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+			iface->state =3D I2C_STATE_ADDR;=0A=
+      			break;=0A=
+=0A=
+		case I2C_STATE_ADDR:=0A=
+    		// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    		// (Because SDA is driven low)=0A=
+			if (i2cms & I2CMS_NA)=0A=
+				iface->num_naks++;=0A=
+			else=0A=
+				iface->num_acks++;=0A=
+=0A=
+      			// If No Slave ACknowledged the Address byte or=0A=
+		  	// Data Length is zero, then skip Write / Read Stage=0A=
+			if ((i2cms & I2CMS_NA) || !iface->len)=0A=
+			{=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+          				iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+  					// No STOP desired, so go to IDLE and set global variable=0A=
+          				iface->state =3D I2C_STATE_IDLE;=0A=
+        			}=0A=
+        			break;=0A=
+			}=0A=
+=0A=
+			iface->len--;=0A=
+			if (iface->xfer =3D=3D I2C_XFER_WRITE) =0A=
+			{=0A=
+		  		// DONE sending address, now send data=0A=
+		        	i2c->i2cdo =3D  I2CDO_DATA(*(iface->buf++));=0A=
+		        	i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+		        	iface->state =3D I2C_STATE_WRITE_DATA;=0A=
+		        	iface->tx_bytes++;=0A=
+		      	}=0A=
+		      	else =0A=
+			{=0A=
+		  		// DONE sending address, now read data=0A=
+				if (iface->len > 0)=0A=
+		    			// Read Another Data Byte (And ACK)=0A=
+		          		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RDACK);=0A=
+				else=0A=
+		    			// Almost done reading data, now send RD (not RDACK!)=0A=
+		          		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RD);=0A=
+		        	iface->state =3D I2C_STATE_READ_DATA;=0A=
+		      	}=0A=
+		      	break;=0A=
+			=0A=
+	    	case I2C_STATE_WRITE_DATA:=0A=
+    			// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    			// (Because SDA is driven low)=0A=
+      			if (i2cms & I2CMS_NA)=0A=
+        			iface->num_naks++;=0A=
+      			else=0A=
+        			iface->num_acks++;=0A=
+=0A=
+      			if (iface->len-- > 0) =0A=
+			{=0A=
+				// Send next data byte=0A=
+		        	i2c->i2cdo =3D  I2CDO_DATA(*(iface->buf++));=0A=
+				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_WD);=0A=
+				iface->tx_bytes++;=0A=
+      			}=0A=
+      			else =0A=
+			{=0A=
+  				// done sending data, now send STOP if desired.=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+					i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+					iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+					// No STOP desired, so go to IDLE and set global variable=0A=
+					iface->state =3D I2C_STATE_IDLE;=0A=
+        			}=0A=
+      			}=0A=
+			break;=0A=
+			 =0A=
+		case I2C_STATE_READ_DATA:=0A=
+    			// Write Incoming Read data to buffer=0A=
+			*iface->buf++ =3D I2CDI_DATA(i2c->i2cdi);=0A=
+      			iface->rx_bytes++;=0A=
+=0A=
+    			// Count ACKs & NAKs - note, an ACK occurs when the ACK bit is =
cleared=0A=
+    			// (Because SDA is driven low)=0A=
+      			if (i2cms & I2CMS_NA)=0A=
+        			iface->num_naks++;=0A=
+      			else=0A=
+        			iface->num_acks++;=0A=
+				=0A=
+			if (iface->len > 0)=0A=
+			{=0A=
+        			if (iface->len-- > 1) =0A=
+				{=0A=
+					// Read Another Data Byte (And ACK)=0A=
+					i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RDACK);=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+      					// Almost done reading data, now send RD (not RDACK!)=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_RD);=0A=
+        			}=0A=
+			}=0A=
+      			else=0A=
+			{=0A=
+				// done sending data, now send STOP if desired.=0A=
+        			if (iface->stop) =0A=
+				{=0A=
+          				i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_STOP);=0A=
+          				iface->state =3D I2C_STATE_STOP;=0A=
+        			}=0A=
+        			else =0A=
+				{=0A=
+	  				// No STOP desired, so go to IDLE and set global variable=0A=
+	          			iface->state =3D I2C_STATE_IDLE;=0A=
+	        		}=0A=
+      			}=0A=
+      			break;=0A=
+=0A=
+    		case I2C_STATE_STOP:=0A=
+    			// Done with packet, set global variable, write NOP command, =
and go to idle=0A=
+      			i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_NOP);=0A=
+      			iface->state =3D I2C_STATE_IDLE;=0A=
+      			break;=0A=
+		=0A=
+    		default:=0A=
+      			printk ("\nErr in Default\n");=0A=
+      			break;=0A=
+  	}=0A=
+}=0A=
+=0A=
+static int i2c_rc32xxx_xfer(struct i2c_adapter *adap, struct i2c_msg =
*msg, int num)=0A=
+{=0A=
+	int	i;=0A=
+=0A=
+	for (i =3D 0; i < num; i++, msg++) =0A=
+	{=0A=
+		if (msg->flags & I2C_M_TEN) =0A=
+		{=0A=
+			printk(KERN_ERR "i2c-rc32438: 10 bits addr not supported!\n");=0A=
+			break;=0A=
+		}=0A=
+=0A=
+		if (msg->flags & I2C_M_RD)=0A=
+		{=0A=
+			iface->xfer =3D I2C_XFER_READ;=0A=
+			iface->addr =3D I2CDO_ADDR(I2C_SLAVE_ADDR) | I2CDO_RD;=0A=
+		}=0A=
+		else=0A=
+		{=0A=
+			iface->xfer =3D I2C_XFER_WRITE;=0A=
+			iface->addr =3D I2CDO_ADDR(I2C_SLAVE_ADDR);=0A=
+		}=0A=
+		iface->len =3D msg->len;=0A=
+		iface->buf =3D msg->buf;=0A=
+		iface->stop =3D TRUE;=0A=
+=0A=
+		// Update Master State=0A=
+		i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_START);=0A=
+		iface->state =3D I2C_STATE_START;=0A=
+=0A=
+	  	while (iface->state !=3D I2C_STATE_IDLE) =0A=
+		{=0A=
+			if (i2c->i2cms & I2CMS_D)=0A=
+				i2c_rc32xxx_master();=0A=
+	 	}=0A=
+	}=0A=
+=0A=
+	return i;=0A=
+}=0A=
+=0A=
+int __init i2c_rc32438_init(void)=0A=
+{=0A=
+	int	rc;=0A=
+=0A=
+	printk("i2c-rc32438: loading driver module\n");=0A=
+=0A=
+	region =3D request_region(I2C_BASE, I2C_REGION, "rc32438-i2c IO");=0A=
+	=0A=
+	iface =3D (i2c_rc32xxx_iface *)kmalloc(sizeof(i2c_rc32xxx_iface), =
GFP_KERNEL);=0A=
+	if (!iface) =0A=
+	{=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+		printk(KERN_ERR "i2c-rc32438: can't allocate inteface!\n");=0A=
+		return -ENOMEM;=0A=
+	}=0A=
+	memset(iface, 0, sizeof(i2c_rc32xxx_iface));=0A=
+=0A=
+	iface->algo.functionality =3D i2c_rc32xxx_func;=0A=
+	iface->algo.master_xfer =3D i2c_rc32xxx_xfer;=0A=
+=0A=
+	sprintf(iface->adap.name, "%s", "RC32438 I2C");=0A=
+	iface->adap.algo =3D &iface->algo;=0A=
+	i2c_set_adapdata(&iface->adap, iface);=0A=
+=0A=
+	rc =3D i2c_add_adapter(&iface->adap);=0A=
+	if (rc)=0A=
+	{=0A=
+		kfree(iface);=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+		printk(KERN_ERR "i2c-rc32438: can't add adapter!\n");=0A=
+		return rc;=0A=
+	}=0A=
+	=0A=
+	iface->state =3D I2C_STATE_IDLE;=0A=
+=0A=
+    	// Initialize master interface=0A=
+  	i2c->i2cc =3D I2CC_MEN;=0A=
+  	i2c->i2ccp =3D  I2CCP_DIV(I2C_PRESCALER);=0A=
+	i2c->i2cmcmd =3D I2CMCMD_CMD(I2CMCMD_NOP);=0A=
+  	i2c->i2cmsm =3D I2CMS_MASK;=0A=
+  	i2c->i2cssm =3D I2CSS_MASK;=0A=
+=0A=
+	return rc;=0A=
+}=0A=
+=0A=
+void __exit i2c_rc32438_exit(void)=0A=
+{=0A=
+	printk("i2c-rc32438: unloading driver module\n");=0A=
+=0A=
+	i2c_del_adapter(&iface->adap);=0A=
+	kfree(iface);		=0A=
+	if (region)=0A=
+		release_region(I2C_BASE, I2C_REGION);=0A=
+}=0A=
+=0A=
+=0A=
+module_init(i2c_rc32438_init);=0A=
+module_exit(i2c_rc32438_exit);=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/i2c/busses/i2c-rc32xxx.h =
idtlinux/drivers/i2c/busses/i2c-rc32xxx.h=0A=
--- linux-2.6.16-rc5/drivers/i2c/busses/i2c-rc32xxx.h	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/i2c/busses/i2c-rc32xxx.h	2006-03-09 =
16:26:13.000000000 -0800=0A=
@@ -0,0 +1,237 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Low level driver for 79RC32xxx=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef _I2C_RC32xxx_=0A=
+#define _I2C_RC32xxx_=0A=
+#ifdef __cplusplus=0A=
+extern "C" {=0A=
+#endif=0A=
+=0A=
+=0A=
+/*	NOTE:!!!=0A=
+ *	Please assign your I2C device's Slave Adress here, =0A=
+ *	otherwise it will use the default values=0A=
+ */=0A=
+#ifdef CONFIG_I2C_RC32438=0A=
+#define	I2C_SLAVE_ADDR		0x50=0A=
+#define I2C_PRESCALER		110=0A=
+#define I2C_BASE		0xb8070000=0A=
+#endif=0A=
+=0A=
+=0A=
+#ifdef CONFIG_I2C_RC32434=0A=
+#define	I2C_SLAVE_ADDR		0x50=0A=
+#define I2C_PRESCALER		250=0A=
+#define I2C_BASE		0xb8068000=0A=
+#endif=0A=
+=0A=
+#ifdef CONFIG_I2C_RC32355=0A=
+#define I2C_SLAVE_ADDR		0x57=0A=
+#define I2C_PRESCALER		63=0A=
+#define I2C_BASE		0xb8070000=0A=
+#endif=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * RC355 GPIO/I2C Interface=0A=
+ =
********************************************************************/=0A=
+#define RC355_GPIOFUNC		0xb8040000=0A=
+=0A=
+#define RC355_GPIOFUNC_ALT_CSN4	0x00010000=0A=
+#define RC355_GPIOFUNC_I2C_PINS	0x0000c000=0A=
+=0A=
+#define rc355_gpiofunc 		(*(volatile u32*)RC355_GPIOFUNC)=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2C Interface=0A=
+ =
********************************************************************/=0A=
+#ifndef TRUE=0A=
+#define TRUE 1=0A=
+#endif=0A=
+#ifndef FALSE=0A=
+#define FALSE 0=0A=
+#endif=0A=
+=0A=
+typedef enum {=0A=
+	I2C_STATE_IDLE,=0A=
+	I2C_STATE_START,=0A=
+	I2C_STATE_ADDR,=0A=
+	I2C_STATE_READ_DATA,=0A=
+	I2C_STATE_WRITE_DATA,=0A=
+	I2C_STATE_STOP=0A=
+} I2C_STATE;=0A=
+=0A=
+typedef enum {=0A=
+	I2C_XFER_READ,=0A=
+	I2C_XFER_WRITE=0A=
+} I2C_XFER;=0A=
+=0A=
+typedef struct {=0A=
+	struct i2c_algorithm	algo;=0A=
+	struct i2c_adapter	adap;=0A=
+	I2C_STATE		state;=0A=
+	I2C_XFER		xfer;=0A=
+	unsigned		addr;=0A=
+	int			len;=0A=
+	u8			*buf;=0A=
+	int			stop;=0A=
+	unsigned		d_ints;=0A=
+	unsigned		la_ints;=0A=
+	unsigned		err_ints;=0A=
+	unsigned		num_acks;=0A=
+	unsigned		num_naks;=0A=
+	unsigned		tx_bytes;=0A=
+	unsigned		rx_bytes;=0A=
+} i2c_rc32xxx_iface;=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2C Registers=0A=
+ =
********************************************************************/=0A=
+#define I2CC			0x00000000=0A=
+#define I2CDI			0x00000004=0A=
+#define I2CDO			0x00000008=0A=
+#define I2CCP			0x0000000c=0A=
+#define I2CMCMD			0x00000010=0A=
+#define I2CMS			0x00000014=0A=
+#define I2CMSM			0x00000018=0A=
+#define I2CSS			0x0000001c=0A=
+#define I2CSSM			0x00000020=0A=
+#define I2CSADDR		0x00000024=0A=
+#define I2CSACK			0x00000028=0A=
+=0A=
+#define I2C_REGION		0x00008000=0A=
+=0A=
+typedef struct {=0A=
+	u32	i2cc;=0A=
+	u32	i2cdi;=0A=
+	u32	i2cdo;=0A=
+	u32	i2ccp;=0A=
+	u32	i2cmcmd;=0A=
+	u32	i2cms;=0A=
+	u32	i2cmsm;=0A=
+	u32	i2css;=0A=
+	u32	i2cssm;=0A=
+	u32	i2csaddr;=0A=
+	u32	i2csack;=0A=
+} I2C;=0A=
+=0A=
+#define i2c 			((volatile I2C*)I2C_BASE)=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CC Register=0A=
+ =
********************************************************************/=0A=
+#define I2CC_MEN		(1<<0)=0A=
+#define I2CC_SEN		(1<<1)=0A=
+#define I2CC_IOM		(1<<2)=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CDI Register=0A=
+ =
********************************************************************/=0A=
+#define I2CDI_DATA(v)		((u8)((v) & 0x000000ff))=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CDO Register=0A=
+ =
********************************************************************/=0A=
+#define I2CDO_DATA(v)		((v) & 0x000000ff)=0A=
+=0A=
+#define I2CDO_ADDR(v)		((v) << 1)=0A=
+#define I2CDO_RD		1=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CCP Register=0A=
+ =
********************************************************************/=0A=
+#define I2CCP_DIV(v)		((v) & 0x0000ffff)=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CMCMD Register=0A=
+ =
********************************************************************/=0A=
+#define I2CMCMD_CMD(v)		((v) & 0x0000000f)=0A=
+=0A=
+#define I2CMCMD_NOP		0=0A=
+#define I2CMCMD_START		1=0A=
+#define I2CMCMD_STOP		2=0A=
+#define I2CMCMD_RD		4=0A=
+#define I2CMCMD_RDACK		5=0A=
+#define I2CMCMD_WD		6=0A=
+#define I2CMCMD_WDACK		7=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CMS Register=0A=
+ =
********************************************************************/=0A=
+#define I2CMS_D			(1<<0)=0A=
+#define I2CMS_NA		(1<<1)=0A=
+#define I2CMS_LA		(1<<2)=0A=
+#define I2CMS_ERR		(1<<3)=0A=
+=0A=
+#define I2CMS_MASK		0x0000000f=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CSS Register=0A=
+ =
********************************************************************/=0A=
+#define I2CSS_RR		(1<<0)=0A=
+#define I2CSS_WR		(1<<1)=0A=
+#define I2CSS_SA		(1<<2)=0A=
+#define I2CSS_TF		(1<<3)=0A=
+#define I2CSS_GC		(1<<4)=0A=
+#define I2CSS_NA		(1<<5)=0A=
+#define I2CSS_ERR		(1<<6)=0A=
+=0A=
+#define I2CSS_MASK		0x0000007f=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CSADDR Register=0A=
+ =
********************************************************************/=0A=
+#define I2CSADDR_ADDR(v)	((v) & 0x000003ff)=0A=
+#define I2CSADDR_GC		(1<<10)=0A=
+#define I2CSADDR_A10		(1<<11)=0A=
+=0A=
+=0A=
+/********************************************************************=0A=
+ * I2CSACK Register=0A=
+ =
********************************************************************/=0A=
+#define I2CSACK_ACK		(1<<0)=0A=
+=0A=
+=0A=
+#ifdef __cplusplus=0A=
+}=0A=
+#endif=0A=
+#endif /* _I2C_RC32xxx_ */=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/i2c/busses/Kconfig =
idtlinux/drivers/i2c/busses/Kconfig=0A=
--- linux-2.6.16-rc5/drivers/i2c/busses/Kconfig	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/drivers/i2c/busses/Kconfig	2006-03-09 16:26:13.000000000 =
-0800=0A=
@@ -511,4 +511,21 @@=0A=
 	  This driver can also be built as a module.  If so, the module=0A=
 	  will be called i2c-mv64xxx.=0A=
 =0A=
+config I2C_RC32438=0A=
+        tristate "I2C IDT RC32438 interface"=0A=
+        depends on I2C_CHARDEV=0A=
+        depends on IDT_EB438=0A=
+	default y=0A=
+=0A=
+config I2C_RC32434=0A=
+        tristate "I2C IDT RC32434/435 interface"=0A=
+        depends on I2C_CHARDEV=0A=
+        depends on IDT_EB434=0A=
+	default y=0A=
+=0A=
+config I2C_RC32355=0A=
+        tristate "I2C IDT RC32355 interface"=0A=
+        depends on I2C_CHARDEV=0A=
+        depends on IDT_EB355=0A=
+	default y=0A=
 endmenu=0A=
diff -uNr linux-2.6.16-rc5/drivers/i2c/busses/Makefile =
idtlinux/drivers/i2c/busses/Makefile=0A=
--- linux-2.6.16-rc5/drivers/i2c/busses/Makefile	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/drivers/i2c/busses/Makefile	2006-03-09 16:26:13.000000000 =
-0800=0A=
@@ -42,6 +42,9 @@=0A=
 obj-$(CONFIG_I2C_VOODOO3)	+=3D i2c-voodoo3.o=0A=
 obj-$(CONFIG_SCx200_ACB)	+=3D scx200_acb.o=0A=
 obj-$(CONFIG_SCx200_I2C)	+=3D scx200_i2c.o=0A=
+obj-$(CONFIG_I2C_RC32438)       +=3D i2c-rc32438.o=0A=
+obj-$(CONFIG_I2C_RC32434)       +=3D i2c-rc32434.o=0A=
+obj-$(CONFIG_I2C_RC32355)       +=3D i2c-rc32355.o=0A=
 =0A=
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)=0A=
 EXTRA_CFLAGS +=3D -DDEBUG=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/Kconfig =
idtlinux/drivers/net/Kconfig=0A=
--- linux-2.6.16-rc5/drivers/net/Kconfig	2006-02-27 02:56:56.000000000 =
-0800=0A=
+++ idtlinux/drivers/net/Kconfig	2006-03-09 16:26:07.000000000 -0800=0A=
@@ -185,6 +185,39 @@=0A=
 	  or internal device.  It is safe to say Y or M here even if your=0A=
 	  ethernet card lack MII.=0A=
 =0A=
+config IDT_RC32438_ETH=0A=
+        tristate "IDT RC32438 Local Ethernet support"=0A=
+        depends on NET_ETHERNET && (IDT_EB438 || IDT_PMC438)=0A=
+	default y=0A=
+        help=0A=
+        IDT RC32438 has two local ethernet ports. Say Y here to enable =
them.=0A=
+        To compile this driver as a module, choose M here.=0A=
+=0A=
+config IDT_RC32434_ETH=0A=
+        tristate "IDT RC32434/435 Local Ethernet support"=0A=
+        depends on NET_ETHERNET && (IDT_EB434 || IDT_PMC434)=0A=
+	default y=0A=
+        help=0A=
+        IDT RC32434/435 has one local ethernet port. Say Y here to =
enable it.=0A=
+        To compile this driver as a module, choose M here.=0A=
+=0A=
+config IDT_RC32355_ETH=0A=
+        tristate "IDT RC32355 Local Ethernet support"=0A=
+        depends on NET_ETHERNET && IDT_EB355=0A=
+	default y=0A=
+        help=0A=
+        IDT RC32365 has one local ethernet port. Say Y here to enable =
it.=0A=
+        To compile this driver as a module, choose M here.=0A=
+=0A=
+config IDT_RC32365_ETH=0A=
+        tristate "IDT RC32365/336 Local Ethernet support"=0A=
+        depends on NET_ETHERNET && IDT_EB365=0A=
+	default y=0A=
+        help=0A=
+        IDT RC32365/336 has two local ethernet ports. Say Y here to =
enable them.=0A=
+        To compile this driver as a module, choose M here.=0A=
+=0A=
+=0A=
 source "drivers/net/arm/Kconfig"=0A=
 =0A=
 config MACE=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/Makefile =
idtlinux/drivers/net/Makefile=0A=
--- linux-2.6.16-rc5/drivers/net/Makefile	2006-02-27 02:56:56.000000000 =
-0800=0A=
+++ idtlinux/drivers/net/Makefile	2006-03-09 16:26:10.000000000 =
-0800=0A=
@@ -74,6 +74,12 @@=0A=
 # end link order section=0A=
 #=0A=
 =0A=
+obj-$(CONFIG_IDT_RC32438_ETH) +=3D rc32438_eth.o=0A=
+obj-$(CONFIG_IDT_RC32434_ETH) +=3D rc32434_eth.o=0A=
+obj-$(CONFIG_IDT_RC32365_ETH) +=3D rc32365_eth.o=0A=
+obj-$(CONFIG_IDT_RC32355_ETH) +=3D rc32355_eth.o=0A=
+=0A=
+=0A=
 obj-$(CONFIG_MII) +=3D mii.o=0A=
 obj-$(CONFIG_PHYLIB) +=3D phy/=0A=
 =0A=
diff -uNr linux-2.6.16-rc5/drivers/net/rc32355_eth.c =
idtlinux/drivers/net/rc32355_eth.c=0A=
--- linux-2.6.16-rc5/drivers/net/rc32355_eth.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/net/rc32355_eth.c	2006-03-09 16:26:04.000000000 =
-0800=0A=
@@ -0,0 +1,1196 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Driver for the IDT RC32355 on-chip ethernet controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/module.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/fcntl.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/ptrace.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/proc_fs.h>=0A=
+#include <linux/in.h>=0A=
+#include <linux/slab.h> =0A=
+#include <linux/string.h>=0A=
+#include <linux/delay.h>=0A=
+#include <linux/netdevice.h>=0A=
+#include <linux/etherdevice.h>=0A=
+#include <linux/skbuff.h>=0A=
+#include <linux/errno.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <asm/segment.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/dma.h>=0A=
+=0A=
+#include "rc32355_eth.h"=0A=
+=0A=
+#define DRIVER_VERSION "(apr2904)"=0A=
+#define DRIVER_NAME "rc32355 Ethernet driver. " DRIVER_VERSION=0A=
+#define STATION_ADDRESS_HIGH(dev) (((dev)->dev_addr[0] << 8) | \=0A=
+				   ((dev)->dev_addr[1]))=0A=
+#define STATION_ADDRESS_LOW(dev)  (((dev)->dev_addr[2] << 24) | \=0A=
+				   ((dev)->dev_addr[3] << 16) | \=0A=
+				   ((dev)->dev_addr[4] << 8)  | \=0A=
+				   ((dev)->dev_addr[5]))=0A=
+=0A=
+#define MII_CLOCK 1250000 					/* no more than 2.5MHz */=0A=
+#define NINTFC		2 						/* number of interface */=0A=
+static char mac[18] =3D "08:00:06:05:40:01"; =0A=
+=0A=
+MODULE_AUTHOR ("IDT Inc");=0A=
+MODULE_DESCRIPTION ("rc32365 Ethernet driver");=0A=
+MODULE_LICENSE("GPL");=0A=
+MODULE_PARM(mac, "c18");=0A=
+MODULE_PARM_DESC(mac0, "MAC address for RC32355 ethernet");=0A=
+=0A=
+static struct rc32355_if_t =0A=
+{=0A=
+	struct net_device *dev;=0A=
+  	char* mac_str;=0A=
+  	u32 iobase;=0A=
+  	int rx_dma_irq;=0A=
+  	int tx_dma_irq;=0A=
+  	int rx_ovr_irq;=0A=
+  	int tx_und_irq;		=0A=
+} rc32355_iflist[] =3D =0A=
+{=0A=
+	{NULL, mac, RC32355_ETH_BASE, ETH_DMA_RX_IRQ, ETH_DMA_TX_IRQ, =
ETH_RX_OVR_IRQ, ETH_TX_UND_IRQ},=0A=
+	{NULL, NULL, 0, 0,0,0,0}=0A=
+};=0A=
+=0A=
+=0A=
+static int parse_mac_addr(struct net_device *dev, char* macstr)=0A=
+{=0A=
+  	int i, j;=0A=
+  	unsigned char result, value;=0A=
+	=0A=
+  	for (i=3D0; i<6; i++) =0A=
+	{=0A=
+    		result =3D 0;=0A=
+    		if (i !=3D 5 && *(macstr+2) !=3D ':') {=0A=
+			ERR(__FILE__ "invalid mac address format: %d %c\n", i, =
*(macstr+2));=0A=
+      			return -EINVAL;=0A=
+    		}=0A=
+		=0A=
+	    	for (j=3D0; j<2; j++) {=0A=
+			if (isxdigit(*macstr) && (value =3D isdigit(*macstr) ? *macstr-'0' =
: toupper(*macstr)-'A'+10) < 16) {=0A=
+				result =3D result*16 + value;=0A=
+				macstr++;=0A=
+			} =0A=
+			else {=0A=
+				ERR(__FILE__ "invalid mac address character: %c\n", *macstr);=0A=
+				return -EINVAL;=0A=
+			}=0A=
+		}=0A=
+		=0A=
+    		macstr++;=0A=
+    		dev->dev_addr[i] =3D result;=0A=
+  	}=0A=
+	=0A=
+  	return 0;=0A=
+}=0A=
+=0A=
+static inline void rc32355_abort_tx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+	rc32355_abort_dma(dev, lp->tx_dma_regs);=0A=
+	=0A=
+}=0A=
+=0A=
+static inline void rc32355_abort_rx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+	rc32355_abort_dma(dev, lp->rx_dma_regs);=0A=
+	=0A=
+}=0A=
+=0A=
+static inline void rc32355_halt_tx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+	if (rc32355_halt_dma(lp->tx_dma_regs))=0A=
+		ERR(__FUNCTION__ ": timeout!\n");=0A=
+}=0A=
+=0A=
+static inline void rc32355_halt_rx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+	if (rc32355_halt_dma(lp->rx_dma_regs))=0A=
+		ERR(__FUNCTION__ ": timeout!\n");=0A=
+}=0A=
+=0A=
+static inline void rc32355_start_tx(struct rc32355_local *lp, volatile =
rc32355_dma_desc_t* td)=0A=
+{=0A=
+  	rc32355_start_dma(lp->tx_dma_regs, CPHYSADDR(td));=0A=
+}=0A=
+=0A=
+static inline void rc32355_start_rx(struct rc32355_local *lp, volatile =
rc32355_dma_desc_t* rd)=0A=
+{=0A=
+	rc32355_start_dma(lp->rx_dma_regs, CPHYSADDR(rd));=0A=
+}=0A=
+=0A=
+static inline void rc32355_chain_tx(struct rc32355_local *lp, volatile =
rc32355_dma_desc_t* td)=0A=
+{=0A=
+	rc32355_chain_dma(lp->tx_dma_regs, CPHYSADDR(td));=0A=
+}=0A=
+=0A=
+static inline void rc32355_chain_rx(struct rc32355_local *lp, volatile =
rc32355_dma_desc_t* rd)=0A=
+{=0A=
+	rc32355_chain_dma(lp->rx_dma_regs, CPHYSADDR(rd));=0A=
+}=0A=
+=0A=
+#ifdef RC32355_PROC_DEBUG=0A=
+static int rc32355_read_proc(char *buf, char **start, off_t fpos,=0A=
+			     int length, int *eof, void *data)=0A=
+{=0A=
+  	struct net_device *dev =3D (struct net_device *)data;=0A=
+  	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+  	int len =3D 0;=0A=
+	=0A=
+  	/* print out header */=0A=
+  	len +=3D sprintf(buf + len, "\n\tRC32355 Ethernet Debug\n\n");=0A=
+	=0A=
+  	len +=3D sprintf (buf + len,=0A=
+			"DMA halt count      =3D %10d, total pkt cnt =3D %10d\n",=0A=
+			lp->dma_halt_cnt, lp->halt_tx_count);=0A=
+  	len +=3D sprintf (buf + len,=0A=
+			"DMA run count       =3D %10d, total pkt cnt =3D %10d\n",=0A=
+			lp->dma_run_cnt, lp->run_tx_count);=0A=
+  	len +=3D sprintf (buf + len,=0A=
+			"DMA race count      =3D %10d, total pkt cnt =3D %10d\n",=0A=
+			lp->dma_race_cnt, lp->race_tx_count);=0A=
+  	len +=3D sprintf (buf + len,=0A=
+			"DMA collision count =3D %10d, total pkt cnt =3D %10d\n",=0A=
+			lp->dma_collide_cnt, lp->collide_tx_count);=0A=
+	=0A=
+  	if (fpos >=3D len) {=0A=
+		*start =3D buf;=0A=
+    		*eof =3D 1;=0A=
+    		return 0;=0A=
+  	}=0A=
+  	*start =3D buf + fpos;=0A=
+  	if ((len -=3D fpos) > length)=0A=
+    		return length;=0A=
+	=0A=
+  	*eof =3D 1;=0A=
+  	return len;=0A=
+	=0A=
+}=0A=
+#endif=0A=
+=0A=
+=0A=
+/*=0A=
+ * Restart the RC32355 ethernet controller. Hold a spin lock=0A=
+ * before calling.=0A=
+ */=0A=
+static int rc32355_restart(struct net_device *dev)=0A=
+{=0A=
+  	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+	=0A=
+  	/*=0A=
+	 * Disable interrupts=0A=
+	 */=0A=
+  	disable_irq(lp->rx_irq);=0A=
+  	disable_irq(lp->tx_irq);=0A=
+  	disable_irq(lp->ovr_irq);=0A=
+    	disable_irq(lp->und_irq);=0A=
+	=0A=
+  	/* Mask F bit in Tx DMA */=0A=
+  	local_writel(local_readl(&lp->tx_dma_regs->dmasm) | DMAS_F, =
&lp->tx_dma_regs->dmasm);=0A=
+    	/* Mask D bit in Rx DMA */=0A=
+  	local_writel(local_readl(&lp->rx_dma_regs->dmasm) | DMAS_D, =
&lp->rx_dma_regs->dmasm);=0A=
+	=0A=
+	rc32355_init(dev);=0A=
+	rc32355_multicast_list(dev);=0A=
+	=0A=
+  	enable_irq(lp->und_irq);=0A=
+  	enable_irq(lp->ovr_irq);=0A=
+  	enable_irq(lp->tx_irq);=0A=
+  	enable_irq(lp->rx_irq);=0A=
+	=0A=
+  	return 0;=0A=
+}=0A=
+=0A=
+int rc32355_init_module(void)=0A=
+{=0A=
+  	int retval=3D0;=0A=
+	=0A=
+	printk(KERN_INFO DRIVER_NAME " \n");=0A=
+	retval =3D rc32355_probe(0);=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+static int rc32355_probe(int port_num)=0A=
+{=0A=
+  	struct rc32355_local *lp =3D NULL;=0A=
+  	struct rc32355_if_t *bif =3D NULL;=0A=
+  	struct net_device *dev =3D NULL;=0A=
+  	int i, retval,err;=0A=
+	=0A=
+	bif =3D &rc32355_iflist[port_num];=0A=
+	dev =3D alloc_etherdev(sizeof(struct rc32355_local));=0A=
+	if(!dev)=0A=
+	{ =0A=
+		ERR("rc32438_eth: alloc_etherdev failed\n");=0A=
+		free_netdev(dev);=0A=
+		return -1;=0A=
+	}=0A=
+	=0A=
+	SET_MODULE_OWNER(dev);=0A=
+	=0A=
+	bif->dev =3D dev;=0A=
+	=0A=
+	=0A=
+  	if ((retval =3D parse_mac_addr(dev, bif->mac_str))) {=0A=
+		ERR(__FUNCTION__ ": MAC address parse failed\n");=0A=
+		retval =3D -EINVAL;=0A=
+		goto probe1_err_out;=0A=
+	}=0A=
+	=0A=
+	=0A=
+	/* Initialize the device structure. */=0A=
+  	if (dev->priv =3D=3D NULL) {=0A=
+		lp =3D (struct rc32355_local *)kmalloc(sizeof(*lp), GFP_KERNEL);=0A=
+		memset(lp, 0, sizeof(struct rc32355_local));=0A=
+	} =0A=
+	else {=0A=
+		lp =3D (struct rc32355_local *)dev->priv;=0A=
+	}=0A=
+  	lp->rx_irq =3D bif->rx_dma_irq;=0A=
+  	lp->tx_irq =3D bif->tx_dma_irq;=0A=
+    	lp->ovr_irq =3D bif->rx_ovr_irq;=0A=
+  	lp->und_irq =3D bif->tx_und_irq;=0A=
+	=0A=
+  	lp->eth_regs =3D ioremap_nocache(bif->iobase, =
sizeof(*lp->eth_regs));=0A=
+	=0A=
+  	if (!lp->eth_regs) {=0A=
+		ERR("Can't remap eth registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe1_err_out;=0A=
+	}=0A=
+	=0A=
+	lp->rx_dma_regs =3D=0A=
+		ioremap_nocache(RC32355_DMA_BASE + 9*DMA_CHAN_OFFSET,=0A=
+				sizeof(rc32355_dma_ch_t));=0A=
+	if (!lp->rx_dma_regs) {=0A=
+		ERR("Can't remap Rx DMA registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe1_err_out;=0A=
+	}=0A=
+	=0A=
+	lp->tx_dma_regs =3D=0A=
+		ioremap_nocache(RC32355_DMA_BASE + 10*DMA_CHAN_OFFSET,=0A=
+				sizeof(rc32355_dma_ch_t));=0A=
+	if (!lp->tx_dma_regs) {=0A=
+		ERR("Can't remap Tx DMA registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe1_err_out;=0A=
+	}=0A=
+	=0A=
+  	lp->td_ring =3D (rc32355_dma_desc_t*)kmalloc(TD_RING_SIZE + =
RD_RING_SIZE, GFP_KERNEL);=0A=
+  	=0A=
+	if (!lp->td_ring) {=0A=
+		ERR("Can't allocate descriptors\n");=0A=
+		retval =3D -ENOMEM;=0A=
+		goto probe1_err_out;=0A=
+	}=0A=
+	=0A=
+  	dma_cache_inv((unsigned long)(lp->td_ring), TD_RING_SIZE + =
RD_RING_SIZE);=0A=
+	=0A=
+  	/* now convert TD_RING pointer to KSEG1 */=0A=
+  	lp->td_ring =3D (rc32355_dma_desc_t *)KSEG1ADDR(lp->td_ring);=0A=
+  	lp->rd_ring =3D &lp->td_ring[RC32355_NUM_TDS];=0A=
+	=0A=
+  	spin_lock_init(&lp->lock);=0A=
+	dev->base_addr =3D bif->iobase;=0A=
+	/* just use the rx dma irq */=0A=
+	=0A=
+	dev->irq =3D bif->rx_dma_irq; =0A=
+	dev->priv =3D lp;=0A=
+  	dev->open =3D rc32355_open;=0A=
+  	dev->stop =3D rc32355_close;=0A=
+  	dev->hard_start_xmit =3D rc32355_send_packet;=0A=
+  	dev->get_stats	=3D rc32355_get_stats;=0A=
+  	dev->set_multicast_list =3D &rc32355_multicast_list;=0A=
+  	dev->tx_timeout =3D rc32355_tx_timeout;=0A=
+  	dev->watchdog_timeo =3D RC32355_TX_TIMEOUT;=0A=
+	=0A=
+	lp->rx_tasklet =3D kmalloc(sizeof(struct tasklet_struct), =
GFP_KERNEL);=0A=
+	tasklet_init(lp->rx_tasklet, rc32355_rx_tasklet, (unsigned =
long)dev);=0A=
+	lp->tx_tasklet =3D kmalloc(sizeof(struct tasklet_struct), =
GFP_KERNEL);=0A=
+	tasklet_init(lp->tx_tasklet, rc32355_tx_tasklet, (unsigned =
long)dev);=0A=
+	=0A=
+	=0A=
+#ifdef RC32355_PROC_DEBUG=0A=
+  	lp->ps =3D create_proc_read_entry ("net/rc32355", 0, NULL,=0A=
+					 rc32355_read_proc, dev);=0A=
+#endif=0A=
+	=0A=
+	=0A=
+	if ((err =3D register_netdev(dev))) {=0A=
+		printk(KERN_ERR "rc32355 ethernet. Cannot register net device %d\n", =
err);=0A=
+		free_netdev(dev);=0A=
+		retval =3D -EINVAL;=0A=
+		goto probe1_err_out;=0A=
+	}=0A=
+	=0A=
+	INFO("HW Address ");=0A=
+  	for (i =3D 0; i < 6; i++) =0A=
+	{=0A=
+		printk("%2.2x", dev->dev_addr[i]);=0A=
+		if (i<5)=0A=
+			printk(":");=0A=
+	}=0A=
+  	printk("\n");=0A=
+	INFO("Rx IRQ %d, Tx IRQ %d\n", bif->rx_dma_irq, bif->tx_dma_irq);=0A=
+	=0A=
+	/* Fill in the fields of the device structure with ethernet values. =
*/=0A=
+  	ether_setup(dev);=0A=
+  	return 0;=0A=
+	=0A=
+ probe1_err_out:=0A=
+  	rc32355_cleanup_module();=0A=
+  	ERR(__FUNCTION__ " failed.  Returns %d\n", retval);=0A=
+  	return retval;=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Open/initialize the RC32355 controller.=0A=
+ *=0A=
+ * This routine should set everything up anew at each open, even=0A=
+ *  registers that "should" only need to be set once at boot, so =
that=0A=
+ *  there is non-reboot way to recover if something goes wrong.=0A=
+ */=0A=
+static int rc32355_open(struct net_device *dev)=0A=
+{=0A=
+	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+	=0A=
+    	/*=0A=
+	 * Initialize=0A=
+	 */=0A=
+  	if (rc32355_init(dev)) {=0A=
+		ERR("Error: cannot open the Ethernet device\n");=0A=
+    		return -EAGAIN;=0A=
+  	}=0A=
+	=0A=
+	/*=0A=
+	 * Install the interrupt handler that handles the dma Done and=0A=
+	 * Finished Events.=0A=
+	 */=0A=
+    	if (request_irq(lp->rx_irq, &rc32355_rx_dma_interrupt,=0A=
+			SA_SHIRQ | SA_INTERRUPT,=0A=
+			"rc32355 ethernet Rx", dev)) {=0A=
+		=0A=
+    		ERR(__FUNCTION__ ": unable to get Rx DMA IRQ %d\n", =
lp->rx_irq);=0A=
+		return -EAGAIN;=0A=
+  	}=0A=
+  	if (request_irq(lp->tx_irq, &rc32355_tx_dma_interrupt,=0A=
+			SA_SHIRQ | SA_INTERRUPT,=0A=
+			"rc32355 ethernet Tx", dev)) {=0A=
+		ERR(__FUNCTION__ ": unable to get Tx DMA IRQ %d\n", lp->tx_irq);=0A=
+    		free_irq(lp->rx_irq, dev);=0A=
+		return -EAGAIN;=0A=
+  	}=0A=
+	=0A=
+  	/* Install handler for overrun error. */=0A=
+  	if (request_irq(lp->ovr_irq, &rc32355_ovr_interrupt,=0A=
+			SA_SHIRQ | SA_INTERRUPT,=0A=
+			"rc32355 ethernet Overflow", dev)) {=0A=
+		ERR(__FUNCTION__ ": unable to get OVR IRQ %d\n",	lp->ovr_irq);=0A=
+    		free_irq(lp->rx_irq, dev);=0A=
+    		free_irq(lp->tx_irq, dev);=0A=
+		return -EAGAIN;=0A=
+  	}=0A=
+	=0A=
+  	/* Install handler for underflow error. */=0A=
+	if (request_irq(lp->und_irq, &rc32355_und_interrupt,=0A=
+			SA_SHIRQ | SA_INTERRUPT,=0A=
+			"rc32355 ethernet Underflow", dev)) {=0A=
+		ERR(__FUNCTION__ ": unable to get UND IRQ %d\n",=0A=
+		    lp->und_irq);=0A=
+		free_irq(lp->rx_irq, dev);=0A=
+		free_irq(lp->tx_irq, dev);=0A=
+		free_irq(lp->ovr_irq, dev);=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+	=0A=
+  	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+/*=0A=
+ * Close the RC32355 device=0A=
+ */=0A=
+static int rc32355_close(struct net_device *dev)=0A=
+{=0A=
+  	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+  	u32 tmp;=0A=
+	=0A=
+	/*=0A=
+	 * Disable interrupts=0A=
+	 */=0A=
+  	disable_irq(lp->rx_irq);=0A=
+  	disable_irq(lp->tx_irq);=0A=
+	disable_irq(lp->ovr_irq);=0A=
+    	disable_irq(lp->und_irq);=0A=
+	=0A=
+  	tmp =3D local_readl(&lp->tx_dma_regs->dmasm);=0A=
+  	tmp =3D tmp | DMAS_F | DMAS_E;=0A=
+  	local_writel(tmp, &lp->tx_dma_regs->dmasm);=0A=
+	=0A=
+  	tmp =3D local_readl(&lp->rx_dma_regs->dmasm);=0A=
+	tmp =3D tmp | DMAS_D | DMAS_H | DMAS_E;=0A=
+	local_writel(tmp, &lp->rx_dma_regs->dmasm);=0A=
+	=0A=
+  	free_irq(lp->rx_irq, dev);=0A=
+  	free_irq(lp->tx_irq, dev);=0A=
+  	free_irq(lp->ovr_irq, dev);=0A=
+    	free_irq(lp->und_irq, dev);	=0A=
+=0A=
+  	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+/* transmit packet */=0A=
+static int rc32355_send_packet(struct sk_buff *skb, struct net_device =
*dev)=0A=
+{=0A=
+	struct rc32355_local	*lp =3D (struct rc32355_local *)dev->priv;=0A=
+	unsigned long 	flags;=0A=
+	u32			length;=0A=
+	volatile rc32355_dma_desc_t * td;=0A=
+	=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+	=0A=
+	td =3D &lp->td_ring[lp->tx_chain_tail];=0A=
+	=0A=
+	//stop queue when full, drop pkts if queue already full=0A=
+	if(lp->tx_count >=3D (RC32355_NUM_TDS - 2)){=0A=
+		lp->tx_full =3D 1;=0A=
+		=0A=
+		if(lp->tx_count =3D=3D (RC32355_NUM_TDS - 2)) {=0A=
+			//this pkt is about to fill the queue=0A=
+			//ERR("Tx Ring now full, queue stopped.\n");			=0A=
+			netif_stop_queue(dev);=0A=
+		}else{=0A=
+			//this pkt cannot be added to the full queue=0A=
+			//ERR("Tx ring full, packet dropped\n");=0A=
+			lp->stats.tx_dropped++;=0A=
+			dev_kfree_skb_any(skb);=0A=
+			spin_unlock_irqrestore(&lp->lock, flags);=0A=
+			return 1;=0A=
+		}	   =0A=
+	}	   =0A=
+	lp->tx_count ++;=0A=
+	=0A=
+	/* make sure payload gets written to memory */=0A=
+	dma_cache_wback_inv((unsigned long)skb->data, skb->len);=0A=
+	=0A=
+	if (lp->tx_skb[lp->tx_chain_tail] !=3D NULL)=0A=
+		dev_kfree_skb_any(lp->tx_skb[lp->tx_chain_tail]);=0A=
+	=0A=
+	lp->tx_skb[lp->tx_chain_tail] =3D skb;=0A=
+	=0A=
+	length =3D skb->len; =0A=
+	=0A=
+	//Setup the transmit descriptor.=0A=
+	td->curr_addr =3D CPHYSADDR(skb->data);=0A=
+	=0A=
+	/* Using the NDPTR to handl the DMA Race Condition */=0A=
+	if(local_readl(&(lp->tx_dma_regs->dmandptr)) =3D=3D 0) {=0A=
+		if( lp->tx_chain_status =3D=3D empty ) {=0A=
+			td->cmdstat =3D DMA_COUNT(length) |DMADESC_COF |DMADESC_IOF; /* =
Update tail */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32355_TDS_MASK; =
/* Move tail */=0A=
+			local_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR */=0A=
+			lp->tx_chain_head =3D lp->tx_chain_tail; /* Move head to tail */=0A=
+		}=0A=
+		else=0A=
+		{=0A=
+			td->cmdstat =3D DMA_COUNT(length) |DMADESC_COF|DMADESC_IOF; /* =
Update tail */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32355_TDS_MASK].cmdstat &=3D  =
~(DMADESC_COF); /* Update prev */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32355_TDS_MASK].link =3D  =
CPHYSADDR(td); /* Link prev to this one */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32355_TDS_MASK; =
/* Move tail */=0A=
+			local_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR */=0A=
+			lp->tx_chain_head =3D lp->tx_chain_tail;  /* Move head to tail =
*/=0A=
+			lp->tx_chain_status =3D empty;  =0A=
+		}=0A=
+	}=0A=
+	else=0A=
+	{=0A=
+		if( lp->tx_chain_status =3D=3D empty ) {=0A=
+			td->cmdstat =3D DMA_COUNT(length) |DMADESC_COF|DMADESC_IOF; /* =
Update tail */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32355_TDS_MASK; =
/* Move tail */=0A=
+			lp->tx_chain_status =3D filled;		=0A=
+		}=0A=
+		else {=0A=
+			td->cmdstat =3D DMA_COUNT(length) |DMADESC_COF |DMADESC_IOF; /* =
Update tail */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32355_TDS_MASK].cmdstat &=3D  =
~(DMADESC_COF);   /* Update prev */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32355_TDS_MASK].link =3D  =
CPHYSADDR(td);	 /* Link prev to this one*/=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32355_TDS_MASK; =
/* Move tail */=0A=
+		}		=0A=
+	}=0A=
+	=0A=
+	=0A=
+	dev->trans_start =3D jiffies;=0A=
+	=0A=
+     	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+	=0A=
+  	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+/* Ethernet Rx Overflow interrupt */=0A=
+static irqreturn_t rc32355_ovr_interrupt(int irq, void *dev_id, struct =
pt_regs * regs)=0A=
+{=0A=
+  	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+  	struct rc32355_local *lp;=0A=
+  	unsigned int i;=0A=
+	irqreturn_t retval =3D IRQ_NONE;=0A=
+	=0A=
+	ASSERT(dev !=3D NULL);=0A=
+	=0A=
+  	lp =3D (struct rc32355_local *)dev->priv;=0A=
+	netif_stop_queue(dev);=0A=
+	=0A=
+	//ERR("Rx overflow\n");=0A=
+	=0A=
+  	spin_lock(&lp->lock);=0A=
+	=0A=
+  	//clear OVR int (sticky bit)=0A=
+  	i =3D local_readl(&lp->eth_regs->ethintfc);=0A=
+  	i &=3D ~ETHERDMA_IN_OVR;=0A=
+  	local_writel(i, &lp->eth_regs->ethintfc);=0A=
+	=0A=
+  	// Restart interface=0A=
+  	rc32355_restart(dev);	  =0A=
+	retval =3D IRQ_HANDLED;=0A=
+  	spin_unlock(&lp->lock);=0A=
+	=0A=
+	return retval;=0A=
+	=0A=
+}=0A=
+=0A=
+/* Ethernet Tx Underflow interrupt */=0A=
+static irqreturn_t rc32355_und_interrupt(int irq, void *dev_id, struct =
pt_regs * regs)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+	struct rc32355_local *lp;=0A=
+	unsigned int i;=0A=
+	irqreturn_t retval =3D IRQ_NONE;=0A=
+	=0A=
+	ASSERT(dev !=3D NULL);=0A=
+	=0A=
+	printk(__FILE__" %d\n",__LINE__);=0A=
+	netif_stop_queue(dev);	=0A=
+	lp =3D (struct rc32355_local *)dev->priv;=0A=
+	=0A=
+	//ERR("Tx underflow - i/f reset\n");=0A=
+	spin_lock(&lp->lock);=0A=
+	=0A=
+	i =3D local_readl(&lp->eth_regs->ethintfc);=0A=
+  	i &=3D ~ETHERDMA_OUT_UND;=0A=
+	local_writel(i, &lp->eth_regs->ethintfc);=0A=
+	=0A=
+	/* Restart interface */=0A=
+	rc32355_restart(dev);     =0A=
+	retval =3D IRQ_HANDLED;=0A=
+	spin_unlock(&lp->lock);=0A=
+	return retval;=0A=
+	=0A=
+}=0A=
+=0A=
+/* Ethernet Rx DMA interrupt */=0A=
+static irqreturn_t=0A=
+rc32355_rx_dma_interrupt(int irq, void *dev_id, struct pt_regs * =
regs)=0A=
+{=0A=
+  	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+  	struct rc32355_local *lp;=0A=
+  	volatile u32 dmas;=0A=
+	irqreturn_t retval =3D IRQ_NONE;=0A=
+	=0A=
+	ASSERT(dev !=3D NULL);=0A=
+	=0A=
+  	lp =3D (struct rc32355_local *)dev->priv;=0A=
+	=0A=
+  	spin_lock(&lp->lock);=0A=
+	/* Mask D H & E bit in Rx DMA so that no interrupts are generated. =
The rx_tasklet=0A=
+	   will take care of un-masking them.	*/=0A=
+	=0A=
+	local_writel(local_readl(&lp->rx_dma_regs->dmasm) | DMAS_D | DMAS_E =
|DMAS_H, &lp->rx_dma_regs->dmasm);=0A=
+	=0A=
+  	dmas =3D local_readl(&lp->rx_dma_regs->dmas);=0A=
+	/* If DMA has halted, deal with it immediately. Else, process the =
packets in tasklet */=0A=
+	if(dmas & DMAS_H)=0A=
+	  rc32355_restart(dev);     =0A=
+	//		lp->rx_tasklet->func((unsigned long)dev);=0A=
+	=0A=
+  	else if(dmas & (DMAS_D|DMAS_E)) {=0A=
+		tasklet_hi_schedule(lp->rx_tasklet);=0A=
+		if(dmas & DMAS_E) {=0A=
+			lp->stats.rx_errors++;=0A=
+		}=0A=
+  	}=0A=
+	retval =3D IRQ_HANDLED;=0A=
+  	spin_unlock(&lp->lock);=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32355_rx_tasklet(unsigned long rx_data_dev)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)rx_data_dev;	=0A=
+  	struct rc32355_local* lp =3D (struct rc32355_local *)dev->priv;=0A=
+  	volatile rc32355_dma_desc_t*  rd =3D =
&lp->rd_ring[lp->rx_next_done];=0A=
+  	struct sk_buff *skb, *skb_new;=0A=
+	u8* pkt_buf;=0A=
+  	u32 devcs, count, pkt_len;=0A=
+  	unsigned long 	flags;=0A=
+	volatile u32 dmas;=0A=
+	=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+	=0A=
+  	/* keep going while we have received into more descriptors */=0A=
+        while ( (count =3D RC32355_RBSIZE - =
(u32)DMA_COUNT(rd->cmdstat)) !=3D 0)=0A=
+    	{=0A=
+		=0A=
+		/* init the var. used for the later operations within the while loop =
*/=0A=
+		skb_new =3D NULL;=0A=
+		devcs =3D rd->devcs;=0A=
+		pkt_len =3D RCVPKT_LENGTH(devcs);=0A=
+		skb =3D lp->rx_skb[lp->rx_next_done];=0A=
+		=0A=
+		//count =3D RC32355_RBSIZE - (u32)DMA_COUNT(rd->cmdstat);=0A=
+		=0A=
+		if( count !=3D pkt_len) {=0A=
+			/*=0A=
+			 * Due to a bug in rc32355 processor, the packet length=0A=
+			 * given by devcs field and count field sometimes differ.=0A=
+			 * If that is the case, report Error.=0A=
+			 */				=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+			=0A=
+		}=0A=
+		else if (count < 64) {=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+		} =0A=
+		else if ((devcs & ( ETHERDMA_IN_LD)) !=3D	ETHERDMA_IN_LD) {=0A=
+			/* Check that this is a whole packet */=0A=
+			/* WARNING: DMA_FD bit incorrectly set in rc32355 (errata ref #077) =
*/=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+		} =0A=
+		else if (devcs & ETHERDMA_IN_ROK) {=0A=
+					=0A=
+			/* must be the (first and) last descriptor then */=0A=
+			pkt_buf =3D (u8*)lp->rx_skb[lp->rx_next_done]->data;=0A=
+			=0A=
+			/* invalidate the cache before copying the buffer */=0A=
+			dma_cache_inv((unsigned long)pkt_buf, (pkt_len-4));=0A=
+			=0A=
+			/* Malloc up new buffer. */					  =0A=
+			skb_new =3D dev_alloc_skb(RC32355_RBSIZE + 2);							=0A=
+			=0A=
+			if (skb_new !=3D NULL) {=0A=
+							=0A=
+				skb_new->dev =3D dev;=0A=
+				=0A=
+				/* Make room */=0A=
+				skb_put(skb_new, (pkt_len-4));		    =0A=
+				=0A=
+				eth_copy_and_sum(skb_new, skb->data, pkt_len-4, 0);=0A=
+				=0A=
+				skb_new->protocol =3D eth_type_trans(skb_new, dev);=0A=
+				=0A=
+				/* pass the packet to upper layers */=0A=
+				netif_rx(skb_new);=0A=
+				=0A=
+				dev->last_rx =3D jiffies;=0A=
+				lp->stats.rx_packets++;=0A=
+				lp->stats.rx_bytes +=3D (pkt_len-4);=0A=
+				=0A=
+				if (IS_RCV_MP(devcs))=0A=
+					lp->stats.multicast++;=0A=
+			}=0A=
+			else {=0A=
+				//ERR("no memory, dropping rx packet.\n");=0A=
+				lp->stats.rx_errors++;				=0A=
+				lp->stats.rx_dropped++;				=0A=
+			}=0A=
+			=0A=
+		}				=0A=
+		else  { // Not O.K!=0A=
+			/* This should only happen if we enable accepting broken packets =
*/=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+			=0A=
+			/* added statistics counters */=0A=
+			if (IS_RCV_CRC_ERR(devcs)) {=0A=
+				DBG(2, "RX CRC error\n");=0A=
+				lp->stats.rx_crc_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_LOR_ERR(devcs)) {=0A=
+				DBG(2, "RX LOR error\n");=0A=
+				lp->stats.rx_length_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_LE_ERR(devcs)) {=0A=
+				DBG(2, "RX LE error\n");=0A=
+				lp->stats.rx_length_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_OVR_ERR(devcs)) {=0A=
+				/*=0A=
+				 * The overflow errors are handled through=0A=
+				 * an interrupt handler.=0A=
+				 */=0A=
+				=0A=
+				lp->stats.rx_over_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_CV_ERR(devcs)) {=0A=
+				/* code violation */=0A=
+				DBG(2, "RX CV error\n");=0A=
+				lp->stats.rx_errors++;					=0A=
+			}=0A=
+			else if (IS_RCV_CES_ERR(devcs)) {=0A=
+				DBG(2, "RX Preamble error\n");=0A=
+				lp->stats.rx_errors++;					=0A=
+			}=0A=
+		}=0A=
+		=0A=
+		/* Restore current descriptor */=0A=
+		rd->devcs =3D 0;=0A=
+		rd->curr_addr =3D CPHYSADDR(skb->data);=0A=
+		rd->cmdstat =3D DMA_COUNT(RC32355_RBSIZE) |DMADESC_COD =
|DMADESC_IOD;=0A=
+		=0A=
+		lp->rd_ring[(lp->rx_next_done-1)& RC32355_RDS_MASK].cmdstat &=3D  =
~(DMADESC_COD); 	=0A=
+		=0A=
+		lp->rx_next_done =3D (lp->rx_next_done + 1) & RC32355_RDS_MASK;=0A=
+		rd =3D &lp->rd_ring[lp->rx_next_done];=0A=
+		=0A=
+	}	=0A=
+	=0A=
+        dmas =3D local_readl(&lp->rx_dma_regs->dmas);=0A=
+        if(dmas & DMAS_H) {=0A=
+		rc32355_start_rx(lp,rd);=0A=
+	}=0A=
+        local_writel(~dmas, &lp->rx_dma_regs->dmas);=0A=
+    	/* Enable D bit in Rx DMA */=0A=
+  	local_writel(local_readl(&lp->rx_dma_regs->dmasm) & ~(DMAS_D | =
DMAS_E | DMAS_H), &lp->rx_dma_regs->dmasm); =0A=
+   	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+/* Ethernet Tx DMA interrupt */=0A=
+static irqreturn_t=0A=
+rc32355_tx_dma_interrupt(int irq, void *dev_id, struct pt_regs * =
regs)=0A=
+{=0A=
+  	struct net_device	*dev =3D (struct net_device *)dev_id;=0A=
+  	struct rc32355_local	*lp;=0A=
+  	volatile u32			dmas;=0A=
+	irqreturn_t retval =3D IRQ_NONE;=0A=
+	=0A=
+	ASSERT(dev !=3D NULL);=0A=
+   	lp =3D (struct rc32355_local *)dev->priv;=0A=
+	=0A=
+  	spin_lock(&lp->lock);=0A=
+	/* Mask F & E bit in Tx DMA */=0A=
+	local_writel(local_readl(&lp->tx_dma_regs->dmasm) | DMAS_F |DMAS_E, =
&lp->tx_dma_regs->dmasm);=0A=
+	=0A=
+	=0A=
+  	dmas =3D local_readl(&lp->tx_dma_regs->dmas);=0A=
+  	if (dmas & DMAS_F){=0A=
+		tasklet_hi_schedule(lp->tx_tasklet);=0A=
+	}=0A=
+  	if (dmas & DMAS_E)=0A=
+    		ERR(__FUNCTION__ ": DMA error\n");=0A=
+	=0A=
+	=0A=
+  	local_writel(~dmas, &lp->tx_dma_regs->dmas);=0A=
+	=0A=
+   	if(lp->tx_chain_status =3D=3D filled && =
(local_readl(&(lp->tx_dma_regs->dmandptr)) =3D=3D 0)) {=0A=
+		local_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr));			=0A=
+		lp->tx_chain_status =3D empty;=0A=
+		lp->tx_chain_head =3D lp->tx_chain_tail;=0A=
+	}=0A=
+	=0A=
+	retval =3D IRQ_HANDLED;=0A=
+  	spin_unlock(&lp->lock);=0A=
+	return retval;=0A=
+	=0A=
+}=0A=
+=0A=
+static void rc32355_tx_tasklet(unsigned long tx_data_dev)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)tx_data_dev;	=0A=
+  	struct rc32355_local* lp =3D (struct rc32355_local *)dev->priv;=0A=
+  	volatile rc32355_dma_desc_t* td =3D =
&lp->td_ring[lp->tx_next_done];=0A=
+    	u32			dmas, devcs;=0A=
+    	unsigned long 	flags;=0A=
+	=0A=
+	=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+	=0A=
+  	dmas =3D local_readl(&lp->tx_dma_regs->dmas);=0A=
+	=0A=
+  	//process all desc that are done=0A=
+  	while(IS_DMA_FINISHED(td->cmdstat)) {=0A=
+=0A=
+  		if (	lp->tx_full =3D=3D 1){=0A=
+			netif_wake_queue(dev);=0A=
+			lp->tx_full =3D 0;=0A=
+		}=0A=
+		=0A=
+		devcs =3D lp->td_ring[lp->tx_next_done].devcs;    =0A=
+		if ((devcs & (ETHERDMA_OUT_FD | ETHERDMA_OUT_LD)) !=3D =
(ETHERDMA_OUT_FD | ETHERDMA_OUT_LD)) {=0A=
+			lp->stats.tx_errors++;=0A=
+	      		lp->stats.tx_dropped++;				=0A=
+			=0A=
+	      		/* should never happen */=0A=
+	      		DBG(1, __FUNCTION__ ": split tx ignored\n");=0A=
+	    	} =0A=
+		else if (IS_TX_TOK(devcs)) {=0A=
+			=0A=
+	      		/* transmit OK */=0A=
+	      		lp->stats.tx_packets++;=0A=
+	    	} =0A=
+		else {=0A=
+			=0A=
+	      		lp->stats.tx_dropped++;				=0A=
+			=0A=
+		      	/* underflow */=0A=
+		  	if (IS_TX_UND_ERR(devcs)) =0A=
+				lp->stats.tx_fifo_errors++;=0A=
+			=0A=
+		      	/* oversized frame */=0A=
+		      	if (IS_TX_OF_ERR(devcs))=0A=
+				lp->stats.tx_aborted_errors++;=0A=
+			=0A=
+		      	/* excessive deferrals */=0A=
+		      	if (IS_TX_ED_ERR(devcs))=0A=
+				lp->stats.tx_carrier_errors++;=0A=
+			=0A=
+		      	/* collisions: medium busy */=0A=
+		      	if (IS_TX_EC_ERR(devcs))=0A=
+				lp->stats.collisions++;=0A=
+			=0A=
+		      	/* late collision */=0A=
+		      	if (IS_TX_LC_ERR(devcs))=0A=
+				lp->stats.tx_window_errors++;=0A=
+			=0A=
+    		}=0A=
+		=0A=
+	    	/* We must always free the original skb */=0A=
+	    	if (lp->tx_skb[lp->tx_next_done] !=3D NULL) {=0A=
+			dev_kfree_skb_irq(lp->tx_skb[lp->tx_next_done]);=0A=
+	      		lp->tx_skb[lp->tx_next_done] =3D NULL;=0A=
+	    	}=0A=
+		=0A=
+		lp->td_ring[lp->tx_next_done].cmdstat =3D DMADESC_IOF;=0A=
+		lp->td_ring[lp->tx_next_done].devcs =3D ETHERDMA_OUT_FD | =
ETHERDMA_OUT_LD;=0A=
+		lp->td_ring[lp->tx_next_done].link =3D 0;=0A=
+		lp->td_ring[lp->tx_next_done].curr_addr =3D 0;=0A=
+	    	lp->tx_count --;=0A=
+		=0A=
+	    	/* go on to next transmission */=0A=
+	    	lp->tx_next_done =3D (lp->tx_next_done + 1) & =
RC32355_TDS_MASK;=0A=
+	    	td =3D &lp->td_ring[lp->tx_next_done];=0A=
+		=0A=
+  	}=0A=
+	=0A=
+   	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+  	/* Enable F bit in Tx DMA */=0A=
+  	local_writel(local_readl(&lp->tx_dma_regs->dmasm) & ~(DMAS_F | =
DMAS_E), &lp->tx_dma_regs->dmasm); =0A=
+	=0A=
+}	=0A=
+=0A=
+/*=0A=
+ * Get the current statistics.=0A=
+ * This may be called with the device open or closed.=0A=
+ */=0A=
+static struct net_device_stats *=0A=
+rc32355_get_stats(struct net_device *dev)=0A=
+{=0A=
+  	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+	=0A=
+	return &lp->stats;=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Set or clear the multicast filter for this adaptor.=0A=
+ */=0A=
+static void=0A=
+rc32355_multicast_list(struct net_device *dev)=0A=
+{   	=0A=
+	/* changed to listen to broadcasts always and to treat	*/=0A=
+  	/*	   IFF bits independantly	*/=0A=
+  	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+  	unsigned long flags;=0A=
+  	u32 recognise =3D ETHERARC_AB; 			/* always accept broadcasts */=0A=
+	=0A=
+  	if (dev->flags & IFF_PROMISC) 				/* set promiscuous mode */=0A=
+    		recognise |=3D ETHERARC_PRO;=0A=
+	=0A=
+  	if ((dev->flags & IFF_ALLMULTI) || (dev->mc_count > 15))=0A=
+    		recognise |=3D ETHERARC_AM;		  	/* all multicast & bcast */=0A=
+	=0A=
+  	else if (dev->mc_count > 0) {=0A=
+		DBG(2, __FUNCTION__ ": mc_count %d\n", dev->mc_count);=0A=
+		=0A=
+    		recognise |=3D ETHERARC_AM;		  	/* for the time being */=0A=
+  	}=0A=
+	=0A=
+  	spin_lock_irqsave(&lp->lock, flags);=0A=
+	=0A=
+  	local_writel(recognise, &lp->eth_regs->etharc);=0A=
+	=0A=
+  	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+static void=0A=
+rc32355_tx_timeout(struct net_device *dev)=0A=
+{=0A=
+  	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+  	unsigned long flags;=0A=
+	=0A=
+  	spin_lock_irqsave(&lp->lock, flags);=0A=
+	printk(__FILE__" %d\n",__LINE__);=0A=
+  	rc32355_restart(dev);=0A=
+  	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Initialize the RC32355 ethernet controller.=0A=
+ */=0A=
+static int rc32355_init(struct net_device *dev)=0A=
+{=0A=
+	struct rc32355_local *lp =3D (struct rc32355_local *)dev->priv;=0A=
+	int i, j;=0A=
+	=0A=
+	/* Disable DMA */       =0A=
+	rc32355_abort_tx(dev);=0A=
+	rc32355_abort_rx(dev); =0A=
+	=0A=
+	/* reset ethernet logic */ =0A=
+	local_writel(0, &lp->eth_regs->ethintfc);=0A=
+	while((local_readl(&lp->eth_regs->ethintfc) & ETHERINTFC_RIP))=0A=
+		dev->trans_start =3D jiffies;		=0A=
+	/* Enable Ethernet Interface */ =0A=
+	local_writel(ETHERINTFC_EN, &lp->eth_regs->ethintfc); =0A=
+	=0A=
+	tasklet_disable(lp->rx_tasklet);=0A=
+	tasklet_disable(lp->tx_tasklet);=0A=
+	=0A=
+	/* Initialize the transmit Descriptors */=0A=
+	for (i =3D 0; i < RC32355_NUM_TDS; i++) {=0A=
+    		lp->td_ring[i].cmdstat =3D DMADESC_IOF;=0A=
+    		lp->td_ring[i].devcs =3D ETHERDMA_OUT_FD | ETHERDMA_OUT_LD;=0A=
+    		lp->td_ring[i].curr_addr =3D 0;=0A=
+    		lp->td_ring[i].link =3D 0;=0A=
+    		if (lp->tx_skb[i] !=3D NULL) {=0A=
+			/* free dangling skb */=0A=
+      			dev_kfree_skb_any(lp->tx_skb[i]);=0A=
+      			lp->tx_skb[i] =3D NULL;=0A=
+    		}=0A=
+	}=0A=
+    	lp->tx_next_done =3D lp->tx_chain_head =3D lp->tx_chain_tail =3D =
=0A=
+    		lp->tx_count =3D lp->tx_full =3D 0;=0A=
+	lp->	tx_chain_status =3D empty;=0A=
+	=0A=
+	/*=0A=
+	 * Initialize the receive descriptors so that they=0A=
+	 * become a circular linked list, ie. let the last=0A=
+	 * descriptor point to the first again.=0A=
+	 */=0A=
+  	for (i=3D0; i<RC32355_NUM_RDS; i++) {=0A=
+		struct sk_buff *skb =3D lp->rx_skb[i];=0A=
+		=0A=
+		if (lp->rx_skb[i] =3D=3D NULL) {=0A=
+			skb =3D dev_alloc_skb(RC32355_RBSIZE + 2);=0A=
+			if (skb =3D=3D NULL) {=0A=
+				//ERR("No memory in the system\n");=0A=
+				for (j =3D 0; j < RC32355_NUM_RDS; j ++)=0A=
+					if (lp->rx_skb[j] !=3D NULL) =0A=
+						dev_kfree_skb_any(lp->rx_skb[j]);=0A=
+				=0A=
+				return 1;=0A=
+			}=0A=
+			else=0A=
+			{=0A=
+				skb->dev =3D dev;=0A=
+				lp->rx_skb[i] =3D skb;=0A=
+			}=0A=
+		}=0A=
+		lp->rd_ring[i].cmdstat =3D	DMADESC_IOD | =
DMA_COUNT(RC32355_RBSIZE);=0A=
+		lp->rd_ring[i].devcs =3D 0;=0A=
+		lp->rd_ring[i].curr_addr =3D CPHYSADDR(skb->data);=0A=
+		lp->rd_ring[i].link =3D CPHYSADDR(&lp->rd_ring[i+1]);=0A=
+  	}=0A=
+    	/* loop back */=0A=
+  	lp->rd_ring[RC32355_NUM_RDS-1].link =3D =
CPHYSADDR(&lp->rd_ring[0]);=0A=
+    	lp->rx_next_done   =3D 0;=0A=
+	=0A=
+#ifdef RX_DMA_CHAIN				=0A=
+  	lp->rd_ring[RC32355_NUM_RDS-1].cmdstat |=3D DMADESC_COD;=0A=
+  	lp->rx_chain_head =3D 0;=0A=
+  	lp->rx_chain_tail =3D 0;=0A=
+  	lp->rx_chain_status =3D empty;=0A=
+#endif=0A=
+	=0A=
+	local_writel(0, &lp->rx_dma_regs->dmas);=0A=
+	/* Start Rx DMA */=0A=
+	rc32355_start_rx(lp, &lp->rd_ring[0]);=0A=
+	=0A=
+  	/* Enable F bit in Tx DMA */=0A=
+  	local_writel(local_readl(&lp->tx_dma_regs->dmasm) & ~(DMAS_F | =
DMAS_E), &lp->tx_dma_regs->dmasm); =0A=
+    	/* Enable D bit in Rx DMA */=0A=
+  	local_writel(local_readl(&lp->rx_dma_regs->dmasm) & ~(DMAS_D | =
DMAS_E), &lp->rx_dma_regs->dmasm); =0A=
+	=0A=
+	=0A=
+	/* Accept only packets destined for this Ethernet device address =
*/=0A=
+	local_writel(ETHERARC_AB, &lp->eth_regs->etharc); =0A=
+	=0A=
+	/* Set all Ether station address registers to their initial values */ =
=0A=
+	local_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal0); =0A=
+	local_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah0);=0A=
+	=0A=
+	local_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal1); =0A=
+	local_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah1);=0A=
+	=0A=
+	local_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal2); =0A=
+	local_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah2);=0A=
+	=0A=
+	local_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal3); =0A=
+	local_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah3); =0A=
+	=0A=
+	/* Frame Length Checking, Pad Enable, CRC Enable, Full Duplex set */ =
=0A=
+	local_writel( ETHERMAC2_PE | ETHERMAC2_CEN | ETHERMAC2_FD,=0A=
+		&lp->eth_regs->ethmac2);  =0A=
+	//ETHERMAC2_FLC	lp->duplex_mode	ETHERMAC2_FD, =0A=
+	=0A=
+	/* Back to back inter-packet-gap */ =0A=
+	local_writel(0x15, &lp->eth_regs->ethipgt); =0A=
+	/* Non - Back to back inter-packet-gap */ =0A=
+	local_writel(0x12, &lp->eth_regs->ethipgr); =0A=
+	=0A=
+	/* Management Clock Prescaler Divisor */=0A=
+	local_writel(((idt_cpu_freq)/MII_CLOCK+1) & ~1, =
&lp->eth_regs->ethmcp);	=0A=
+	=0A=
+	/* don't transmit until fifo contains 48b */=0A=
+	local_writel(48, &lp->eth_regs->ethfifott);=0A=
+	=0A=
+	local_writel(ETHERMAC1_RE, &lp->eth_regs->ethmac1);=0A=
+	=0A=
+	tasklet_enable(lp->rx_tasklet);=0A=
+	tasklet_enable(lp->tx_tasklet);=0A=
+	=0A=
+	netif_start_queue(dev);=0A=
+	=0A=
+	/* Enable Ethernet Interface */ =0A=
+	local_writel(ETHERINTFC_EN, &lp->eth_regs->ethintfc); =0A=
+	=0A=
+	=0A=
+	return 0; =0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32355_cleanup_module(void)=0A=
+{=0A=
+  	int i;=0A=
+	=0A=
+  	for (i =3D 0; rc32355_iflist[i].iobase; i++) {=0A=
+		struct rc32355_if_t * bif =3D &rc32355_iflist[i];=0A=
+    		if (bif->dev !=3D NULL) {=0A=
+			struct rc32355_local *lp =3D (struct rc32355_local =
*)bif->dev->priv;=0A=
+      			if (lp !=3D NULL) {=0A=
+				if (lp->eth_regs)=0A=
+					iounmap((void*)lp->eth_regs);=0A=
+				if (lp->rx_dma_regs)=0A=
+					iounmap((void*)lp->rx_dma_regs);=0A=
+				if (lp->tx_dma_regs)=0A=
+					iounmap((void*)lp->tx_dma_regs);=0A=
+				if (lp->td_ring)=0A=
+	  				kfree((void*)KSEG0ADDR(lp->td_ring));=0A=
+				=0A=
+#ifdef RC32355_PROC_DEBUG=0A=
+				if (lp->ps)=0A=
+	  				remove_proc_entry("net/rc32355", NULL);=0A=
+#endif=0A=
+				kfree(lp);=0A=
+      			}=0A=
+			=0A=
+      			unregister_netdev(bif->dev);=0A=
+			free_netdev(bif->dev);=0A=
+     			kfree(bif->dev);=0A=
+		}=0A=
+  	}=0A=
+}=0A=
+=0A=
+=0A=
+#ifndef MODULE=0A=
+=0A=
+static int __init rc32355_setup(char *options)=0A=
+{=0A=
+  	/* no options yet */=0A=
+  	return 1;=0A=
+}=0A=
+=0A=
+static int __init rc32355_setup_ethaddr(char *options)=0A=
+{=0A=
+  	memcpy(mac, options, 17);=0A=
+  	mac[17]=3D '\0';=0A=
+  	return 1;=0A=
+}=0A=
+=0A=
+__setup("rc3255eth=3D", rc32355_setup);=0A=
+=0A=
+__setup("ethaddr=3D", rc32355_setup_ethaddr);=0A=
+=0A=
+#endif /* !MODULE */=0A=
+=0A=
+module_init(rc32355_init_module);=0A=
+module_exit(rc32355_cleanup_module);=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/rc32355_eth.h =
idtlinux/drivers/net/rc32355_eth.h=0A=
--- linux-2.6.16-rc5/drivers/net/rc32355_eth.h	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/net/rc32355_eth.h	2006-03-09 16:26:05.000000000 =
-0800=0A=
@@ -0,0 +1,203 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Driver for the IDT RC32355 on-chip ethernet controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED=
.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#ifndef RC32355_H=0A=
+#define RC32355_H=0A=
+=0A=
+#include  <asm/idt-boards/rc32300/rc32355_eth.h> =0A=
+#include  <asm/idt-boards/rc32300/rc32355_dma.h> =0A=
+#include  <asm/idt-boards/rc32300/rc32355.h> =0A=
+=0A=
+=0A=
+#define RC32355_DEBUG	2=0A=
+#define RC32355_PROC_DEBUG=0A=
+=0A=
+#undef	RC32355_DEBUG=0A=
+#if 0=0A=
+#undef	RC32355_PROC_DEBUG=0A=
+#endif=0A=
+=0A=
+#ifdef RC32355_DEBUG=0A=
+=0A=
+/* use 0 for production, 1 for verification, >2 for debug */=0A=
+static int rc32355_debug =3D RC32355_DEBUG;=0A=
+=0A=
+/*ASSERT*/=0A=
+#define ASSERT(expr) \=0A=
+	if(!(expr)) {	\=0A=
+		printk( "Assertion failed! %s,%s,%s,line=3D%d\n",	\=0A=
+		#expr,__FILE__,__FUNCTION__,__LINE__);		}=0A=
+=0A=
+/*DBG*/=0A=
+#define DBG(lvl, format, arg...) if (rc32355_debug > lvl) =
printk(KERN_INFO "%s: " format, dev->name , ## arg)=0A=
+#define ERR(format, arg...) printk(KERN_ERR "%s: " format, dev->name , =
## arg)=0A=
+#define WARN(format, arg...) printk(KERN_WARNING "%s: " format, =
dev->name , ## arg)		=0A=
+=0A=
+#else=0A=
+=0A=
+#define ASSERT(expr) do {} while (0)=0A=
+#define DBG(lvl, format, arg...) do {} while (0)=0A=
+#define ERR(format, arg...) do {} while (0)=0A=
+#define WARN(format, arg...) do {} while (0)=0A=
+=0A=
+#endif=0A=
+=0A=
+/* INFO */=0A=
+#define INFO(format, arg...) printk(KERN_INFO "%s: " format, dev->name =
, ## arg)=0A=
+=0A=
+=0A=
+=0A=
+#define ETH_DMA_RX_IRQ   GROUP1_IRQ_BASE + 9=0A=
+#define ETH_DMA_TX_IRQ   GROUP1_IRQ_BASE + 10=0A=
+#define ETH_RX_OVR_IRQ   GROUP3_IRQ_BASE + 22=0A=
+#define ETH_TX_UND_IRQ   GROUP3_IRQ_BASE + 23=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+/* Index to functions, as function prototypes. */=0A=
+static int rc32355_open(struct net_device *dev);=0A=
+static int rc32355_send_packet(struct sk_buff *skb, struct net_device =
*dev);=0A=
+//static void rc32355_mii_handler(unsigned long data);=0A=
+static irqreturn_t rc32355_ovr_interrupt(int irq, void *dev_id,=0A=
+					 struct pt_regs * regs);=0A=
+static irqreturn_t rc32355_und_interrupt(int irq, void *dev_id,=0A=
+					 struct pt_regs * regs);=0A=
+static irqreturn_t rc32355_rx_dma_interrupt(int irq, void *dev_id,=0A=
+					    struct pt_regs * regs);=0A=
+static irqreturn_t rc32355_tx_dma_interrupt(int irq, void *dev_id,=0A=
+					    struct pt_regs * regs);=0A=
+//static void rc32355_rx(struct net_device *dev);=0A=
+//static void rc32355_tx(struct net_device *dev);=0A=
+static int  rc32355_close(struct net_device *dev);=0A=
+static struct net_device_stats *rc32355_get_stats(struct net_device =
*dev);=0A=
+static void rc32355_multicast_list(struct net_device *dev);=0A=
+static int  rc32355_init(struct net_device *dev);=0A=
+static void rc32355_tx_timeout(struct net_device *dev);=0A=
+static void rc32355_tx_tasklet(unsigned long tx_data_dev);=0A=
+static void rc32355_rx_tasklet(unsigned long rx_data_dev);=0A=
+static void rc32355_cleanup_module(void);=0A=
+static int rc32355_probe(int port_num);=0A=
+int rc32355_init_module(void);=0A=
+=0A=
+=0A=
+/* the following must be powers of two */=0A=
+#define RC32355_NUM_RDS	 128    	/* number of receive descriptors =
*/=0A=
+#define RC32355_NUM_TDS	 128    	/* number of transmit descriptors =
*/=0A=
+=0A=
+#define RC32355_RBSIZE	 1536  		/* size of one resource buffer =3D =
Ether MTU */=0A=
+#define RC32355_RDS_MASK	 (RC32355_NUM_RDS-1)=0A=
+#define RC32355_TDS_MASK	 (RC32355_NUM_TDS-1)=0A=
+#define RD_RING_SIZE (RC32355_NUM_RDS * sizeof(rc32355_dma_desc_t))=0A=
+#define TD_RING_SIZE (RC32355_NUM_TDS * sizeof(rc32355_dma_desc_t))=0A=
+=0A=
+#define RC32355_TX_TIMEOUT HZ * 100=0A=
+=0A=
+enum status	{ filled,	empty};=0A=
+#define RX_DMA_CHAIN		=0A=
+=0A=
+=0A=
+/* Information that need to be kept for each board. */=0A=
+struct rc32355_local {=0A=
+	rc32355_eth_regs_t* eth_regs;=0A=
+	rc32355_dma_ch_t* rx_dma_regs;=0A=
+	rc32355_dma_ch_t* tx_dma_regs;=0A=
+ 	volatile rc32355_dma_desc_t * td_ring;  		/* transmit descriptor =
ring */ =0A=
+	volatile rc32355_dma_desc_t * rd_ring;  		/* receive descriptor ring  =
*/=0A=
+=0A=
+	struct sk_buff* tx_skb[RC32355_NUM_TDS]; 	/* skbuffs for pkt to trans =
*/=0A=
+	struct sk_buff* rx_skb[RC32355_NUM_RDS]; 	/* skbuffs for pkt to trans =
*/=0A=
+=0A=
+	struct tasklet_struct * rx_tasklet;=0A=
+	struct tasklet_struct * tx_tasklet;=0A=
+	=0A=
+	int	rx_next_done;=0A=
+	int	rx_chain_head;=0A=
+	int	rx_chain_tail;=0A=
+	enum status	rx_chain_status;=0A=
+	=0A=
+	int	tx_next_done;=0A=
+	int	tx_chain_head;=0A=
+	int	tx_chain_tail;=0A=
+	enum status	tx_chain_status;=0A=
+	int	tx_count;	   						/* current # of pkts waiting to be sent */=0A=
+	int	tx_full;=0A=
+	=0A=
+	struct timer_list    mii_phy_timer;=0A=
+	unsigned long duplex_mode;=0A=
+	=0A=
+	int	rx_irq;=0A=
+	int	tx_irq;=0A=
+	int  	ovr_irq;=0A=
+	int  	und_irq;		=0A=
+	=0A=
+	struct net_device_stats stats;=0A=
+	spinlock_t lock; 							/* Serialise access to device */=0A=
+	=0A=
+	/* debug /proc entry */=0A=
+	struct proc_dir_entry *ps;=0A=
+	int dma_halt_cnt;    u32 halt_tx_count;=0A=
+	int dma_collide_cnt; u32 collide_tx_count;=0A=
+	int dma_run_cnt;     u32 run_tx_count;=0A=
+	int dma_race_cnt;    u32 race_tx_count;=0A=
+};=0A=
+=0A=
+=0A=
+static inline void rc32355_abort_dma(struct net_device *dev, =
rc32355_dma_ch_t* ch)=0A=
+{=0A=
+	=0A=
+	if (readl(&ch->dmac) & DMAC_RUN) =0A=
+	{=0A=
+		writel(0x10, &ch->dmac); 	=0A=
+		while (!(readl(&ch->dmas) & DMAS_H))=0A=
+			dev->trans_start =3D jiffies;			=0A=
+		writel(0, &ch->dmas);  =0A=
+	}=0A=
+	=0A=
+	writel(0, &ch->dmadptr); =0A=
+	writel(0, &ch->dmandptr); =0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+#endif /* RC32355_H */=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/rc32365_eth.c =
idtlinux/drivers/net/rc32365_eth.c=0A=
--- linux-2.6.16-rc5/drivers/net/rc32365_eth.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/net/rc32365_eth.c	2006-03-09 16:26:06.000000000 =
-0800=0A=
@@ -0,0 +1,1300 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Driver for the IDT RC32365 on-chip ethernet controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/module.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/moduleparam.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/fcntl.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/ptrace.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/proc_fs.h>=0A=
+#include <linux/in.h>=0A=
+#include <linux/slab.h> =0A=
+#include <linux/string.h>=0A=
+#include <linux/delay.h>=0A=
+#include <linux/netdevice.h>=0A=
+#include <linux/etherdevice.h>=0A=
+#include <linux/skbuff.h>=0A=
+#include <linux/errno.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <asm/segment.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/dma.h>=0A=
+=0A=
+#include "rc32365_eth.h"=0A=
+=0A=
+#define CONFIG_IDT_NUM_ETH_PORTS 2=0A=
+=0A=
+#if CONFIG_IDT_NUM_ETH_PORTS > 2=0A=
+#error "Only 2 ports are available."=0A=
+#endif=0A=
+=0A=
+#define DRIVER_VERSION =0A=
+=0A=
+#define DRIVER_NAME "rc32365 Ethernet driver" DRIVER_VERSION=0A=
+=0A=
+=0A=
+#define STATION_ADDRESS_HIGH(dev) (((dev)->dev_addr[0] << 8) | \=0A=
+				   ((dev)->dev_addr[1]))=0A=
+#define STATION_ADDRESS_LOW(dev)  (((dev)->dev_addr[2] << 24) | \=0A=
+				   ((dev)->dev_addr[3] << 16) | \=0A=
+				   ((dev)->dev_addr[4] << 8)  | \=0A=
+				   ((dev)->dev_addr[5]))=0A=
+=0A=
+#define MII_CLOCK 1250000 			/* no more than 2.5MHz */=0A=
+static char mac0[18] =3D "08:00:06:05:40:01"; =0A=
+static char mac1[18] =3D "08:00:06:05:50:01"; =0A=
+=0A=
+MODULE_AUTHOR ("IDT Inc");=0A=
+MODULE_DESCRIPTION ("rc32365 Ethernet driver");=0A=
+MODULE_LICENSE("GPL");=0A=
+=0A=
+MODULE_PARM(mac0, "c18");=0A=
+MODULE_PARM_DESC(mac0, "MAC address for RC32365 ethernet port 0");=0A=
+MODULE_PARM(mac1, "c18");=0A=
+MODULE_PARM_DESC(mac1, "MAC address for RC32365 ethernet port 1");=0A=
+=0A=
+static void rc32365_remove(int);=0A=
+=0A=
+static struct rc32365_if_t =0A=
+{=0A=
+	struct net_device *dev;=0A=
+	char *name;=0A=
+	char* mac_str;=0A=
+	u32 iobase;=0A=
+	u32 rxdmabase;=0A=
+	u32 txdmabase;=0A=
+	int rx_dma_irq;=0A=
+	int tx_dma_irq;=0A=
+	int rx_ovr_irq;=0A=
+	int tx_und_irq;=0A=
+	u32 ipabmc;=0A=
+} rc32365_iflist[] =3D =0A=
+{=0A=
+	{=0A=
+		NULL,=0A=
+		"rc32365_eth0",=0A=
+		mac0, =0A=
+		ETH0_PhysicalAddress, =0A=
+		ETH0_RX_DMA_ADDR,=0A=
+		ETH0_TX_DMA_ADDR,=0A=
+		ETH0_DMA_RX_IRQ, =0A=
+		ETH0_DMA_TX_IRQ, =0A=
+		ETH0_RX_OVR_IRQ, =0A=
+		ETH0_TX_UND_IRQ,=0A=
+		ETH0_IPABMC_PhysicalAddress=0A=
+	},=0A=
+	{=0A=
+		NULL, =0A=
+		"rc32365_eth1", =0A=
+		mac1, =0A=
+		ETH1_PhysicalAddress, =0A=
+		ETH1_RX_DMA_ADDR,=0A=
+		ETH1_TX_DMA_ADDR,=0A=
+		ETH1_DMA_RX_IRQ, =0A=
+		ETH1_DMA_TX_IRQ, =0A=
+		ETH1_RX_OVR_IRQ, =0A=
+		ETH1_TX_UND_IRQ,=0A=
+		ETH1_IPABMC_PhysicalAddress=0A=
+	}=0A=
+};=0A=
+=0A=
+static int parse_mac_addr(struct net_device *dev, char* macstr)=0A=
+{=0A=
+	int i, j;=0A=
+	unsigned char result, value;=0A=
+	=0A=
+	for (i=3D0; i<6; i++) {=0A=
+		result =3D 0;=0A=
+		if (i !=3D 5 && *(macstr+2) !=3D ':') {=0A=
+			ERR("invalid mac address format: %d %c\n", i, *(macstr+2));=0A=
+			return -EINVAL;=0A=
+		}=0A=
+		=0A=
+		for (j=3D0; j<2; j++) {=0A=
+			if (isxdigit(*macstr) && (value =3D isdigit(*macstr) ? =0A=
+						  *macstr-'0' : toupper(*macstr)-'A'+10) < 16) {=0A=
+				result =3D result*16 + value;=0A=
+				macstr++;=0A=
+			} =0A=
+			else {=0A=
+				ERR("invalid mac address character: %c\n", *macstr);=0A=
+				return -EINVAL;=0A=
+			}=0A=
+		}=0A=
+		=0A=
+		macstr++;=0A=
+		dev->dev_addr[i] =3D result;=0A=
+	}=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static inline void rc32365_abort_tx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+	rc32365_abort_dma(dev, lp->tx_dma_regs,&lp->ipabmc->ipabmctx);=0A=
+}=0A=
+=0A=
+static inline void rc32365_abort_rx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+	rc32365_abort_dma(dev, lp->rx_dma_regs,&lp->ipabmc->ipabmcrx);=0A=
+}=0A=
+=0A=
+static inline void rc32365_start_tx(struct rc32365_local *lp, volatile =
DMAD_t td)=0A=
+{=0A=
+	rc32365_start_dma(lp->tx_dma_regs, CPHYSADDR(td));=0A=
+}=0A=
+static inline void rc32365_start_rx(struct rc32365_local *lp, volatile =
DMAD_t rd)=0A=
+{=0A=
+	rc32365_start_dma(lp->rx_dma_regs, CPHYSADDR(rd));=0A=
+}=0A=
+=0A=
+static inline void rc32365_chain_tx(struct rc32365_local *lp, volatile =
DMAD_t td)=0A=
+{=0A=
+	rc32365_chain_dma(lp->tx_dma_regs, CPHYSADDR(td));=0A=
+}=0A=
+static inline void rc32365_chain_rx(struct rc32365_local *lp, volatile =
DMAD_t rd)=0A=
+{=0A=
+	rc32365_chain_dma(lp->rx_dma_regs, CPHYSADDR(rd));=0A=
+}=0A=
+=0A=
+#ifdef RC32365_PROC_DEBUG=0A=
+static int rc32365_read_proc(char *buf, char **start, off_t fpos,=0A=
+			     int length, int *eof, void *data)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)data;=0A=
+	struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+	int len =3D 0;=0A=
+	=0A=
+	/* print out header */=0A=
+	=0A=
+	len +=3D sprintf(buf + len, "\n\t rc32365 Ethernet Debug\n\n");=0A=
+	=0A=
+	len +=3D sprintf (buf + len,=0A=
+			"DMA halt count      =3D %10d, DMA run count =3D %10d\n",=0A=
+			lp->dma_halt_cnt, lp->dma_run_cnt);=0A=
+	if (fpos >=3D len) =0A=
+	{=0A=
+		*start =3D buf;=0A=
+		*eof =3D 1;=0A=
+		return 0;=0A=
+	}=0A=
+	*start =3D buf + fpos;=0A=
+	if ((len -=3D fpos) > length)=0A=
+		return length;=0A=
+	=0A=
+	*eof =3D 1;=0A=
+	return len;=0A=
+}=0A=
+#endif=0A=
+=0A=
+=0A=
+/*=0A=
+ * Restart the RC32365 ethernet controller. =0A=
+ */=0A=
+static int rc32365_restart(struct net_device *dev)=0A=
+{=0A=
+	struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+	=0A=
+	/*=0A=
+	 * Disable interrupts=0A=
+	 */=0A=
+	disable_irq(lp->rx_irq);=0A=
+	disable_irq(lp->tx_irq);=0A=
+	if (cedar_za)=0A=
+		disable_irq(lp->ovr_irq);=0A=
+	disable_irq(lp->und_irq);=0A=
+	=0A=
+	/* Mask F Ebit in Tx DMA */=0A=
+	local_writel(local_readl(&lp->tx_dma_regs->dmasm) | DMASM_f_m | =
DMASM_e_m, &lp->tx_dma_regs->dmasm);=0A=
+	/* Mask D H E bit in Rx DMA */=0A=
+	local_writel(local_readl(&lp->rx_dma_regs->dmasm) =0A=
+		     | DMASM_d_m |DMASM_h_m | DMASM_e_m, =
&lp->rx_dma_regs->dmasm);=0A=
+	=0A=
+	rc32365_init(dev);=0A=
+	rc32365_multicast_list(dev);=0A=
+=0A=
+	enable_irq(lp->und_irq);=0A=
+	if (cedar_za)=0A=
+		enable_irq(lp->ovr_irq);=0A=
+	enable_irq(lp->tx_irq);=0A=
+	enable_irq(lp->rx_irq);=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static int __init rc32365_init_module(void)=0A=
+{=0A=
+	int i;=0A=
+	for(i=3D0;i<CONFIG_IDT_NUM_ETH_PORTS;i++)=0A=
+		if (rc32365_probe(i))=0A=
+			printk(KERN_ERR DRIVER_NAME " Port 0 load failed.\n");=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static int rc32365_probe(int port_num)=0A=
+{=0A=
+	struct rc32365_if_t *bif =3D &rc32365_iflist[port_num];=0A=
+	struct rc32365_local *lp =3D NULL;=0A=
+	struct net_device *dev =3D NULL;=0A=
+	int i, retval;=0A=
+	=0A=
+	dev =3D alloc_etherdev(sizeof(struct rc32365_local));=0A=
+	if(!dev){=0A=
+		printk(KERN_ERR DRIVER_NAME "alloc_etherdev failed\n");=0A=
+		return -ENODEV;=0A=
+	}=0A=
+	=0A=
+	SET_MODULE_OWNER(dev);=0A=
+  =0A=
+	bif->dev =3D dev;=0A=
+  =0A=
+	if ((retval =3D parse_mac_addr(dev, bif->mac_str))) {=0A=
+		printk(KERN_ERR DRIVER_NAME" MAC address parse failed\n");=0A=
+		free_netdev(dev);=0A=
+		bif->dev =3D NULL;=0A=
+		return(-ENODEV);=0A=
+	}=0A=
+	/* Initialize the device structure. */=0A=
+	lp =3D (struct rc32365_local *)dev->priv;=0A=
+	=0A=
+	lp->rx_irq =3D bif->rx_dma_irq;=0A=
+	lp->tx_irq =3D bif->tx_dma_irq;=0A=
+	lp->ovr_irq =3D bif->rx_ovr_irq;=0A=
+	lp->und_irq =3D bif->tx_und_irq;=0A=
+	=0A=
+	lp->eth_regs =3D ioremap_nocache(bif->iobase, =
sizeof(*lp->eth_regs));=0A=
+	=0A=
+	if (!lp->eth_regs) {=0A=
+		printk(KERN_ERR DRIVER_NAME" Can't remap eth registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	=0A=
+	lp->ipabmc =3D ioremap_nocache(bif->ipabmc, sizeof(*lp->ipabmc));=0A=
+	=0A=
+	if (!lp->ipabmc){=0A=
+		printk(KERN_ERR DRIVER_NAME" Cannot map ipabmc registers.\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	=0A=
+	lp->rx_dma_regs =3D ioremap_nocache(bif->rxdmabase, sizeof(struct =
DMA_Chan_s));=0A=
+	=0A=
+	if (!lp->rx_dma_regs) {=0A=
+		printk(KERN_ERR DRIVER_NAME" Can't remap Rx DMA registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}		=0A=
+=0A=
+	lp->tx_dma_regs =3D ioremap_nocache(bif->txdmabase,sizeof(struct =
DMA_Chan_s));=0A=
+	=0A=
+	if (!lp->tx_dma_regs) {=0A=
+		printk(KERN_ERR DRIVER_NAME" Can't remap Tx DMA registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	=0A=
+#ifdef RC32365_PROC_DEBUG=0A=
+	lp->ps =3D create_proc_read_entry (bif->name, 0, proc_net,=0A=
+					 rc32365_read_proc, dev);=0A=
+#endif=0A=
+	=0A=
+	lp->td_ring =3D (DMAD_t)kmalloc(TD_RING_SIZE + RD_RING_SIZE, =
GFP_KERNEL);=0A=
+	if (!lp->td_ring) {=0A=
+		printk(KERN_ERR DRIVER_NAME" Can't allocate descriptors\n");=0A=
+		retval =3D -ENOMEM;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	dma_cache_inv((unsigned long)(lp->td_ring), TD_RING_SIZE + =
RD_RING_SIZE);=0A=
+  =0A=
+  	/* now convert TD_RING pointer to KSEG1 */=0A=
+	lp->td_ring =3D (DMAD_t )KSEG1ADDR(lp->td_ring);=0A=
+	lp->rd_ring =3D &lp->td_ring[RC32365_NUM_TDS];=0A=
+	=0A=
+	spin_lock_init(&lp->lock);=0A=
+  =0A=
+	/* Fill in the 'dev' fields. */=0A=
+	dev->base_addr =3D bif->iobase;=0A=
+	/* just use the rx dma irq */=0A=
+	dev->irq =3D bif->rx_dma_irq; =0A=
+	=0A=
+	dev->priv =3D lp;=0A=
+	=0A=
+	dev->open =3D rc32365_open;=0A=
+	dev->stop =3D rc32365_close;=0A=
+	dev->hard_start_xmit =3D rc32365_send_packet;=0A=
+	dev->get_stats	=3D rc32365_get_stats;=0A=
+	dev->set_multicast_list =3D &rc32365_multicast_list;=0A=
+	dev->tx_timeout =3D rc32365_tx_timeout;=0A=
+	dev->watchdog_timeo =3D RC32365_TX_TIMEOUT;=0A=
+  =0A=
+	lp->rx_tasklet =3D kmalloc(sizeof(struct tasklet_struct), =
GFP_KERNEL);=0A=
+	if(lp->rx_tasklet =3D=3D NULL){=0A=
+		printk(KERN_ERR DRIVER_NAME" Cannot allocate memory for =
rx_tasklet\n");=0A=
+		retval =3D -ENOMEM;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	lp->tx_tasklet =3D kmalloc(sizeof(struct tasklet_struct), =
GFP_KERNEL);=0A=
+	if(lp->tx_tasklet =3D=3D NULL){=0A=
+		printk(KERN_ERR DRIVER_NAME" Cannot allocate memory for =
tx_tasklet\n");=0A=
+		retval =3D -ENOMEM;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+=0A=
+	tasklet_init(lp->rx_tasklet, rc32365_rx_tasklet, (unsigned =
long)dev);=0A=
+	tasklet_init(lp->tx_tasklet, rc32365_tx_tasklet, (unsigned =
long)dev);=0A=
+	=0A=
+	if (register_netdev(dev)) {=0A=
+		printk(KERN_ERR DRIVER_NAME" Cannot register_netdev\n");=0A=
+		retval =3D -EINVAL;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+=0A=
+	INFO("Rx IRQ %d, Tx IRQ %d, ", bif->rx_dma_irq, bif->tx_dma_irq);=0A=
+	for (i =3D 0; i < 6; i++) {=0A=
+		printk("%2.2x", dev->dev_addr[i]);=0A=
+		if (i<5)=0A=
+			printk(":");=0A=
+	}=0A=
+	printk("\n");=0A=
+	return 0;=0A=
+	=0A=
+ probe_err_out:=0A=
+	rc32365_remove(port_num);=0A=
+	printk(KERN_ERR DRIVER_NAME " failed.  Returns %d\n", retval);=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Open/initialize the RC32365 Ethernet device.=0A=
+ *=0A=
+ * This routine should set everything up new at each open, even=0A=
+ *  registers that "should" only need to be set once at boot, so =
that=0A=
+ *  there is non-reboot way to recover if something goes wrong.=0A=
+ */=0A=
+static int rc32365_open(struct net_device *dev)=0A=
+{=0A=
+  struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+  =0A=
+  /*=0A=
+   * Initialize=0A=
+   */=0A=
+  if (rc32365_init(dev)) =0A=
+    {=0A=
+      ERR("Erroe: cannot open the Ethernet device\n");=0A=
+      return -EAGAIN;=0A=
+    }=0A=
+=0A=
+  if (request_irq(lp->rx_irq, &rc32365_rx_dma_interrupt,=0A=
+		  SA_SHIRQ | SA_INTERRUPT,=0A=
+		  "rc32365 ethernet Rx", dev)) =0A=
+    {=0A=
+      INFO("unable to get Rx DMA IRQ %d\n", lp->rx_irq);=0A=
+      return -EAGAIN;=0A=
+    }=0A=
+=0A=
+  if (request_irq(lp->tx_irq, &rc32365_tx_dma_interrupt,=0A=
+		  SA_SHIRQ | SA_INTERRUPT,=0A=
+		  "rc32365 ethernet Tx", dev)) =0A=
+    {=0A=
+      INFO("unable to get Tx DMA IRQ %d\n", lp->tx_irq);=0A=
+      free_irq(lp->rx_irq, dev);=0A=
+      return -EAGAIN;=0A=
+    }=0A=
+=0A=
+  /* Install handler for overrun error. */=0A=
+  if (cedar_za)=0A=
+    if (request_irq(lp->ovr_irq, &rc32365_ovr_interrupt,=0A=
+		    SA_SHIRQ | SA_INTERRUPT,=0A=
+		    "Ethernet Overflow", dev)) =0A=
+      {=0A=
+        INFO("unable to get OVR IRQ %d\n",	lp->ovr_irq);=0A=
+        free_irq(lp->rx_irq, dev);=0A=
+        free_irq(lp->tx_irq, dev);=0A=
+        return -EAGAIN;=0A=
+      }=0A=
+=0A=
+  /* Install handler for underflow error. */=0A=
+  if (request_irq(lp->und_irq, &rc32365_und_interrupt,=0A=
+		  SA_SHIRQ | SA_INTERRUPT,=0A=
+		  "Ethernet Underflow", dev)) =0A=
+    {=0A=
+      INFO("unable to get UND IRQ %d\n",	lp->und_irq);=0A=
+      free_irq(lp->rx_irq, dev);=0A=
+      free_irq(lp->tx_irq, dev);=0A=
+      if (cedar_za)=0A=
+        free_irq(lp->ovr_irq, dev);		=0A=
+      return -EAGAIN;=0A=
+    }=0A=
+=0A=
+  /*=0A=
+    init_timer(&lp->mii_phy_timer);=0A=
+    lp->mii_phy_timer.expires =3D jiffies + 10 * HZ;	=0A=
+    lp->mii_phy_timer.data =3D (unsigned long)dev;=0A=
+    lp->mii_phy_timer.function	 =3D rc32365_mii_handler;=0A=
+    add_timer(&lp->mii_phy_timer);=0A=
+  */=0A=
+  =0A=
+  return 0;=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Close the RC32365 ethernet device.=0A=
+ */=0A=
+static int rc32365_close(struct net_device *dev)=0A=
+{=0A=
+  struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+  u32 tmp;=0A=
+  =0A=
+  /*=0A=
+   * Disable interrupts=0A=
+   */=0A=
+  disable_irq(lp->rx_irq);=0A=
+  disable_irq(lp->tx_irq);=0A=
+  if (cedar_za)=0A=
+    disable_irq(lp->ovr_irq);=0A=
+  disable_irq(lp->und_irq);=0A=
+  =0A=
+  tmp =3D local_readl(&lp->tx_dma_regs->dmasm);=0A=
+  tmp =3D tmp | DMASM_f_m | DMASM_e_m;=0A=
+  local_writel(tmp, &lp->tx_dma_regs->dmasm);=0A=
+=0A=
+  tmp =3D local_readl(&lp->rx_dma_regs->dmasm);=0A=
+  tmp =3D tmp | DMASM_d_m | DMASM_h_m | DMASM_e_m;=0A=
+  local_writel(tmp, &lp->rx_dma_regs->dmasm);=0A=
+  =0A=
+  free_irq(lp->rx_irq, dev);=0A=
+  free_irq(lp->tx_irq, dev);=0A=
+  if (cedar_za)=0A=
+    free_irq(lp->ovr_irq, dev);=0A=
+  free_irq(lp->und_irq, dev);=0A=
+=0A=
+  //Not enabled this feature at this time.=0A=
+  //del_timer(&lp->mii_phy_timer);=0A=
+  return 0;=0A=
+}=0A=
+=0A=
+=0A=
+/* transmit packet */=0A=
+static int rc32365_send_packet(struct sk_buff *skb, struct net_device =
*dev)=0A=
+{=0A=
+  struct rc32365_local	*lp =3D (struct rc32365_local *)dev->priv;=0A=
+  unsigned long 	flags;=0A=
+  u32			length;=0A=
+  DMAD_t		td;=0A=
+=0A=
+  spin_lock_irqsave(&lp->lock, flags);=0A=
+=0A=
+  td =3D &lp->td_ring[lp->tx_chain_tail];=0A=
+=0A=
+  /* stop queue when full, drop pkts if queue already full */=0A=
+  if(lp->tx_count >=3D (RC32365_NUM_TDS - 2))=0A=
+    {=0A=
+      lp->tx_full =3D 1;=0A=
+      =0A=
+      if(lp->tx_count =3D=3D (RC32365_NUM_TDS - 2))=0A=
+	{=0A=
+	  /* this pkt is about to fill the queue */=0A=
+	  //	  ERR("Tx Ring now full, queue stopped.\n");=0A=
+	  netif_stop_queue(dev);=0A=
+	}=0A=
+      else{=0A=
+	/* this pkt cannot be added to the full queue */=0A=
+	//ERR("Tx ring full, packet dropped\n");=0A=
+	lp->stats.tx_dropped++;=0A=
+	dev_kfree_skb_any(skb);=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	return 1;=0A=
+      }=0A=
+    }=0A=
+  lp->tx_count ++;=0A=
+  =0A=
+  /* make sure payload gets written to memory */=0A=
+  dma_cache_wback_inv((unsigned long)skb->data, skb->len);=0A=
+=0A=
+  lp->tx_skb[lp->tx_chain_tail] =3D skb;=0A=
+  =0A=
+  length =3D skb->len;=0A=
+=0A=
+  /* Setup the transmit descriptor. */=0A=
+  td->ca =3D CPHYSADDR(skb->data);=0A=
+=0A=
+  if(local_readl(&(lp->tx_dma_regs->dmandptr)) =3D=3D 0) 		=0A=
+    {=0A=
+      if( lp->tx_chain_status =3D=3D empty ) =0A=
+	{=0A=
+	  td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /*  Update tail      */=0A=
+	  lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32365_TDS_MASK;   =
                        /*   Move tail       */=0A=
+	  local_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR    */=0A=
+	  lp->tx_chain_head =3D lp->tx_chain_tail;                            =
                      /* Move head to tail */=0A=
+	}=0A=
+      else=0A=
+	{=0A=
+	  td->control =3D DMA_COUNT(length) |DMAD_cof_m|DMAD_iof_m;           =
                      /* Update tail */=0A=
+	  lp->td_ring[(lp->tx_chain_tail-1)& RC32365_TDS_MASK].control &=3D  =
~(DMAD_cof_m);           /* Link to prev */=0A=
+	  lp->td_ring[(lp->tx_chain_tail-1)& RC32365_TDS_MASK].link =3D  =
CPHYSADDR(td);               /* Link to prev */=0A=
+	  lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32365_TDS_MASK;   =
                        /* Move tail */=0A=
+	  local_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR */=0A=
+	  lp->tx_chain_head =3D lp->tx_chain_tail;                            =
                      /* Move head to tail */=0A=
+	  lp->tx_chain_status =3D empty;  =0A=
+	}=0A=
+    }=0A=
+  else=0A=
+    {=0A=
+      if( lp->tx_chain_status =3D=3D empty )=0A=
+	{=0A=
+	  td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /* Update tail */=0A=
+	  lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32365_TDS_MASK;   =
                        /* Move tail */=0A=
+	  lp->tx_chain_status =3D filled;		=0A=
+	}=0A=
+      else=0A=
+	{=0A=
+	  td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /* Update tail */=0A=
+	  lp->td_ring[(lp->tx_chain_tail-1)& RC32365_TDS_MASK].control &=3D  =
~(DMAD_cof_m);           /* Link to prev */=0A=
+	  lp->td_ring[(lp->tx_chain_tail-1)& RC32365_TDS_MASK].link =3D  =
CPHYSADDR(td);	          /* Link to prev */=0A=
+	  lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32365_TDS_MASK;   =
                        /* Move tail */=0A=
+	}		=0A=
+    }=0A=
+=0A=
+  dev->trans_start =3D jiffies;=0A=
+  =0A=
+  spin_unlock_irqrestore(&lp->lock, flags);=0A=
+  =0A=
+  return 0;=0A=
+}=0A=
+=0A=
+=0A=
+/* Ethernet MII-PHY Handler */=0A=
+static void rc32365_mii_handler(unsigned long data)=0A=
+{=0A=
+  struct net_device *dev =3D (struct net_device *)data;		=0A=
+  struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+  unsigned long 	flags;=0A=
+  unsigned long duplex_status;=0A=
+  int port_addr =3D (lp->rx_irq =3D=3D 0x2a? 1:0) << 8;=0A=
+=0A=
+  spin_lock_irqsave(&lp->lock, flags);=0A=
+=0A=
+  /* Two ports are using the same MII, the difference is the PHY =
address */=0A=
+  local_writel(0, &rc32365_eth0_regs->miimcfg);  =0A=
+  local_writel(0, &rc32365_eth0_regs->miimcmd);  =0A=
+  local_writel(port_addr |0x05, &rc32365_eth0_regs->miimaddr);  =0A=
+  local_writel(MIIMCMD_scn_m, &rc32365_eth0_regs->miimcmd);  =0A=
+  while(local_readl(&rc32365_eth0_regs->miimind) & MIIMIND_nv_m);=0A=
+=0A=
+  ERR("irq:%x		port_addr:%x	RDD:%x\n", =0A=
+      lp->rx_irq, port_addr, =
local_readl(&rc32365_eth0_regs->miimrdd));=0A=
+  duplex_status =3D (local_readl(&rc32365_eth0_regs->miimrdd) & =
0x140)? ETHMAC2_fd_m: 0;=0A=
+  if(duplex_status !=3D lp->duplex_mode)=0A=
+    {=0A=
+      ERR("The MII-PHY is Auto-negotiated to %s-Duplex mode for =
Eth-%x\n", =0A=
+	  duplex_status? "Full":"Half", lp->rx_irq =3D=3D 0x2a? 1:0);		=0A=
+      lp->duplex_mode =3D duplex_status;=0A=
+      rc32365_restart(dev);		=0A=
+    }=0A=
+=0A=
+  lp->mii_phy_timer.expires =3D jiffies + 10 * HZ;	=0A=
+  add_timer(&lp->mii_phy_timer);=0A=
+  =0A=
+  spin_unlock_irqrestore(&lp->lock, flags);=0A=
+=0A=
+}=0A=
+=0A=
+/* Ethernet Rx Overflow interrupt */=0A=
+static irqreturn_t rc32365_ovr_interrupt(int irq, void *dev_id, struct =
pt_regs * regs)=0A=
+{=0A=
+  struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+  struct rc32365_local *lp;=0A=
+  unsigned int ovr;=0A=
+  irqreturn_t retval =3D IRQ_NONE;=0A=
+	=0A=
+  ASSERT(dev !=3D NULL);=0A=
+  =0A=
+  lp =3D (struct rc32365_local *)dev->priv;=0A=
+  spin_lock(&lp->lock);=0A=
+  ovr =3D local_readl(&lp->eth_regs->ethintfc);=0A=
+=0A=
+  if(ovr & ETHINTFC_ovr_m)=0A=
+    {=0A=
+      netif_stop_queue(dev);=0A=
+=0A=
+      /* clear OVR bit */=0A=
+      local_writel((ovr & ~ETHINTFC_ovr_m), =
&lp->eth_regs->ethintfc);=0A=
+=0A=
+      /* Restart interface */=0A=
+      rc32365_restart(dev);	  =0A=
+      retval =3D IRQ_HANDLED;=0A=
+    }=0A=
+  spin_unlock(&lp->lock);=0A=
+=0A=
+  return retval;=0A=
+}=0A=
+=0A=
+/* Ethernet Tx Underflow interrupt */=0A=
+static irqreturn_t rc32365_und_interrupt(int irq, void *dev_id, struct =
pt_regs * regs)=0A=
+{=0A=
+  struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+  struct rc32365_local *lp;=0A=
+  unsigned int und;=0A=
+  irqreturn_t retval =3D IRQ_NONE;=0A=
+	=0A=
+  ASSERT(dev !=3D NULL);=0A=
+	=0A=
+  lp =3D (struct rc32365_local *)dev->priv;=0A=
+  =0A=
+  spin_lock(&lp->lock);=0A=
+=0A=
+  und =3D local_readl(&lp->eth_regs->ethintfc);=0A=
+=0A=
+  if(und & ETHINTFC_und_m)=0A=
+    {=0A=
+      netif_stop_queue(dev);	=0A=
+      =0A=
+      local_writel((und & ~ETHINTFC_und_m), =
&lp->eth_regs->ethintfc);=0A=
+=0A=
+      /* Restart interface */=0A=
+      rc32365_restart(dev);    =0A=
+      retval =3D IRQ_HANDLED;=0A=
+    }=0A=
+	=0A=
+  spin_unlock(&lp->lock);=0A=
+	=0A=
+  return retval;=0A=
+=0A=
+}=0A=
+=0A=
+=0A=
+/* Ethernet Rx DMA interrupt */=0A=
+static irqreturn_t=0A=
+rc32365_rx_dma_interrupt(int irq, void *dev_id, struct pt_regs * =
regs)=0A=
+{=0A=
+  struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+  struct rc32365_local* lp;=0A=
+  volatile u32 dmas,dmasm;=0A=
+  irqreturn_t retval =3D IRQ_NONE;=0A=
+=0A=
+  ASSERT(dev !=3D NULL);=0A=
+=0A=
+  lp =3D (struct rc32365_local *)dev->priv;=0A=
+=0A=
+  spin_lock(&lp->lock);=0A=
+  dmas =3D local_readl(&lp->rx_dma_regs->dmas);=0A=
+  if(dmas & (DMAS_d_m|DMAS_h_m|DMAS_e_m))=0A=
+    { =0A=
+      if (cedar_za)=0A=
+        local_writel(~dmas, &lp->rx_dma_regs->dmas);=0A=
+=0A=
+      /* Mask D H E bit in Rx DMA */=0A=
+      dmasm =3D local_readl(&lp->rx_dma_regs->dmasm);=0A=
+      local_writel(dmasm | (DMASM_d_m | DMASM_h_m | DMASM_e_m), =
&lp->rx_dma_regs->dmasm);=0A=
+      tasklet_hi_schedule(lp->rx_tasklet);=0A=
+=0A=
+      if (dmas & DMAS_e_m)=0A=
+	ERR(": DMA error\n");=0A=
+=0A=
+      retval =3D IRQ_HANDLED;=0A=
+    }=0A=
+=0A=
+  spin_unlock(&lp->lock);=0A=
+  return retval;=0A=
+}=0A=
+=0A=
+static void rc32365_rx_tasklet(unsigned long rx_data_dev)=0A=
+{=0A=
+  struct net_device *dev =3D (struct net_device *)rx_data_dev;	=0A=
+  struct rc32365_local* lp =3D (struct rc32365_local *)dev->priv;=0A=
+  volatile DMAD_t  rd =3D &lp->rd_ring[lp->rx_next_done];=0A=
+  struct sk_buff *skb, *skb_new;=0A=
+  u8* pkt_buf;=0A=
+  volatile u32 devcs;=0A=
+  volatile u32 dmas;=0A=
+  volatile u32 dmasm;=0A=
+  volatile u32 count;=0A=
+  volatile u32 pkt_len;=0A=
+  unsigned long 	flags;=0A=
+=0A=
+  spin_lock_irqsave(&lp->lock, flags);=0A=
+  /* keep going while we have received into more descriptors */=0A=
+  while ( (count =3D RC32365_RBSIZE - (u32)DMA_COUNT(rd->control)) =
!=3D 0)=0A=
+    {=0A=
+      /* init the var. used for the operations within the while loop =
later */=0A=
+      skb_new =3D NULL;=0A=
+      devcs =3D rd->devcs;=0A=
+      pkt_len =3D RCVPKT_LENGTH(devcs);=0A=
+      skb =3D lp->rx_skb[lp->rx_next_done];=0A=
+=0A=
+      if( count !=3D pkt_len) =0A=
+	{	=0A=
+	  lp->stats.rx_errors++;=0A=
+	  lp->stats.rx_dropped++;=0A=
+	}=0A=
+      else if (count < 64) =0A=
+	{=0A=
+	  lp->stats.rx_errors++;=0A=
+	  lp->stats.rx_dropped++;=0A=
+	}=0A=
+      else if ((devcs & ( ETHRX_ld_m)) !=3D	ETHRX_ld_m)=0A=
+	{=0A=
+	  lp->stats.rx_errors++; =0A=
+	}=0A=
+      else if (devcs & ETHRX_rok_m) =0A=
+	{				=0A=
+	  pkt_buf =3D (u8*)lp->rx_skb[lp->rx_next_done]->data;=0A=
+	      =0A=
+	  /* invalidate the cache before copying the buffer */=0A=
+	  dma_cache_inv((unsigned long)pkt_buf, (pkt_len-4));=0A=
+	      =0A=
+	  /* Malloc up new buffer. */					  =0A=
+	  skb_new =3D dev_alloc_skb(RC32365_RBSIZE + 2);=0A=
+=0A=
+	  if (skb_new !=3D NULL)=0A=
+	    {=0A=
+	      /* Make room */=0A=
+	      skb_put(skb, (pkt_len-4));		    =0A=
+	      =0A=
+	      skb->protocol =3D eth_type_trans(skb, dev);=0A=
+	      /* pass the packet to upper layers */=0A=
+	      netif_rx(skb);=0A=
+	      dev->last_rx =3D jiffies;=0A=
+	      lp->stats.rx_packets++;=0A=
+	      lp->stats.rx_bytes +=3D (pkt_len-4);=0A=
+	      =0A=
+	      if (IS_RCV_MP(devcs))=0A=
+		lp->stats.multicast++;=0A=
+=0A=
+	      /* 16 bit align */=0A=
+	      skb_reserve(skb_new, 2);	=0A=
+=0A=
+	      skb_new->dev =3D dev;=0A=
+	      lp->rx_skb[lp->rx_next_done] =3D skb_new;=0A=
+	    }=0A=
+	  else=0A=
+	    {=0A=
+	      ERR("no memory, dropping rx packet.\n");=0A=
+	      lp->stats.rx_errors++;				=0A=
+	      lp->stats.rx_dropped++;				=0A=
+	    }=0A=
+	}				=0A=
+      else =0A=
+	{=0A=
+=0A=
+	  /* This should only happen if we enable accepting broken packets =
*/=0A=
+	  lp->stats.rx_errors++;=0A=
+	  lp->stats.rx_dropped++;=0A=
+	  =0A=
+	  /* added statistics counters */=0A=
+	  if (IS_RCV_CRC_ERR(devcs)) =0A=
+	    {			  			=0A=
+	      DBG(2, "RX CRC error\n");=0A=
+	      lp->stats.rx_crc_errors++;=0A=
+	    }=0A=
+	  else if (IS_RCV_LOR_ERR(devcs)) =0A=
+	    {			=0A=
+	      DBG(2, "RX LOR error\n");=0A=
+	      lp->stats.rx_length_errors++;=0A=
+	    }=0A=
+	  else if (IS_RCV_LE_ERR(devcs)) =0A=
+	    {			=0A=
+	      DBG(2, "RX LE error\n");=0A=
+	      lp->stats.rx_length_errors++;=0A=
+	    }=0A=
+	  else if (IS_RCV_OVR_ERR(devcs)) =0A=
+	    {=0A=
+	      /*=0A=
+	       * The overflow errors are handled through=0A=
+	       * an interrupt handler.=0A=
+	       */=0A=
+	      lp->stats.rx_over_errors++;=0A=
+	    }=0A=
+	  else if (IS_RCV_CV_ERR(devcs)) =0A=
+	    {			=0A=
+	      /* code violation */=0A=
+	      DBG(2, "RX CV error\n");=0A=
+	      lp->stats.rx_errors++;					=0A=
+	    }=0A=
+	  else if (IS_RCV_CES_ERR(devcs)) =0A=
+	    {=0A=
+	      DBG(2, "RX Preamble error\n");=0A=
+	      lp->stats.rx_errors++;					=0A=
+	    }=0A=
+	}=0A=
+      =0A=
+      /*=0A=
+       * clear the bits that let us see whether this=0A=
+       * descriptor has been used or not & reset reception=0A=
+       * length.=0A=
+       */		 =0A=
+      rd->devcs =3D 0;=0A=
+      /* restore descriptor's curr_addr */=0A=
+      if (skb_new)=0A=
+	rd->ca =3D CPHYSADDR(skb_new->data); =0A=
+      else=0A=
+	rd->ca =3D CPHYSADDR(skb->data);=0A=
+=0A=
+      rd->control =3D DMA_COUNT(RC32365_RBSIZE) |DMAD_cod_m =
|DMAD_iod_m;=0A=
+=0A=
+      lp->rd_ring[(lp->rx_next_done-1)& RC32365_RDS_MASK].control &=3D =
 ~(DMAD_cod_m); 	=0A=
+=0A=
+      lp->rx_next_done =3D (lp->rx_next_done + 1) & =
RC32365_RDS_MASK;=0A=
+      rd =3D &lp->rd_ring[lp->rx_next_done];=0A=
+=0A=
+    }	=0A=
+  if (!cedar_za) {=0A=
+  dmas =3D local_readl(&lp->rx_dma_regs->dmas);=0A=
+  if(dmas & DMAS_h_m)=0A=
+    {=0A=
+#ifdef RC32365_PROC_DEBUG=0A=
+      lp->dma_halt_cnt++;=0A=
+#endif=0A=
+      rd->devcs =3D 0;=0A=
+      skb =3D lp->rx_skb[lp->rx_next_done];=0A=
+      rd->ca =3D CPHYSADDR(skb->data);=0A=
+      rc32365_chain_rx(lp,rd);=0A=
+    }=0A=
+  }=0A=
+  local_writel(~dmas, &lp->rx_dma_regs->dmas);=0A=
+  /* Enable D H E bit in Rx DMA */=0A=
+  dmasm =3D local_readl(&lp->rx_dma_regs->dmasm);=0A=
+  local_writel(dmasm & ~(DMASM_d_m | DMASM_h_m | DMASM_e_m), =
&lp->rx_dma_regs->dmasm);=0A=
+  spin_unlock_irqrestore(&lp->lock, flags);=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+/* Ethernet Tx DMA interrupt */=0A=
+static irqreturn_t=0A=
+rc32365_tx_dma_interrupt(int irq, void *dev_id, struct pt_regs * =
regs)=0A=
+{=0A=
+  struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+  struct rc32365_local *lp;=0A=
+  volatile u32 dmas,dmasm;=0A=
+  irqreturn_t retval =3D IRQ_NONE;=0A=
+=0A=
+  ASSERT(dev !=3D NULL);=0A=
+=0A=
+  lp =3D (struct rc32365_local *)dev->priv;=0A=
+=0A=
+  spin_lock(&lp->lock);=0A=
+=0A=
+  dmas =3D local_readl(&lp->tx_dma_regs->dmas);=0A=
+=0A=
+  if (dmas & (DMAS_f_m | DMAS_e_m))=0A=
+    {=0A=
+      dmasm =3D local_readl(&lp->tx_dma_regs->dmasm);=0A=
+      /* Mask F E bit in Tx DMA */=0A=
+      local_writel(dmasm | (DMASM_f_m | DMASM_e_m), =
&lp->tx_dma_regs->dmasm);=0A=
+=0A=
+      tasklet_hi_schedule(lp->tx_tasklet);=0A=
+=0A=
+      if(lp->tx_chain_status =3D=3D filled && =
(local_readl(&(lp->tx_dma_regs->dmandptr)) =3D=3D 0))=0A=
+	{ =0A=
+	  local_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr));=0A=
+	  lp->tx_chain_status =3D empty;=0A=
+	  lp->tx_chain_head =3D lp->tx_chain_tail;=0A=
+	  dev->trans_start =3D jiffies;=0A=
+	}=0A=
+=0A=
+      if (dmas & DMAS_e_m)=0A=
+	ERR(": DMA error\n");=0A=
+=0A=
+      retval =3D IRQ_HANDLED;=0A=
+    }=0A=
+=0A=
+  spin_unlock(&lp->lock);=0A=
+=0A=
+  return retval;=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32365_tx_tasklet(unsigned long tx_data_dev)=0A=
+{=0A=
+  struct net_device *dev =3D (struct net_device *)tx_data_dev;	=0A=
+  struct rc32365_local* lp =3D (struct rc32365_local *)dev->priv;=0A=
+  volatile DMAD_t td =3D &lp->td_ring[lp->tx_next_done];=0A=
+  volatile u32	devcs;=0A=
+  unsigned long 	flags;=0A=
+  volatile u32 dmasm;=0A=
+=0A=
+  spin_lock_irqsave(&lp->lock, flags);=0A=
+=0A=
+  /* process all desc that are done */=0A=
+  while(IS_DMA_FINISHED(td->control)) =0A=
+    {=0A=
+      if(lp->tx_full =3D=3D 1)=0A=
+	{=0A=
+	  netif_wake_queue(dev);=0A=
+	  lp->tx_full =3D 0;=0A=
+	}=0A=
+=0A=
+      devcs =3D lp->td_ring[lp->tx_next_done].devcs;    =0A=
+      if ((devcs & (ETHTX_fd_m | ETHTX_ld_m)) !=3D (ETHTX_fd_m | =
ETHTX_ld_m)) =0A=
+	{=0A=
+	  lp->stats.tx_errors++;=0A=
+	  lp->stats.tx_dropped++;				=0A=
+	  =0A=
+	  /* should never happen */=0A=
+	  INFO("split tx ignored\n");=0A=
+	} =0A=
+      else if (IS_TX_TOK(devcs)) =0A=
+	{=0A=
+	  /* transmit OK */=0A=
+	  lp->stats.tx_packets++;=0A=
+	} =0A=
+      else =0A=
+	{=0A=
+	  =0A=
+	  lp->stats.tx_dropped++;				=0A=
+	  =0A=
+	  /* underflow */=0A=
+	  if (IS_TX_UND_ERR(devcs)) =0A=
+	    lp->stats.tx_fifo_errors++;=0A=
+	  =0A=
+	  /* oversized frame */=0A=
+	  if (IS_TX_OF_ERR(devcs))=0A=
+	    lp->stats.tx_aborted_errors++;=0A=
+=0A=
+	  /* excessive deferrals */=0A=
+	  if (IS_TX_ED_ERR(devcs))=0A=
+	    lp->stats.tx_carrier_errors++;=0A=
+=0A=
+	  /* collisions: medium busy */=0A=
+	  if (IS_TX_EC_ERR(devcs))=0A=
+	    lp->stats.collisions++;=0A=
+=0A=
+	  /* late collision */=0A=
+	  if (IS_TX_LC_ERR(devcs))=0A=
+	    lp->stats.tx_window_errors++;=0A=
+=0A=
+	}=0A=
+      /* We must always free the original skb */=0A=
+      if (lp->tx_skb[lp->tx_next_done] !=3D NULL) =0A=
+	{=0A=
+	  dev_kfree_skb_any(lp->tx_skb[lp->tx_next_done]);=0A=
+	  lp->tx_skb[lp->tx_next_done] =3D NULL;=0A=
+	}=0A=
+=0A=
+      lp->td_ring[lp->tx_next_done].control =3D DMAD_iof_m;=0A=
+      lp->td_ring[lp->tx_next_done].devcs =3D ETHTX_fd_m | ETHTX_ld_m;	=
=0A=
+      lp->td_ring[lp->tx_next_done].link =3D 0;=0A=
+      lp->td_ring[lp->tx_next_done].ca =3D 0;=0A=
+=0A=
+      lp->tx_count--;=0A=
+=0A=
+      /* go on to next transmission */=0A=
+      lp->tx_next_done =3D (lp->tx_next_done + 1) & =
RC32365_TDS_MASK;=0A=
+      td =3D &lp->td_ring[lp->tx_next_done];=0A=
+      =0A=
+    }=0A=
+=0A=
+  /* Enable F E bit in Tx DMA */=0A=
+  dmasm =3D local_readl(&lp->tx_dma_regs->dmasm);=0A=
+  local_writel(dmasm & ~(DMASM_f_m | =
DMASM_e_m),&lp->tx_dma_regs->dmasm);=0A=
+	=0A=
+  spin_unlock_irqrestore(&lp->lock, flags);=0A=
+=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Get the current statistics.=0A=
+ * This may be called with the device open or closed.=0A=
+ */=0A=
+static struct net_device_stats *=0A=
+rc32365_get_stats(struct net_device *dev)=0A=
+{=0A=
+  struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+  =0A=
+  return &lp->stats;=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Set or clear the multicast filter for this adaptor.=0A=
+ */=0A=
+static void=0A=
+rc32365_multicast_list(struct net_device *dev)=0A=
+{   	=0A=
+  struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+  unsigned long flags;=0A=
+  u32 recognise =3D ETHARC_ab_m; 		/* always accept broadcasts */=0A=
+  =0A=
+  if (dev->flags & IFF_PROMISC) 			/* set promiscuous mode */=0A=
+    recognise |=3D ETHARC_pro_m;=0A=
+  =0A=
+  if ((dev->flags & IFF_ALLMULTI) || (dev->mc_count > 15))=0A=
+    recognise |=3D ETHARC_am_m;		/* all multicast & bcast */=0A=
+  =0A=
+  else if (dev->mc_count > 0) =0A=
+    {=0A=
+      DBG(2, __FUNCTION__ ": mc_count %d\n", dev->mc_count);=0A=
+      =0A=
+      recognise |=3D ETHARC_am_m;		/* for the time being */=0A=
+    }=0A=
+  =0A=
+  spin_lock_irqsave(&lp->lock, flags);=0A=
+  =0A=
+  local_writel(recognise, &lp->eth_regs->etharc);=0A=
+	=0A=
+  spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+static void=0A=
+rc32365_tx_timeout(struct net_device *dev)=0A=
+{=0A=
+  struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+  unsigned long flags;=0A=
+  =0A=
+  spin_lock_irqsave(&lp->lock, flags);=0A=
+  dev->trans_start =3D jiffies;=0A=
+  rc32365_restart(dev);=0A=
+  spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Initialize the RC32365 ethernet controller.=0A=
+ */=0A=
+static int rc32365_init(struct net_device *dev)=0A=
+{=0A=
+  struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+  int i, j;=0A=
+=0A=
+  /* Disable DMA */       =0A=
+  rc32365_abort_rx(dev);	=0A=
+  rc32365_abort_tx(dev);=0A=
+=0A=
+  /* reset ethernet logic */ =0A=
+  local_writel(0, &lp->eth_regs->ethintfc);=0A=
+  while((local_readl(&lp->eth_regs->ethintfc) & ETHINTFC_rip_m))=0A=
+    dev->trans_start =3D jiffies;=0A=
+	=0A=
+  /* Enable Ethernet Interface */ =0A=
+  local_writel(ETHINTFC_en_m, &lp->eth_regs->ethintfc); =0A=
+=0A=
+  tasklet_disable(lp->rx_tasklet);=0A=
+  tasklet_disable(lp->tx_tasklet);=0A=
+=0A=
+  /* Initialize the transmit Descriptors */=0A=
+  for (i =3D 0; i < RC32365_NUM_TDS; i++) {=0A=
+    lp->td_ring[i].control =3D DMAD_iof_m;=0A=
+    lp->td_ring[i].devcs =3D ETHTX_fd_m | ETHTX_ld_m;=0A=
+    lp->td_ring[i].ca =3D 0;=0A=
+    lp->td_ring[i].link =3D 0;=0A=
+    if (lp->tx_skb[i] !=3D NULL) =0A=
+      {=0A=
+	/* free dangling skb */=0A=
+	dev_kfree_skb_any(lp->tx_skb[i]);=0A=
+	lp->tx_skb[i] =3D NULL;=0A=
+      }=0A=
+  }=0A=
+  lp->tx_next_done =3D lp->tx_chain_head =3D lp->tx_chain_tail =3D =0A=
+    lp->tx_count =3D lp->tx_full =3D 0;=0A=
+  lp->tx_chain_status =3D empty;=0A=
+	=0A=
+  /*=0A=
+   * Initialize the receive descriptors so that they=0A=
+   * become a circular linked list, ie. let the last=0A=
+   * descriptor point to the first again.=0A=
+   */=0A=
+  for (i=3D0; i<RC32365_NUM_RDS; i++) =0A=
+    {=0A=
+      struct sk_buff *skb =3D lp->rx_skb[i];=0A=
+=0A=
+      if (lp->rx_skb[i] =3D=3D NULL) =0A=
+	{=0A=
+	  skb =3D dev_alloc_skb(RC32365_RBSIZE + 2);=0A=
+	  if (skb =3D=3D NULL)=0A=
+	    {=0A=
+	      printk("No memory in the system\n");=0A=
+	      for (j =3D 0; j < RC32365_NUM_RDS; j ++)=0A=
+		if (lp->rx_skb[j] !=3D NULL) =0A=
+		  dev_kfree_skb_any(lp->rx_skb[j]);=0A=
+	      return 1;=0A=
+	    }=0A=
+	  else=0A=
+	    {=0A=
+	      skb->dev =3D dev;=0A=
+	      skb_reserve(skb, 2);=0A=
+	      lp->rx_skb[i] =3D skb;=0A=
+	      lp->rd_ring[i].ca =3D CPHYSADDR(skb->data); =0A=
+	    }=0A=
+	}=0A=
+      lp->rd_ring[i].control =3D	DMAD_iod_m | =
DMA_COUNT(RC32365_RBSIZE);=0A=
+      lp->rd_ring[i].devcs =3D 0;=0A=
+      lp->rd_ring[i].ca =3D CPHYSADDR(skb->data);=0A=
+      lp->rd_ring[i].link =3D CPHYSADDR(&lp->rd_ring[i+1]);=0A=
+    }=0A=
+  /* loop back */=0A=
+  lp->rd_ring[RC32365_NUM_RDS-1].link =3D =
CPHYSADDR(&lp->rd_ring[0]);=0A=
+  lp->rx_next_done   =3D 0;=0A=
+  lp->rd_ring[RC32365_NUM_RDS-1].control |=3D DMAD_cod_m;=0A=
+  lp->rx_chain_head =3D 0;=0A=
+  lp->rx_chain_tail =3D 0;=0A=
+  lp->rx_chain_status =3D empty;=0A=
+=0A=
+  local_writel(0, &lp->rx_dma_regs->dmas);=0A=
+  /* Start Rx DMA */=0A=
+  rc32365_start_rx(lp, &lp->rd_ring[0]);=0A=
+	=0A=
+  /* Enable F E bit in Tx DMA */=0A=
+  local_writel(local_readl(&lp->tx_dma_regs->dmasm) & ~(DMASM_f_m | =
DMASM_e_m), &lp->tx_dma_regs->dmasm); =0A=
+  /* Enable D H E bit in Rx DMA */=0A=
+  local_writel(local_readl(&lp->rx_dma_regs->dmasm) & ~(DMASM_d_m =
|DMASM_h_m| DMASM_e_m), &lp->rx_dma_regs->dmasm); =0A=
+=0A=
+  /* Accept only packets destined for this Ethernet device address =
*/=0A=
+  local_writel(ETHARC_ab_m, &lp->eth_regs->etharc); =0A=
+ =0A=
+  /* Set all Ether station address registers to their initial values =
*/ =0A=
+  local_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal0); =0A=
+  local_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah0);=0A=
+  =0A=
+  local_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal1); =0A=
+  local_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah1);=0A=
+	=0A=
+  local_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal2); =0A=
+  local_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah2);=0A=
+	=0A=
+  local_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal3); =0A=
+  local_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah3); =0A=
+ =0A=
+  /* Frame Length Checking, Pad Enable, CRC Enable, Full Duplex set */ =
=0A=
+  local_writel( ETHMAC2_pe_m | ETHMAC2_cen_m | =
ETHMAC2_fd_m,&lp->eth_regs->ethmac2);  =0A=
+=0A=
+  /* Back to back inter-packet-gap */ =0A=
+  local_writel(0x15, &lp->eth_regs->ethipgt); =0A=
+  /* Non - Back to back inter-packet-gap */ =0A=
+  local_writel(0x12, &lp->eth_regs->ethipgr); =0A=
+     =0A=
+  /* Management Clock Prescaler Divisor */=0A=
+  local_writel((idt_cpu_freq/MII_CLOCK+1) & ~1, =
&lp->eth_regs->ethmcp);=0A=
+=0A=
+  /* don't transmit until fifo contains 48b */=0A=
+  local_writel(48, &lp->eth_regs->ethfifott);=0A=
+  tasklet_enable(lp->rx_tasklet);=0A=
+  tasklet_enable(lp->tx_tasklet);=0A=
+=0A=
+  netif_start_queue(dev);=0A=
+=0A=
+  local_writel(ETHMAC1_re_m, &lp->eth_regs->ethmac1);=0A=
+=0A=
+  return 0; =0A=
+=0A=
+}=0A=
+static void rc32365_remove(int port_num)=0A=
+{=0A=
+	struct rc32365_if_t * bif =3D &rc32365_iflist[port_num];=0A=
+	if (bif->dev !=3D NULL) {=0A=
+		struct rc32365_local *lp =3D (struct rc32365_local =
*)bif->dev->priv;=0A=
+		if (lp !=3D NULL) {=0A=
+			if (lp->rx_tasklet) {=0A=
+				tasklet_disable(lp->rx_tasklet);=0A=
+				tasklet_kill(lp->rx_tasklet);=0A=
+				kfree(lp->rx_tasklet);=0A=
+			}=0A=
+			if (lp->tx_tasklet) {=0A=
+				tasklet_disable(lp->tx_tasklet);=0A=
+				tasklet_kill(lp->tx_tasklet);=0A=
+				kfree(lp->tx_tasklet);=0A=
+			}=0A=
+			if (lp->eth_regs)=0A=
+				iounmap((void*)lp->eth_regs);=0A=
+			if (lp->ipabmc)=0A=
+				iounmap((void*)lp->ipabmc);=0A=
+			if (lp->rx_dma_regs)=0A=
+				iounmap((void*)lp->rx_dma_regs);=0A=
+			if (lp->tx_dma_regs)=0A=
+				iounmap((void*)lp->tx_dma_regs);=0A=
+			if (lp->td_ring)=0A=
+				kfree((void*)KSEG0ADDR(lp->td_ring));=0A=
+			=0A=
+#ifdef RC32365_PROC_DEBUG=0A=
+			if (lp->ps)=0A=
+				remove_proc_entry(bif->name, proc_net);=0A=
+#endif=0A=
+		}=0A=
+		unregister_netdev(bif->dev);=0A=
+		free_netdev(bif->dev);=0A=
+		bif->dev =3D NULL;=0A=
+	}=0A=
+}=0A=
+static void __exit rc32365_cleanup_module(void)=0A=
+{=0A=
+	int i;=0A=
+	printk(KERN_ERR " Removing.\n");=0A=
+	for(i=3D0;i<CONFIG_IDT_NUM_ETH_PORTS;i++)=0A=
+		rc32365_remove(i);=0A=
+	printk(KERN_INFO DRIVER_NAME " Un-loaded.\n");=0A=
+}=0A=
+=0A=
+=0A=
+#ifndef MODULE=0A=
+=0A=
+static int __init rc32365_setup(char *options)=0A=
+{=0A=
+  /* no options yet */=0A=
+  return 1;=0A=
+}=0A=
+=0A=
+static int __init rc32365_setup_ethaddr0(char *options)=0A=
+{=0A=
+  memcpy(mac0, options, 17);=0A=
+  mac0[17]=3D '\0';=0A=
+  return 1;=0A=
+}=0A=
+=0A=
+static int __init rc32365_setup_ethaddr1(char *options)=0A=
+{=0A=
+  memcpy(mac1, options, 17);=0A=
+  mac1[17]=3D '\0';=0A=
+  return 1;=0A=
+}=0A=
+=0A=
+__setup("rc32365eth=3D", rc32365_setup);=0A=
+=0A=
+__setup("ethaddr0=3D", rc32365_setup_ethaddr0);=0A=
+__setup("ethaddr1=3D", rc32365_setup_ethaddr1);=0A=
+=0A=
+#endif /* !MODULE */=0A=
+=0A=
+module_init(rc32365_init_module);=0A=
+module_exit(rc32365_cleanup_module);=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/rc32365_eth.h =
idtlinux/drivers/net/rc32365_eth.h=0A=
--- linux-2.6.16-rc5/drivers/net/rc32365_eth.h	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/net/rc32365_eth.h	2006-03-09 16:26:00.000000000 =
-0800=0A=
@@ -0,0 +1,179 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Definitions for IDT RC32365 on-chip ethernet controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include  <asm/idt-boards/rc32300/rc32365_dma_v.h>=0A=
+#include  <asm/idt-boards/rc32300/rc32365_eth_v.h>=0A=
+#include  <asm/idt-boards/rc32300/rc32365_eth.h> =0A=
+#include  <asm/idt-boards/rc32300/rc32365_dma.h> =0A=
+#include  <asm/idt-boards/rc32300/rc32365.h> =0A=
+=0A=
+#define RC32365_DEBUG	2=0A=
+#define RC32365_PROC_DEBUG=0A=
+#undef	RC32365_DEBUG=0A=
+//#undef	RC32365_PROC_DEBUG=0A=
+=0A=
+#ifdef RC32365_DEBUG=0A=
+=0A=
+static int rc32365_debug =3D RC32365_DEBUG;=0A=
+#define ASSERT(expr) \=0A=
+	if(!(expr)) {	\=0A=
+		printk( "Assertion failed! %s,%s,%s,line=3D%d\n",	\=0A=
+		#expr,__FILE__,__FUNCTION__,__LINE__);		}=0A=
+#define DBG(lvl, format, arg...) \=0A=
+         if (rc32365_debug > lvl) printk(KERN_INFO "%s: " format, =
dev->name , ## arg)=0A=
+#else=0A=
+#define ASSERT(expr) do {} while (0)=0A=
+#define DBG(lvl, format, arg...) do {} while (0)=0A=
+#endif=0A=
+=0A=
+#define ERR(format, arg...) printk(KERN_ERR "%s: " format, dev->name , =
## arg)=0A=
+#define WARN(format, arg...) printk(KERN_WARNING "%s: " format, =
dev->name , ## arg)		=0A=
+#define INFO(format, arg...) printk(KERN_INFO "%s: " format, dev->name =
, ## arg)=0A=
+=0A=
+#define ETH0_DMA_RX_IRQ   (GROUP1_IRQ_BASE + 0)=0A=
+#define ETH0_DMA_TX_IRQ   (GROUP1_IRQ_BASE + 1)=0A=
+#define ETH0_RX_OVR_IRQ   (GROUP3_IRQ_BASE + 4)=0A=
+#define ETH0_TX_UND_IRQ   (GROUP3_IRQ_BASE + 5)=0A=
+#define ETH1_DMA_RX_IRQ   (GROUP1_IRQ_BASE + 2)=0A=
+#define ETH1_DMA_TX_IRQ   (GROUP1_IRQ_BASE + 3)=0A=
+#define ETH1_RX_OVR_IRQ   (GROUP3_IRQ_BASE + 7)=0A=
+#define ETH1_TX_UND_IRQ   (GROUP3_IRQ_BASE + 8)=0A=
+=0A=
+#define ETH0_RX_DMA_ADDR  (DMA0_PhysicalAddress + =
0*DMA_CHAN_OFFSET)=0A=
+#define ETH0_TX_DMA_ADDR  (DMA0_PhysicalAddress + =
1*DMA_CHAN_OFFSET)=0A=
+#define ETH1_RX_DMA_ADDR  (DMA0_PhysicalAddress + =
2*DMA_CHAN_OFFSET)=0A=
+#define ETH1_TX_DMA_ADDR  (DMA0_PhysicalAddress + =
3*DMA_CHAN_OFFSET)=0A=
+=0A=
+#define RC32365_NUM_RDS	 128    /* number of receive descriptors */=0A=
+#define RC32365_NUM_TDS	 128    /* number of transmit descriptors =
*/=0A=
+=0A=
+#define RC32365_RBSIZE	 1536  /* size of one resource buffer =3D Ether =
MTU */=0A=
+#define RC32365_RDS_MASK (RC32365_NUM_RDS-1)=0A=
+#define RC32365_TDS_MASK (RC32365_NUM_TDS-1)=0A=
+#define RD_RING_SIZE	 (RC32365_NUM_RDS * sizeof(struct DMAD_s))=0A=
+#define TD_RING_SIZE	 (RC32365_NUM_TDS * sizeof(struct DMAD_s))=0A=
+=0A=
+//#define RC32365_TX_TIMEOUT HZ/4=0A=
+#define RC32365_TX_TIMEOUT HZ * 100=0A=
+=0A=
+#define rc32365_eth0_regs ((ETH_t)(ETH0_VirtualAddress))=0A=
+#define rc32365_eth1_regs ((ETH_t)(ETH1_VirtualAddress))=0A=
+=0A=
+enum status	{ filled,	empty};=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+=0A=
+/* Index to functions, as function prototypes. */=0A=
+static int rc32365_open(struct net_device *dev);=0A=
+static int rc32365_send_packet(struct sk_buff *skb, struct net_device =
*dev);=0A=
+static void rc32365_mii_handler(unsigned long data);=0A=
+static irqreturn_t rc32365_ovr_interrupt(int irq, void *dev_id, struct =
pt_regs * regs);=0A=
+static irqreturn_t rc32365_und_interrupt(int irq, void *dev_id, struct =
pt_regs * regs);=0A=
+static irqreturn_t rc32365_rx_dma_interrupt(int irq, void *dev_id, =
struct pt_regs * regs);=0A=
+static irqreturn_t rc32365_tx_dma_interrupt(int irq, void *dev_id, =
struct pt_regs * regs);=0A=
+static int  rc32365_close(struct net_device *dev);=0A=
+static struct net_device_stats *rc32365_get_stats(struct net_device =
*dev);=0A=
+static void rc32365_multicast_list(struct net_device *dev);=0A=
+static int  rc32365_init(struct net_device *dev);=0A=
+static void rc32365_tx_timeout(struct net_device *dev);=0A=
+static void rc32365_rx_tasklet(unsigned long rx_data_dev);=0A=
+static void rc32365_tx_tasklet(unsigned long tx_data_dev);=0A=
+static void rc32365_cleanup_module(void);=0A=
+static int rc32365_probe(int port_num);=0A=
+=0A=
+=0A=
+/* Information that need to be kept for each board. */=0A=
+struct rc32365_local {=0A=
+	ETH_t  eth_regs;=0A=
+	DMA_Chan_t  rx_dma_regs;=0A=
+	DMA_Chan_t  tx_dma_regs;=0A=
+	IPABM_ETH_t ipabmc;=0A=
+	=0A=
+	volatile DMAD_t   td_ring; 			/* transmit descriptor ring */ =0A=
+	volatile DMAD_t   rd_ring; 			/* receive descriptor ring  */=0A=
+	=0A=
+	struct sk_buff* tx_skb[RC32365_NUM_TDS]; 	/* skbuffs for pkt to trans =
*/=0A=
+	struct sk_buff* rx_skb[RC32365_NUM_RDS]; 	/* skbuffs for pkt to trans =
*/=0A=
+	=0A=
+	struct tasklet_struct * rx_tasklet;=0A=
+	struct tasklet_struct * tx_tasklet;=0A=
+	struct tasklet_struct * ovr_tasklet;=0A=
+	=0A=
+	int	rx_next_done;=0A=
+	int	rx_chain_head;=0A=
+	int	rx_chain_tail;=0A=
+	enum status	rx_chain_status;=0A=
+	=0A=
+	int	tx_next_done;=0A=
+	int	tx_chain_head;=0A=
+	int	tx_chain_tail;=0A=
+	enum status	tx_chain_status;=0A=
+	int	tx_count;	                        /* current # of pkts waiting to =
be sent */=0A=
+	int	tx_full;=0A=
+	struct timer_list    mii_phy_timer;=0A=
+	unsigned long duplex_mode;=0A=
+	=0A=
+	int	rx_irq;=0A=
+	int	tx_irq;=0A=
+	int	ovr_irq;=0A=
+	int	und_irq;=0A=
+	=0A=
+	struct net_device_stats stats;=0A=
+	spinlock_t lock; 				=0A=
+	=0A=
+	/* debug /proc entry */=0A=
+	struct proc_dir_entry *ps;=0A=
+	int dma_halt_cnt;  int dma_run_cnt;=0A=
+};=0A=
+=0A=
+static inline void rc32365_abort_dma(struct net_device *dev, =
DMA_Chan_t ch, volatile u32 *ipabmcx)=0A=
+{=0A=
+	volatile u32 ipabmc;=0A=
+#ifdef RC32365_PROC_DEBUG=0A=
+	struct rc32365_local *lp =3D (struct rc32365_local *)dev->priv;=0A=
+#endif=0A=
+	if (local_readl(&ch->dmac) & DMAC_run_m) =0A=
+	{=0A=
+		ipabmc =3D local_readl(ipabmcx);=0A=
+		local_writel(ipabmc|0x00004000,ipabmcx);=0A=
+		local_writel(0x10, &ch->dmac); 	=0A=
+		local_writel(ipabmc,ipabmcx);=0A=
+		while (!(local_readl(&ch->dmas) & DMAS_h_m))=0A=
+			dev->trans_start =3D jiffies;			=0A=
+		local_writel(0, &ch->dmas);  =0A=
+#ifdef RC32365_PROC_DEBUG=0A=
+		lp->dma_run_cnt++;=0A=
+#endif=0A=
+	}=0A=
+	local_writel(0, &ch->dmandptr); =0A=
+	local_writel(0, &ch->dmadptr); =0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/rc32434_eth.c =
idtlinux/drivers/net/rc32434_eth.c=0A=
--- linux-2.6.16-rc5/drivers/net/rc32434_eth.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/net/rc32434_eth.c	2006-03-09 16:26:04.000000000 =
-0800=0A=
@@ -0,0 +1,1251 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Driver for the IDT RC32434/435 on-chip ethernet controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/moduleparam.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/types.h>=0A=
+#include <linux/fcntl.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/ptrace.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/proc_fs.h>=0A=
+#include <linux/in.h>=0A=
+#include <linux/slab.h>=0A=
+#include <linux/string.h>=0A=
+#include <linux/delay.h>=0A=
+#include <linux/netdevice.h>=0A=
+#include <linux/etherdevice.h>=0A=
+#include <linux/skbuff.h>=0A=
+#include <linux/errno.h>=0A=
+#include <asm/bootinfo.h>=0A=
+#include <asm/system.h>=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/pgtable.h>=0A=
+#include <asm/segment.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/dma.h>=0A=
+=0A=
+#include "rc32434_eth.h"=0A=
+=0A=
+#define DRIVER_VERSION "(mar2904)"=0A=
+=0A=
+#define DRIVER_NAME "rc32434/435 Ethernet driver. " DRIVER_VERSION=0A=
+=0A=
+=0A=
+#define STATION_ADDRESS_HIGH(dev) (((dev)->dev_addr[0] << 8) | \=0A=
+			           ((dev)->dev_addr[1]))=0A=
+#define STATION_ADDRESS_LOW(dev)  (((dev)->dev_addr[2] << 24) | \=0A=
+				   ((dev)->dev_addr[3] << 16) | \=0A=
+				   ((dev)->dev_addr[4] << 8)  | \=0A=
+				   ((dev)->dev_addr[5]))=0A=
+=0A=
+#define MII_CLOCK 1250000 				/* no more than 2.5MHz */=0A=
+static char mac0[18] =3D "08:00:06:05:40:01"; =0A=
+=0A=
+MODULE_PARM(mac0, "c18");=0A=
+MODULE_PARM_DESC(mac0, "MAC address for RC32434/435 ethernet0");=0A=
+=0A=
+static struct rc32434_if_t {=0A=
+	char *name;=0A=
+	struct net_device *dev;=0A=
+	char* mac_str;=0A=
+	int weight;=0A=
+	u32 iobase;=0A=
+	u32 rxdmabase;=0A=
+	u32 txdmabase;=0A=
+	int rx_dma_irq;=0A=
+	int tx_dma_irq;=0A=
+	int rx_ovr_irq;=0A=
+	int tx_und_irq;			=0A=
+} rc32434_iflist[] =3D =0A=
+{=0A=
+	{=0A=
+		"rc32434_eth0",      NULL,       mac0, =0A=
+		64,=0A=
+		ETH0_PhysicalAddress,=0A=
+		ETH0_RX_DMA_ADDR,=0A=
+		ETH0_TX_DMA_ADDR,=0A=
+		ETH0_DMA_RX_IRQ,=0A=
+		ETH0_DMA_TX_IRQ,=0A=
+		ETH0_RX_OVR_IRQ,=0A=
+		ETH0_TX_UND_IRQ=0A=
+	}=0A=
+};=0A=
+=0A=
+=0A=
+static int parse_mac_addr(struct net_device *dev, char* macstr)=0A=
+{=0A=
+	int i, j;=0A=
+	unsigned char result, value;=0A=
+	=0A=
+	for (i=3D0; i<6; i++) {=0A=
+		result =3D 0;=0A=
+		if (i !=3D 5 && *(macstr+2) !=3D ':') {=0A=
+			ERR("invalid mac address format: %d %c\n",=0A=
+			    i, *(macstr+2));=0A=
+			return -EINVAL;=0A=
+		}				=0A=
+		for (j=3D0; j<2; j++) {=0A=
+			if (isxdigit(*macstr) && (value =3D isdigit(*macstr) ? *macstr-'0' =
: =0A=
+						  toupper(*macstr)-'A'+10) < 16) {=0A=
+				result =3D result*16 + value;=0A=
+				macstr++;=0A=
+			} =0A=
+			else {=0A=
+				ERR("invalid mac address "=0A=
+				    "character: %c\n", *macstr);=0A=
+				return -EINVAL;=0A=
+			}=0A=
+		}=0A=
+		=0A=
+		macstr++; =0A=
+		dev->dev_addr[i] =3D result;=0A=
+	}=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+static inline void rc32434_abort_tx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	rc32434_abort_dma(dev, lp->tx_dma_regs);=0A=
+	=0A=
+}=0A=
+=0A=
+static inline void rc32434_abort_rx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	rc32434_abort_dma(dev, lp->rx_dma_regs);=0A=
+	=0A=
+}=0A=
+=0A=
+static inline void rc32434_start_tx(struct rc32434_local *lp,  =
volatile DMAD_t td)=0A=
+{=0A=
+	rc32434_start_dma(lp->tx_dma_regs, CPHYSADDR(td));=0A=
+}=0A=
+=0A=
+static inline void rc32434_start_rx(struct rc32434_local *lp, volatile =
DMAD_t rd)=0A=
+{=0A=
+	rc32434_start_dma(lp->rx_dma_regs, CPHYSADDR(rd));=0A=
+}=0A=
+=0A=
+static inline void rc32434_chain_tx(struct rc32434_local *lp, volatile =
DMAD_t td)=0A=
+{=0A=
+	rc32434_chain_dma(lp->tx_dma_regs, CPHYSADDR(td));=0A=
+}=0A=
+=0A=
+static inline void rc32434_chain_rx(struct rc32434_local *lp, volatile =
DMAD_t rd)=0A=
+{=0A=
+	rc32434_chain_dma(lp->rx_dma_regs, CPHYSADDR(rd));=0A=
+}=0A=
+=0A=
+#ifdef RC32434_PROC_DEBUG=0A=
+static int rc32434_read_proc(char *buf, char **start, off_t fpos,=0A=
+			     int length, int *eof, void *data)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)data;=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	int len =3D 0;=0A=
+	=0A=
+	/* print out header */=0A=
+	len +=3D sprintf(buf + len, "\n\tRC32434 Ethernet Debug\n\n");=0A=
+	len +=3D sprintf (buf + len,=0A=
+			"DMA halt count      =3D %10d, DMA run count =3D %10d\n",=0A=
+			lp->dma_halt_cnt, lp->dma_run_cnt);=0A=
+	=0A=
+	if (fpos >=3D len) {=0A=
+		*start =3D buf;=0A=
+		*eof =3D 1;=0A=
+		return 0;=0A=
+	}=0A=
+	*start =3D buf + fpos;=0A=
+	=0A=
+	if ((len -=3D fpos) > length) =0A=
+		return length;	=0A=
+	*eof =3D 1;=0A=
+	=0A=
+	return len;=0A=
+	=0A=
+}=0A=
+#endif=0A=
+=0A=
+=0A=
+/*=0A=
+ * Restart the RC32434 ethernet controller. =0A=
+ */=0A=
+static int rc32434_restart(struct net_device *dev)=0A=
+{=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	=0A=
+	/*=0A=
+	 * Disable interrupts=0A=
+	 */=0A=
+	disable_irq(lp->rx_irq);=0A=
+	disable_irq(lp->tx_irq);=0A=
+#ifdef	RC32434_REVISION=0A=
+	disable_irq(lp->ovr_irq);=0A=
+#endif	=0A=
+	disable_irq(lp->und_irq);=0A=
+	=0A=
+	/* Mask F E bit in Tx DMA */=0A=
+	rc32434_writel(rc32434_readl(&lp->tx_dma_regs->dmasm) | DMASM_f_m | =
DMASM_e_m, &lp->tx_dma_regs->dmasm);=0A=
+	/* Mask D H E bit in Rx DMA */=0A=
+	rc32434_writel(rc32434_readl(&lp->rx_dma_regs->dmasm) | DMASM_d_m | =
DMASM_h_m | DMASM_e_m, &lp->rx_dma_regs->dmasm);=0A=
+	=0A=
+	rc32434_init(dev);=0A=
+	rc32434_multicast_list(dev);=0A=
+	=0A=
+	enable_irq(lp->und_irq);=0A=
+#ifdef	RC32434_REVISION=0A=
+	enable_irq(lp->ovr_irq);=0A=
+#endif=0A=
+	enable_irq(lp->tx_irq);=0A=
+	enable_irq(lp->rx_irq);=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+int rc32434_init_module(void)=0A=
+{=0A=
+	printk(KERN_INFO DRIVER_NAME " \n");=0A=
+	return rc32434_probe(0);=0A=
+}=0A=
+=0A=
+static int rc32434_probe(int port_num)=0A=
+{=0A=
+	struct rc32434_if_t *bif =3D &rc32434_iflist[port_num];=0A=
+	struct rc32434_local *lp =3D NULL;=0A=
+	struct net_device *dev =3D NULL;=0A=
+	int i, retval,err;=0A=
+	=0A=
+	dev =3D alloc_etherdev(sizeof(struct rc32434_local));=0A=
+	if(!dev) {=0A=
+		ERR("rc32434_eth: alloc_etherdev failed\n");=0A=
+		return -1;=0A=
+	}=0A=
+	=0A=
+	SET_MODULE_OWNER(dev);=0A=
+	bif->dev =3D dev;=0A=
+	=0A=
+	printk("mac: %s\n", bif->mac_str);=0A=
+	if ((retval =3D parse_mac_addr(dev, bif->mac_str))) {=0A=
+		ERR("MAC address parse failed\n");=0A=
+		free_netdev(dev);=0A=
+		return -1;=0A=
+	}=0A=
+	=0A=
+	=0A=
+	/* Initialize the device structure. */=0A=
+	if (dev->priv =3D=3D NULL) {=0A=
+		lp =3D (struct rc32434_local *)kmalloc(sizeof(*lp), GFP_KERNEL);=0A=
+		memset(lp, 0, sizeof(struct rc32434_local));=0A=
+	} =0A=
+	else {=0A=
+		lp =3D (struct rc32434_local *)dev->priv;=0A=
+	}=0A=
+	=0A=
+	lp->rx_irq =3D bif->rx_dma_irq;=0A=
+	lp->tx_irq =3D bif->tx_dma_irq;=0A=
+	lp->ovr_irq =3D bif->rx_ovr_irq;=0A=
+	lp->und_irq =3D bif->tx_und_irq;=0A=
+	=0A=
+	lp->eth_regs =3D ioremap_nocache(bif->iobase, =
sizeof(*lp->eth_regs));=0A=
+=0A=
+	if (!lp->eth_regs) {=0A=
+		ERR("Can't remap eth registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	=0A=
+	lp->rx_dma_regs =3D ioremap_nocache(bif->rxdmabase, sizeof(struct =
DMA_Chan_s));=0A=
+	=0A=
+	if (!lp->rx_dma_regs) {=0A=
+		ERR("Can't remap Rx DMA registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	lp->tx_dma_regs =3D ioremap_nocache(bif->txdmabase,sizeof(struct =
DMA_Chan_s));=0A=
+	=0A=
+	if (!lp->tx_dma_regs) {=0A=
+		ERR("Can't remap Tx DMA registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	=0A=
+#ifdef RC32434_PROC_DEBUG=0A=
+	lp->ps =3D create_proc_read_entry (bif->name, 0, proc_net,=0A=
+					 rc32434_read_proc, dev);=0A=
+#endif=0A=
+	=0A=
+	lp->td_ring =3D	(DMAD_t)kmalloc(TD_RING_SIZE + RD_RING_SIZE, =
GFP_KERNEL);=0A=
+	if (!lp->td_ring) {=0A=
+		ERR("Can't allocate descriptors\n");=0A=
+		retval =3D -ENOMEM;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	=0A=
+	dma_cache_inv((unsigned long)(lp->td_ring), TD_RING_SIZE + =
RD_RING_SIZE);=0A=
+	=0A=
+	/* now convert TD_RING pointer to KSEG1 */=0A=
+	lp->td_ring =3D (DMAD_t )KSEG1ADDR(lp->td_ring);=0A=
+	lp->rd_ring =3D &lp->td_ring[RC32434_NUM_TDS];=0A=
+	=0A=
+	=0A=
+	spin_lock_init(&lp->lock);=0A=
+	=0A=
+	dev->base_addr =3D bif->iobase;=0A=
+	/* just use the rx dma irq */=0A=
+	dev->irq =3D bif->rx_dma_irq; =0A=
+	=0A=
+	dev->priv =3D lp;=0A=
+	=0A=
+	dev->open =3D rc32434_open;=0A=
+	dev->stop =3D rc32434_close;=0A=
+	dev->hard_start_xmit =3D rc32434_send_packet;=0A=
+	dev->get_stats	=3D rc32434_get_stats;=0A=
+	dev->set_multicast_list =3D &rc32434_multicast_list;=0A=
+	dev->tx_timeout =3D rc32434_tx_timeout;=0A=
+	dev->watchdog_timeo =3D RC32434_TX_TIMEOUT;=0A=
+=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+	dev->poll =3D rc32434_poll;=0A=
+	dev->weight =3D bif->weight;=0A=
+	printk("Using NAPI with weight %d\n",dev->weight);=0A=
+#else=0A=
+	lp->rx_tasklet =3D kmalloc(sizeof(struct tasklet_struct), =
GFP_KERNEL);=0A=
+	tasklet_init(lp->rx_tasklet, rc32434_rx_tasklet, (unsigned =
long)dev);=0A=
+#endif=0A=
+	lp->tx_tasklet =3D kmalloc(sizeof(struct tasklet_struct), =
GFP_KERNEL);=0A=
+	tasklet_init(lp->tx_tasklet, rc32434_tx_tasklet, (unsigned =
long)dev);=0A=
+	=0A=
+	if ((err =3D register_netdev(dev))) {=0A=
+		printk(KERN_ERR "rc32434 ethernet. Cannot register net device %d\n", =
err);=0A=
+		free_netdev(dev);=0A=
+		retval =3D -EINVAL;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	=0A=
+	INFO("Rx IRQ %d, Tx IRQ %d, ", bif->rx_dma_irq, bif->tx_dma_irq);=0A=
+	for (i =3D 0; i < 6; i++) {=0A=
+		printk("%2.2x", dev->dev_addr[i]);=0A=
+		if (i<5)=0A=
+			printk(":");=0A=
+	}=0A=
+	printk("\n");=0A=
+	=0A=
+	return 0;=0A=
+	=0A=
+ probe_err_out:=0A=
+	rc32434_cleanup_module();=0A=
+	ERR(" failed.  Returns %d\n", retval);=0A=
+	return retval;=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32434_cleanup_module(void)=0A=
+{=0A=
+	int i;=0A=
+	=0A=
+	for (i =3D 0; rc32434_iflist[i].iobase; i++) {=0A=
+		struct rc32434_if_t * bif =3D &rc32434_iflist[i];=0A=
+		if (bif->dev !=3D NULL) {=0A=
+			struct rc32434_local *lp =3D (struct rc32434_local =
*)bif->dev->priv;=0A=
+			if (lp !=3D NULL) {=0A=
+				if (lp->eth_regs)=0A=
+					iounmap((void*)lp->eth_regs);=0A=
+				if (lp->rx_dma_regs)=0A=
+					iounmap((void*)lp->rx_dma_regs);=0A=
+				if (lp->tx_dma_regs)=0A=
+					iounmap((void*)lp->tx_dma_regs);=0A=
+				if (lp->td_ring)=0A=
+					kfree((void*)KSEG0ADDR(lp->td_ring));=0A=
+				=0A=
+#ifdef RC32434_PROC_DEBUG=0A=
+				if (lp->ps) {=0A=
+					remove_proc_entry(bif->name, proc_net);=0A=
+				}=0A=
+#endif=0A=
+				kfree(lp);=0A=
+			}=0A=
+			=0A=
+			unregister_netdev(bif->dev);=0A=
+			free_netdev(bif->dev);=0A=
+			kfree(bif->dev);=0A=
+		}=0A=
+	}=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+static int rc32434_open(struct net_device *dev)=0A=
+{=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	=0A=
+	/* Initialize */=0A=
+	if (rc32434_init(dev)) {=0A=
+		ERR("Error: cannot open the Ethernet device\n");=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+	=0A=
+	/* Install the interrupt handler that handles the Done Finished Ovr =
and Und Events */	=0A=
+	if (request_irq(lp->rx_irq, &rc32434_rx_dma_interrupt,=0A=
+		  SA_SHIRQ | SA_INTERRUPT,=0A=
+			"rc32434 ethernet Rx", dev)) {=0A=
+		ERR(": unable to get Rx DMA IRQ %d\n",=0A=
+		    lp->rx_irq);=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+	if (request_irq(lp->tx_irq, &rc32434_tx_dma_interrupt,=0A=
+		  SA_SHIRQ | SA_INTERRUPT,=0A=
+			"rc32434 ethernet Tx", dev)) {=0A=
+		ERR(": unable to get Tx DMA IRQ %d\n",=0A=
+		    lp->tx_irq);=0A=
+		free_irq(lp->rx_irq, dev);=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+	=0A=
+#ifdef	RC32434_REVISION=0A=
+	/* Install handler for overrun error. */=0A=
+	if (request_irq(lp->ovr_irq, &rc32434_ovr_interrupt,=0A=
+			SA_SHIRQ | SA_INTERRUPT,=0A=
+			"Ethernet Overflow", dev)) {=0A=
+		ERR(": unable to get OVR IRQ %d\n",=0A=
+		    lp->ovr_irq);=0A=
+		free_irq(lp->rx_irq, dev);=0A=
+		free_irq(lp->tx_irq, dev);=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+#endif=0A=
+	=0A=
+	/* Install handler for underflow error. */=0A=
+	if (request_irq(lp->und_irq, &rc32434_und_interrupt,=0A=
+			SA_SHIRQ | SA_INTERRUPT,=0A=
+			"Ethernet Underflow", dev)) {=0A=
+		ERR(": unable to get UND IRQ %d\n",=0A=
+		    lp->und_irq);=0A=
+		free_irq(lp->rx_irq, dev);=0A=
+		free_irq(lp->tx_irq, dev);=0A=
+#ifdef	RC32434_REVISION		=0A=
+		free_irq(lp->ovr_irq, dev);		=0A=
+#endif=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+	=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+static int rc32434_close(struct net_device *dev)=0A=
+{=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	u32 tmp;=0A=
+	=0A=
+	/* Disable interrupts */=0A=
+	disable_irq(lp->rx_irq);=0A=
+	disable_irq(lp->tx_irq);=0A=
+#ifdef	RC32434_REVISION=0A=
+	disable_irq(lp->ovr_irq);=0A=
+#endif=0A=
+	disable_irq(lp->und_irq);=0A=
+	=0A=
+	tmp =3D rc32434_readl(&lp->tx_dma_regs->dmasm);=0A=
+	tmp =3D tmp | DMASM_f_m | DMASM_e_m;=0A=
+	rc32434_writel(tmp, &lp->tx_dma_regs->dmasm);=0A=
+	=0A=
+	tmp =3D rc32434_readl(&lp->rx_dma_regs->dmasm);=0A=
+	tmp =3D tmp | DMASM_d_m | DMASM_h_m | DMASM_e_m;=0A=
+	rc32434_writel(tmp, &lp->rx_dma_regs->dmasm);=0A=
+	=0A=
+	free_irq(lp->rx_irq, dev);=0A=
+	free_irq(lp->tx_irq, dev);=0A=
+#ifdef	RC32434_REVISION	=0A=
+	free_irq(lp->ovr_irq, dev);=0A=
+#endif=0A=
+	free_irq(lp->und_irq, dev);=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+/* transmit packet */=0A=
+static int rc32434_send_packet(struct sk_buff *skb, struct net_device =
*dev)=0A=
+{=0A=
+	struct rc32434_local		*lp =3D (struct rc32434_local *)dev->priv;=0A=
+	unsigned long 			flags;=0A=
+	u32					length;=0A=
+	DMAD_t				td;=0A=
+	=0A=
+	=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+	=0A=
+	td =3D &lp->td_ring[lp->tx_chain_tail];=0A=
+	=0A=
+	/* stop queue when full, drop pkts if queue already full */=0A=
+	if(lp->tx_count >=3D (RC32434_NUM_TDS - 2)) {=0A=
+		lp->tx_full =3D 1;=0A=
+		=0A=
+		if(lp->tx_count =3D=3D (RC32434_NUM_TDS - 2)) {=0A=
+			netif_stop_queue(dev);=0A=
+		}=0A=
+		else {=0A=
+			lp->stats.tx_dropped++;=0A=
+			dev_kfree_skb_any(skb);=0A=
+			spin_unlock_irqrestore(&lp->lock, flags);=0A=
+			return 1;=0A=
+		}	   =0A=
+	}	 =0A=
+	=0A=
+	lp->tx_count ++;=0A=
+	=0A=
+	lp->tx_skb[lp->tx_chain_tail] =3D skb;=0A=
+	=0A=
+	length =3D skb->len;=0A=
+	=0A=
+	/* Setup the transmit descriptor. */=0A=
+	td->ca =3D CPHYSADDR(skb->data);=0A=
+	=0A=
+	if(rc32434_readl(&(lp->tx_dma_regs->dmandptr)) =3D=3D 0) {=0A=
+		if( lp->tx_chain_status =3D=3D empty ) {=0A=
+			td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /*  Update tail      */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32434_TDS_MASK;   =
                       /*   Move tail       */=0A=
+			rc32434_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR    */=0A=
+			lp->tx_chain_head =3D lp->tx_chain_tail;                            =
                      /* Move head to tail */=0A=
+		}=0A=
+		else {=0A=
+			td->control =3D DMA_COUNT(length) |DMAD_cof_m|DMAD_iof_m;           =
                      /* Update tail */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32434_TDS_MASK].control &=3D  =
~(DMAD_cof_m);          /* Link to prev */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32434_TDS_MASK].link =3D  =
CPHYSADDR(td);              /* Link to prev */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32434_TDS_MASK;   =
                       /* Move tail */=0A=
+			rc32434_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR */=0A=
+			lp->tx_chain_head =3D lp->tx_chain_tail;                            =
                      /* Move head to tail */=0A=
+			lp->tx_chain_status =3D empty;=0A=
+		}=0A=
+	}=0A=
+	else {=0A=
+		if( lp->tx_chain_status =3D=3D empty ) {=0A=
+			td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /* Update tail */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32434_TDS_MASK;   =
                       /* Move tail */=0A=
+			lp->tx_chain_status =3D filled;=0A=
+		}=0A=
+		else {=0A=
+			td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /* Update tail */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32434_TDS_MASK].control &=3D  =
~(DMAD_cof_m);          /* Link to prev */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32434_TDS_MASK].link =3D  =
CPHYSADDR(td);              /* Link to prev */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32434_TDS_MASK;   =
                       /* Move tail */=0A=
+		}=0A=
+	}=0A=
+	=0A=
+	dev->trans_start =3D jiffies;				=0A=
+	=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+//Experimental, not enabled yet=0A=
+=0A=
+#if 0=0A=
+/* Ethernet MII-PHY Handler */=0A=
+static void rc32434_mii_handler(unsigned long data)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)data;		=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	unsigned long 	flags;=0A=
+	unsigned long duplex_status;=0A=
+	int port_addr =3D (lp->rx_irq =3D=3D 0x2c? 1:0) << 8;=0A=
+	=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+	=0A=
+	/* Two ports are using the same MII, the difference is the PHY =
address */=0A=
+	rc32434_writel(0, &rc32434_eth0_regs->miimcfg);  =0A=
+	rc32434_writel(0, &rc32434_eth0_regs->miimcmd);  =0A=
+	rc32434_writel(port_addr |0x05, &rc32434_eth0_regs->miimaddr);  =0A=
+	rc32434_writel(MIIMCMD_scn_m, &rc32434_eth0_regs->miimcmd);  =0A=
+	while(rc32434_readl(&rc32434_eth0_regs->miimind) & MIIMIND_nv_m);=0A=
+	=0A=
+	ERR("irq:%x		port_addr:%x	RDD:%x\n", =0A=
+	    lp->rx_irq, port_addr, =
rc32434_readl(&rc32434_eth0_regs->miimrdd));=0A=
+	duplex_status =3D (rc32434_readl(&rc32434_eth0_regs->miimrdd) & =
0x140)? ETHMAC2_fd_m: 0;=0A=
+	if(duplex_status !=3D lp->duplex_mode) {=0A=
+		ERR("The MII-PHY is Auto-negotiated to %s-Duplex mode for Eth-%x\n", =
duplex_status? "Full":"Half", lp->rx_irq =3D=3D 0x2c? 1:0);		=0A=
+		lp->duplex_mode =3D duplex_status;=0A=
+		rc32434_restart(dev);		=0A=
+	}=0A=
+	=0A=
+	lp->mii_phy_timer.expires =3D jiffies + 10 * HZ;	=0A=
+	add_timer(&lp->mii_phy_timer);=0A=
+	=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+}=0A=
+#endif=0A=
+=0A=
+=0A=
+#ifdef	RC32434_REVISION	=0A=
+/* Ethernet Rx Overflow interrupt */=0A=
+static irqreturn_t=0A=
+rc32434_ovr_interrupt(int irq, void *dev_id, struct pt_regs * regs)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+	struct rc32434_local *lp;=0A=
+	unsigned int ovr;=0A=
+	irqreturn_t retval =3D IRQ_NONE;=0A=
+	=0A=
+	ASSERT(dev !=3D NULL);=0A=
+	=0A=
+	lp =3D (struct rc32434_local *)dev->priv;=0A=
+	spin_lock(&lp->lock);=0A=
+	ovr =3D rc32434_readl(&lp->eth_regs->ethintfc);=0A=
+	=0A=
+	if(ovr & ETHINTFC_ovr_m) {=0A=
+		netif_stop_queue(dev);=0A=
+		=0A=
+		/* clear OVR bit */=0A=
+		rc32434_writel((ovr & ~ETHINTFC_ovr_m), &lp->eth_regs->ethintfc);=0A=
+		=0A=
+		/* Restart interface */=0A=
+		rc32434_restart(dev);=0A=
+		retval =3D IRQ_HANDLED;=0A=
+	}=0A=
+	spin_unlock(&lp->lock);=0A=
+	=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+#endif=0A=
+=0A=
+=0A=
+/* Ethernet Tx Underflow interrupt */=0A=
+static irqreturn_t=0A=
+rc32434_und_interrupt(int irq, void *dev_id, struct pt_regs * regs)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+	struct rc32434_local *lp;=0A=
+	unsigned int und;=0A=
+	irqreturn_t retval =3D IRQ_NONE;=0A=
+	=0A=
+	ASSERT(dev !=3D NULL);=0A=
+	=0A=
+	lp =3D (struct rc32434_local *)dev->priv;=0A=
+	=0A=
+	spin_lock(&lp->lock);=0A=
+	=0A=
+	und =3D rc32434_readl(&lp->eth_regs->ethintfc);=0A=
+	=0A=
+	if(und & ETHINTFC_und_m) {=0A=
+		netif_stop_queue(dev);=0A=
+		=0A=
+		rc32434_writel((und & ~ETHINTFC_und_m), &lp->eth_regs->ethintfc);=0A=
+		=0A=
+		/* Restart interface */=0A=
+		rc32434_restart(dev);=0A=
+		retval =3D IRQ_HANDLED;=0A=
+	}=0A=
+	=0A=
+	spin_unlock(&lp->lock);=0A=
+	=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+=0A=
+/* Ethernet Rx DMA interrupt */=0A=
+static irqreturn_t=0A=
+rc32434_rx_dma_interrupt(int irq, void *dev_id, struct pt_regs * =
regs)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+	struct rc32434_local* lp;=0A=
+	volatile u32 dmas,dmasm;=0A=
+	irqreturn_t retval;=0A=
+	=0A=
+	ASSERT(dev !=3D NULL);=0A=
+	=0A=
+	lp =3D (struct rc32434_local *)dev->priv;=0A=
+	=0A=
+	spin_lock(&lp->lock);=0A=
+	dmas =3D rc32434_readl(&lp->rx_dma_regs->dmas);=0A=
+	if(dmas & (DMAS_d_m|DMAS_h_m|DMAS_e_m)) {=0A=
+		/* Mask D H E bit in Rx DMA */=0A=
+		dmasm =3D rc32434_readl(&lp->rx_dma_regs->dmasm);=0A=
+		rc32434_writel(dmasm | (DMASM_d_m | DMASM_h_m | DMASM_e_m), =
&lp->rx_dma_regs->dmasm);=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+		if(netif_rx_schedule_prep(dev))=0A=
+                        __netif_rx_schedule(dev);=0A=
+#else=0A=
+		tasklet_hi_schedule(lp->rx_tasklet);=0A=
+#endif=0A=
+		=0A=
+		if (dmas & DMAS_e_m)=0A=
+			ERR(": DMA error\n");=0A=
+		=0A=
+		retval =3D IRQ_HANDLED;=0A=
+	}=0A=
+	else=0A=
+		retval =3D IRQ_NONE;=0A=
+	=0A=
+	spin_unlock(&lp->lock);=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+static int rc32434_poll(struct net_device *rx_data_dev, int =
*budget)=0A=
+#else=0A=
+static void rc32434_rx_tasklet(unsigned long rx_data_dev)=0A=
+#endif=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)rx_data_dev;	=0A=
+	struct rc32434_local* lp =3D netdev_priv(dev);=0A=
+	volatile DMAD_t  rd =3D &lp->rd_ring[lp->rx_next_done];=0A=
+	struct sk_buff *skb, *skb_new;=0A=
+	u8* pkt_buf;=0A=
+	u32 devcs, count, pkt_len, pktuncrc_len;=0A=
+	volatile u32 dmas;=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+	u32 received =3D 0;=0A=
+	int rx_work_limit =3D min(*budget,dev->quota);=0A=
+#else=0A=
+	unsigned long 	flags;=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+#endif=0A=
+	=0A=
+	while ( (count =3D RC32434_RBSIZE - (u32)DMA_COUNT(rd->control)) !=3D =
0) {=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+		if(--rx_work_limit <0)=0A=
+                {=0A=
+                        break;=0A=
+                }=0A=
+#endif=0A=
+		/* init the var. used for the later operations within the while loop =
*/=0A=
+		skb_new =3D NULL;=0A=
+		devcs =3D rd->devcs;=0A=
+		pkt_len =3D RCVPKT_LENGTH(devcs);=0A=
+		skb =3D lp->rx_skb[lp->rx_next_done];=0A=
+      =0A=
+		if (count < 64) {=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;			=0A=
+		}=0A=
+		else if ((devcs & ( ETHRX_ld_m)) !=3D	ETHRX_ld_m) {=0A=
+			/* check that this is a whole packet */=0A=
+			/* WARNING: DMA_FD bit incorrectly set in Rc32434 (errata ref #077) =
*/=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+		}=0A=
+		else if ( (devcs & ETHRX_rok_m)  ) {=0A=
+			=0A=
+			{=0A=
+				/* must be the (first and) last descriptor then */=0A=
+				pkt_buf =3D (u8*)lp->rx_skb[lp->rx_next_done]->data;=0A=
+				=0A=
+				pktuncrc_len =3D pkt_len - 4;=0A=
+				/* invalidate the cache */=0A=
+				dma_cache_inv((unsigned long)pkt_buf, pktuncrc_len);=0A=
+				=0A=
+				/* Malloc up new buffer. */					  =0A=
+				skb_new =3D dev_alloc_skb(RC32434_RBSIZE + 2);					             	=
=0A=
+				=0A=
+				if (skb_new !=3D NULL){=0A=
+					/* Make room */=0A=
+					skb_put(skb, pktuncrc_len);		    =0A=
+					=0A=
+					skb->protocol =3D eth_type_trans(skb, dev);=0A=
+					=0A=
+					/* pass the packet to upper layers */=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+					netif_receive_skb(skb);=0A=
+#else=0A=
+					netif_rx(skb);=0A=
+#endif=0A=
+					=0A=
+					dev->last_rx =3D jiffies;=0A=
+					lp->stats.rx_packets++;=0A=
+					lp->stats.rx_bytes +=3D pktuncrc_len;=0A=
+					=0A=
+					if (IS_RCV_MP(devcs))=0A=
+						lp->stats.multicast++;=0A=
+					=0A=
+					/* 16 bit align */						  =0A=
+					skb_reserve(skb_new, 2);	=0A=
+					=0A=
+					skb_new->dev =3D dev;=0A=
+					lp->rx_skb[lp->rx_next_done] =3D skb_new;=0A=
+				}=0A=
+				else {=0A=
+					ERR("no memory, dropping rx packet.\n");=0A=
+					lp->stats.rx_errors++;		=0A=
+					lp->stats.rx_dropped++;					=0A=
+				}=0A=
+			}=0A=
+			=0A=
+		}			=0A=
+		else {=0A=
+			/* This should only happen if we enable accepting broken packets =
*/=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+			=0A=
+			/* add statistics counters */=0A=
+			if (IS_RCV_CRC_ERR(devcs)) {=0A=
+				DBG(2, "RX CRC error\n");=0A=
+				lp->stats.rx_crc_errors++;=0A=
+			} =0A=
+			else if (IS_RCV_LOR_ERR(devcs)) {=0A=
+				DBG(2, "RX LOR error\n");=0A=
+				lp->stats.rx_length_errors++;=0A=
+			}				=0A=
+			else if (IS_RCV_LE_ERR(devcs)) {=0A=
+				DBG(2, "RX LE error\n");=0A=
+				lp->stats.rx_length_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_OVR_ERR(devcs)) {=0A=
+				lp->stats.rx_over_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_CV_ERR(devcs)) {=0A=
+				/* code violation */=0A=
+				DBG(2, "RX CV error\n");=0A=
+				lp->stats.rx_frame_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_CES_ERR(devcs)) {=0A=
+				DBG(2, "RX Preamble error\n");=0A=
+			}=0A=
+		}=0A=
+		=0A=
+		rd->devcs =3D 0;=0A=
+		=0A=
+		/* restore descriptor's curr_addr */=0A=
+		if(skb_new)=0A=
+			rd->ca =3D CPHYSADDR(skb_new->data); =0A=
+		else=0A=
+			rd->ca =3D CPHYSADDR(skb->data);=0A=
+		=0A=
+		rd->control =3D DMA_COUNT(RC32434_RBSIZE) |DMAD_cod_m =
|DMAD_iod_m;=0A=
+		lp->rd_ring[(lp->rx_next_done-1)& RC32434_RDS_MASK].control &=3D  =
~(DMAD_cod_m); 	=0A=
+		=0A=
+		lp->rx_next_done =3D (lp->rx_next_done + 1) & RC32434_RDS_MASK;=0A=
+		rd =3D &lp->rd_ring[lp->rx_next_done];=0A=
+		rc32434_writel( ~DMAS_d_m, &lp->rx_dma_regs->dmas);=0A=
+	}	=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+        dev->quota -=3D received;=0A=
+        *budget =3D- received;=0A=
+        if(rx_work_limit < 0)=0A=
+                goto not_done;=0A=
+#endif=0A=
+	=0A=
+	dmas =3D rc32434_readl(&lp->rx_dma_regs->dmas);=0A=
+	=0A=
+	if(dmas & DMAS_h_m) {=0A=
+		rc32434_writel( ~(DMAS_h_m | DMAS_e_m), &lp->rx_dma_regs->dmas);=0A=
+#ifdef RC32434_PROC_DEBUG=0A=
+		lp->dma_halt_cnt++;=0A=
+#endif=0A=
+		rd->devcs =3D 0;=0A=
+		skb =3D lp->rx_skb[lp->rx_next_done];=0A=
+		rd->ca =3D CPHYSADDR(skb->data);=0A=
+		rc32434_chain_rx(lp,rd);=0A=
+	}=0A=
+	=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+	netif_rx_complete(dev);=0A=
+#endif=0A=
+	/* Enable D H E bit in Rx DMA */=0A=
+	rc32434_writel(rc32434_readl(&lp->rx_dma_regs->dmasm) & ~(DMASM_d_m | =
DMASM_h_m |DMASM_e_m), &lp->rx_dma_regs->dmasm); =0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+	return 0;=0A=
+ not_done:=0A=
+	return 1;=0A=
+#else=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	return;=0A=
+#endif=0A=
+=0A=
+	=0A=
+}	=0A=
+=0A=
+=0A=
+=0A=
+/* Ethernet Tx DMA interrupt */=0A=
+static irqreturn_t=0A=
+rc32434_tx_dma_interrupt(int irq, void *dev_id, struct pt_regs * =
regs)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+	struct rc32434_local *lp;=0A=
+	volatile u32 dmas,dmasm;=0A=
+	irqreturn_t retval;=0A=
+	=0A=
+	ASSERT(dev !=3D NULL);=0A=
+	=0A=
+	lp =3D (struct rc32434_local *)dev->priv;=0A=
+	=0A=
+	spin_lock(&lp->lock);=0A=
+	=0A=
+	dmas =3D rc32434_readl(&lp->tx_dma_regs->dmas);=0A=
+	=0A=
+	if (dmas & (DMAS_f_m | DMAS_e_m)) {=0A=
+		dmasm =3D rc32434_readl(&lp->tx_dma_regs->dmasm);=0A=
+		/* Mask F E bit in Tx DMA */=0A=
+		rc32434_writel(dmasm | (DMASM_f_m | DMASM_e_m), =
&lp->tx_dma_regs->dmasm);=0A=
+		=0A=
+		tasklet_hi_schedule(lp->tx_tasklet);=0A=
+		=0A=
+		if(lp->tx_chain_status =3D=3D filled && =
(rc32434_readl(&(lp->tx_dma_regs->dmandptr)) =3D=3D 0)) {=0A=
+			rc32434_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr));			=0A=
+			lp->tx_chain_status =3D empty;=0A=
+			lp->tx_chain_head =3D lp->tx_chain_tail;=0A=
+			dev->trans_start =3D jiffies;=0A=
+		}=0A=
+		=0A=
+		if (dmas & DMAS_e_m)=0A=
+			ERR(": DMA error\n");=0A=
+		=0A=
+		retval =3D IRQ_HANDLED;=0A=
+	}=0A=
+	else=0A=
+		retval =3D IRQ_NONE;=0A=
+	=0A=
+	spin_unlock(&lp->lock);=0A=
+	=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32434_tx_tasklet(unsigned long tx_data_dev)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)tx_data_dev;	=0A=
+	struct rc32434_local* lp =3D (struct rc32434_local *)dev->priv;=0A=
+	volatile DMAD_t td =3D &lp->td_ring[lp->tx_next_done];=0A=
+	u32 devcs;=0A=
+	unsigned long 	flags;=0A=
+	volatile u32 dmas;=0A=
+	=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+	=0A=
+	/* process all desc that are done */=0A=
+	while(IS_DMA_FINISHED(td->control)) {=0A=
+		if(lp->tx_full =3D=3D 1) {=0A=
+			netif_wake_queue(dev);=0A=
+			lp->tx_full =3D 0;=0A=
+		}=0A=
+		=0A=
+		devcs =3D lp->td_ring[lp->tx_next_done].devcs;    =0A=
+		if ((devcs & (ETHTX_fd_m | ETHTX_ld_m)) !=3D (ETHTX_fd_m | =
ETHTX_ld_m)) {=0A=
+			lp->stats.tx_errors++;=0A=
+			lp->stats.tx_dropped++;				=0A=
+			=0A=
+			/* should never happen */=0A=
+			DBG(1, __FUNCTION__ ": split tx ignored\n");=0A=
+		}=0A=
+		else if (IS_TX_TOK(devcs)) {=0A=
+			lp->stats.tx_packets++;=0A=
+		}=0A=
+		else {=0A=
+			lp->stats.tx_errors++;=0A=
+			lp->stats.tx_dropped++;				=0A=
+			=0A=
+			/* underflow */=0A=
+			if (IS_TX_UND_ERR(devcs)) =0A=
+				lp->stats.tx_fifo_errors++;=0A=
+			=0A=
+			/* oversized frame */=0A=
+			if (IS_TX_OF_ERR(devcs))=0A=
+				lp->stats.tx_aborted_errors++;=0A=
+			=0A=
+			/* excessive deferrals */=0A=
+			if (IS_TX_ED_ERR(devcs))=0A=
+				lp->stats.tx_carrier_errors++;=0A=
+			=0A=
+			/* collisions: medium busy */=0A=
+			if (IS_TX_EC_ERR(devcs))=0A=
+				lp->stats.collisions++;=0A=
+			=0A=
+			/* late collision */=0A=
+			if (IS_TX_LC_ERR(devcs))=0A=
+				lp->stats.tx_window_errors++;=0A=
+			=0A=
+		}=0A=
+		=0A=
+		/* We must always free the original skb */=0A=
+		if (lp->tx_skb[lp->tx_next_done] !=3D NULL) {=0A=
+			dev_kfree_skb_any(lp->tx_skb[lp->tx_next_done]);=0A=
+			lp->tx_skb[lp->tx_next_done] =3D NULL;=0A=
+		}=0A=
+		=0A=
+		lp->td_ring[lp->tx_next_done].control =3D DMAD_iof_m;=0A=
+		lp->td_ring[lp->tx_next_done].devcs =3D ETHTX_fd_m | ETHTX_ld_m;	=0A=
+		lp->td_ring[lp->tx_next_done].link =3D 0;=0A=
+		lp->td_ring[lp->tx_next_done].ca =3D 0;=0A=
+		lp->tx_count --;=0A=
+		=0A=
+		/* go on to next transmission */=0A=
+		lp->tx_next_done =3D (lp->tx_next_done + 1) & RC32434_TDS_MASK;=0A=
+		td =3D &lp->td_ring[lp->tx_next_done];=0A=
+		=0A=
+	}=0A=
+	=0A=
+	dmas =3D rc32434_readl(&lp->tx_dma_regs->dmas);=0A=
+	rc32434_writel( ~dmas, &lp->tx_dma_regs->dmas);=0A=
+	=0A=
+	/* Enable F E bit in Tx DMA */=0A=
+	rc32434_writel(rc32434_readl(&lp->tx_dma_regs->dmasm) & ~(DMASM_f_m | =
DMASM_e_m), &lp->tx_dma_regs->dmasm); =0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+static struct net_device_stats * rc32434_get_stats(struct net_device =
*dev)=0A=
+{=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	return &lp->stats;=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Set or clear the multicast filter for this adaptor.=0A=
+ */=0A=
+static void rc32434_multicast_list(struct net_device *dev)=0A=
+{   =0A=
+	/* listen to broadcasts always and to treat 	*/=0A=
+	/*       IFF bits independantly	*/=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	unsigned long flags;=0A=
+	u32 recognise =3D ETHARC_ab_m; 		/* always accept broadcasts */=0A=
+	=0A=
+	if (dev->flags & IFF_PROMISC)         		/* set promiscuous mode */=0A=
+		recognise |=3D ETHARC_pro_m;=0A=
+	=0A=
+	if ((dev->flags & IFF_ALLMULTI) || (dev->mc_count > 15))=0A=
+		recognise |=3D ETHARC_am_m;    	  	/* all multicast & bcast */=0A=
+	else if (dev->mc_count > 0) {=0A=
+		DBG(2, __FUNCTION__ ": mc_count %d\n", dev->mc_count);=0A=
+		recognise |=3D ETHARC_am_m;    	  	/* for the time being */=0A=
+	}=0A=
+	=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+	rc32434_writel(recognise, &lp->eth_regs->etharc);=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32434_tx_timeout(struct net_device *dev)=0A=
+{=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	unsigned long flags;=0A=
+	=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+	rc32434_restart(dev);=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Initialize the RC32434 ethernet controller.=0A=
+ */=0A=
+static int rc32434_init(struct net_device *dev)=0A=
+{=0A=
+	struct rc32434_local *lp =3D (struct rc32434_local *)dev->priv;=0A=
+	int i, j;=0A=
+	=0A=
+	/* Disable DMA */       =0A=
+	rc32434_abort_tx(dev);=0A=
+	rc32434_abort_rx(dev); =0A=
+	=0A=
+	/* reset ethernet logic */ =0A=
+	rc32434_writel(0, &lp->eth_regs->ethintfc);=0A=
+	while((rc32434_readl(&lp->eth_regs->ethintfc) & ETHINTFC_rip_m))=0A=
+		dev->trans_start =3D jiffies;	=0A=
+	=0A=
+	/* Enable Ethernet Interface */ =0A=
+	rc32434_writel(ETHINTFC_en_m, &lp->eth_regs->ethintfc); =0A=
+	=0A=
+#ifndef CONFIG_IDT_USE_NAPI=0A=
+	tasklet_disable(lp->rx_tasklet);=0A=
+#endif=0A=
+	tasklet_disable(lp->tx_tasklet);=0A=
+	=0A=
+	/* Initialize the transmit Descriptors */=0A=
+	for (i =3D 0; i < RC32434_NUM_TDS; i++) {=0A=
+		lp->td_ring[i].control =3D DMAD_iof_m;=0A=
+		lp->td_ring[i].devcs =3D ETHTX_fd_m | ETHTX_ld_m;=0A=
+		lp->td_ring[i].ca =3D 0;=0A=
+		lp->td_ring[i].link =3D 0;=0A=
+		if (lp->tx_skb[i] !=3D NULL) {=0A=
+			dev_kfree_skb_any(lp->tx_skb[i]);=0A=
+			lp->tx_skb[i] =3D NULL;=0A=
+		}=0A=
+	}=0A=
+	lp->tx_next_done =3D lp->tx_chain_head =3D lp->tx_chain_tail =3D 	=
lp->tx_full =3D lp->tx_count =3D 0;=0A=
+	lp->	tx_chain_status =3D empty;=0A=
+	=0A=
+	/*=0A=
+	 * Initialize the receive descriptors so that they=0A=
+	 * become a circular linked list, ie. let the last=0A=
+	 * descriptor point to the first again.=0A=
+	 */=0A=
+	for (i=3D0; i<RC32434_NUM_RDS; i++) {=0A=
+		struct sk_buff *skb =3D lp->rx_skb[i];=0A=
+		=0A=
+		if (lp->rx_skb[i] =3D=3D NULL) {=0A=
+			skb =3D dev_alloc_skb(RC32434_RBSIZE + 2);=0A=
+			if (skb =3D=3D NULL) {=0A=
+				ERR("No memory in the system\n");=0A=
+				for (j =3D 0; j < RC32434_NUM_RDS; j ++)=0A=
+					if (lp->rx_skb[j] !=3D NULL) =0A=
+						dev_kfree_skb_any(lp->rx_skb[j]);=0A=
+				=0A=
+				return 1;=0A=
+			}=0A=
+			else {=0A=
+				skb->dev =3D dev;=0A=
+				skb_reserve(skb, 2);=0A=
+				lp->rx_skb[i] =3D skb;=0A=
+				lp->rd_ring[i].ca =3D CPHYSADDR(skb->data); =0A=
+				=0A=
+			}=0A=
+		}=0A=
+		lp->rd_ring[i].control =3D	DMAD_iod_m | =
DMA_COUNT(RC32434_RBSIZE);=0A=
+		lp->rd_ring[i].devcs =3D 0;=0A=
+		lp->rd_ring[i].ca =3D CPHYSADDR(skb->data);=0A=
+		lp->rd_ring[i].link =3D CPHYSADDR(&lp->rd_ring[i+1]);=0A=
+		=0A=
+	}=0A=
+	/* loop back */=0A=
+	lp->rd_ring[RC32434_NUM_RDS-1].link =3D =
CPHYSADDR(&lp->rd_ring[0]);=0A=
+	lp->rx_next_done   =3D 0;=0A=
+	=0A=
+	lp->rd_ring[RC32434_NUM_RDS-1].control |=3D DMAD_cod_m;=0A=
+	lp->rx_chain_head =3D 0;=0A=
+	lp->rx_chain_tail =3D 0;=0A=
+	lp->rx_chain_status =3D empty;=0A=
+	=0A=
+	rc32434_writel(0, &lp->rx_dma_regs->dmas);=0A=
+	/* Start Rx DMA */=0A=
+	rc32434_start_rx(lp, &lp->rd_ring[0]);=0A=
+	=0A=
+	/* Enable F E bit in Tx DMA */=0A=
+	rc32434_writel(rc32434_readl(&lp->tx_dma_regs->dmasm) & ~(DMASM_f_m | =
DMASM_e_m), &lp->tx_dma_regs->dmasm); =0A=
+	/* Enable D H E bit in Rx DMA */=0A=
+	rc32434_writel(rc32434_readl(&lp->rx_dma_regs->dmasm) & ~(DMASM_d_m | =
DMASM_h_m | DMASM_e_m), &lp->rx_dma_regs->dmasm); =0A=
+	=0A=
+	/* Accept only packets destined for this Ethernet device address =
*/=0A=
+	rc32434_writel(ETHARC_ab_m, &lp->eth_regs->etharc); =0A=
+	=0A=
+	/* Set all Ether station address registers to their initial values */ =
=0A=
+	rc32434_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal0); =0A=
+	rc32434_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah0);=0A=
+	=0A=
+	rc32434_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal1); =0A=
+	rc32434_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah1);=0A=
+	=0A=
+	rc32434_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal2); =0A=
+	rc32434_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah2);=0A=
+	=0A=
+	rc32434_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal3); =0A=
+	rc32434_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah3); =
=0A=
+	=0A=
+	=0A=
+	/* Frame Length Checking, Pad Enable, CRC Enable, Full Duplex set */ =
=0A=
+	rc32434_writel(ETHMAC2_pe_m | ETHMAC2_cen_m | ETHMAC2_fd_m, =
&lp->eth_regs->ethmac2);  =0A=
+	//ETHMAC2_flc_m		ETHMAC2_fd_m	lp->duplex_mode=0A=
+	=0A=
+	/* Back to back inter-packet-gap */ =0A=
+	rc32434_writel(0x15, &lp->eth_regs->ethipgt); =0A=
+	/* Non - Back to back inter-packet-gap */ =0A=
+	rc32434_writel(0x12, &lp->eth_regs->ethipgr); =0A=
+	=0A=
+	/* Management Clock Prescaler Divisor */=0A=
+	/* Clock independent setting */=0A=
+	rc32434_writel(((idt_cpu_freq)/MII_CLOCK+1) & ~1,=0A=
+		       &lp->eth_regs->ethmcp);=0A=
+	=0A=
+	/* don't transmit until fifo contains 48b */=0A=
+	rc32434_writel(48, &lp->eth_regs->ethfifott);=0A=
+	=0A=
+	rc32434_writel(ETHMAC1_re_m, &lp->eth_regs->ethmac1);=0A=
+	=0A=
+#ifndef CONFIG_IDT_USE_NAPI=0A=
+	tasklet_enable(lp->rx_tasklet);=0A=
+#endif=0A=
+	tasklet_enable(lp->tx_tasklet);=0A=
+	=0A=
+	netif_start_queue(dev);=0A=
+	=0A=
+	=0A=
+	return 0; =0A=
+	=0A=
+}=0A=
+=0A=
+=0A=
+#ifndef MODULE=0A=
+=0A=
+static int __init rc32434_setup(char *options)=0A=
+{=0A=
+	/* no options yet */=0A=
+	return 1;=0A=
+}=0A=
+=0A=
+static int __init rc32434_setup_ethaddr0(char *options)=0A=
+{=0A=
+	memcpy(mac0, options, 17);=0A=
+	mac0[17]=3D '\0';=0A=
+	return 1;=0A=
+}=0A=
+=0A=
+__setup("rc32434eth=3D", rc32434_setup);=0A=
+__setup("ethaddr0=3D", rc32434_setup_ethaddr0);=0A=
+=0A=
+=0A=
+#endif /* MODULE */=0A=
+=0A=
+module_init(rc32434_init_module);=0A=
+module_exit(rc32434_cleanup_module);=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/rc32434_eth.h =
idtlinux/drivers/net/rc32434_eth.h=0A=
--- linux-2.6.16-rc5/drivers/net/rc32434_eth.h	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/net/rc32434_eth.h	2006-03-09 16:26:06.000000000 =
-0800=0A=
@@ -0,0 +1,178 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Definitions for IDT RC32434 on-chip ethernet controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#include  <asm/idt-boards/rc32434/rc32434.h>=0A=
+#include  <asm/idt-boards/rc32434/rc32434_dma_v.h>=0A=
+#include  <asm/idt-boards/rc32434/rc32434_eth_v.h>=0A=
+=0A=
+=0A=
+#define RC32434_DEBUG	2=0A=
+//#define RC32434_PROC_DEBUG=0A=
+#undef	RC32434_DEBUG=0A=
+=0A=
+#ifdef RC32434_DEBUG=0A=
+=0A=
+/* use 0 for production, 1 for verification, >2 for debug */=0A=
+static int rc32434_debug =3D RC32434_DEBUG;=0A=
+#define ASSERT(expr) \=0A=
+	if(!(expr)) {	\=0A=
+		printk( "Assertion failed! %s,%s,%s,line=3D%d\n",	\=0A=
+		#expr,__FILE__,__FUNCTION__,__LINE__);		}=0A=
+#define DBG(lvl, format, arg...) if (rc32434_debug > lvl) =
printk(KERN_INFO "%s: " format, dev->name , ## arg)=0A=
+#else=0A=
+#define ASSERT(expr) do {} while (0)=0A=
+#define DBG(lvl, format, arg...) do {} while (0)=0A=
+#endif=0A=
+=0A=
+#define INFO(format, arg...) printk(KERN_INFO "%s: " format, dev->name =
, ## arg)=0A=
+#define ERR(format, arg...) printk(KERN_ERR "%s: " format, dev->name , =
## arg)=0A=
+#define WARN(format, arg...) printk(KERN_WARNING "%s: " format, =
dev->name , ## arg)		=0A=
+=0A=
+#define ETH0_DMA_RX_IRQ   	GROUP1_IRQ_BASE + 0=0A=
+#define ETH0_DMA_TX_IRQ   	GROUP1_IRQ_BASE + 1 =0A=
+#define ETH0_RX_OVR_IRQ   	GROUP3_IRQ_BASE + 9=0A=
+#define ETH0_TX_UND_IRQ   	GROUP3_IRQ_BASE + 10=0A=
+=0A=
+#define ETH0_RX_DMA_ADDR  (DMA0_PhysicalAddress + =
0*DMA_CHAN_OFFSET)=0A=
+#define ETH0_TX_DMA_ADDR  (DMA0_PhysicalAddress + =
1*DMA_CHAN_OFFSET)=0A=
+=0A=
+/* the following must be powers of two */=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+#define RC32434_NUM_RDS    64    		/* number of receive descriptors =
*/=0A=
+#define RC32434_NUM_TDS    64    		/* number of transmit descriptors =
*/=0A=
+#else=0A=
+#define RC32434_NUM_RDS    128    		/* number of receive descriptors =
*/=0A=
+#define RC32434_NUM_TDS    128    		/* number of transmit descriptors =
*/=0A=
+#endif=0A=
+=0A=
+#define RC32434_RBSIZE     1536  		/* size of one resource buffer =3D =
Ether MTU */=0A=
+#define RC32434_RDS_MASK   (RC32434_NUM_RDS-1)=0A=
+#define RC32434_TDS_MASK   (RC32434_NUM_TDS-1)=0A=
+#define RD_RING_SIZE (RC32434_NUM_RDS * sizeof(struct DMAD_s))=0A=
+#define TD_RING_SIZE (RC32434_NUM_TDS * sizeof(struct DMAD_s))=0A=
+=0A=
+#define RC32434_TX_TIMEOUT HZ * 100=0A=
+=0A=
+#define rc32434_eth0_regs ((ETH_t)(ETH0_VirtualAddress))=0A=
+#define rc32434_eth1_regs ((ETH_t)(ETH1_VirtualAddress))=0A=
+=0A=
+enum status	{ filled,	empty};=0A=
+#define IS_DMA_FINISHED(X)   (((X) & (DMAD_f_m)) !=3D 0)=0A=
+#define IS_DMA_DONE(X)   (((X) & (DMAD_d_m)) !=3D 0)=0A=
+=0A=
+=0A=
+/* Information that need to be kept for each board. */=0A=
+struct rc32434_local {=0A=
+	ETH_t  eth_regs;=0A=
+	DMA_Chan_t  rx_dma_regs;=0A=
+	DMA_Chan_t  tx_dma_regs;=0A=
+	volatile DMAD_t   td_ring;			/* transmit descriptor ring */ =0A=
+	volatile DMAD_t   rd_ring;			/* receive descriptor ring  */=0A=
+	=0A=
+	struct sk_buff* tx_skb[RC32434_NUM_TDS]; 	/* skbuffs for pkt to trans =
*/=0A=
+	struct sk_buff* rx_skb[RC32434_NUM_RDS]; 	/* skbuffs for pkt to trans =
*/=0A=
+	=0A=
+#ifndef CONFIG_IDT_USE_NAPI=0A=
+	struct tasklet_struct * rx_tasklet;=0A=
+#endif=0A=
+	struct tasklet_struct * tx_tasklet;=0A=
+	=0A=
+	int	rx_next_done;=0A=
+	int	rx_chain_head;=0A=
+	int	rx_chain_tail;=0A=
+	enum status	rx_chain_status;=0A=
+	=0A=
+	int	tx_next_done;=0A=
+	int	tx_chain_head;=0A=
+	int	tx_chain_tail;=0A=
+	enum status	tx_chain_status;=0A=
+	int tx_count;			=0A=
+	int	tx_full;=0A=
+	=0A=
+	struct timer_list    mii_phy_timer;=0A=
+	unsigned long duplex_mode;=0A=
+	=0A=
+	int   	rx_irq;=0A=
+	int    tx_irq;=0A=
+	int    ovr_irq;=0A=
+	int    und_irq;=0A=
+	=0A=
+	struct net_device_stats stats;=0A=
+	spinlock_t lock; =0A=
+	=0A=
+	/* debug /proc entry */=0A=
+	struct proc_dir_entry *ps;=0A=
+	int dma_halt_cnt;  int dma_run_cnt;=0A=
+};=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+/* Index to functions, as function prototypes. */=0A=
+static int rc32434_open(struct net_device *dev);=0A=
+static int rc32434_send_packet(struct sk_buff *skb, struct net_device =
*dev);=0A=
+//static void rc32434_mii_handler(unsigned long data);=0A=
+static irqreturn_t  rc32434_und_interrupt(int irq, void *dev_id, =
struct pt_regs * regs);=0A=
+static irqreturn_t rc32434_rx_dma_interrupt(int irq, void *dev_id, =
struct pt_regs * regs);=0A=
+static irqreturn_t rc32434_tx_dma_interrupt(int irq, void *dev_id, =
struct pt_regs * regs);=0A=
+#ifdef	RC32434_REVISION	=0A=
+static irqreturn_t rc32434_ovr_interrupt(int irq, void *dev_id, struct =
pt_regs * regs);=0A=
+#endif=0A=
+static int  rc32434_close(struct net_device *dev);=0A=
+static struct net_device_stats *rc32434_get_stats(struct net_device =
*dev);=0A=
+static void rc32434_multicast_list(struct net_device *dev);=0A=
+static int  rc32434_init(struct net_device *dev);=0A=
+static void rc32434_tx_timeout(struct net_device *dev);=0A=
+=0A=
+static void rc32434_tx_tasklet(unsigned long tx_data_dev);=0A=
+#ifdef CONFIG_IDT_USE_NAPI=0A=
+static int rc32434_poll(struct net_device *rx_data_dev, int =
*budget);=0A=
+#else=0A=
+static void rc32434_rx_tasklet(unsigned long rx_data_dev);=0A=
+#endif=0A=
+static void rc32434_cleanup_module(void);=0A=
+static int rc32434_probe(int port_num);=0A=
+int rc32434_init_module(void);=0A=
+=0A=
+=0A=
+static inline void rc32434_abort_dma(struct net_device *dev, =
DMA_Chan_t ch)=0A=
+{=0A=
+	if (rc32434_readl(&ch->dmac) & DMAC_run_m) {=0A=
+		rc32434_writel(0x10, &ch->dmac); =0A=
+		=0A=
+		while (!(rc32434_readl(&ch->dmas) & DMAS_h_m))=0A=
+			dev->trans_start =3D jiffies;		=0A=
+		=0A=
+		rc32434_writel(0, &ch->dmas);  =0A=
+	}=0A=
+	=0A=
+	rc32434_writel(0, &ch->dmadptr); =0A=
+	rc32434_writel(0, &ch->dmandptr); =0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/rc32438_eth.c =
idtlinux/drivers/net/rc32438_eth.c=0A=
--- linux-2.6.16-rc5/drivers/net/rc32438_eth.c	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/net/rc32438_eth.c	2006-03-09 16:26:04.000000000 =
-0800=0A=
@@ -0,0 +1,1379 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Driver for the IDT RC32438 on-chip ethernet controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *=0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+#include <linux/config.h>=0A=
+#include <linux/module.h>=0A=
+#include <linux/kernel.h>=0A=
+#include <linux/sched.h>=0A=
+#include <linux/string.h>=0A=
+#include <linux/timer.h>=0A=
+#include <linux/errno.h>=0A=
+#include <linux/proc_fs.h>=0A=
+#include <linux/in.h>=0A=
+#include <linux/ioport.h>=0A=
+#include <linux/slab.h>=0A=
+#include <linux/interrupt.h>=0A=
+#include <linux/init.h>=0A=
+#include <linux/netdevice.h>=0A=
+#include <linux/etherdevice.h>=0A=
+#include <linux/ethtool.h>=0A=
+#include <linux/skbuff.h>=0A=
+#include <linux/delay.h>=0A=
+#include <linux/ctype.h>=0A=
+#include <linux/mii.h>=0A=
+=0A=
+#include <asm/irq.h>=0A=
+#include <asm/bitops.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/uaccess.h>=0A=
+=0A=
+#include "rc32438_eth.h"=0A=
+#define DRIVER_VERSION "(July04)"=0A=
+=0A=
+#define DRIVER_NAME "rc32438 Ethernet driver. " DRIVER_VERSION=0A=
+=0A=
+=0A=
+#define STATION_ADDRESS_HIGH(dev) (((dev)->dev_addr[0] << 8) | \=0A=
+			           ((dev)->dev_addr[1]))=0A=
+#define STATION_ADDRESS_LOW(dev)  (((dev)->dev_addr[2] << 24) | \=0A=
+				   ((dev)->dev_addr[3] << 16) | \=0A=
+				   ((dev)->dev_addr[4] << 8)  | \=0A=
+				   ((dev)->dev_addr[5]))=0A=
+=0A=
+#define MII_CLOCK 1250000 				/* no more than 2.5MHz */=0A=
+static char mac0[18] =3D "08:00:06:05:40:01";=0A=
+static char mac1[18] =3D "08:00:06:05:50:01";=0A=
+=0A=
+MODULE_PARM(mac0, "c18");=0A=
+MODULE_PARM(mac1, "c18");=0A=
+MODULE_PARM_DESC(mac0, "MAC address for RC32438 ethernet0");=0A=
+MODULE_PARM_DESC(mac1, "MAC address for RC32438 ethernet1");=0A=
+=0A=
+static struct rc32438_if_t {=0A=
+	char *name;=0A=
+	struct net_device *dev;=0A=
+	int weight;=0A=
+	char* mac_str;=0A=
+	u32 iobase;=0A=
+	u32 rxdmabase;=0A=
+	u32 txdmabase;=0A=
+	int rx_dma_irq;=0A=
+	int tx_dma_irq;=0A=
+	int rx_ovr_irq;=0A=
+	int tx_und_irq;=0A=
+} rc32438_iflist[] =3D=0A=
+{=0A=
+	{=0A=
+		"rc32438_eth0",=0A=
+		NULL,=0A=
+		300,=0A=
+		mac0,=0A=
+		ETH0_PhysicalAddress,=0A=
+		ETH0_RX_DMA_ADDR,=0A=
+		ETH0_TX_DMA_ADDR,=0A=
+		ETH0_DMA_RX_IRQ,=0A=
+		ETH0_DMA_TX_IRQ,=0A=
+		ETH0_RX_OVR_IRQ,=0A=
+		ETH0_TX_UND_IRQ=0A=
+	},=0A=
+	{=0A=
+		"rc32438_eth1",=0A=
+		NULL,=0A=
+		300,=0A=
+		mac1,=0A=
+		ETH1_PhysicalAddress,=0A=
+		ETH1_RX_DMA_ADDR,=0A=
+		ETH1_TX_DMA_ADDR,=0A=
+		ETH1_DMA_RX_IRQ,=0A=
+		ETH1_DMA_TX_IRQ,=0A=
+		ETH1_RX_OVR_IRQ,=0A=
+		ETH1_TX_UND_IRQ=0A=
+	}=0A=
+};=0A=
+=0A=
+=0A=
+static int parse_mac_addr(struct net_device *dev, char* macstr)=0A=
+{=0A=
+	int i, j;=0A=
+	unsigned char result, value;=0A=
+=0A=
+	for (i=3D0; i<6; i++)=0A=
+	{=0A=
+		result =3D 0;=0A=
+		if (i !=3D 5 && *(macstr+2) !=3D ':')=0A=
+		{=0A=
+			ERR("invalid mac address format: %d %c\n",=0A=
+			    i, *(macstr+2));=0A=
+			return -EINVAL;=0A=
+		}=0A=
+		for (j=3D0; j<2; j++)=0A=
+		{=0A=
+			if (isxdigit(*macstr) && (value =3D isdigit(*macstr) ? *macstr-'0' =
:=0A=
+						  toupper(*macstr)-'A'+10) < 16)=0A=
+			{=0A=
+				result =3D result*16 + value;=0A=
+				macstr++;=0A=
+			}=0A=
+			else=0A=
+			{=0A=
+				ERR("invalid mac address "=0A=
+				    "character: %c\n", *macstr);=0A=
+				return -EINVAL;=0A=
+			}=0A=
+		}=0A=
+=0A=
+		macstr++;=0A=
+		dev->dev_addr[i] =3D result;=0A=
+	}=0A=
+=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+static inline void rc32438_abort_tx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+=0A=
+	rc32438_abort_dma(dev, lp->tx_dma_regs);=0A=
+=0A=
+}=0A=
+=0A=
+static inline void rc32438_abort_rx(struct net_device *dev)=0A=
+{=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+=0A=
+	rc32438_abort_dma(dev, lp->rx_dma_regs);=0A=
+=0A=
+}=0A=
+=0A=
+static inline void rc32438_start_tx(struct rc32438_local *lp,  =
volatile DMAD_t td)=0A=
+{=0A=
+	rc32438_start_dma(lp->tx_dma_regs, CPHYSADDR(td));=0A=
+}=0A=
+=0A=
+static inline void rc32438_start_rx(struct rc32438_local *lp, volatile =
DMAD_t rd)=0A=
+{=0A=
+	rc32438_start_dma(lp->rx_dma_regs, CPHYSADDR(rd));=0A=
+}=0A=
+=0A=
+static inline void rc32438_chain_tx(struct rc32438_local *lp, volatile =
DMAD_t td)=0A=
+{=0A=
+	rc32438_chain_dma(lp->tx_dma_regs, CPHYSADDR(td));=0A=
+}=0A=
+static inline void rc32438_chain_rx(struct rc32438_local *lp, volatile =
DMAD_t rd)=0A=
+{=0A=
+	rc32438_chain_dma(lp->rx_dma_regs, CPHYSADDR(rd));=0A=
+}=0A=
+=0A=
+#ifdef RC32438_PROC_DEBUG=0A=
+static int rc32438_read_proc(char *buf, char **start, off_t fpos,=0A=
+			     int length, int *eof, void *data)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)data;=0A=
+=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+=0A=
+	int len =3D 0;=0A=
+=0A=
+	/* print out header */=0A=
+	len +=3D sprintf(buf + len, "\n\tRC32438 Ethernet Debug\n\n");=0A=
+=0A=
+ 	len +=3D sprintf (buf + len,=0A=
+			"DMA halt count  =3D %10d, DMA ovr count  =3D %10d\n",=0A=
+			lp->dma_halt_cnt,lp->dma_ovr_count);=0A=
+=0A=
+=0A=
+        len +=3D sprintf (buf + len,=0A=
+			"note_done_cnt   =3D %10d, DMA halt_nd_count =3D %10d\n",=0A=
+			lp->not_done_cnt,lp->dma_halt_nd_cnt);=0A=
+=0A=
+        len +=3D sprintf (buf + len,=0A=
+			"budget          =3D %10d, quota             =3D %10d\n",=0A=
+			lp->ibudget,lp->iquota);=0A=
+=0A=
+        len +=3D sprintf (buf + len,=0A=
+			"tx_stopped          =3D %10d, quota             =3D %10d\n",=0A=
+			lp->tx_stopped,lp->iquota);=0A=
+=0A=
+	if (fpos >=3D len)=0A=
+	{=0A=
+		*start =3D buf;=0A=
+		*eof =3D 1;=0A=
+		return 0;=0A=
+	}=0A=
+	*start =3D buf + fpos;=0A=
+=0A=
+	if ((len -=3D fpos) > length)=0A=
+		return length;=0A=
+	*eof =3D 1;=0A=
+=0A=
+	return len;=0A=
+=0A=
+}=0A=
+#endif=0A=
+=0A=
+/*=0A=
+ * Restart the RC32438 ethernet controller.=0A=
+ */=0A=
+static int rc32438_restart(struct net_device *dev)=0A=
+{=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+=0A=
+	/*=0A=
+	 * Disable interrupts=0A=
+	 */=0A=
+	disable_irq(lp->rx_irq);=0A=
+	disable_irq(lp->tx_irq);=0A=
+=0A=
+	/* Mask F E bit in Tx DMA */=0A=
+	rc32438_writel(rc32438_readl(&lp->tx_dma_regs->dmasm) | DMASM_f_m | =
DMASM_e_m, &lp->tx_dma_regs->dmasm);=0A=
+	/* Mask D H E bit in Rx DMA */=0A=
+	rc32438_writel(rc32438_readl(&lp->rx_dma_regs->dmasm) | DMASM_d_m | =
DMASM_h_m | DMASM_e_m, &lp->rx_dma_regs->dmasm);=0A=
+=0A=
+	rc32438_init(dev);=0A=
+	rc32438_multicast_list(dev);=0A=
+=0A=
+	enable_irq(lp->tx_irq);=0A=
+	enable_irq(lp->rx_irq);=0A=
+=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+int rc32438_init_module(void)=0A=
+{=0A=
+	int retval;=0A=
+=0A=
+	printk(KERN_INFO DRIVER_NAME " \n");=0A=
+=0A=
+	retval  =3D rc32438_probe(0);=0A=
+	retval |=3D rc32438_probe(1);=0A=
+=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+static int rc32438_probe(int port_num)=0A=
+{=0A=
+	struct rc32438_if_t *bif =3D &rc32438_iflist[port_num];=0A=
+	struct rc32438_local *lp =3D NULL;=0A=
+	struct net_device *dev =3D NULL;=0A=
+	int i, retval,err;=0A=
+=0A=
+	dev =3D alloc_etherdev(sizeof(struct rc32438_local));=0A=
+	if(!dev)=0A=
+	{=0A=
+		ERR("rc32438_eth: alloc_etherdev failed\n");=0A=
+		return -1;=0A=
+	}=0A=
+=0A=
+	SET_MODULE_OWNER(dev);=0A=
+=0A=
+	bif->dev =3D dev;=0A=
+=0A=
+	if ((retval =3D parse_mac_addr(dev, bif->mac_str)))=0A=
+	{=0A=
+		ERR("MAC address parse failed\n");=0A=
+		free_netdev(dev);=0A=
+		return -1;=0A=
+	}=0A=
+=0A=
+	/* Initialize the device structure. */=0A=
+	if (dev->priv =3D=3D NULL)=0A=
+	{=0A=
+		lp =3D (struct rc32438_local *)kmalloc(sizeof(*lp), GFP_KERNEL);=0A=
+		memset(lp, 0, sizeof(struct rc32438_local));=0A=
+	}=0A=
+	else=0A=
+	{=0A=
+		lp =3D (struct rc32438_local *)dev->priv;=0A=
+	}=0A=
+=0A=
+	lp->rx_irq =3D bif->rx_dma_irq;=0A=
+	lp->tx_irq =3D bif->tx_dma_irq;=0A=
+=0A=
+	lp->weight =3D bif->weight;=0A=
+=0A=
+	lp->eth_regs =3D ioremap_nocache(bif->iobase, =
sizeof(*lp->eth_regs));=0A=
+=0A=
+	if (!lp->eth_regs)=0A=
+	{=0A=
+		ERR("Can't remap eth registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+=0A=
+	lp->rx_dma_regs =3D ioremap_nocache(bif->rxdmabase, sizeof(struct =
DMA_Chan_s));=0A=
+=0A=
+	if (!lp->rx_dma_regs)=0A=
+	{=0A=
+		ERR("Can't remap Rx DMA registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+	lp->tx_dma_regs =3D ioremap_nocache(bif->txdmabase,sizeof(struct =
DMA_Chan_s));=0A=
+=0A=
+	if (!lp->tx_dma_regs)=0A=
+	{=0A=
+		ERR("Can't remap Tx DMA registers\n");=0A=
+		retval =3D -ENXIO;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+=0A=
+#ifdef RC32438_PROC_DEBUG=0A=
+	lp->ps =3D create_proc_read_entry (bif->name, 0, proc_net,=0A=
+					 rc32438_read_proc, dev);=0A=
+#endif=0A=
+=0A=
+	lp->td_ring =3D	(DMAD_t)kmalloc(TD_RING_SIZE + RD_RING_SIZE, =
GFP_KERNEL);=0A=
+	if (!lp->td_ring)=0A=
+	{=0A=
+		ERR("Can't allocate descriptors\n");=0A=
+		retval =3D -ENOMEM;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+=0A=
+	dma_cache_inv((unsigned long)(lp->td_ring), TD_RING_SIZE + =
RD_RING_SIZE);=0A=
+=0A=
+	/* now convert TD_RING pointer to KSEG1 */=0A=
+	lp->td_ring =3D (DMAD_t )KSEG1ADDR(lp->td_ring);=0A=
+	lp->rd_ring =3D &lp->td_ring[RC32438_NUM_TDS];=0A=
+=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_lock_init(&lp->lock);=0A=
+#endif=0A=
+	dev->base_addr =3D bif->iobase;=0A=
+	/* just use the rx dma irq */=0A=
+	dev->irq =3D bif->rx_dma_irq;=0A=
+=0A=
+	dev->priv =3D lp;=0A=
+=0A=
+	dev->open =3D rc32438_open;=0A=
+	dev->stop =3D rc32438_close;=0A=
+	dev->hard_start_xmit =3D rc32438_send_packet;=0A=
+	dev->get_stats	=3D rc32438_get_stats;=0A=
+	dev->set_multicast_list =3D &rc32438_multicast_list;=0A=
+	dev->tx_timeout =3D rc32438_tx_timeout;=0A=
+	dev->watchdog_timeo =3D RC32438_TX_TIMEOUT;=0A=
+=0A=
+	dev->poll =3D rc32438_poll;=0A=
+	dev->weight =3D lp->weight;=0A=
+=0A=
+	lp->tx_tasklet =3D kmalloc(sizeof(struct tasklet_struct), =
GFP_KERNEL);=0A=
+	tasklet_init(lp->tx_tasklet, rc32438_tx_tasklet, (unsigned =
long)dev);=0A=
+=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+	lp->ovr_und_tasklet =3D kmalloc(sizeof(struct tasklet_struct), =
GFP_KERNEL);=0A=
+	tasklet_init(lp->ovr_und_tasklet, rc32438_ovr_und_tasklet, (unsigned =
long)dev);=0A=
+#endif=0A=
+=0A=
+	if ((err =3D register_netdev(dev))) {=0A=
+		printk(KERN_ERR "rc32438 ethernet. Cannot register net device %d\n", =
err);=0A=
+		free_netdev(dev);=0A=
+		retval =3D -EINVAL;=0A=
+		goto probe_err_out;=0A=
+	}=0A=
+=0A=
+	INFO("Rx IRQ %d, Tx IRQ %d, TDS %d RDS %d weight %d ",=0A=
+	     bif->rx_dma_irq, bif->tx_dma_irq,RC32438_NUM_TDS, =
RC32438_NUM_RDS,dev->weight);=0A=
+	for (i =3D 0; i < 6; i++)=0A=
+	{=0A=
+		printk("%2.2x", dev->dev_addr[i]);=0A=
+		if (i<5)=0A=
+			printk(":");=0A=
+	}=0A=
+	printk("\n");=0A=
+=0A=
+	return 0;=0A=
+=0A=
+ probe_err_out:=0A=
+	rc32438_cleanup_module();=0A=
+	ERR(" failed.  Returns %d\n", retval);=0A=
+	return retval;=0A=
+=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32438_cleanup_module(void)=0A=
+{=0A=
+	int i;=0A=
+=0A=
+	for (i =3D 0; rc32438_iflist[i].iobase; i++)=0A=
+	{=0A=
+		struct rc32438_if_t * bif =3D &rc32438_iflist[i];=0A=
+		if (bif->dev !=3D NULL)=0A=
+		{=0A=
+			struct rc32438_local *lp =3D (struct rc32438_local =
*)bif->dev->priv;=0A=
+			if (lp !=3D NULL)=0A=
+			{=0A=
+				if (lp->eth_regs)=0A=
+					iounmap((void*)lp->eth_regs);=0A=
+				if (lp->rx_dma_regs)=0A=
+					iounmap((void*)lp->rx_dma_regs);=0A=
+				if (lp->tx_dma_regs)=0A=
+					iounmap((void*)lp->tx_dma_regs);=0A=
+				if (lp->td_ring)=0A=
+					kfree((void*)KSEG0ADDR(lp->td_ring));=0A=
+=0A=
+#ifdef RC32438_PROC_DEBUG=0A=
+				if (lp->ps)=0A=
+				{=0A=
+					remove_proc_entry(bif->name, proc_net);=0A=
+				}=0A=
+#endif=0A=
+				kfree(lp);=0A=
+			}=0A=
+=0A=
+			unregister_netdev(bif->dev);=0A=
+			free_netdev(bif->dev);=0A=
+			kfree(bif->dev);=0A=
+		}=0A=
+	}=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Open/initialize the RC32438 controller.=0A=
+ *=0A=
+ * This routine should set everything up anew at each open, even=0A=
+ *  registers that "should" only need to be set once at boot, so =
that=0A=
+ *  there is non-reboot way to recover if something goes wrong.=0A=
+ */=0A=
+=0A=
+static int rc32438_open(struct net_device *dev)=0A=
+{=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+=0A=
+	/* Initialize */=0A=
+	if (rc32438_init(dev))=0A=
+	{=0A=
+		ERR("Erroe: cannot open the Ethernet device\n");=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+=0A=
+	/* Install the interrupt handler that handles the Done Finished Ovr =
and Und Events */=0A=
+	if (request_irq(lp->rx_irq, &rc32438_rx_dma_interrupt,=0A=
+			SA_INTERRUPT,=0A=
+			"rc32438 ethernet Rx", dev))=0A=
+	{=0A=
+		ERR(": unable to get Rx DMA IRQ %d\n",=0A=
+		    lp->rx_irq);=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+	if (request_irq(lp->tx_irq, &rc32438_tx_dma_interrupt,=0A=
+			SA_INTERRUPT,=0A=
+			"rc32438 ethernet Tx", dev))=0A=
+	{=0A=
+		ERR(": unable to get Tx DMA IRQ %d\n",=0A=
+		    lp->tx_irq);=0A=
+		free_irq(lp->rx_irq, dev);=0A=
+		return -EAGAIN;=0A=
+	}=0A=
+=0A=
+	/*Start MII-PHY Timer*/=0A=
+	//Not enabled this feature at this time.=0A=
+	/*=0A=
+	  init_timer(&lp->mii_phy_timer);=0A=
+	  lp->mii_phy_timer.expires =3D jiffies + 10 * HZ;=0A=
+	  lp->mii_phy_timer.data =3D (unsigned long)dev;=0A=
+	  lp->mii_phy_timer.function	 =3D rc32438_mii_handler;=0A=
+	  add_timer(&lp->mii_phy_timer);=0A=
+	*/=0A=
+=0A=
+#ifdef RC32438_PROC_DEBUG=0A=
+	lp->dma_halt_cnt =3D 0;=0A=
+      	lp->dma_halt_nd_cnt =3D 0;=0A=
+	lp->not_done_cnt =3D 0;=0A=
+        lp->ibudget =3D 0;=0A=
+        lp->iquota  =3D 0;=0A=
+        lp->done_cnt    =3D0;=0A=
+        lp->firstTime =3D 0;=0A=
+	lp->tx_stopped =3D 0;=0A=
+#endif=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Close the RC32438 device=0A=
+ */=0A=
+static int rc32438_close(struct net_device *dev)=0A=
+{=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	u32 tmp;=0A=
+=0A=
+	/* Disable interrupts */=0A=
+	disable_irq(lp->rx_irq);=0A=
+	disable_irq(lp->tx_irq);=0A=
+=0A=
+	tmp =3D rc32438_readl(&lp->tx_dma_regs->dmasm);=0A=
+	tmp =3D tmp | DMASM_f_m | DMASM_e_m;=0A=
+	rc32438_writel(tmp, &lp->tx_dma_regs->dmasm);=0A=
+=0A=
+	tmp =3D rc32438_readl(&lp->rx_dma_regs->dmasm);=0A=
+	tmp =3D tmp | DMASM_d_m | DMASM_h_m | DMASM_e_m;=0A=
+	rc32438_writel(tmp, &lp->rx_dma_regs->dmasm);=0A=
+=0A=
+	free_irq(lp->rx_irq, dev);=0A=
+	free_irq(lp->tx_irq, dev);=0A=
+=0A=
+	//Not enabled this feature at this time.=0A=
+	//del_timer(&lp->mii_phy_timer);=0A=
+=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+=0A=
+/* transmit packet */=0A=
+static int rc32438_send_packet(struct sk_buff *skb, struct net_device =
*dev)=0A=
+{=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	unsigned long 			flags;=0A=
+	u32				length;=0A=
+	volatile DMAD_t				td;=0A=
+=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_save(flags);=0A=
+#endif=0A=
+	td =3D &lp->td_ring[lp->tx_chain_tail];=0A=
+=0A=
+	/* stop queue when full, drop pkts if queue already full */=0A=
+	if(lp->tx_count >=3D (RC32438_NUM_TDS - 2))=0A=
+	{=0A=
+		lp->tx_full =3D 1;=0A=
+=0A=
+		if(lp->tx_count =3D=3D (RC32438_NUM_TDS - 2))=0A=
+		{=0A=
+			/* this pkt is about to fill the queue*/=0A=
+			lp->tx_stopped++;=0A=
+			netif_stop_queue(dev);=0A=
+		}=0A=
+		else=0A=
+		{=0A=
+			/* this pkt cannot be added to the full queue */=0A=
+			printk("Tx ring full, packet dropped\n");=0A=
+			lp->stats.tx_dropped++;=0A=
+			dev_kfree_skb_any(skb);=0A=
+#ifdef CONFIG_SMP=0A=
+			spin_unlock_irqrestore(&lp->lock, flags);=0A=
+#else=0A=
+			local_irq_restore(flags);=0A=
+#endif=0A=
+			return 1;=0A=
+		}=0A=
+	}=0A=
+=0A=
+	lp->tx_count ++;=0A=
+=0A=
+	lp->tx_skb[lp->tx_chain_tail] =3D skb;=0A=
+=0A=
+	length =3D skb->len;=0A=
+=0A=
+	/* Setup the transmit descriptor. */=0A=
+	td->ca =3D CPHYSADDR(skb->data);=0A=
+=0A=
+	if(rc32438_readl(&(lp->tx_dma_regs->dmandptr)) =3D=3D 0)=0A=
+	{=0A=
+		if( lp->tx_chain_status =3D=3D empty )=0A=
+		{=0A=
+			td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /*  Update tail      */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32438_TDS_MASK;   =
                       /*   Move tail       */=0A=
+			rc32438_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR    */=0A=
+			lp->tx_chain_head =3D lp->tx_chain_tail;                            =
                      /* Move head to tail */=0A=
+		}=0A=
+		else=0A=
+		{=0A=
+			td->control =3D DMA_COUNT(length) |DMAD_cof_m|DMAD_iof_m;           =
                      /* Update tail */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32438_TDS_MASK].control &=3D  =
~(DMAD_cof_m);          /* Link to prev */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32438_TDS_MASK].link =3D  =
CPHYSADDR(td);              /* Link to prev */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32438_TDS_MASK;   =
                       /* Move tail */=0A=
+			rc32438_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR */=0A=
+			lp->tx_chain_head =3D lp->tx_chain_tail;                            =
                      /* Move head to tail */=0A=
+			lp->tx_chain_status =3D empty;=0A=
+		}=0A=
+	}=0A=
+	else=0A=
+	{=0A=
+		if( lp->tx_chain_status =3D=3D empty )=0A=
+		{=0A=
+			td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /* Update tail */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32438_TDS_MASK;   =
                       /* Move tail */=0A=
+			lp->tx_chain_status =3D filled;=0A=
+		}=0A=
+		else=0A=
+		{=0A=
+			td->control =3D DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;          =
                      /* Update tail */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32438_TDS_MASK].control &=3D  =
~(DMAD_cof_m);          /* Link to prev */=0A=
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32438_TDS_MASK].link =3D  =
CPHYSADDR(td);              /* Link to prev */=0A=
+			lp->tx_chain_tail =3D (lp->tx_chain_tail + 1) & RC32438_TDS_MASK;   =
                       /* Move tail */=0A=
+		}=0A=
+	}=0A=
+=0A=
+	dev->trans_start =3D jiffies;=0A=
+=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_restore(flags);=0A=
+#endif=0A=
+=0A=
+	return 0;=0A=
+}=0A=
+=0A=
+//Experimental, not enables right now=0A=
+=0A=
+#if 0=0A=
+/* Ethernet MII-PHY Handler */=0A=
+static void rc32438_mii_handler(unsigned long data)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)data;=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	unsigned long 	flags;=0A=
+	unsigned long duplex_status;=0A=
+	int port_addr =3D (lp->rx_irq =3D=3D 0x2c? 1:0) << 8;=0A=
+=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_save(flags);=0A=
+#endif=0A=
+=0A=
+	/* Two ports are using the same MII, the difference is the PHY =
address */=0A=
+	rc32438_writel(0, &rc32438_eth0_regs->miimcfg);=0A=
+	rc32438_writel(0, &rc32438_eth0_regs->miimcmd);=0A=
+	rc32438_writel(port_addr |0x05, &rc32438_eth0_regs->miimaddr);=0A=
+	rc32438_writel(MIIMCMD_scn_m, &rc32438_eth0_regs->miimcmd);=0A=
+	while(rc32438_readl(&rc32438_eth0_regs->miimind) & MIIMIND_nv_m);=0A=
+=0A=
+	ERR("irq:%x		port_addr:%x	RDD:%x\n",=0A=
+	    lp->rx_irq, port_addr, =
rc32438_readl(&rc32438_eth0_regs->miimrdd));=0A=
+	duplex_status =3D (rc32438_readl(&rc32438_eth0_regs->miimrdd) & =
0x140)? ETHMAC2_fd_m: 0;=0A=
+	if(duplex_status !=3D lp->duplex_mode)=0A=
+	{=0A=
+		ERR("The MII-PHY is Auto-negotiated to %s-Duplex mode for Eth-%x\n", =
duplex_status? "Full":"Half", lp->rx_irq =3D=3D 0x2c? 1:0);=0A=
+		lp->duplex_mode =3D duplex_status;=0A=
+		rc32438_restart(dev);=0A=
+	}=0A=
+=0A=
+	lp->mii_phy_timer.expires =3D jiffies + 10 * HZ;=0A=
+	add_timer(&lp->mii_phy_timer);=0A=
+=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_restore(flags);=0A=
+#endif=0A=
+=0A=
+}=0A=
+#endif=0A=
+=0A=
+=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+static void rc32438_ovr_und_tasklet(unsigned long dev_id)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+=0A=
+	unsigned int status;=0A=
+	unsigned long flags;=0A=
+=0A=
+	ASSERT(dev !=3D NULL);=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_lock_irqsave(&lp->lock,flags);=0A=
+#else=0A=
+	local_irq_save(flags);=0A=
+#endif=0A=
+	status =3D rc32438_readl(&lp->eth_regs->ethintfc);=0A=
+=0A=
+	lp->dma_ovr_count++;=0A=
+	if(status & (ETHINTFC_und_m | ETHINTFC_ovr_m) )=0A=
+	{=0A=
+		netif_stop_queue(dev);=0A=
+=0A=
+		/* clear OVR bit */=0A=
+		rc32438_writel((status & ~(ETHINTFC_und_m | ETHINTFC_ovr_m)), =
&lp->eth_regs->ethintfc);=0A=
+=0A=
+		/* Restart interface */=0A=
+		rc32438_restart(dev);=0A=
+	}=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_unlock_irqrestore(&lp->lock,flags);=0A=
+#else=0A=
+	local_irq_restore(flags);=0A=
+#endif=0A=
+}=0A=
+#endif=0A=
+/* Ethernet Rx DMA interrupt */=0A=
+static irqreturn_t=0A=
+rc32438_rx_dma_interrupt(int irq, void *dev_id, struct pt_regs * =
regs)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	volatile u32 dmas,dmasm;=0A=
+	irqreturn_t retval =3D IRQ_NONE;=0A=
+=0A=
+	ASSERT(dev !=3D NULL);=0A=
+=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_lock(&lp->lock);=0A=
+#endif=0A=
+	dmas =3D rc32438_readl(&lp->rx_dma_regs->dmas);=0A=
+	if(dmas & (DMAS_d_m|DMAS_h_m|DMAS_e_m))=0A=
+	{=0A=
+		/* Mask D H E bit in Rx DMA */=0A=
+		dmasm =3D rc32438_readl(&lp->rx_dma_regs->dmasm);=0A=
+		rc32438_writel(dmasm | (DMASM_d_m | DMASM_h_m | DMASM_e_m), =
&lp->rx_dma_regs->dmasm);=0A=
+=0A=
+		if (dmas & DMAS_h_m){=0A=
+		  printk("DMA Halted\n");=0A=
+		  rc32438_restart(dev);=0A=
+		}=0A=
+		if(netif_rx_schedule_prep(dev))=0A=
+		  __netif_rx_schedule(dev);=0A=
+		=0A=
+		if (dmas & DMAS_e_m)=0A=
+		  ERR(": DMA error\n");=0A=
+=0A=
+		retval =3D IRQ_HANDLED;=0A=
+	}=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_unlock(&lp->lock);=0A=
+#endif=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+static int rc32438_poll(struct net_device *dev, int *budget)=0A=
+{=0A=
+	struct rc32438_local* lp =3D netdev_priv(dev);=0A=
+	volatile DMAD_t  rd;=0A=
+	u32 rx_next_done;=0A=
+	struct sk_buff *skb, *skb_new;=0A=
+	u8* pkt_buf;=0A=
+	u32 count, pkt_len, pktuncrc_len;=0A=
+	volatile u32 dmas,devcs;=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+	volatile u32 ovr_und;=0A=
+#endif=0A=
+	u32 received =3D 0;=0A=
+	int rx_work_limit =3D 0;=0A=
+=0A=
+	rx_next_done  =3D lp->rx_next_done;=0A=
+	rd =3D &lp->rd_ring[rx_next_done];=0A=
+=0A=
+	rx_work_limit =3D min(*budget,dev->quota);=0A=
+=0A=
+        while ( (count =3D RC32438_RBSIZE - =
(u32)DMA_COUNT(rd->control)) !=3D 0)=0A=
+        {=0A=
+                if(--rx_work_limit <0)=0A=
+                {=0A=
+#ifdef RC32438_PROC_DEBUG=0A=
+                        if(lp->firstTime =3D=3D 0)=0A=
+                        {=0A=
+                                lp->ibudget =3D *budget;=0A=
+                                lp->iquota  =3D dev->quota;=0A=
+                                lp->firstTime =3D 1;=0A=
+                        }=0A=
+#endif=0A=
+			break;=0A=
+                }=0A=
+                /* init the var. used for the later operations within =
the while loop */=0A=
+                skb_new =3D NULL;=0A=
+                devcs =3D rd->devcs;=0A=
+                pkt_len =3D RCVPKT_LENGTH(devcs);=0A=
+		skb =3D lp->rx_skb[rx_next_done];=0A=
+=0A=
+		if ((devcs & ( ETHRX_ld_m)) !=3D	ETHRX_ld_m)=0A=
+		{=0A=
+			/* check that this is a whole packet */=0A=
+			/* WARNING: DMA_FD bit incorrectly set in Rc32438 (errata ref #077) =
*/=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+		}=0A=
+		else if (pkt_len < 64)=0A=
+		{=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+		}=0A=
+		else if ( (devcs & ETHRX_rok_m)  )=0A=
+		{=0A=
+			/* must be the (first and) last descriptor then */=0A=
+			pkt_buf =3D (u8*)lp->rx_skb[rx_next_done]->data;=0A=
+=0A=
+			pktuncrc_len =3D pkt_len - 4;=0A=
+			/* invalidate the cache */=0A=
+			dma_cache_inv((unsigned long)pkt_buf, pktuncrc_len);=0A=
+=0A=
+			/* Malloc up new buffer. */=0A=
+			skb_new =3D dev_alloc_skb(RC32438_RBSIZE + 2);=0A=
+=0A=
+			if (skb_new !=3D NULL)=0A=
+			{=0A=
+				/* Make room */=0A=
+				skb_put(skb, pktuncrc_len);=0A=
+=0A=
+				skb->protocol =3D eth_type_trans(skb, dev);=0A=
+=0A=
+				/* pass the packet to upper layers */=0A=
+				netif_receive_skb(skb);=0A=
+				dev->last_rx =3D jiffies;=0A=
+				lp->stats.rx_packets++;=0A=
+				lp->stats.rx_bytes +=3D pktuncrc_len;=0A=
+=0A=
+				if (IS_RCV_MP(devcs))=0A=
+					lp->stats.multicast++;=0A=
+=0A=
+				/* 16 bit align */=0A=
+				skb_reserve(skb_new, 2);=0A=
+=0A=
+				skb_new->dev =3D dev;=0A=
+				lp->rx_skb[rx_next_done] =3D skb_new;=0A=
+				received++;=0A=
+			}=0A=
+			else=0A=
+			{=0A=
+				ERR("no memory, dropping rx packet.\n");=0A=
+				lp->stats.rx_errors++;=0A=
+				lp->stats.rx_dropped++;=0A=
+			}=0A=
+		}=0A=
+		else=0A=
+		{=0A=
+			/* This should only happen if we enable accepting broken packets =
*/=0A=
+			lp->stats.rx_errors++;=0A=
+			lp->stats.rx_dropped++;=0A=
+=0A=
+			/* add statistics counters */=0A=
+			if (IS_RCV_CRC_ERR(devcs))=0A=
+			{=0A=
+				DBG(2, "RX CRC error\n");=0A=
+				lp->stats.rx_crc_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_LOR_ERR(devcs))=0A=
+			{=0A=
+				DBG(2, "RX LOR error\n");=0A=
+				lp->stats.rx_length_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_LE_ERR(devcs))=0A=
+			{=0A=
+				DBG(2, "RX LE error\n");=0A=
+				lp->stats.rx_length_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_OVR_ERR(devcs))=0A=
+			{=0A=
+				/*=0A=
+				 * The overflow errors are handled through=0A=
+				 * an interrupt handler.=0A=
+				 */=0A=
+				lp->stats.rx_over_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_CV_ERR(devcs))=0A=
+			{=0A=
+				/* code violation */=0A=
+				DBG(2, "RX CV error\n");=0A=
+				lp->stats.rx_frame_errors++;=0A=
+			}=0A=
+			else if (IS_RCV_CES_ERR(devcs))=0A=
+			{=0A=
+				DBG(2, "RX Preamble error\n");=0A=
+			}=0A=
+		}=0A=
+=0A=
+		rd->devcs =3D 0;=0A=
+=0A=
+		/* restore descriptor's curr_addr */=0A=
+		if(skb_new)=0A=
+			rd->ca =3D CPHYSADDR(skb_new->data);=0A=
+		else=0A=
+			rd->ca =3D CPHYSADDR(skb->data);=0A=
+=0A=
+		rd->control =3D DMA_COUNT(RC32438_RBSIZE) |DMAD_cod_m =
|DMAD_iod_m;=0A=
+=0A=
+		/* There is a race condition here. See below */=0A=
+		lp->rd_ring[(rx_next_done-1)& RC32438_RDS_MASK].control &=3D  =
~(DMAD_cod_m);=0A=
+=0A=
+		rx_next_done =3D (rx_next_done + 1) & RC32438_RDS_MASK;=0A=
+		rd =3D &lp->rd_ring[rx_next_done];=0A=
+		rc32438_writel(~DMAS_d_m, &lp->rx_dma_regs->dmas);=0A=
+	}=0A=
+=0A=
+	dev->quota -=3D received;=0A=
+	*budget =3D- received;=0A=
+=0A=
+	lp->rx_next_done =3D rx_next_done;=0A=
+	if(rx_work_limit < 0)=0A=
+		goto not_done;=0A=
+=0A=
+	dmas =3D rc32438_readl(&lp->rx_dma_regs->dmas);=0A=
+=0A=
+#if 0=0A=
+	if(dmas & DMAS_h_m)=0A=
+	{=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+		ovr_und =3D rc32438_readl(&lp->eth_regs->ethintfc);=0A=
+		if(ovr_und & (ETHINTFC_ovr_m | ETHINTFC_und_m))=0A=
+			goto over_under_flow;=0A=
+#endif=0A=
+=0A=
+#ifdef RC32438_PROC_DEBUG=0A=
+		lp->dma_halt_cnt++;=0A=
+#endif=0A=
+=0A=
+/**********************************************************************=
*************=0A=
+  There is a race condition here. Imagine software completed =
processing 0 descriptor=0A=
+  and is updating the control field of N-1 descriptor. At the same =
time, DMA =0A=
+  processed N-1 descriptor and is also updating the descriptor. If =
Software is=0A=
+  updating the descriptor after DMA, the D bit in the descriptor gets =
cleared,=0A=
+  though DMA has set it and halted. Now, when Software arrives to N-1, =
it sees=0A=
+  D bit not being set. However, it finds the DMA halted. The Software, =
in order=0A=
+  to start the DMA again, loads this descriptor. Though the control =
field of=0A=
+  this descriptor is fine, the devcs and ca fields are wrong. Hence, =
the software=0A=
+  needs to update those fields before loading DMA.=0A=
+***********************************************************************=
************/=0A=
+		rd->devcs =3D 0;=0A=
+		skb =3D lp->rx_skb[rx_next_done];=0A=
+		rd->ca =3D CPHYSADDR(skb->data);=0A=
+		rc32438_chain_rx(lp,rd);=0A=
+	}=0A=
+#endif=0A=
+=0A=
+	rc32438_writel( ~(DMAS_h_m | DMAS_e_m), &lp->rx_dma_regs->dmas);=0A=
+=0A=
+	netif_rx_complete(dev);=0A=
+	/* Enable D H E bit in Rx DMA */=0A=
+	rc32438_writel(rc32438_readl(&lp->rx_dma_regs->dmasm) & ~(DMASM_d_m | =
DMASM_h_m |DMASM_e_m), &lp->rx_dma_regs->dmasm);=0A=
+=0A=
+	return 0;=0A=
+=0A=
+ not_done:=0A=
+#ifdef RC32438_PROC_DEBUG=0A=
+	lp->not_done_cnt++;=0A=
+#endif=0A=
+	return 1;=0A=
+=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+ over_under_flow:=0A=
+ 	netif_rx_complete(dev);=0A=
+	tasklet_hi_schedule(lp->ovr_und_tasklet);=0A=
+	return 0;=0A=
+#endif=0A=
+}=0A=
+=0A=
+/* Ethernet Tx DMA interrupt */=0A=
+static irqreturn_t=0A=
+rc32438_tx_dma_interrupt(int irq, void *dev_id, struct pt_regs * =
regs)=0A=
+{=0A=
+	struct net_device *dev =3D (struct net_device *)dev_id;=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	volatile u32 dmas,dmasm;=0A=
+	irqreturn_t retval =3D IRQ_NONE;=0A=
+=0A=
+	ASSERT(dev !=3D NULL);=0A=
+=0A=
+//	spin_lock(&lp->lock);=0A=
+=0A=
+	dmas =3D rc32438_readl(&lp->tx_dma_regs->dmas);=0A=
+=0A=
+	if (dmas & (DMAS_f_m | DMAS_e_m))=0A=
+	{=0A=
+		dmasm =3D rc32438_readl(&lp->tx_dma_regs->dmasm);=0A=
+		/* Mask F E bit in Tx DMA */=0A=
+		rc32438_writel(dmasm | (DMASM_f_m | DMASM_e_m), =
&lp->tx_dma_regs->dmasm);=0A=
+=0A=
+		tasklet_schedule(lp->tx_tasklet);=0A=
+=0A=
+		if(lp->tx_chain_status =3D=3D filled && =
(rc32438_readl(&(lp->tx_dma_regs->dmandptr)) =3D=3D 0))=0A=
+		{=0A=
+			rc32438_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), =
&(lp->tx_dma_regs->dmandptr));=0A=
+			lp->tx_chain_status =3D empty;=0A=
+			lp->tx_chain_head =3D lp->tx_chain_tail;=0A=
+			dev->trans_start =3D jiffies;=0A=
+		}=0A=
+=0A=
+		if (dmas & DMAS_e_m)=0A=
+			ERR(": DMA error\n");=0A=
+=0A=
+		retval =3D IRQ_HANDLED;=0A=
+	}=0A=
+=0A=
+//	spin_unlock(&lp->lock);=0A=
+=0A=
+	return retval;=0A=
+}=0A=
+=0A=
+static void rc32438_tx_tasklet(unsigned long tx_data_dev)=0A=
+{=0A=
+        struct net_device *dev =3D (struct net_device =
*)tx_data_dev;=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+        volatile DMAD_t td =3D &lp->td_ring[lp->tx_next_done];=0A=
+        unsigned long   flags;=0A=
+        volatile u32 dmas;=0A=
+        volatile u32 devcs;=0A=
+=0A=
+	u32 tx_next_done =3D lp->tx_next_done;=0A=
+#ifdef CONFIG_SMP=0A=
+        spin_lock_irqsave(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_save(flags);=0A=
+#endif=0A=
+=0A=
+        /* process all desc that are done */=0A=
+        while(IS_DMA_FINISHED(td->control))=0A=
+        {=0A=
+                if(lp->tx_full =3D=3D 1)=0A=
+                {=0A=
+                        netif_wake_queue(dev);=0A=
+                        lp->tx_full =3D 0;=0A=
+                }=0A=
+=0A=
+                devcs =3D lp->td_ring[tx_next_done].devcs;=0A=
+                if ((devcs & (ETHTX_fd_m | ETHTX_ld_m)) !=3D =
(ETHTX_fd_m | ETHTX_ld_m))=0A=
+                {=0A=
+                        lp->stats.tx_errors++;=0A=
+                        lp->stats.tx_dropped++;=0A=
+=0A=
+                        /* should never happen */=0A=
+                        DBG(1, __FUNCTION__ ": split tx =
ignored\n");=0A=
+                }=0A=
+                else if (IS_TX_TOK(devcs))=0A=
+                {=0A=
+                        /* transmit OK */=0A=
+                        lp->stats.tx_packets++;=0A=
+                }=0A=
+                else=0A=
+                {=0A=
+                        lp->stats.tx_errors++;=0A=
+                        lp->stats.tx_dropped++;=0A=
+=0A=
+                        /* underflow */=0A=
+                        if (IS_TX_UND_ERR(devcs))=0A=
+                                lp->stats.tx_fifo_errors++;=0A=
+=0A=
+                        /* oversized frame */=0A=
+                        if (IS_TX_OF_ERR(devcs))=0A=
+                                lp->stats.tx_aborted_errors++;=0A=
+=0A=
+                        /* excessive deferrals */=0A=
+                        if (IS_TX_ED_ERR(devcs))=0A=
+                                lp->stats.tx_carrier_errors++;=0A=
+=0A=
+                        /* collisions: medium busy */=0A=
+                        if (IS_TX_EC_ERR(devcs))=0A=
+                                lp->stats.collisions++;=0A=
+=0A=
+                        /* late collision */=0A=
+                        if (IS_TX_LC_ERR(devcs))=0A=
+                                lp->stats.tx_window_errors++;=0A=
+=0A=
+                }=0A=
+=0A=
+                /* We must always free the original skb */=0A=
+                if (lp->tx_skb[tx_next_done] !=3D NULL)=0A=
+                {=0A=
+                        =
dev_kfree_skb_any(lp->tx_skb[tx_next_done]);=0A=
+                        lp->tx_skb[tx_next_done] =3D NULL;=0A=
+                }=0A=
+=0A=
+                lp->td_ring[tx_next_done].control =3D DMAD_iof_m;=0A=
+                lp->td_ring[tx_next_done].devcs =3D ETHTX_fd_m | =
ETHTX_ld_m;=0A=
+                lp->td_ring[tx_next_done].link =3D 0;=0A=
+                lp->td_ring[tx_next_done].ca =3D 0;=0A=
+                lp->tx_count --;=0A=
+=0A=
+                /* go on to next transmission */=0A=
+                tx_next_done =3D (tx_next_done + 1) & =
RC32438_TDS_MASK;=0A=
+                td =3D &lp->td_ring[tx_next_done];=0A=
+=0A=
+        }=0A=
+	lp->tx_next_done =3D tx_next_done;=0A=
+        dmas =3D rc32438_readl(&lp->tx_dma_regs->dmas);=0A=
+	rc32438_writel( ~dmas, &lp->tx_dma_regs->dmas);=0A=
+=0A=
+        /* Enable F E bit in Tx DMA */=0A=
+        rc32438_writel(rc32438_readl(&lp->tx_dma_regs->dmasm) & =
~(DMASM_f_m | DMASM_e_m), &lp->tx_dma_regs->dmasm);=0A=
+#ifdef CONFIG_SMP=0A=
+        spin_unlock_irqrestore(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_restore(flags);=0A=
+#endif=0A=
+}=0A=
+/*=0A=
+ * Get the current statistics.=0A=
+ * This may be called with the device open or closed.=0A=
+ */=0A=
+static struct net_device_stats * rc32438_get_stats(struct net_device =
*dev)=0A=
+{=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	return &lp->stats;=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Set or clear the multicast filter for this adaptor.=0A=
+ */=0A=
+static void rc32438_multicast_list(struct net_device *dev)=0A=
+{=0A=
+	/* listen to broadcasts always and to treat 	*/=0A=
+	/*       IFF bits independantly	*/=0A=
+=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	unsigned long flags;=0A=
+	u32 recognise =3D ETHARC_ab_m; 		/* always accept broadcasts */=0A=
+=0A=
+	if (dev->flags & IFF_PROMISC)         		/* set promiscuous mode */=0A=
+		recognise |=3D ETHARC_pro_m;=0A=
+=0A=
+	if ((dev->flags & IFF_ALLMULTI) || (dev->mc_count > 15))=0A=
+		recognise |=3D ETHARC_am_m;    	  	/* all multicast & bcast */=0A=
+	else if (dev->mc_count > 0)=0A=
+	{=0A=
+		DBG(2, __FUNCTION__ ": mc_count %d\n", dev->mc_count);=0A=
+		recognise |=3D ETHARC_am_m;    	  	/* for the time being */=0A=
+	}=0A=
+=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_save(flags);=0A=
+#endif=0A=
+	rc32438_writel(recognise, &lp->eth_regs->etharc);=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_restore(flags);=0A=
+#endif=0A=
+}=0A=
+=0A=
+=0A=
+static void rc32438_tx_timeout(struct net_device *dev)=0A=
+{=0A=
+	unsigned long flags;=0A=
+=0A=
+#ifdef CONFIG_SMP=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	spin_lock_irqsave(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_save(flags);=0A=
+#endif=0A=
+	rc32438_restart(dev);=0A=
+#ifdef CONFIG_SMP=0A=
+	spin_unlock_irqrestore(&lp->lock, flags);=0A=
+#else=0A=
+	local_irq_restore(flags);=0A=
+#endif=0A=
+=0A=
+}=0A=
+=0A=
+=0A=
+/*=0A=
+ * Initialize the RC32438 ethernet controller.=0A=
+ */=0A=
+static int rc32438_init(struct net_device *dev)=0A=
+{=0A=
+	struct rc32438_local *lp =3D netdev_priv(dev);=0A=
+	int i, j;=0A=
+=0A=
+	/* Disable DMA */=0A=
+	rc32438_abort_tx(dev);=0A=
+	rc32438_abort_rx(dev);=0A=
+=0A=
+	/* reset ethernet logic */=0A=
+	rc32438_writel(0, &lp->eth_regs->ethintfc);=0A=
+	while((rc32438_readl(&lp->eth_regs->ethintfc) & ETHINTFC_rip_m))=0A=
+		dev->trans_start =3D jiffies;=0A=
+=0A=
+	/* Enable Ethernet Interface */=0A=
+	rc32438_writel(ETHINTFC_en_m, &lp->eth_regs->ethintfc);=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+	tasklet_disable(lp->ovr_und_tasklet);=0A=
+#endif=0A=
+	tasklet_disable(lp->tx_tasklet);=0A=
+=0A=
+	/* Initialize the transmit Descriptors */=0A=
+	for (i =3D 0; i < RC32438_NUM_TDS; i++)=0A=
+	{=0A=
+		lp->td_ring[i].control =3D DMAD_iof_m;=0A=
+		lp->td_ring[i].devcs =3D ETHTX_fd_m | ETHTX_ld_m;=0A=
+		lp->td_ring[i].ca =3D 0;=0A=
+		lp->td_ring[i].link =3D 0;=0A=
+		if (lp->tx_skb[i] !=3D NULL)=0A=
+		{=0A=
+			/* free dangling skb */=0A=
+			dev_kfree_skb_any(lp->tx_skb[i]);=0A=
+			lp->tx_skb[i] =3D NULL;=0A=
+		}=0A=
+	}=0A=
+	lp->tx_next_done =3D lp->tx_chain_head =3D lp->tx_chain_tail =3D 	=
lp->tx_full =3D lp->tx_count =3D 0;=0A=
+	lp->tx_chain_status =3D empty;=0A=
+=0A=
+	/*=0A=
+	 * Initialize the receive descriptors so that they=0A=
+	 * become a circular linked list, ie. let the last=0A=
+	 * descriptor point to the first again.=0A=
+	 */=0A=
+	for (i=3D0; i<RC32438_NUM_RDS; i++)=0A=
+	{=0A=
+		struct sk_buff *skb =3D lp->rx_skb[i];=0A=
+=0A=
+		if (lp->rx_skb[i] =3D=3D NULL)=0A=
+		{=0A=
+			skb =3D dev_alloc_skb(RC32438_RBSIZE + 2);=0A=
+			if (skb =3D=3D NULL)=0A=
+			{=0A=
+				ERR("No memory in the system\n");=0A=
+				for (j =3D 0; j < RC32438_NUM_RDS; j ++)=0A=
+					if (lp->rx_skb[j] !=3D NULL)=0A=
+						dev_kfree_skb_any(lp->rx_skb[j]);=0A=
+=0A=
+				return 1;=0A=
+			}=0A=
+			else=0A=
+			{=0A=
+				skb->dev =3D dev;=0A=
+				skb_reserve(skb, 2);=0A=
+				lp->rx_skb[i] =3D skb;=0A=
+				lp->rd_ring[i].ca =3D CPHYSADDR(skb->data);=0A=
+=0A=
+			}=0A=
+		}=0A=
+		lp->rd_ring[i].control =3D	DMAD_iod_m | =
DMA_COUNT(RC32438_RBSIZE);=0A=
+		lp->rd_ring[i].devcs =3D 0;=0A=
+		lp->rd_ring[i].ca =3D CPHYSADDR(skb->data);=0A=
+		lp->rd_ring[i].link =3D CPHYSADDR(&lp->rd_ring[i+1]);=0A=
+=0A=
+	}=0A=
+	/* loop back */=0A=
+	lp->rd_ring[RC32438_NUM_RDS-1].link =3D =
CPHYSADDR(&lp->rd_ring[0]);=0A=
+	lp->rx_next_done   =3D 0;=0A=
+=0A=
+	lp->rd_ring[RC32438_NUM_RDS-1].control |=3D DMAD_cod_m;=0A=
+	lp->rx_chain_head =3D 0;=0A=
+	lp->rx_chain_tail =3D 0;=0A=
+	lp->rx_chain_status =3D empty;=0A=
+=0A=
+	rc32438_writel(0, &lp->rx_dma_regs->dmas);=0A=
+	/* Start Rx DMA */=0A=
+	rc32438_start_rx(lp, &lp->rd_ring[0]);=0A=
+=0A=
+	/* Enable F E bit in Tx DMA */=0A=
+	rc32438_writel(rc32438_readl(&lp->tx_dma_regs->dmasm) & ~(DMASM_f_m | =
DMASM_e_m), &lp->tx_dma_regs->dmasm);=0A=
+	/* Enable D H E bit in Rx DMA */=0A=
+	rc32438_writel(rc32438_readl(&lp->rx_dma_regs->dmasm) & ~(DMASM_d_m | =
DMASM_h_m | DMASM_e_m), &lp->rx_dma_regs->dmasm);=0A=
+=0A=
+	/* Accept only packets destined for this Ethernet device address =
*/=0A=
+	rc32438_writel(ETHARC_ab_m, &lp->eth_regs->etharc);=0A=
+=0A=
+	/* Set all Ether station address registers to their initial values =
*/=0A=
+	rc32438_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal0);=0A=
+	rc32438_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah0);=0A=
+=0A=
+	rc32438_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal1);=0A=
+	rc32438_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah1);=0A=
+=0A=
+	rc32438_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal2);=0A=
+	rc32438_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah2);=0A=
+=0A=
+	rc32438_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal3);=0A=
+	rc32438_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah3);=0A=
+=0A=
+=0A=
+	/* Frame Length Checking, Pad Enable, CRC Enable, Full Duplex set =
*/=0A=
+	rc32438_writel(ETHMAC2_pe_m | ETHMAC2_cen_m | ETHMAC2_fd_m, =
&lp->eth_regs->ethmac2);=0A=
+	//ETHMAC2_flc_m		ETHMAC2_fd_m	lp->duplex_mode=0A=
+=0A=
+	/* Back to back inter-packet-gap */=0A=
+	rc32438_writel(0x15, &lp->eth_regs->ethipgt);=0A=
+	/* Non - Back to back inter-packet-gap */=0A=
+	rc32438_writel(0x12, &lp->eth_regs->ethipgr);=0A=
+=0A=
+	/* Management Clock Prescaler Divisor */=0A=
+	/* Clock independent setting */=0A=
+	rc32438_writel(((idt_cpu_freq)/MII_CLOCK+1) & ~1,=0A=
+		       &lp->eth_regs->ethmcp);=0A=
+=0A=
+	/* don't transmit until fifo contains 48b */=0A=
+	rc32438_writel(48, &lp->eth_regs->ethfifott);=0A=
+=0A=
+	rc32438_writel(ETHMAC1_re_m, &lp->eth_regs->ethmac1);=0A=
+=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+	tasklet_enable(lp->ovr_und_tasklet);=0A=
+#endif=0A=
+	tasklet_enable(lp->tx_tasklet);=0A=
+=0A=
+	netif_start_queue(dev);=0A=
+=0A=
+=0A=
+	return 0;=0A=
+=0A=
+}=0A=
+=0A=
+=0A=
+#ifndef MODULE=0A=
+=0A=
+static int __init rc32438_setup(char *options)=0A=
+{=0A=
+	/* no options yet */=0A=
+	return 1;=0A=
+}=0A=
+=0A=
+static int __init rc32438_setup_ethaddr0(char *options)=0A=
+{=0A=
+	memcpy(mac0, options, 17);=0A=
+	mac0[17]=3D '\0';=0A=
+	return 1;=0A=
+}=0A=
+=0A=
+static int __init rc32438_setup_ethaddr1(char *options)=0A=
+{=0A=
+	memcpy(mac1, options, 17);=0A=
+	mac1[17]=3D '\0';=0A=
+	return 1;=0A=
+}=0A=
+=0A=
+__setup("rc32438eth=3D", rc32438_setup);=0A=
+__setup("ethaddr0=3D", rc32438_setup_ethaddr0);=0A=
+__setup("ethaddr1=3D", rc32438_setup_ethaddr1);=0A=
+=0A=
+=0A=
+#endif /* MODULE */=0A=
+=0A=
+module_init(rc32438_init_module);=0A=
+module_exit(rc32438_cleanup_module);=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/drivers/net/rc32438_eth.h =
idtlinux/drivers/net/rc32438_eth.h=0A=
--- linux-2.6.16-rc5/drivers/net/rc32438_eth.h	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/drivers/net/rc32438_eth.h	2006-03-09 16:26:04.000000000 =
-0800=0A=
@@ -0,0 +1,183 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Definitions for IDT RC32438 on-chip ethernet controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *=0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THEg POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#include  <asm/idt-boards/rc32438/rc32438.h>=0A=
+#include  <asm/idt-boards/rc32438/rc32438_dma_v.h>=0A=
+#include  <asm/idt-boards/rc32438/rc32438_eth_v.h>=0A=
+=0A=
+#define RC32438_PROC_DEBUG=0A=
+//#define RC32438_DEBUG	2=0A=
+=0A=
+#ifdef RC32438_DEBUG=0A=
+=0A=
+/* use 0 for production, 1 for verification, >2 for debug */=0A=
+static int rc32438_debug =3D RC32438_DEBUG;=0A=
+#define ASSERT(expr) \=0A=
+	if(!(expr)) {	\=0A=
+		printk( "Assertion failed! %s,%s,%s,line=3D%d\n",	\=0A=
+		#expr,__FILE__,__FUNCTION__,__LINE__);		}=0A=
+#define DBG(lvl, format, arg...) if (rc32438_debug > lvl) =
printk(KERN_INFO "%s: " format, dev->name , ## arg)=0A=
+#else=0A=
+#define ASSERT(expr) do {} while (0)=0A=
+#define DBG(lvl, format, arg...) do {} while (0)=0A=
+#endif=0A=
+=0A=
+#define INFO(format, arg...) printk(KERN_INFO "%s: " format, dev->name =
, ## arg)=0A=
+#define ERR(format, arg...) printk(KERN_ERR "%s: " format, dev->name , =
## arg)=0A=
+#define WARN(format, arg...) printk(KERN_WARNING "%s: " format, =
dev->name , ## arg)=0A=
+=0A=
+#define ETH0_DMA_RX_IRQ   GROUP1_IRQ_BASE + 2=0A=
+#define ETH0_DMA_TX_IRQ   GROUP1_IRQ_BASE + 3=0A=
+#define ETH0_RX_OVR_IRQ   GROUP3_IRQ_BASE + 12=0A=
+#define ETH0_TX_UND_IRQ   GROUP3_IRQ_BASE + 13=0A=
+#define ETH1_DMA_RX_IRQ   GROUP1_IRQ_BASE + 4=0A=
+#define ETH1_DMA_TX_IRQ   GROUP1_IRQ_BASE + 5=0A=
+#define ETH1_RX_OVR_IRQ   GROUP3_IRQ_BASE + 15=0A=
+#define ETH1_TX_UND_IRQ   GROUP3_IRQ_BASE + 16=0A=
+=0A=
+#define ETH0_RX_DMA_ADDR  (DMA0_PhysicalAddress + =
2*DMA_CHAN_OFFSET)=0A=
+#define ETH0_TX_DMA_ADDR  (DMA0_PhysicalAddress + =
3*DMA_CHAN_OFFSET)=0A=
+#define ETH1_RX_DMA_ADDR  (DMA0_PhysicalAddress + =
4*DMA_CHAN_OFFSET)=0A=
+#define ETH1_TX_DMA_ADDR  (DMA0_PhysicalAddress + =
5*DMA_CHAN_OFFSET)=0A=
+=0A=
+/* the following must be powers of two */=0A=
+#define RC32438_NUM_RDS    64    		/* number of receive descriptors =
*/=0A=
+#define RC32438_NUM_TDS    64    		/* number of transmit descriptors =
*/=0A=
+=0A=
+#define RC32438_RBSIZE     1536  		/* size of one resource buffer =3D =
Ether MTU */=0A=
+#define RC32438_RDS_MASK   (RC32438_NUM_RDS-1)=0A=
+#define RC32438_TDS_MASK   (RC32438_NUM_TDS-1)=0A=
+#define RD_RING_SIZE (RC32438_NUM_RDS * sizeof(struct DMAD_s))=0A=
+#define TD_RING_SIZE (RC32438_NUM_TDS * sizeof(struct DMAD_s))=0A=
+=0A=
+#define RC32438_TX_TIMEOUT HZ * 100=0A=
+=0A=
+#define rc32438_eth0_regs ((ETH_t)(ETH0_VirtualAddress))=0A=
+#define rc32438_eth1_regs ((ETH_t)(ETH1_VirtualAddress))=0A=
+=0A=
+enum status	{ filled,	empty};=0A=
+#define IS_DMA_FINISHED(X)   (((X) & (DMAD_f_m)) !=3D 0)=0A=
+#define IS_DMA_DONE(X)   (((X) & (DMAD_d_m)) !=3D 0)=0A=
+=0A=
+=0A=
+/* Information that need to be kept for each board. */=0A=
+struct rc32438_local {=0A=
+	ETH_t  eth_regs;=0A=
+	DMA_Chan_t  rx_dma_regs;=0A=
+	DMA_Chan_t  tx_dma_regs;=0A=
+	volatile DMAD_t   td_ring;			/* transmit descriptor ring */=0A=
+	volatile DMAD_t   rd_ring;			/* receive descriptor ring  */=0A=
+=0A=
+	struct sk_buff* tx_skb[RC32438_NUM_TDS]; 	/* skbuffs for pkt to trans =
*/=0A=
+	struct sk_buff* rx_skb[RC32438_NUM_RDS]; 	/* skbuffs for pkt to trans =
*/=0A=
+=0A=
+	int weight;=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+	struct tasklet_struct * ovr_und_tasklet;=0A=
+#endif=0A=
+	struct tasklet_struct * tx_tasklet;=0A=
+=0A=
+	int	rx_next_done;=0A=
+	int	rx_chain_head;=0A=
+	int	rx_chain_tail;=0A=
+	enum status	rx_chain_status;=0A=
+=0A=
+	int	tx_next_done;=0A=
+	int	tx_chain_head;=0A=
+	int	tx_chain_tail;=0A=
+	enum status	tx_chain_status;=0A=
+	int tx_count;=0A=
+	int	tx_full;=0A=
+=0A=
+	struct timer_list    mii_phy_timer;=0A=
+	unsigned long duplex_mode;=0A=
+=0A=
+	int   	rx_irq;=0A=
+	int    tx_irq;=0A=
+	int    ovr_irq;=0A=
+	int    und_irq;=0A=
+=0A=
+	struct net_device_stats stats;=0A=
+#ifdef CONFIG_SMP=0A=
+	spinlock_t lock;=0A=
+#endif=0A=
+=0A=
+	/* debug /proc entry */=0A=
+	struct proc_dir_entry *ps;=0A=
+	int dma_halt_cnt;=0A=
+        int ibudget;=0A=
+        int iquota;=0A=
+        int done_cnt;=0A=
+        int firstTime;=0A=
+        int not_done_cnt;=0A=
+        int dma_halt_nd_cnt;=0A=
+        int dma_ovr_count;=0A=
+        int dma_und_count;=0A=
+	int tx_stopped;=0A=
+};=0A=
+=0A=
+extern unsigned int idt_cpu_freq;=0A=
+=0A=
+/* Index to functions, as function prototypes. */=0A=
+static int rc32438_open(struct net_device *dev);=0A=
+static int rc32438_send_packet(struct sk_buff *skb, struct net_device =
*dev);=0A=
+//static void rc32438_mii_handler(unsigned long data);=0A=
+static irqreturn_t rc32438_rx_dma_interrupt(int irq, void *dev_id, =
struct pt_regs * regs);=0A=
+static irqreturn_t rc32438_tx_dma_interrupt(int irq, void *dev_id, =
struct pt_regs * regs);=0A=
+static int rc32438_poll(struct net_device *dev, int *budget);=0A=
+static int  rc32438_close(struct net_device *dev);=0A=
+static struct net_device_stats *rc32438_get_stats(struct net_device =
*dev);=0A=
+static void rc32438_multicast_list(struct net_device *dev);=0A=
+static int  rc32438_init(struct net_device *dev);=0A=
+static void rc32438_tx_timeout(struct net_device *dev);=0A=
+static void rc32438_tx_tasklet(unsigned long dev_id);=0A=
+#ifdef CONFIG_RC32438_REVISION_ZA=0A=
+static void rc32438_ovr_und_tasklet(unsigned long dev_id);=0A=
+#endif=0A=
+static void rc32438_cleanup_module(void);=0A=
+static int rc32438_probe(int port_num);=0A=
+int rc32438_init_module(void);=0A=
+=0A=
+static inline void rc32438_abort_dma(struct net_device *dev, =
DMA_Chan_t ch)=0A=
+{=0A=
+	if (rc32438_readl(&ch->dmac) & DMAC_run_m)=0A=
+	{=0A=
+		rc32438_writel(0x10, &ch->dmac);=0A=
+=0A=
+		while (!(rc32438_readl(&ch->dmas) & DMAS_h_m))=0A=
+			dev->trans_start =3D jiffies;=0A=
+=0A=
+		rc32438_writel(0, &ch->dmas);=0A=
+	}=0A=
+=0A=
+	rc32438_writel(0, &ch->dmadptr);=0A=
+	rc32438_writel(0, &ch->dmandptr);=0A=
+}=0A=
diff -uNr linux-2.6.16-rc5/.gitignore idtlinux/.gitignore=0A=
--- linux-2.6.16-rc5/.gitignore	2006-02-27 02:56:56.000000000 -0800=0A=
+++ idtlinux/.gitignore	1969-12-31 16:00:00.000000000 -0800=0A=
@@ -1,37 +0,0 @@=0A=
-#=0A=
-# NOTE! Don't add files that are generated in specific=0A=
-# subdirectories here. Add them in the ".gitignore" file=0A=
-# in that subdirectory instead.=0A=
-#=0A=
-# Normal rules=0A=
-#=0A=
-.*=0A=
-*.o=0A=
-*.a=0A=
-*.s=0A=
-*.ko=0A=
-*.so=0A=
-*.mod.c=0A=
-=0A=
-#=0A=
-# Top-level generic files=0A=
-#=0A=
-vmlinux*=0A=
-System.map=0A=
-Module.symvers=0A=
-=0A=
-#=0A=
-# Generated include files=0A=
-#=0A=
-include/asm=0A=
-include/asm-*/asm-offsets.h=0A=
-include/config=0A=
-include/linux/autoconf.h=0A=
-include/linux/compile.h=0A=
-include/linux/version.h=0A=
-include/asm-*/asm-offsets.h=0A=
-=0A=
-#=0A=
-# Quilt=0A=
-#=0A=
-patches=0A=
diff -uNr linux-2.6.16-rc5/include/asm-mips/bootinfo.h =
idtlinux/include/asm-mips/bootinfo.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/bootinfo.h	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/bootinfo.h	2006-03-09 16:26:31.000000000 =
-0800=0A=
@@ -218,6 +218,20 @@=0A=
 #define MACH_GROUP_TITAN       22	/* PMC-Sierra Titan		*/=0A=
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/=0A=
 =0A=
+=0A=
+/*                                                                     =
                                                                        =
                                                                   =0A=
+ * Valid machtype for group IDT boards                                 =
                                                                        =
                                                                   =0A=
+ */=0A=
+#define MACH_GROUP_IDT       23 /* IDT chips */=0A=
+=0A=
+#define  MACH_IDT_S334       0 /*  S334 */=0A=
+#define  MACH_IDT_EB355       1 /* EB355 */=0A=
+#define  MACH_IDT_EB438       2 /* EB438 */=0A=
+#define  MACH_IDT_EB365       3 /* EB365 */=0A=
+#define  MACH_IDT_EB434       4 /* EB434 */=0A=
+=0A=
+=0A=
+=0A=
 #define CL_SIZE			COMMAND_LINE_SIZE=0A=
 =0A=
 const char *get_system_type(void);=0A=
diff -uNr linux-2.6.16-rc5/include/asm-mips/cpu.h =
idtlinux/include/asm-mips/cpu.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/cpu.h	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/cpu.h	2006-03-09 16:26:31.000000000 =
-0800=0A=
@@ -53,6 +53,9 @@=0A=
 #define PRID_IMP_R12000		0x0e00=0A=
 #define PRID_IMP_R8000		0x1000=0A=
 #define PRID_IMP_PR4450		0x1200=0A=
+#define PRID_IMP_RC32334        0x1800=0A=
+#define PRID_IMP_RC32355        0x1900=0A=
+#define PRID_IMP_RC32365        0x1900=0A=
 #define PRID_IMP_R4600		0x2000=0A=
 #define PRID_IMP_R4700		0x2100=0A=
 #define PRID_IMP_TX39		0x2200=0A=
@@ -196,7 +199,8 @@=0A=
 #define CPU_34K			60=0A=
 #define CPU_PR4450		61=0A=
 #define CPU_SB1A		62=0A=
-#define CPU_LAST		62=0A=
+#define CPU_RC32300             63=0A=
+#define CPU_LAST		63=0A=
 =0A=
 /*=0A=
  * ISA Level encodings=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32300.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32300.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32300.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32300.h	2006-03-09 =
16:26:31.000000000 -0800=0A=
@@ -0,0 +1,135 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   RC32300 helper routines=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32300_H__=0A=
+#define __IDT_RC32300_H__=0A=
+=0A=
+#include <linux/delay.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+=0A=
+/* cpu pipeline flush */=0A=
+static inline void rc32300_sync(void)=0A=
+{=0A=
+	__asm__ volatile ("sync");=0A=
+}=0A=
+=0A=
+static inline void rc32300_sync_udelay(int us)=0A=
+{=0A=
+	__asm__ volatile ("sync");=0A=
+	udelay(us);=0A=
+}=0A=
+=0A=
+static inline void rc32300_sync_delay(int ms)=0A=
+{=0A=
+	__asm__ volatile ("sync");=0A=
+	mdelay(ms);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Macros to access internal RC32300 registers. No byte=0A=
+ * swapping should be done when accessing the internal=0A=
+ * registers.=0A=
+ */=0A=
+=0A=
+static inline u8 rc32300_readb(unsigned long pa)=0A=
+{=0A=
+	return *((volatile u8 *)KSEG1ADDR(pa));=0A=
+}=0A=
+static inline u16 rc32300_readw(unsigned long pa)=0A=
+{=0A=
+	return *((volatile u16 *)KSEG1ADDR(pa));=0A=
+}=0A=
+static inline u32 rc32300_readl(unsigned long pa)=0A=
+{=0A=
+	return *((volatile u32 *)KSEG1ADDR(pa));=0A=
+}=0A=
+static inline void rc32300_writeb(u8 val, unsigned long pa)=0A=
+{=0A=
+	*((volatile u8 *)KSEG1ADDR(pa)) =3D val;=0A=
+}=0A=
+static inline void rc32300_writew(u16 val, unsigned long pa)=0A=
+{=0A=
+	*((volatile u16 *)KSEG1ADDR(pa)) =3D val;=0A=
+}=0A=
+static inline void rc32300_writel(u32 val, unsigned long pa)=0A=
+{=0A=
+	*((volatile u32 *)KSEG1ADDR(pa)) =3D val;=0A=
+}=0A=
+=0A=
+=0A=
+#define local_readb __raw_readb=0A=
+#define local_readw __raw_readw=0A=
+#define local_readl __raw_readl=0A=
+=0A=
+#define local_writeb __raw_writeb=0A=
+#define local_writew __raw_writew=0A=
+#define local_writel __raw_writel=0A=
+=0A=
+=0A=
+/*=0A=
+ * C access to CLZ and CLO instructions=0A=
+ * (count leading zeroes/ones).=0A=
+ */=0A=
+static inline int rc32300_clz(unsigned long val)=0A=
+{=0A=
+	int ret;=0A=
+	__asm__ volatile (=0A=
+		".set\tnoreorder\n\t"=0A=
+		".set\tnoat\n\t"=0A=
+		".set\tmips32\n\t"=0A=
+		"clz\t%0,%1\n\t"=0A=
+		".set\tmips0\n\t"=0A=
+		".set\tat\n\t"=0A=
+		".set\treorder"=0A=
+		: "=3Dr" (ret)=0A=
+		: "r" (val));=0A=
+	=0A=
+	return ret;=0A=
+}=0A=
+static inline int rc32300_clo(unsigned long val)=0A=
+{=0A=
+	int ret;=0A=
+	__asm__ volatile (=0A=
+		    ".set\tnoreorder\n\t"=0A=
+		    ".set\tnoat\n\t"=0A=
+		    ".set\tmips32\n\t"=0A=
+		    "clo\t%0,%1\n\t"=0A=
+		    ".set\tmips0\n\t"=0A=
+		    ".set\tat\n\t"=0A=
+		    ".set\treorder"=0A=
+		    : "=3Dr" (ret)=0A=
+		    : "r" (val));=0A=
+	=0A=
+	return ret;=0A=
+}=0A=
+=0A=
+#endif  // __IDT_RC32300_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32334.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32334.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32334.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32334.h	2006-03-09 =
16:26:31.000000000 -0800=0A=
@@ -0,0 +1,200 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for IDT RC32334 CPU.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#ifndef __IDT_RC32334_H__=0A=
+#define __IDT_RC32334_H__=0A=
+=0A=
+#include <linux/delay.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+/* Base address of internal registers */=0A=
+#define RC32334_REG_BASE   0x18000000=0A=
+=0A=
+/* CPU and IP Bus Control */=0A=
+#define CPU_PORT_WIDTH     0xffffe200 // virtual!=0A=
+#define CPU_BTA            0xffffe204 // virtual!=0A=
+#define CPU_BUSERR_ADDR    0xffffe208 // virtual!=0A=
+#define CPU_IP_BTA         (RC32334_REG_BASE + 0x0000)=0A=
+#define CPU_IP_ADDR_LATCH  (RC32334_REG_BASE + 0x0004)=0A=
+#define CPU_IP_ARBITRATION (RC32334_REG_BASE + 0x0008)=0A=
+#define CPU_IP_BUSERR_CNTL (RC32334_REG_BASE + 0x0010)=0A=
+#define CPU_IP_BUSERR_ADDR (RC32334_REG_BASE + 0x0014)=0A=
+#define CPU_IP_SYSID       (RC32334_REG_BASE + 0x0018)=0A=
+=0A=
+/* Memory Controller */=0A=
+#define MEM_BASE_BANK0     (RC32334_REG_BASE + 0x0080)=0A=
+#define MEM_MASK_BANK0     (RC32334_REG_BASE + 0x0084)=0A=
+#define MEM_CNTL_BANK0     (RC32334_REG_BASE + 0x0200)=0A=
+#define MEM_BASE_BANK1     (RC32334_REG_BASE + 0x0088)=0A=
+#define MEM_MASK_BANK1     (RC32334_REG_BASE + 0x008c)=0A=
+#define MEM_CNTL_BANK1     (RC32334_REG_BASE + 0x0204)=0A=
+#define MEM_CNTL_BANK2     (RC32334_REG_BASE + 0x0208)=0A=
+#define MEM_CNTL_BANK3     (RC32334_REG_BASE + 0x020c)=0A=
+#define MEM_CNTL_BANK4     (RC32334_REG_BASE + 0x0210)=0A=
+#define MEM_CNTL_BANK5     (RC32334_REG_BASE + 0x0214)=0A=
+=0A=
+/* PCI Controller */=0A=
+#define PCI_INTR_PEND      (RC32334_REG_BASE + 0x05b0)=0A=
+#define PCI_INTR_MASK      (RC32334_REG_BASE + 0x05b4)=0A=
+#define PCI_INTR_CLEAR     (RC32334_REG_BASE + 0x05b8)=0A=
+#define CPU2PCI_INTR_PEND  (RC32334_REG_BASE + 0x05c0)=0A=
+#define CPU2PCI_INTR_MASK  (RC32334_REG_BASE + 0x05c4)=0A=
+#define CPU2PCI_INTR_CLEAR (RC32334_REG_BASE + 0x05c8)=0A=
+#define PCI2CPU_INTR_PEND  (RC32334_REG_BASE + 0x05d0)=0A=
+#define PCI2CPU_INTR_MASK  (RC32334_REG_BASE + 0x05d4)=0A=
+#define PCI2CPU_INTR_CLEAR (RC32334_REG_BASE + 0x05d8)=0A=
+#define PCI_MEM1_BASE      (RC32334_REG_BASE + 0x20b0)=0A=
+#define PCI_MEM2_BASE      (RC32334_REG_BASE + 0x20b8)=0A=
+#define PCI_MEM3_BASE      (RC32334_REG_BASE + 0x20c0)=0A=
+#define PCI_IO1_BASE       (RC32334_REG_BASE + 0x20c8)=0A=
+#define PCI_ARBITRATION    (RC32334_REG_BASE + 0x20e0)=0A=
+#define PCI_CPU_MEM1_BASE  (RC32334_REG_BASE + 0x20e8)=0A=
+#define PCI_CPU_IO_BASE    (RC32334_REG_BASE + 0x2100)=0A=
+#define PCI_CFG_CNTL	   (RC32334_REG_BASE + 0x2cf8)=0A=
+#define PCI_CFG_DATA	   (RC32334_REG_BASE + 0x2cfc)=0A=
+=0A=
+/* Timers */=0A=
+#define TIMER0_CNTL        (RC32334_REG_BASE + 0x0700)=0A=
+#define TIMER0_COUNT       (RC32334_REG_BASE + 0x0704)=0A=
+#define TIMER0_COMPARE     (RC32334_REG_BASE + 0x0708)=0A=
+#define TIMER_REG_OFFSET   0x10=0A=
+=0A=
+/* Programmable I/O */=0A=
+#define PIO_DATA0          (RC32334_REG_BASE + 0x0600)=0A=
+#define PIO_DATA1          (RC32334_REG_BASE + 0x0610)=0A=
+=0A=
+/*=0A=
+ * DMA=0A=
+ *=0A=
+ * NOTE: DMA_IO is a trick for non linear RC32300_IO_DMA stuff=0A=
+ *=0A=
+ * DMA0: 18001400=0A=
+ * DMA1: 18001440=0A=
+ * DMA2: 18001900=0A=
+ * DMA3: 18001940=0A=
+ * NB: dma number must be immediate value or variable.=0A=
+ *      It MUST NOT be a function since it would get called twice!=0A=
+ */=0A=
+#define DMA_IO(n)       (((n)>1?0x500:0)+((n)&1?0x40:0))=0A=
+ =0A=
+#define RC32300_IO_DMA(n)       (RC32334_REG_BASE + 0x1400 + =
DMA_IO(n))=0A=
+#define RC32300_DMA_CONFREG(n)  RC32300_IO_DMA(n)=0A=
+#define RC32300_DMA_BASEREG(n)  (RC32300_IO_DMA(n)+0x4)=0A=
+=0A=
+#define RC32300_DMA_CURRREG(n)  (RC32300_IO_DMA(n)+0x8)=0A=
+#define RC32300_DMA_STATREG(n)  (RC32300_IO_DMA(n)+0x10)=0A=
+#define RC32300_DMA_SRCREG(n)   (RC32300_IO_DMA(n)+0x14)=0A=
+#define RC32300_DMA_DSTREG(n)   (RC32300_IO_DMA(n)+0x18)=0A=
+#define RC32300_DMA_NEXTREG(n)  (RC32300_IO_DMA(n)+0x1c)=0A=
+=0A=
+#define RC32300_DMA_IRQ(n)  (GROUP7_IRQ_BASE+5*(n))=0A=
+=0A=
+/* Expansion Interrupt Controller */=0A=
+#define IC_GROUP0_PEND     (RC32334_REG_BASE + 0x0500)=0A=
+#define IC_GROUP0_MASK     (RC32334_REG_BASE + 0x0504)=0A=
+#define IC_GROUP0_CLEAR    (RC32334_REG_BASE + 0x0508)=0A=
+#define IC_GROUP_OFFSET    0x10=0A=
+=0A=
+#define NUM_INTR_GROUPS    15=0A=
+/*=0A=
+ * The IRQ mapping is as follows:=0A=
+ *=0A=
+ *    IRQ         Mapped To=0A=
+ *    ---     -------------------=0A=
+ *     0      SW0  (IP0) SW0 intr=0A=
+ *     1      SW1  (IP1) SW1 intr=0A=
+ *     2      Int0 (IP2) board-specific=0A=
+ *     3      Int1 (IP3) board-specific=0A=
+ *     4      Int2 (IP4) board-specific=0A=
+ *     -      Int3 (IP5) not used, mapped to IRQ's 8 and up=0A=
+ *     6      Int4 (IP6) board-specific=0A=
+ *     7      Int5 (IP7) CP0 Timer=0A=
+ *=0A=
+ * IRQ's 8 and up are all mapped to Int3 (IP5), which=0A=
+ * internally on the RC32334 is routed to the Expansion=0A=
+ * Interrupt Controller.=0A=
+ */=0A=
+#define MIPS_CPU_TIMER_IRQ 7=0A=
+=0A=
+#define GROUP1_IRQ_BASE  8                       // bus error=0A=
+#define GROUP2_IRQ_BASE  (GROUP1_IRQ_BASE + 1)   // PIO active low=0A=
+#define GROUP3_IRQ_BASE  (GROUP2_IRQ_BASE + 12)  // PIO active high=0A=
+#define GROUP4_IRQ_BASE  (GROUP3_IRQ_BASE + 8)   // Timer Rollovers=0A=
+#define GROUP5_IRQ_BASE  (GROUP4_IRQ_BASE + 8)   // UART0=0A=
+#define GROUP6_IRQ_BASE  (GROUP5_IRQ_BASE + 3)   // UART1=0A=
+#define GROUP7_IRQ_BASE  (GROUP6_IRQ_BASE + 3)   // DMA Ch0=0A=
+#define GROUP8_IRQ_BASE  (GROUP7_IRQ_BASE + 5)   // DMA Ch1=0A=
+#define GROUP9_IRQ_BASE  (GROUP8_IRQ_BASE + 5)   // DMA Ch2=0A=
+#define GROUP10_IRQ_BASE (GROUP9_IRQ_BASE + 5)   // DMA Ch3=0A=
+#define GROUP11_IRQ_BASE (GROUP10_IRQ_BASE + 5)  // PCI Ctlr errors=0A=
+#define GROUP12_IRQ_BASE (GROUP11_IRQ_BASE + 4)  // PCI Satellite =
Mode=0A=
+#define GROUP13_IRQ_BASE (GROUP12_IRQ_BASE + 16) // PCI to CPU =
Mailbox=0A=
+#define GROUP14_IRQ_BASE (GROUP13_IRQ_BASE + 4)  // SPI=0A=
+=0A=
+#define RC32334_NR_IRQS  (GROUP14_IRQ_BASE + 1)=0A=
+=0A=
+/* 16550 UARTs */=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32300_UART0_BASE (RC32334_REG_BASE + 0x0803)=0A=
+#define RC32300_UART1_BASE (RC32334_REG_BASE + 0x0823)=0A=
+#else=0A=
+#define RC32300_UART0_BASE (RC32334_REG_BASE + 0x0800)=0A=
+#define RC32300_UART1_BASE (RC32334_REG_BASE + 0x0820)=0A=
+#endif=0A=
+=0A=
+#define RC32300_UART0_IRQ  GROUP5_IRQ_BASE=0A=
+#define RC32300_UART1_IRQ  GROUP6_IRQ_BASE=0A=
+=0A=
+#define IDT_CLOCK_MULT 2=0A=
+=0A=
+/* NVRAM */=0A=
+#define NVRAM_BASE         0x12000000=0A=
+#define NVRAM_ENVSIZE_OFF  4=0A=
+#define NVRAM_ENVSTART_OFF 0x40=0A=
+=0A=
+/* LCD 4-digit display */=0A=
+#define LCD_CLEAR          0x14000400=0A=
+#define LCD_DIGIT0         0x1400000f=0A=
+#define LCD_DIGIT1         0x14000008=0A=
+#define LCD_DIGIT2         0x14000007=0A=
+#define LCD_DIGIT3         0x14000003=0A=
+=0A=
+/* Interrupts routed on 79S334A board (see rc32334.h) */=0A=
+#define RC32334_SCC8530_IRQ  2=0A=
+#define RC32334_PCI_INTA_IRQ 3=0A=
+#define RC32334_PCI_INTB_IRQ 4=0A=
+#define RC32334_PCI_INTC_IRQ 6=0A=
+#define RC32334_PCI_INTD_IRQ 7=0A=
+=0A=
+#define RAM_SIZE	(32*1024*1024)=0A=
+=0A=
+#endif // __IDT_RC32334_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32355_dma.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32355_dma.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32355_dma.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32355_dma.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,202 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     DMA controller defines on IDT RC32355=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef BANYAN_DMA_H=0A=
+#define BANYAN_DMA_H=0A=
+#include  <asm/idt-boards/rc32300/rc32300.h>=0A=
+=0A=
+/*=0A=
+ * An image of one RC32355 dma channel registers=0A=
+ */=0A=
+typedef struct {=0A=
+	u32 dmac;=0A=
+	u32 dmas;=0A=
+	u32 dmasm;=0A=
+	u32 dmadptr;=0A=
+	u32 dmandptr;=0A=
+} rc32355_dma_ch_t;=0A=
+=0A=
+/*=0A=
+ * An image of all RC32355 dma channel registers=0A=
+ */=0A=
+typedef struct {=0A=
+	rc32355_dma_ch_t ch[16];=0A=
+} rc32355_dma_regs_t;=0A=
+=0A=
+=0A=
+#define rc32355_dma_regs =
((rc32355_dma_regs_t*)KSEG1ADDR(RC32355_DMA_BASE))=0A=
+=0A=
+=0A=
+/* DMAC register layout */=0A=
+=0A=
+#define DMAC_RUN	0x1	/* Halts processing when cleared	*/=0A=
+#define DMAC_DM		0x2	/* Done Mask, ignore DMA events		*/=0A=
+#define DMAC_MODE_MASK	0xC	/* DMA operating mode			*/=0A=
+=0A=
+#define DMAC_MODE_AUTO	0x0	/* DMA Auto Request Mode		*/=0A=
+#define DMAC_MODE_BURST	0x4	/* DMA Burst Request Mode		*/=0A=
+#define DMAC_MODE_TFER	0x8	/* DMA Transfer Request Mode		*/=0A=
+=0A=
+/* DMAS and DMASM register layout */=0A=
+=0A=
+#define DMAS_F		0x01	/* Finished */=0A=
+#define DMAS_D		0x02	/* Done */=0A=
+#define DMAS_C		0x04	/* Chain */=0A=
+#define DMAS_E		0x08	/* Error */=0A=
+#define DMAS_H		0x10	/* Halt */=0A=
+=0A=
+/* Polling count for DMAS_H bit in DMAS register after halting DMA =
*/=0A=
+#define DMA_HALT_TIMEOUT 500=0A=
+=0A=
+=0A=
+static inline int rc32355_halt_dma(rc32355_dma_ch_t* ch)=0A=
+{=0A=
+	int timeout=3D1;=0A=
+	=0A=
+	if (local_readl(&ch->dmac) & DMAC_RUN) {=0A=
+		local_writel(0, &ch->dmac); =0A=
+		for (timeout =3D DMA_HALT_TIMEOUT; timeout > 0; timeout--) {=0A=
+			if (local_readl(&ch->dmas) & DMAS_H) {=0A=
+				local_writel(0, &ch->dmas);  =0A=
+				break;=0A=
+			}=0A=
+		}=0A=
+	}=0A=
+=0A=
+	return timeout ? 0 : 1;=0A=
+}=0A=
+=0A=
+static inline void rc32355_start_dma(rc32355_dma_ch_t* ch, u32 =
dma_addr)=0A=
+{=0A=
+	local_writel(0, &ch->dmandptr); =0A=
+	local_writel(dma_addr, &ch->dmadptr);=0A=
+}=0A=
+=0A=
+static inline void rc32355_chain_dma(rc32355_dma_ch_t* ch, u32 =
dma_addr)=0A=
+{=0A=
+	local_writel(dma_addr, &ch->dmandptr);=0A=
+}=0A=
+=0A=
+=0A=
+/* The following can be used to describe DMA channels 0 to 15, and the	=
*/=0A=
+/* sub device's needed to select them in the DMADESC_DS_MASK field	=
*/=0A=
+=0A=
+#define DMA_CHAN_ATM01		0	     /* ATM interface 0,1 chan	*/=0A=
+=0A=
+#define DMA_CHAN_ATM0IN		0	     /* ATM interface 0 input	*/=0A=
+#define DMA_DEV_ATM0IN		0	     /* ATM interface 0 input	*/=0A=
+=0A=
+#define DMA_CHAN_ATM1IN		0	     /* ATM interface 1 input	*/=0A=
+#define DMA_DEV_ATM1IN		1	     /* ATM interface 1 input	*/=0A=
+=0A=
+#define DMA_CHAN_ATM0OUT	0	     /* ATM interface 0 output	*/=0A=
+#define DMA_DEV_ATM0OUT		2	     /* ATM interface 0 output	*/=0A=
+=0A=
+#define DMA_CHAN_ATM1OUT	0	     /* ATM interface 1 output	*/=0A=
+#define DMA_DEV_ATM1OUT		3	     /* ATM interface 1 output	*/=0A=
+=0A=
+/* for entry in {0,1,2,3,4,5,6,7} - note 5,6,7 share with those below =
*/=0A=
+#define DMA_CHAN_ATMVCC(entry)	((entry)+1)  /* ATM VC cache entry 	=
*/=0A=
+#define DMA_DEV_ATMVCC(entry)	0=0A=
+=0A=
+#define DMA_CHAN_MEMTOMEM	6	     /* Memory to memory DMA 	*/=0A=
+#define DMA_DEV_MEMTOMEM	1	     /* Memory to memory DMA 	*/=0A=
+=0A=
+#define DMA_CHAN_ATMFMB0	7	     /* ATM Frame Mode Buffer 0	*/=0A=
+#define DMA_DEV_ATMFMB0		1	     /* ATM Frame Mode Buffer 0	*/=0A=
+=0A=
+#define DMA_CHAN_ATMFMB1	8	     /* ATM Frame Mode Buffer 1	*/=0A=
+#define DMA_DEV_ATMFMB1		1	     /* ATM Frame Mode Buffer 1	*/=0A=
+=0A=
+#define DMA_CHAN_ETHERIN	9	     /* Ethernet input		*/=0A=
+#define DMA_DEV_ETHERIN		0	     /* Ethernet input		*/=0A=
+=0A=
+#define DMA_CHAN_ETHEROUT	10	     /* Ethernet output		*/=0A=
+#define DMA_DEV_ETHEROUT	0	     /* Ethernet output		*/=0A=
+=0A=
+#define DMA_CHAN_TDMIN		11	     /* TDM Bus input		*/=0A=
+#define DMA_DEV_TDMIN		0	     /* TDM Bus input		*/=0A=
+=0A=
+#define DMA_CHAN_TDMOUT		12	     /* TDM Bus output		*/=0A=
+#define DMA_DEV_TDMOUT		0	     /* TDM Bus output		*/=0A=
+=0A=
+#define DMA_CHAN_USBIN		13	     /* USB input		*/=0A=
+#define DMA_DEV_USBIN		0	     /* USB input		*/=0A=
+=0A=
+#define DMA_CHAN_USBOUT		14	     /* USB output		*/=0A=
+#define DMA_DEV_USBOUT		0	     /* USB output		*/=0A=
+=0A=
+#define DMA_CHAN_EXTERN		15	     /* External DMA		*/=0A=
+#define DMA_DEV_EXTERN		0	     /* External DMA		*/=0A=
+=0A=
+/*=0A=
+ * An RC32355 dma descriptor in system memory=0A=
+ */=0A=
+typedef struct {=0A=
+	u32 cmdstat;	/* control and status */=0A=
+	u32 curr_addr;	/* current address of data */=0A=
+	u32 devcs;	/* peripheral-specific control and status */=0A=
+	u32 link;	/* link to next descriptor */=0A=
+} rc32355_dma_desc_t;=0A=
+=0A=
+/* Values for the descriptor cmdstat word */=0A=
+=0A=
+#define DMADESC_F		0x80000000u  /* Finished bit		*/=0A=
+#define DMADESC_D		0x40000000u  /* Done bit		*/=0A=
+#define DMADESC_T		0x20000000u  /* Terminated bit		*/=0A=
+#define DMADESC_IOD		0x10000000u  /* Interrupt On Done	*/=0A=
+#define DMADESC_IOF		0x08000000u  /* Interrupt On Finished	*/=0A=
+#define DMADESC_COD		0x04000000u  /* Chain On Done		*/=0A=
+#define DMADESC_COF		0x02000000u  /* Chain On Finished	*/=0A=
+=0A=
+#define DMADESC_DEVCMD_MASK	0x01C00000u  /* Device Command mask	*/=0A=
+#define DMADESC_DEVCMD_SHIFT	22	     /* Device Command shift	*/=0A=
+=0A=
+#define DMADESC_DS_MASK		0x00300000u  /* Device Select mask	*/=0A=
+#define DMADESC_DS_SHIFT	20	     /* Device Select shift	*/=0A=
+=0A=
+#define DMADESC_COUNT_MASK	0x0003FFFFu  /* Byte Count mask		*/=0A=
+#define DMADESC_COUNT_SHIFT	0	     /* Byte Count shift	*/=0A=
+=0A=
+#define IS_DMA_FINISHED(X)   ( ( (X) & DMADESC_F ) >> 31)   /* F Bit   =
 */=0A=
+#define IS_DMA_DONE(X)       ( ( (X) & DMADESC_D ) >> 30)   /* D Bit   =
 */=0A=
+#define IS_DMA_TERMINATED(X) ( ( (X) & DMADESC_T ) >> 29)   /* T Bit   =
 */=0A=
+#define IS_DMA_USED(X) (((X) & (DMADESC_F | DMADESC_D | DMADESC_T)) =
!=3D 0)=0A=
+=0A=
+#define DMA_DEVCMD(devcmd) \=0A=
+  (((devcmd) << DMADESC_DEVCMD_SHIFT) & DMADESC_DS_MASK)=0A=
+#define DMA_DS(ds)         \=0A=
+  (((ds) << DMADESC_DS_SHIFT) & DMADESC_DS_MASK)=0A=
+#define DMA_COUNT(count)   \=0A=
+  ((count) & DMADESC_COUNT_MASK)=0A=
+=0A=
+#endif /* RC32355_DMA_H */=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32355_eth.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32355_eth.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32355_eth.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32355_eth.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,438 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Ethernet registers on IDT RC32355=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#ifndef RC32355_ETHER_H=0A=
+#define RC32355_ETHER_H=0A=
+=0A=
+#include <asm/idt-boards/rc32300/rc32355_dma.h>=0A=
+=0A=
+/*=0A=
+ * A partial image of the RC32355 ethernet registers=0A=
+ */=0A=
+typedef struct {=0A=
+	u32 ethintfc;=0A=
+	u32 ethfifott;=0A=
+	u32 etharc;=0A=
+	u32 ethhash0;=0A=
+	u32 ethhash1;=0A=
+	u32 ethfifost;=0A=
+	u32 ethfifos;=0A=
+	u32 ethodeops;=0A=
+	u32 ethis;=0A=
+	u32 ethos;=0A=
+	u32 ethmcp;=0A=
+	u32 _u1;=0A=
+	u32 ethid;=0A=
+	u32 _u2;=0A=
+	u32 _u3;=0A=
+	u32 _u4;=0A=
+	u32 ethod;=0A=
+	u32 _u5;=0A=
+	u32 _u6;=0A=
+	u32 _u7;=0A=
+	u32 ethodeop;=0A=
+	u32 _u8[43]; =0A=
+	u32 ethsal0;=0A=
+	u32 ethsah0;=0A=
+	u32 ethsal1;=0A=
+	u32 ethsah1;=0A=
+	u32 ethsal2;=0A=
+	u32 ethsah2;=0A=
+	u32 ethsal3;=0A=
+	u32 ethsah3;=0A=
+	u32 ethrbc;=0A=
+	u32 ethrpc;=0A=
+	u32 ethrupc;=0A=
+	u32 ethrfc;=0A=
+	u32 ethtbc;=0A=
+	u32 ethgpf;=0A=
+	u32 _u9[50];=0A=
+	u32 ethmac1;=0A=
+	u32 ethmac2;=0A=
+	u32 ethipgt;=0A=
+	u32 ethipgr;=0A=
+	u32 ethclrt;=0A=
+	u32 ethmaxf;=0A=
+	u32 _u10;=0A=
+	u32 ethmtest;=0A=
+	u32 miimcfg;=0A=
+	u32 miimcmd;=0A=
+	u32 miimaddr;=0A=
+	u32 miimwtd;=0A=
+	u32 miimrdd;=0A=
+	u32 miimind;=0A=
+	u32 _u11;=0A=
+	u32 _u12;=0A=
+	u32 ethcfsa0;=0A=
+	u32 ethcfsa1;=0A=
+	u32 ethcfsa2;=0A=
+} rc32355_eth_regs_t;=0A=
+ =0A=
+#define rc32355_eth_regs =
((rc32355_eth_regs_t*)KSEG1ADDR(RC32355_ETH_BASE))=0A=
+=0A=
+#define ETH_INTFC   (RC32355_ETH_BASE + 0x000) /* INTerFace Control  =
*/=0A=
+#define ETH_FIFOTT  (RC32355_ETH_BASE + 0x004) /* FIFO Transmit =
Threshold  */=0A=
+#define ETH_ARC     (RC32355_ETH_BASE + 0x008) /* Address Recognition =
Ctrl  */=0A=
+#define ETH_HASH0   (RC32355_ETH_BASE + 0x00C) /* 32 multicast Hash =
bits */=0A=
+#define ETH_HASH1   (RC32355_ETH_BASE + 0x010) /* another 32 Hash bits =
*/=0A=
+#define ETH_FIFOST  (RC32355_ETH_BASE + 0x014) /* FIFO Status =
Threshold */=0A=
+#define ETH_FIFOS   (RC32355_ETH_BASE + 0x018) /* FIFO Status Register =
*/=0A=
+#define ETH_ODEOPS  (RC32355_ETH_BASE + 0x01C) /* Out Data End-Of-Pkt =
Size */=0A=
+#define ETH_IS      (RC32355_ETH_BASE + 0x020) /* Input Status */=0A=
+#define ETH_OS      (RC32355_ETH_BASE + 0x024) /* Output Status  */=0A=
+#define ETH_MCP     (RC32355_ETH_BASE + 0x028) /* Managemt Clock =
Prescaler */=0A=
+#define ETH_ID      (RC32355_ETH_BASE + 0x030) /* Input Data register =
*/=0A=
+#define ETH_OD      (RC32355_ETH_BASE + 0x040) /* Output Data register =
*/=0A=
+#define ETH_ODEOP   (RC32355_ETH_BASE + 0x050) /* OD End-Of-Packet =
Size */=0A=
+=0A=
+/* for n in { 0, 1, 2, 3 } */=0A=
+#define ETH_SAL(n)  (RC32355_ETH_BASE + 0x100 + (n * 8)) /* Stn =
Address 2-5 */=0A=
+#define ETH_SAH(n)  (RC32355_ETH_BASE + 0x104 + (n * 8)) /* Stn Address=
 0-1 */=0A=
+=0A=
+#define ETH_RBC     (RC32355_ETH_BASE + 0x120) /* Receive Byte Count =
*/=0A=
+#define ETH_RPC     (RC32355_ETH_BASE + 0x124) /* Receive Packet Count =
*/=0A=
+#define ETH_RUPC    (RC32355_ETH_BASE + 0x128) /* Rx Undersized Pkt =
count */=0A=
+#define ETH_RFC     (RC32355_ETH_BASE + 0x12C) /* Receive Fragment =
Count */=0A=
+#define ETH_TBC     (RC32355_ETH_BASE + 0x130) /* Transmit Byte Count =
*/=0A=
+#define ETH_GPF     (RC32355_ETH_BASE + 0x134) /* Generate Pause Frame =
*/=0A=
+#define ETH_MAC1    (RC32355_ETH_BASE + 0x200) /* Medium Access =
Control 1 */=0A=
+#define ETH_MAC2    (RC32355_ETH_BASE + 0x204) /* Medium Access =
Control 2 */=0A=
+#define ETH_IPGT    (RC32355_ETH_BASE + 0x208) /* Back-to-back =
InterPkt Gap */=0A=
+#define ETH_IPGR    (RC32355_ETH_BASE + 0x20C) /* Non " InterPkt Gap =
*/=0A=
+#define ETH_CLRT    (RC32355_ETH_BASE + 0x210) /* Collis'n Window and =
Retry */=0A=
+#define ETH_MAXF    (RC32355_ETH_BASE + 0x214) /* Maximum Frame Length =
*/=0A=
+#define ETH_MTEST   (RC32355_ETH_BASE + 0x21C) /* MAC Test */=0A=
+=0A=
+#define ETHMIIM_CFG (RC32355_ETH_BASE + 0x220) /* MII Mgmt =
Configuration */=0A=
+#define ETHMIIM_CMD (RC32355_ETH_BASE + 0x224) /* MII Mgmt Command  =
*/=0A=
+#define ETHMIIM_ADDR (RC32355_ETH_BASE + 0x228) /* MII Mgmt Address =
*/=0A=
+#define ETHMIIM_WTD (RC32355_ETH_BASE + 0x22C) /* MII Mgmt Write Data =
*/=0A=
+#define ETHMIIM_RDD (RC32355_ETH_BASE + 0x230) /* MII Mgmt Read Data =
*/=0A=
+#define ETHMIIM_IND (RC32355_ETH_BASE + 0x234) /* MII Mgmt Indicators =
*/=0A=
+=0A=
+/* for n in { 0, 1, 2 } */=0A=
+#define ETH_CFSA(n) (RC32355_ETH_BASE + 0x240 + ((n) * 4))  /* Station =
Addr */=0A=
+=0A=
+=0A=
+/*=0A=
+ * Register Interpretations follow=0A=
+ */=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHINTFC register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERINTFC_EN            (1<<0)=0A=
+#define ETHERINTFC_ITS           (1<<1)=0A=
+#define ETHERINTFC_RES           (1<<2)=0A=
+#define ETHERINTFC_RIP           (1<<2)=0A=
+#define ETHERINTFC_JAM           (1<<3)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHFIFOTT register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERFIFOTT_TTH(v)      (((v)&0x3f)<<0)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHARC register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERARC_PRO             (1<<0)=0A=
+#define ETHERARC_AM              (1<<1)=0A=
+#define ETHERARC_AFM             (1<<2)=0A=
+#define ETHERARC_AB              (1<<3)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHHASH registers=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERHASH0(v)            (((v)&0xffff)<<0)=0A=
+#define ETHERHASH1(v)            (((v)&0xffff)<<0)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHSA registers=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERSAL0(v)             (((v)&0xffff)<<0)=0A=
+#define ETHERSAL1(v)             (((v)&0xffff)<<0)=0A=
+#define ETHERSAL2(v)             (((v)&0xffff)<<0)=0A=
+#define ETHERSAL3(v)             (((v)&0xffff)<<0)=0A=
+#define ETHERSAH0(v)             (((v)&0xff)<<0)=0A=
+#define ETHERSAH1(v)             (((v)&0xff)<<0)=0A=
+#define ETHERSAH2(v)             (((v)&0xff)<<0)=0A=
+#define ETHERSAH3(v)             (((v)&0xff)<<0)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHFIFOST register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERFIFOST_IRTH(v)      (((v)&0x3f)<<0)=0A=
+#define ETHERFIFOST_ORTH(v)      (((v)&0x3f)<<16)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHFIFOS register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERFIFOS_IR            (1<<0)=0A=
+#define ETHERFIFOS_OR            (1<<1)  =0A=
+#define ETHERFIFOS_OVR           (1<<2)  =0A=
+#define ETHERFIFOS_UND           (1<<3)  =0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * DATA registers=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERID(v)               (((v)&0xffff)<<0)=0A=
+#define ETHEROD(v)               (((v)&0xffff)<<0)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHODEOPS register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERODEOPS_SIZE(v)      (((v)&0x3)<<0)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHODEOP register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERODEOP(v)            (((v)&0xffff)<<0)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHIS register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERIS_EOP              (1<<0)  =0A=
+#define ETHERIS_ROK              (1<<2)  =0A=
+#define ETHERIS_FM               (1<<3)  =0A=
+#define ETHERIS_MP               (1<<4)  =0A=
+#define ETHERIS_BP               (1<<5)  =0A=
+#define ETHERIS_VLT              (1<<6)  =0A=
+#define ETHERIS_CF               (1<<7)  =0A=
+#define ETHERIS_OVR              (1<<8)  =0A=
+#define ETHERIS_CRC              (1<<9)  =0A=
+#define ETHERIS_CV               (1<<10)  =0A=
+#define ETHERIS_DB               (1<<11)  =0A=
+#define ETHERIS_LE               (1<<12)  =0A=
+#define ETHERIS_LOR              (1<<13)  =0A=
+#define ETHERIS_SIZE(v)          (((v)&0x3)<<14)=0A=
+#define ETHERIS_LENGTH(v)        (((v)&0xff)<<16)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHOS register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHEROS_T                (1<<0)  =0A=
+#define ETHEROS_TOK              (1<<6)  =0A=
+#define ETHEROS_MP               (1<<7)  =0A=
+#define ETHEROS_BP               (1<<8)  =0A=
+#define ETHEROS_UND              (1<<9)  =0A=
+#define ETHEROS_OF               (1<<10)  =0A=
+#define ETHEROS_ED               (1<<11)  =0A=
+#define ETHEROS_EC               (1<<12)  =0A=
+#define ETHEROS_LC               (1<<13)  =0A=
+#define ETHEROS_TD               (1<<14)  =0A=
+#define ETHEROS_CRC              (1<<15)  =0A=
+#define ETHEROS_LE               (1<<16)  =0A=
+#define ETHEROS_CC(v)            (((v)&0xf)<<17)=0A=
+#define ETHEROS_PFD              (1<<21)  =0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * Statistics registers=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERRBC(v)              (((v)&0xffff)<<0)=0A=
+#define ETHERRPC(v)              (((v)&0xffff)<<0)=0A=
+#define ETHERRUPC(v)             (((v)&0xffff)<<0)=0A=
+#define ETHERRFC(v)              (((v)&0xffff)<<0)=0A=
+#define ETHERTBC(v)              (((v)&0xffff)<<0)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * ETHGPF register=0A=
+ =
************************************************************************=
*****/=0A=
+=0A=
+#define ETHERGPF_PTV(v)          (((v)&0xff)<<0)=0A=
+=0A=
+/**********************************************************************=
********=0A=
+ * MAC registers=0A=
+ =
************************************************************************=
*****/=0A=
+//ETHMAC1=0A=
+#define ETHERMAC1_RE             (1<<0)=0A=
+#define ETHERMAC1_PAF            (1<<1)=0A=
+#define ETHERMAC1_RFC            (1<<2)=0A=
+#define ETHERMAC1_TFC            (1<<3)=0A=
+#define ETHERMAC1_LB             (1<<4)=0A=
+#define ETHERMAC1_MR             (1<<15)=0A=
+=0A=
+//ETHMAC2=0A=
+#define ETHERMAC2_FD             (1<<0)=0A=
+#define ETHERMAC2_FLC            (1<<1)=0A=
+#define ETHERMAC2_HFE            (1<<2)=0A=
+#define ETHERMAC2_DC             (1<<3)=0A=
+#define ETHERMAC2_CEN            (1<<4)=0A=
+#define ETHERMAC2_PE             (1<<5)=0A=
+#define ETHERMAC2_VPE            (1<<6)=0A=
+#define ETHERMAC2_APE            (1<<7)=0A=
+#define ETHERMAC2_PPE            (1<<8)=0A=
+#define ETHERMAC2_LPE            (1<<9)=0A=
+#define ETHERMAC2_NB             (1<<12)=0A=
+#define ETHERMAC2_BP             (1<<13)=0A=
+#define ETHERMAC2_ED             (1<<14)=0A=
+=0A=
+//ETHIPGT=0A=
+#define ETHERIPGT(v)             (((v)&0x3f)<<0)=0A=
+=0A=
+//ETHIPGR=0A=
+#define ETHERIPGR_IPGR1(v)       (((v)&0x3f)<<0)=0A=
+#define ETHERIPGR_IPGR2(v)       (((v)&0x3f)<<8)=0A=
+=0A=
+//ETHCLRT=0A=
+#define ETHERCLRT_MAXRET(v)      (((v)&0x3f)<<0)=0A=
+#define ETHERCLRT_COLWIN(v)      (((v)&0x3f)<<8)=0A=
+=0A=
+//ETHMAXF=0A=
+#define ETHERMAXF(v)             (((v)&0x3f)<<0)=0A=
+=0A=
+//ETHMTEST=0A=
+#define ETHERMTEST_TB            (1<<2)=0A=
+=0A=
+//ETHMCP=0A=
+#define ETHERMCP_DIV(v)          (((v)&0xff)<<0)=0A=
+=0A=
+//MIIMCFG=0A=
+#define ETHERMIIMCFG_CS(v)          (((v)&0x3)<<2)=0A=
+#define ETHERMIIMCFG_R              (1<<15)=0A=
+=0A=
+//MIIMCMD=0A=
+#define ETHERMIIMCMD_RD             (1<<0)=0A=
+#define ETHERMIIMCMD_SCN            (1<<1)=0A=
+=0A=
+//MIIMADDR=0A=
+#define ETHERMIIMADDR_REGADDR(v)    (((v)&0x1f)<<0)=0A=
+#define ETHERMIIMADDR_PHYADDR(v)    (((v)&0x1f)<<8)=0A=
+=0A=
+//MIIMWTD=0A=
+#define ETHERMIIMWTD(v)             (((v)&0xff)<<0)=0A=
+=0A=
+//MIIMRDD=0A=
+#define ETHERMIIMRDD(v)             (((v)&0xff)<<0)=0A=
+=0A=
+//MIIMIND=0A=
+#define ETHERMIIMIND_BSY            (1<<0)=0A=
+#define ETHERMIIMIND_SCN            (1<<1)=0A=
+#define ETHERMIIMIND_NV             (1<<2)=0A=
+=0A=
+//DMA DEVCS IN=0A=
+#define ETHERDMA_IN_LENGTH(v)	(((v)&0xffff)<<16)=0A=
+#define ETHERDMA_IN_CES		(1<<14)=0A=
+#define ETHERDMA_IN_LOR		(1<<13)=0A=
+#define ETHERDMA_IN_LE		(1<<12)=0A=
+#define ETHERDMA_IN_DB		(1<<11)=0A=
+#define ETHERDMA_IN_CV		(1<<10)=0A=
+#define ETHERDMA_IN_CRC		(1<<9)=0A=
+#define ETHERDMA_IN_OVR		(1<<8)=0A=
+#define ETHERDMA_IN_CF		(1<<7)=0A=
+#define ETHERDMA_IN_VLT		(1<<6)=0A=
+#define ETHERDMA_IN_BP		(1<<5)=0A=
+#define ETHERDMA_IN_MP		(1<<4)=0A=
+#define ETHERDMA_IN_FM		(1<<3)=0A=
+#define ETHERDMA_IN_ROK		(1<<2)=0A=
+#define ETHERDMA_IN_LD		(1<<1)=0A=
+#define ETHERDMA_IN_FD		(1<<0)=0A=
+=0A=
+//DMA DEVCS OUT=0A=
+#define ETHERDMA_OUT_CC(v)	(((v)&0xf)<<17)=0A=
+#define ETHERDMA_OUT_CNT         0x001e0000=0A=
+#define ETHERDMA_OUT_SHFT       17=0A=
+#define ETHERDMA_OUT_LE		(1<<16)=0A=
+=0A=
+#define ETHERDMA_OUT_CRC	(1<<15)=0A=
+#define ETHERDMA_OUT_TD		(1<<14)=0A=
+#define ETHERDMA_OUT_LC		(1<<13)=0A=
+#define ETHERDMA_OUT_EC		(1<<12)=0A=
+#define ETHERDMA_OUT_ED		(1<<11)=0A=
+#define ETHERDMA_OUT_OF		(1<<10)=0A=
+#define ETHERDMA_OUT_UND	(1<<9)=0A=
+#define ETHERDMA_OUT_BP		(1<<8)=0A=
+#define ETHERDMA_OUT_MP		(1<<7)=0A=
+#define ETHERDMA_OUT_TOK	(1<<6)=0A=
+#define ETHERDMA_OUT_HEN	(1<<5)=0A=
+#define ETHERDMA_OUT_CEN	(1<<4)=0A=
+#define ETHERDMA_OUT_PEN	(1<<3)=0A=
+#define ETHERDMA_OUT_OEN	(1<<2)=0A=
+#define ETHERDMA_OUT_LD		(1<<1)=0A=
+#define ETHERDMA_OUT_FD		(1<<0)=0A=
+=0A=
+#define RCV_ERRS \=0A=
+  (ETHERDMA_IN_OVR | ETHERDMA_IN_CRC | ETHERDMA_IN_CV | =
ETHERDMA_IN_LE)=0A=
+#define TX_ERRS  \=0A=
+  (ETHERDMA_OUT_LC | ETHERDMA_OUT_EC | ETHERDMA_OUT_ED | \=0A=
+   ETHERDMA_OUT_OF | ETHERDMA_OUT_UND)=0A=
+=0A=
+#define IS_RCV_ROK(X)        (((X) & (1<<2)) >> 2)       /* Receive =
Okay     */=0A=
+#define IS_RCV_FM(X)         (((X) & (1<<3)) >> 3)       /* Is Filter =
Match  */=0A=
+#define IS_RCV_MP(X)         (((X) & (1<<4)) >> 4)       /* Is it MP   =
      */=0A=
+#define IS_RCV_BP(X)         (((X) & (1<<5)) >> 5)       /* Is it BP   =
      */=0A=
+#define IS_RCV_VLT(X)        (((X) & (1<<6)) >> 6)       /* VLAN Tag =
Detect  */=0A=
+#define IS_RCV_CF(X)         (((X) & (1<<7)) >> 7)       /* Control =
Frame    */=0A=
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<8)) >> 8)       /* Receive =
Overflow */=0A=
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<9)) >> 9)       /* CRC Error  =
      */=0A=
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<10))>>10)       /* Code =
Violation   */=0A=
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<11))>>11)       /* Dribble =
Bits     */=0A=
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<12))>>12)       /* Length =
error     */=0A=
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<13))>>13)       /* Length Out =
of=0A=
+                                                            Range      =
      */=0A=
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<14))>>14)       /* Preamble =
error   */=0A=
+#define RCVPKT_LENGTH(X)     (((X) & 0xFFFF0000)>>16)    /* Length of =
the=0A=
+                                                            received =
packet  */=0A=
+=0A=
+#define IS_TX_TOK(X)         (((X) & (1<<6) ) >> 6 )     /* Transmit =
Okay    */=0A=
+#define IS_TX_MP(X)          (((X) & (1<<7) ) >> 7 )     /* Multicast  =
      */=0A=
+=0A=
+#define IS_TX_BP(X)          (((X) & (1<<8) ) >> 8 )     /* Broadcast  =
      */=0A=
+#define IS_TX_UND_ERR(X)     (((X) & (1<<9) ) >> 9 )     /* Transmit =
FIFO=0A=
+                                                            Underflow  =
      */=0A=
+#define IS_TX_OF_ERR(X)      (((X) & (1<<10)) >>10 )     /* Oversized =
frame  */=0A=
+#define IS_TX_ED_ERR(X)      (((X) & (1<<11)) >>11 )     /* =
Excessive=0A=
+							    deferral        */=0A=
+#define IS_TX_EC_ERR(X)      (((X) & (1<<12)) >>12 )     /* =
Excessive=0A=
+							    collisions      */=0A=
+#define IS_TX_LC_ERR(X)      (((X) & (1<<13)) >>13 )     /* Late =
Collision   */=0A=
+#define IS_TX_TD_ERR(X)      (((X) & (1<<14)) >>14 )     /* Transmit =
deferred*/=0A=
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<15)) >>15 )     /* CRC Error  =
      */=0A=
+#define IS_TX_LE_ERR(X)      (((X) & (1<<16)) >>16 )     /* Length =
Error     */=0A=
+=0A=
+#define TX_COLLISION_COUNT(X) (((X) & 0x001E0000u)>>17)  /* Collision =
Count  */=0A=
+=0A=
+#endif /* RC32355_ETHER_H */=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32355.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32355.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32355.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32355.h	2006-03-09 =
16:26:31.000000000 -0800=0A=
@@ -0,0 +1,174 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *     Definitions for IDT RC32355 CPU.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc.=0A=
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com=0A=
+ *=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+=0A=
+#ifndef _RC32355_H_=0A=
+#define _RC32355_H_=0A=
+=0A=
+#include <linux/delay.h>=0A=
+#include <asm/io.h>=0A=
+=0A=
+/* Base address of internal registers */=0A=
+#define RC32355_REG_BASE   0x18000000=0A=
+=0A=
+/* System ID Registers */=0A=
+#define CPU_SYSID          (RC32355_REG_BASE + 0x00018)=0A=
+#define CPU_BTADDR         (RC32355_REG_BASE + 0x0001c)=0A=
+#define CPU_REV            (RC32355_REG_BASE + 0x0002c)=0A=
+=0A=
+/* Reset Controller */=0A=
+#define RESET_CNTL         (RC32355_REG_BASE + 0x08000)=0A=
+=0A=
+/* Device Controller */=0A=
+#define DEV0_BASE          (RC32355_REG_BASE + 0x10000)=0A=
+#define DEV0_MASK          (RC32355_REG_BASE + 0x10004)=0A=
+#define DEV0_CNTL          (RC32355_REG_BASE + 0x10008)=0A=
+#define DEV0_TIMING        (RC32355_REG_BASE + 0x1000c)=0A=
+#define DEV_REG_OFFSET     0x10=0A=
+=0A=
+/* SDRAM Controller */=0A=
+#define SDRAM0_BASE        (RC32355_REG_BASE + 0x18000)=0A=
+#define SDRAM0_MASK        (RC32355_REG_BASE + 0x18004)=0A=
+#define SDRAM1_BASE        (RC32355_REG_BASE + 0x18008)=0A=
+#define SDRAM1_MASK        (RC32355_REG_BASE + 0x1800c)=0A=
+#define SDRAM_CNTL         (RC32355_REG_BASE + 0x18010)=0A=
+=0A=
+/* Bus Arbiter */=0A=
+#define BUS_ARB_CNTL0      (RC32355_REG_BASE + 0x20000)=0A=
+#define BUS_ARB_CNTL1      (RC32355_REG_BASE + 0x20004)=0A=
+=0A=
+/* Counters/Timers */=0A=
+#define TIMER0_COUNT       (RC32355_REG_BASE + 0x28000)=0A=
+#define TIMER0_COMPARE     (RC32355_REG_BASE + 0x28004)=0A=
+#define TIMER0_CNTL        (RC32355_REG_BASE + 0x28008)=0A=
+#define TIMER_REG_OFFSET   0x0C=0A=
+=0A=
+/* System Integrity */=0A=
+=0A=
+/* Interrupt Controller */=0A=
+#define IC_GROUP0_PEND     (RC32355_REG_BASE + 0x30000)=0A=
+#define IC_GROUP0_MASK     (RC32355_REG_BASE + 0x30004)=0A=
+#define IC_GROUP_OFFSET    0x08=0A=
+=0A=
+#define NUM_INTR_GROUPS    5=0A=
+/*=0A=
+ * The IRQ mapping is as follows:=0A=
+ *=0A=
+ *    IRQ         Mapped To=0A=
+ *    ---     -------------------=0A=
+ *     0      SW0  (IP0) SW0 intr=0A=
+ *     1      SW1  (IP1) SW1 intr=0A=
+ *     -      Int0 (IP2) mapped to GROUP0_IRQ_BASE=0A=
+ *     -      Int1 (IP3) mapped to GROUP1_IRQ_BASE=0A=
+ *     -      Int2 (IP4) mapped to GROUP2_IRQ_BASE=0A=
+ *     -      Int3 (IP5) mapped to GROUP3_IRQ_BASE=0A=
+ *     -      Int4 (IP6) mapped to GROUP4_IRQ_BASE=0A=
+ *     7      Int5 (IP7) CP0 Timer=0A=
+ *=0A=
+ * IRQ's 8 and up are all mapped to Int0-4 (IP2-IP6), which=0A=
+ * internally on the RC32355 is routed to the Expansion=0A=
+ * Interrupt Controller.=0A=
+ */=0A=
+#define MIPS_CPU_TIMER_IRQ 7=0A=
+=0A=
+#define GROUP0_IRQ_BASE  8                      // Counter/Timers, =
UCW=0A=
+#define GROUP1_IRQ_BASE  (GROUP0_IRQ_BASE + 32) // DMA=0A=
+#define GROUP2_IRQ_BASE  (GROUP1_IRQ_BASE + 32) // ATM=0A=
+#define GROUP3_IRQ_BASE  (GROUP2_IRQ_BASE + 32) // TDM, Eth, USB, =
UARTs, I2C=0A=
+#define GROUP4_IRQ_BASE  (GROUP3_IRQ_BASE + 32) // GPIO=0A=
+=0A=
+#define RC32355_NR_IRQS  (GROUP4_IRQ_BASE + 32)=0A=
+=0A=
+/* DMA - see rc32355_dma.h for full list of registers */=0A=
+=0A=
+#define RC32355_DMA_BASE (RC32355_REG_BASE + 0x38000)=0A=
+#define DMA_CHAN_OFFSET  0x14=0A=
+=0A=
+/* GPIO Controller */=0A=
+=0A=
+/* TDM Bus */=0A=
+=0A=
+/* 16550 UARTs */=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32300_UART0_BASE (RC32355_REG_BASE + 0x50003)=0A=
+#define RC32300_UART1_BASE (RC32355_REG_BASE + 0x50023)=0A=
+#else=0A=
+#define RC32300_UART0_BASE (RC32355_REG_BASE + 0x50000)=0A=
+#define RC32300_UART1_BASE (RC32355_REG_BASE + 0x50020)=0A=
+#endif=0A=
+=0A=
+#define RC32300_UART0_IRQ  (GROUP3_IRQ_BASE + 14)=0A=
+#define RC32300_UART1_IRQ  (GROUP3_IRQ_BASE + 17)=0A=
+=0A=
+/* ATM */=0A=
+=0A=
+/* Ethernet - see rc32355_eth.h for full list of registers */=0A=
+=0A=
+#define RC32355_ETH_BASE   (RC32355_REG_BASE + 0x60000)=0A=
+=0A=
+=0A=
+#define IDT_CLOCK_MULT 2=0A=
+=0A=
+/* Memory map of 79EB355 board */=0A=
+=0A=
+/* DRAM */=0A=
+#define RAM_BASE        0x00000000=0A=
+#define RAM_SIZE	(32*1024*1024)=0A=
+=0A=
+/* SRAM (device 1) */=0A=
+#define SRAM_BASE       0x02000000=0A=
+#define SRAM_SIZE       0x00100000=0A=
+=0A=
+/* FLASH (device 2) */=0A=
+#define FLASH_BASE      0x0C000000=0A=
+#define FLASH_SIZE      0x00C00000=0A=
+=0A=
+/* ATM PHY (device 4) */=0A=
+#define ATM_PHY_BASE    0x14000000=0A=
+=0A=
+/* TDM switch (device 3) */=0A=
+#define TDM_BASE        0x1A000000=0A=
+=0A=
+/* LCD panel (device 3) */=0A=
+#define LCD_BASE        0x1A002000=0A=
+=0A=
+/* RTC (DS1511W) (device 3) */=0A=
+#define RTC_BASE        0x1A004000=0A=
+=0A=
+/* NVRAM (256 bytes internal to the DS1511 RTC) */=0A=
+#define NVRAM_ADDR      RTC_BASE + 0x10=0A=
+#define NVRAM_DATA      RTC_BASE + 0x13=0A=
+#define NVRAM_ENVSIZE_OFF  4=0A=
+#define NVRAM_ENVSTART_OFF 32=0A=
+=0A=
+#endif /* _RC32355_H_ */=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_dma.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_dma.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_dma.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_dma.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,220 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   RC32365/336 DMA hardware abstraction.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32365_DMA_H__=0A=
+#define __IDT_RC32365_DMA_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMA0_PhysicalAddress	=3D 0x18038000,=0A=
+	DMA_PhysicalAddress	=3D DMA0_PhysicalAddress,		// Default=0A=
+=0A=
+	DMA0_VirtualAddress	=3D 0xb8038000,=0A=
+	DMA_VirtualAddress	=3D DMA0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA descriptor (in physical memory).=0A=
+ */=0A=
+=0A=
+typedef struct DMAD_s=0A=
+{=0A=
+	u32			control ;	// Control. use DMAD_*=0A=
+	u32			ca ;		// Current Address.=0A=
+	u32			devcs ; 	// Device control and status.=0A=
+	u32			link ;		// Next descriptor in chain.=0A=
+} volatile *DMAD_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMAD_size		=3D sizeof (struct DMAD_s),=0A=
+	DMAD_count_b		=3D 0,		// in DMAD_t -> control=0A=
+	DMAD_count_m		=3D 0x0003ffff,	// in DMAD_t -> control=0A=
+	DMAD_ds_b		=3D 20,		// in DMAD_t -> control=0A=
+	DMAD_ds_m		=3D 0x00300000,	// in DMAD_t -> control=0A=
+	DMAD_ds_extToMem0_v	=3D 0,=0A=
+	DMAD_ds_memToExt0_v	=3D 1,=0A=
+	DMAD_ds_extToMem1_v	=3D 0,=0A=
+	DMAD_ds_memToExt1_v	=3D 1,=0A=
+	DMAD_ds_ethRcv0_v	=3D 0,=0A=
+	DMAD_ds_ethXmt0_v	=3D 0,=0A=
+	DMAD_ds_ethRcv1_v	=3D 0,=0A=
+	DMAD_ds_ethXmt2_v	=3D 0,=0A=
+	DMAD_ds_memToFifo_v	=3D 0,=0A=
+	DMAD_ds_fifoToMem_v	=3D 0,=0A=
+	DMAD_ds_rng_de_v	   =3D 1,//randomNumberGenerator on LC/DE=0A=
+	DMAD_ds_pciToMem_v	=3D 0,=0A=
+	DMAD_ds_memToPci_v	=3D 0,=0A=
+	DMAD_ds_securityInput_v =3D 0,=0A=
+	DMAD_ds_securityOutput_v =3D 0,=0A=
+	DMAD_ds_rng_se_v	=3D 0,//randomNumberGenerator on SE=0A=
+	=0A=
+	DMAD_devcmd_b		=3D 22,		// in DMAD_t -> control=0A=
+	DMAD_devcmd_m		=3D 0x01c00000,	// in DMAD_t -> control=0A=
+	DMAD_devcmd_byte_v	=3D 0,	//memory-to-memory=0A=
+	DMAD_devcmd_halfword_v	=3D 1,	//memory-to-memory=0A=
+	DMAD_devcmd_word_v	=3D 2,	//memory-to-memory=0A=
+	DMAD_devcmd_2words_v	=3D 3,	//memory-to-memory=0A=
+	DMAD_devcmd_4words_v	=3D 4,	//memory-to-memory=0A=
+	DMAD_devcmd_6words_v	=3D 5,	//memory-to-memory=0A=
+	DMAD_devcmd_8words_v	=3D 6,	//memory-to-memory=0A=
+	DMAD_devcmd_16words_v	=3D 7,	//memory-to-memory=0A=
+	DMAD_cof_b		=3D 25,		// chain on finished=0A=
+	DMAD_cof_m		=3D 0x02000000,	// =0A=
+	DMAD_cod_b		=3D 26,		// chain on done=0A=
+	DMAD_cod_m		=3D 0x04000000,	// =0A=
+	DMAD_iof_b		=3D 27,		// interrupt on finished=0A=
+	DMAD_iof_m		=3D 0x08000000,	// =0A=
+	DMAD_iod_b		=3D 28,		// interrupt on done=0A=
+	DMAD_iod_m		=3D 0x10000000,	// =0A=
+	DMAD_t_b		=3D 29,		// terminated=0A=
+	DMAD_t_m		=3D 0x20000000,	// =0A=
+	DMAD_d_b		=3D 30,		// done=0A=
+	DMAD_d_m		=3D 0x40000000,	// =0A=
+	DMAD_f_b		=3D 31,		// finished=0A=
+	DMAD_f_m		=3D 0x80000000,	// =0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA register (within Internal Register Map).=0A=
+ */=0A=
+=0A=
+struct DMA_Chan_s=0A=
+{=0A=
+	u32		dmac ;		// Control.=0A=
+	u32		dmas ;		// Status.	=0A=
+	u32		dmasm ; 	// Mask.=0A=
+	u32		dmadptr ;	// Descriptor pointer.=0A=
+	u32		dmandptr ;	// Next descriptor pointer.=0A=
+};=0A=
+=0A=
+typedef struct DMA_Chan_s volatile *DMA_Chan_t ;=0A=
+=0A=
+//DMA_Channels	  use DMACH_count instead=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMAC_run_b	=3D 0,		// =0A=
+	DMAC_run_m	=3D 0x00000001,	// =0A=
+	DMAC_dm_b	=3D 1,		// done mask=0A=
+	DMAC_dm_m	=3D 0x00000002,	// =0A=
+	DMAC_mode_b	=3D 2,		// =0A=
+	DMAC_mode_m	=3D 0x0000000c,	// =0A=
+	DMAC_mode_auto_v	=3D 0,=0A=
+	DMAC_mode_burst_v	=3D 1,=0A=
+	DMAC_mode_transfer_v	=3D 2, //usually used=0A=
+	DMAC_mode_reserved_v	=3D 3,=0A=
+	DMAC_a_b	=3D 4,		// =0A=
+	DMAC_a_m	=3D 0x00000010,	// =0A=
+	=0A=
+	DMAS_f_b	=3D 0,		// finished (sticky) =0A=
+	DMAS_f_m	=3D 0x00000001,	//		     =0A=
+	DMAS_d_b	=3D 1,		// done (sticky)     =0A=
+	DMAS_d_m	=3D 0x00000002,	//		     =0A=
+	DMAS_c_b	=3D 2,		// chain (sticky)    =0A=
+	DMAS_c_m	=3D 0x00000004,	//		     =0A=
+	DMAS_e_b	=3D 3,		// error (sticky)    =0A=
+	DMAS_e_m	=3D 0x00000008,	//		     =0A=
+	DMAS_h_b	=3D 4,		// halt (sticky)     =0A=
+	DMAS_h_m	=3D 0x00000010,	//		     =0A=
+=0A=
+	DMASM_f_b	=3D 0,		// finished (1=3Dmask)=0A=
+	DMASM_f_m	=3D 0x00000001,	// =0A=
+	DMASM_d_b	=3D 1,		// done (1=3Dmask)=0A=
+	DMASM_d_m	=3D 0x00000002,	// =0A=
+	DMASM_c_b	=3D 2,		// chain (1=3Dmask)=0A=
+	DMASM_c_m	=3D 0x00000004,	// =0A=
+	DMASM_e_b	=3D 3,		// error (1=3Dmask)=0A=
+	DMASM_e_m	=3D 0x00000008,	// =0A=
+	DMASM_h_b	=3D 4,		// halt (1=3Dmask)=0A=
+	DMASM_h_m	=3D 0x00000010,	// =0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA channel definitions=0A=
+ */=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMACH_ethRcv0 =3D 0,=0A=
+	DMACH_ethXmt0 =3D 1,=0A=
+	DMACH_ethRcv1 =3D 2,=0A=
+	DMACH_ethXmt2 =3D 3,=0A=
+	DMACH_pciToMem =3D 4,=0A=
+	DMACH_memToPci =3D 5,=0A=
+	DMACH_securityInput =3D 6,=0A=
+	DMACH_securityOutput =3D 7,=0A=
+	DMACH_rng =3D 8, =0A=
+	=0A=
+	DMACH_count //must be last=0A=
+};=0A=
+=0A=
+=0A=
+typedef struct DMAC_s=0A=
+{=0A=
+	struct DMA_Chan_s ch [DMACH_count] ; //use ch[DMACH_]=0A=
+} volatile *DMA_t ;=0A=
+=0A=
+=0A=
+/*=0A=
+ * External DMA parameters=0A=
+*/=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMADEVCMD_ts_b	=3D 0,		// ts field in devcmd=0A=
+	DMADEVCMD_ts_m	=3D 0x00000007,	// ts field in devcmd=0A=
+	DMADEVCMD_ts_byte_v	=3D 0,=0A=
+	DMADEVCMD_ts_halfword_v	=3D 1,=0A=
+	DMADEVCMD_ts_word_v	=3D 2,=0A=
+	DMADEVCMD_ts_2word_v	=3D 3,=0A=
+	DMADEVCMD_ts_4word_v	=3D 4,=0A=
+	DMADEVCMD_ts_6word_v	=3D 5,=0A=
+	DMADEVCMD_ts_8word_v	=3D 6,=0A=
+	DMADEVCMD_ts_16word_v	=3D 7=0A=
+};=0A=
+=0A=
+=0A=
+#if 1	// aws - Compatibility.=0A=
+#	define	EXTDMA_ts_b		DMADEVCMD_ts_b=0A=
+#	define	EXTDMA_ts_m		DMADEVCMD_ts_m=0A=
+#	define	EXTDMA_ts_byte_v	DMADEVCMD_ts_byte_v=0A=
+#	define	EXTDMA_ts_halfword_v	DMADEVCMD_ts_halfword_v=0A=
+#	define	EXTDMA_ts_word_v	DMADEVCMD_ts_word_v=0A=
+#	define	EXTDMA_ts_2word_v	DMADEVCMD_ts_2word_v=0A=
+#	define	EXTDMA_ts_4word_v	DMADEVCMD_ts_4word_v=0A=
+#	define	EXTDMA_ts_6word_v	DMADEVCMD_ts_6word_v=0A=
+#	define	EXTDMA_ts_8word_v	DMADEVCMD_ts_8word_v=0A=
+#	define	EXTDMA_ts_16word_v	DMADEVCMD_ts_16word_v=0A=
+#endif	// aws - Compatibility.=0A=
+=0A=
+#endif	// __IDT_RC32365_DMA_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_dma_v.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_dma_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_dma_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_dma_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,78 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   RC32365/336 DMA interface routines.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32365_DMA_V_H__=0A=
+#define __IDT_RC32365_DMA_V_H__=0A=
+=0A=
+=0A=
+#include  <asm/idt-boards/rc32300/rc32300.h>=0A=
+#include  <asm/idt-boards/rc32300/rc32365_dma.h> =0A=
+#include  <asm/idt-boards/rc32300/rc32365.h>=0A=
+=0A=
+#define DMA_CHAN_OFFSET  0x14=0A=
+#define IS_DMA_USED(X) (((X) & (DMAD_f_m | DMAD_d_m | DMAD_t_m)) !=3D =
0)=0A=
+#define IS_DMA_FINISHED(X)   (((X) & (DMAD_f_m)) !=3D 0)=0A=
+#define IS_DMA_DONE(X)   (((X) & (DMAD_d_m)) !=3D 0)=0A=
+=0A=
+#define DMA_COUNT(count)   \=0A=
+  ((count) & DMAD_count_m)=0A=
+=0A=
+#define DMA_HALT_TIMEOUT 500=0A=
+=0A=
+static inline int rc32365_halt_dma(DMA_Chan_t ch)=0A=
+{=0A=
+	int timeout=3D1;=0A=
+	if (local_readl(&ch->dmac) & DMAC_run_m) {=0A=
+		local_writel(0, &ch->dmac); =0A=
+		=0A=
+		for (timeout =3D DMA_HALT_TIMEOUT; timeout > 0; timeout--) {=0A=
+			if (local_readl(&ch->dmas) & DMAS_h_m) {=0A=
+				local_writel(0, &ch->dmas);  =0A=
+				break;=0A=
+			}=0A=
+		}=0A=
+=0A=
+	}=0A=
+=0A=
+	return timeout ? 0 : 1;=0A=
+}=0A=
+=0A=
+=0A=
+static inline void rc32365_start_dma(DMA_Chan_t ch, u32 dma_addr)=0A=
+{=0A=
+	local_writel(0, &ch->dmandptr); =0A=
+	local_writel(dma_addr, &ch->dmadptr);=0A=
+}=0A=
+=0A=
+static inline void rc32365_chain_dma(DMA_Chan_t ch, u32 dma_addr)=0A=
+{=0A=
+	local_writel(dma_addr, &ch->dmandptr);=0A=
+}=0A=
+#endif //__IDT_RC32365_DMA_V_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_eth.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_eth.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_eth.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_eth.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,336 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   RC32365/336 Ethernet hardware abstraction.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef	__IDT_RC32365_ETH_H__=0A=
+#define	__IDT_RC32365_ETH_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	ETH0_PhysicalAddress	=3D 0x18058000,=0A=
+	ETH_PhysicalAddress	=3D ETH0_PhysicalAddress,		// Default=0A=
+	ETH0_VirtualAddress	=3D 0xb8058000,=0A=
+=0A=
+	ETH_VirtualAddress	=3D ETH0_VirtualAddress,		// Default=0A=
+=0A=
+	ETH1_PhysicalAddress	=3D 0x18060000,=0A=
+	ETH1_VirtualAddress	=3D 0xb8060000,			// Default=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32 ethintfc		;=0A=
+	u32 ethfifott		;=0A=
+	u32 etharc		;=0A=
+	u32 ethhash0		;=0A=
+	u32 ethhash1		;=0A=
+	u32 ethu0 [4]		;	// Reserved.	=0A=
+	u32 ethpfs		;=0A=
+	u32 ethmcp		;=0A=
+	u32 eth_u1 [10]		;	// Reserved.=0A=
+	u32 ethspare		;=0A=
+	u32 eth_u2 [42]		;	// Reserved. =0A=
+	u32 ethsal0		;=0A=
+	u32 ethsah0		;=0A=
+	u32 ethsal1		;=0A=
+	u32 ethsah1		;=0A=
+	u32 ethsal2		;=0A=
+	u32 ethsah2		;=0A=
+	u32 ethsal3		;=0A=
+	u32 ethsah3		;=0A=
+	u32 ethrbc		;=0A=
+	u32 ethrpc		;=0A=
+	u32 ethrupc		;=0A=
+	u32 ethrfc		;=0A=
+	u32 ethtbc		;=0A=
+	u32 ethgpf		;=0A=
+	u32 eth_u9 [50]		;	// Reserved.	=0A=
+	u32 ethmac1		;=0A=
+	u32 ethmac2		;=0A=
+	u32 ethipgt		;=0A=
+	u32 ethipgr		;=0A=
+	u32 ethclrt		;=0A=
+	u32 ethmaxf		;=0A=
+	u32 eth_u10		;	// Reserved.	=0A=
+	u32 ethmtest		;=0A=
+	u32 miimcfg		;=0A=
+	u32 miimcmd		;=0A=
+	u32 miimaddr		;=0A=
+	u32 miimwtd		;=0A=
+	u32 miimrdd		;=0A=
+	u32 miimind		;=0A=
+	u32 eth_u11		;	// Reserved.=0A=
+	u32 eth_u12		;	// Reserved.=0A=
+	u32 ethcfsa0		;=0A=
+	u32 ethcfsa1		;=0A=
+	u32 ethcfsa2		;=0A=
+} volatile *ETH_t;=0A=
+=0A=
+enum=0A=
+{=0A=
+	ETHINTFC_en_b		=3D 0,=0A=
+	ETHINTFC_en_m		=3D 0x00000001,=0A=
+	ETHINTFC_its_b		=3D 1,=0A=
+	ETHINTFC_its_m		=3D 0x00000002,=0A=
+	ETHINTFC_rip_b		=3D 2,=0A=
+	ETHINTFC_rip_m		=3D 0x00000004,=0A=
+	ETHINTFC_jam_b		=3D 3,=0A=
+	ETHINTFC_jam_m		=3D 0x00000008,=0A=
+	ETHINTFC_ovr_b		=3D 4,=0A=
+	ETHINTFC_ovr_m		=3D 0x00000010,=0A=
+	ETHINTFC_und_b		=3D 5,=0A=
+	ETHINTFC_und_m		=3D 0x00000020,=0A=
+=0A=
+	ETHFIFOTT_tth_b		=3D 0,=0A=
+	ETHFIFOTT_tth_m		=3D 0x0000007f,=0A=
+=0A=
+	ETHARC_pro_b		=3D 0,=0A=
+	ETHARC_pro_m		=3D 0x00000001,=0A=
+	ETHARC_am_b		=3D 1,=0A=
+	ETHARC_am_m		=3D 0x00000002,=0A=
+	ETHARC_afm_b		=3D 2,=0A=
+	ETHARC_afm_m		=3D 0x00000004,=0A=
+	ETHARC_ab_b		=3D 3,=0A=
+	ETHARC_ab_m		=3D 0x00000008,=0A=
+=0A=
+	ETHSAL_byte5_b		=3D 0,=0A=
+	ETHSAL_byte5_m		=3D 0x000000ff,=0A=
+	ETHSAL_byte4_b		=3D 8,=0A=
+	ETHSAL_byte4_m		=3D 0x0000ff00,=0A=
+	ETHSAL_byte3_b		=3D 16,=0A=
+	ETHSAL_byte3_m		=3D 0x00ff0000,=0A=
+	ETHSAL_byte2_b		=3D 24,=0A=
+	ETHSAL_byte2_m		=3D 0xff000000,=0A=
+=0A=
+	ETHSAH_byte1_b		=3D 0,=0A=
+	ETHSAH_byte1_m		=3D 0x000000ff,=0A=
+	ETHSAH_byte0_b		=3D 8,=0A=
+	ETHSAH_byte0_m		=3D 0x0000ff00,=0A=
+	=0A=
+	ETHGPF_ptv_b		=3D 0,=0A=
+	ETHGPF_ptv_m		=3D 0x0000ffff,=0A=
+=0A=
+	ETHPFS_pfd_b		=3D 0,=0A=
+	ETHPFS_pfd_m		=3D 0x00000001,=0A=
+=0A=
+	ETHCFSA0_cfsa4_b	=3D 0,=0A=
+	ETHCFSA0_cfsa4_m	=3D 0x000000ff,=0A=
+	ETHCFSA0_cfsa5_b	=3D 8,=0A=
+	ETHCFSA0_cfsa5_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHCFSA1_cfsa2_b	=3D 0,=0A=
+	ETHCFSA1_cfsa2_m	=3D 0x000000ff,=0A=
+	ETHCFSA1_cfsa3_b	=3D 8,=0A=
+	ETHCFSA1_cfsa3_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHCFSA2_cfsa0_b	=3D 0,=0A=
+	ETHCFSA2_cfsa0_m	=3D 0x000000ff,=0A=
+	ETHCFSA2_cfsa1_b	=3D 8,=0A=
+	ETHCFSA2_cfsa1_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHMAC1_re_b		=3D 0,=0A=
+	ETHMAC1_re_m		=3D 0x00000001,=0A=
+	ETHMAC1_paf_b		=3D 1,=0A=
+	ETHMAC1_paf_m		=3D 0x00000002,=0A=
+	ETHMAC1_rfc_b		=3D 2,=0A=
+	ETHMAC1_rfc_m		=3D 0x00000004,=0A=
+	ETHMAC1_tfc_b		=3D 3,=0A=
+	ETHMAC1_tfc_m		=3D 0x00000008,=0A=
+	ETHMAC1_lb_b		=3D 4,=0A=
+	ETHMAC1_lb_m		=3D 0x00000010,=0A=
+	ETHMAC1_mr_b		=3D 31,=0A=
+	ETHMAC1_mr_m		=3D 0x80000000,=0A=
+=0A=
+	ETHMAC2_fd_b		=3D 0,=0A=
+	ETHMAC2_fd_m		=3D 0x00000001,=0A=
+	ETHMAC2_flc_b		=3D 1,=0A=
+	ETHMAC2_flc_m		=3D 0x00000002,=0A=
+	ETHMAC2_hfe_b		=3D 2,=0A=
+	ETHMAC2_hfe_m		=3D 0x00000004,=0A=
+	ETHMAC2_dc_b		=3D 3,=0A=
+	ETHMAC2_dc_m		=3D 0x00000008,=0A=
+	ETHMAC2_cen_b		=3D 4,=0A=
+	ETHMAC2_cen_m		=3D 0x00000010,=0A=
+	ETHMAC2_pe_b		=3D 5,=0A=
+	ETHMAC2_pe_m		=3D 0x00000020,=0A=
+	ETHMAC2_vpe_b		=3D 6,=0A=
+	ETHMAC2_vpe_m		=3D 0x00000040,=0A=
+	ETHMAC2_ape_b		=3D 7,=0A=
+	ETHMAC2_ape_m		=3D 0x00000080,=0A=
+	ETHMAC2_ppe_b		=3D 8,=0A=
+	ETHMAC2_ppe_m		=3D 0x00000100,=0A=
+	ETHMAC2_lpe_b		=3D 9,=0A=
+	ETHMAC2_lpe_m		=3D 0x00000200,=0A=
+	ETHMAC2_nb_b		=3D 12,=0A=
+	ETHMAC2_nb_m		=3D 0x00001000,=0A=
+	ETHMAC2_bp_b		=3D 13,=0A=
+	ETHMAC2_bp_m		=3D 0x00002000,=0A=
+	ETHMAC2_ed_b		=3D 14,=0A=
+	ETHMAC2_ed_m		=3D 0x00004000,=0A=
+=0A=
+	ETHIPGT_ipgt_b		=3D 0,=0A=
+	ETHIPGT_ipgt_m		=3D 0x0000007f,=0A=
+=0A=
+	ETHIPGR_ipgr2_b		=3D 0,=0A=
+	ETHIPGR_ipgr2_m		=3D 0x0000007f,=0A=
+	ETHIPGR_ipgr1_b		=3D 8,=0A=
+	ETHIPGR_ipgr1_m		=3D 0x00007f00,=0A=
+=0A=
+	ETHCLRT_maxret_b	=3D 0,=0A=
+	ETHCLRT_maxret_m	=3D 0x0000000f,=0A=
+	ETHCLRT_colwin_b	=3D 8,=0A=
+	ETHCLRT_colwin_m	=3D 0x00003f00,=0A=
+=0A=
+	ETHMAXF_maxf_b		=3D 0,=0A=
+	ETHMAXF_maxf_m		=3D 0x0000ffff,=0A=
+=0A=
+	ETHMTEST_tb_b		=3D 2,=0A=
+	ETHMTEST_tb_m		=3D 0x00000004,=0A=
+=0A=
+	ETHMCP_div_b		=3D 0,=0A=
+	ETHMCP_div_m		=3D 0x000000ff,=0A=
+	=0A=
+	MIIMCFG_rsv_b		=3D 0,=0A=
+	MIIMCFG_rsv_m		=3D 0x0000000c,=0A=
+=0A=
+	MIIMCMD_rd_b		=3D 0,=0A=
+	MIIMCMD_rd_m		=3D 0x00000001,=0A=
+	MIIMCMD_scn_b		=3D 1,=0A=
+	MIIMCMD_scn_m		=3D 0x00000002,=0A=
+=0A=
+	MIIMADDR_regaddr_b	=3D 0,=0A=
+	MIIMADDR_regaddr_m	=3D 0x0000001f,=0A=
+	MIIMADDR_phyaddr_b	=3D 8,=0A=
+	MIIMADDR_phyaddr_m	=3D 0x00001f00,=0A=
+=0A=
+	MIIMWTD_wdata_b		=3D 0,=0A=
+	MIIMWTD_wdata_m		=3D 0x0000ffff,=0A=
+=0A=
+	MIIMRDD_rdata_b		=3D 0,=0A=
+	MIIMRDD_rdata_m		=3D 0x0000ffff,=0A=
+=0A=
+	MIIMIND_bsy_b		=3D 0,=0A=
+	MIIMIND_bsy_m		=3D 0x00000001,=0A=
+	MIIMIND_scn_b		=3D 1,=0A=
+	MIIMIND_scn_m		=3D 0x00000002,=0A=
+	MIIMIND_nv_b		=3D 2,=0A=
+	MIIMIND_nv_m		=3D 0x00000004,=0A=
+=0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * Values for the DEVCS field of the Ethernet DMA Rx and Tx =
descriptors.=0A=
+ */=0A=
+enum=0A=
+{=0A=
+	ETHRX_fd_b		=3D 0,=0A=
+	ETHRX_fd_m		=3D 0x00000001,=0A=
+	ETHRX_ld_b		=3D 1,=0A=
+	ETHRX_ld_m		=3D 0x00000002,=0A=
+	ETHRX_rok_b		=3D 2,=0A=
+	ETHRX_rok_m		=3D 0x00000004,=0A=
+	ETHRX_fm_b		=3D 3,=0A=
+	ETHRX_fm_m		=3D 0x00000008,=0A=
+	ETHRX_mp_b		=3D 4,=0A=
+	ETHRX_mp_m		=3D 0x00000010,=0A=
+	ETHRX_bp_b		=3D 5,=0A=
+	ETHRX_bp_m		=3D 0x00000020,=0A=
+	ETHRX_vlt_b		=3D 6,=0A=
+	ETHRX_vlt_m		=3D 0x00000040,=0A=
+	ETHRX_cf_b		=3D 7,=0A=
+	ETHRX_cf_m		=3D 0x00000080,=0A=
+	ETHRX_ovr_b		=3D 8,=0A=
+	ETHRX_ovr_m		=3D 0x00000100,=0A=
+	ETHRX_crc_b		=3D 9,=0A=
+	ETHRX_crc_m		=3D 0x00000200,=0A=
+	ETHRX_cv_b		=3D 10,=0A=
+	ETHRX_cv_m		=3D 0x00000400,=0A=
+	ETHRX_db_b		=3D 11,=0A=
+	ETHRX_db_m		=3D 0x00000800,=0A=
+	ETHRX_le_b		=3D 12,=0A=
+	ETHRX_le_m		=3D 0x00001000,=0A=
+	ETHRX_lor_b		=3D 13,=0A=
+	ETHRX_lor_m		=3D 0x00002000,=0A=
+	ETHRX_ces_b		=3D 14,=0A=
+	ETHRX_ces_m		=3D 0x00004000,=0A=
+	ETHRX_length_b		=3D 16,=0A=
+	ETHRX_length_m		=3D 0xffff0000,=0A=
+=0A=
+	ETHTX_fd_b		=3D 0,=0A=
+	ETHTX_fd_m		=3D 0x00000001,=0A=
+	ETHTX_ld_b		=3D 1,=0A=
+	ETHTX_ld_m		=3D 0x00000002,=0A=
+	ETHTX_oen_b		=3D 2,=0A=
+	ETHTX_oen_m		=3D 0x00000004,=0A=
+	ETHTX_pen_b		=3D 3,=0A=
+	ETHTX_pen_m		=3D 0x00000008,=0A=
+	ETHTX_cen_b		=3D 4,=0A=
+	ETHTX_cen_m		=3D 0x00000010,=0A=
+	ETHTX_hen_b		=3D 5,=0A=
+	ETHTX_hen_m		=3D 0x00000020,=0A=
+	ETHTX_tok_b		=3D 6,=0A=
+	ETHTX_tok_m		=3D 0x00000040,=0A=
+	ETHTX_mp_b		=3D 7,=0A=
+	ETHTX_mp_m		=3D 0x00000080,=0A=
+	ETHTX_bp_b		=3D 8,=0A=
+	ETHTX_bp_m		=3D 0x00000100,=0A=
+	ETHTX_und_b		=3D 9,=0A=
+	ETHTX_und_m		=3D 0x00000200,=0A=
+	ETHTX_of_b		=3D 10,=0A=
+	ETHTX_of_m		=3D 0x00000400,=0A=
+	ETHTX_ed_b		=3D 11,=0A=
+	ETHTX_ed_m		=3D 0x00000800,=0A=
+	ETHTX_ec_b		=3D 12,=0A=
+	ETHTX_ec_m		=3D 0x00001000,=0A=
+	ETHTX_lc_b		=3D 13,=0A=
+	ETHTX_lc_m		=3D 0x00002000,=0A=
+	ETHTX_td_b		=3D 14,=0A=
+	ETHTX_td_m		=3D 0x00004000,=0A=
+	ETHTX_crc_b		=3D 15,=0A=
+	ETHTX_crc_m		=3D 0x00008000,=0A=
+	ETHTX_le_b		=3D 16,=0A=
+	ETHTX_le_m		=3D 0x00010000,=0A=
+	ETHTX_cc_b		=3D 17,=0A=
+	ETHTX_cc_m		=3D 0x001E0000,=0A=
+} ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	ETH0_IPABMC_PhysicalAddress	=3D 0x18040010,=0A=
+	ETH0_IPABMC_VirtualAddress	=3D 0xb8040000,=0A=
+	ETH1_IPABMC_PhysicalAddress	=3D 0x18040018,=0A=
+	ETH1_IPABMC_VirtualAddress	=3D 0xb8040018,=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32 ipabmcrx		;=0A=
+	u32 ipabmctx		;=0A=
+}volatile *IPABM_ETH_t;=0A=
+#endif //__IDT_RC32365_ETH_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_eth_v.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_eth_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_eth_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_eth_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,65 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   RC32365/336 Ethernet status checking.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32365_ETH_V_H__=0A=
+#define __IDT_RC32365_ETH_V_H__=0A=
+#include  <asm/idt-boards/rc32300/rc32365_eth.h> =0A=
+=0A=
+#define IS_TX_TOK(X)         (((X) & (1<<ETHTX_tok_b)) >> ETHTX_tok_b =
)   /* Transmit Okay    */=0A=
+#define IS_TX_MP(X)          (((X) & (1<<ETHTX_mp_b))  >> ETHTX_mp_b ) =
   /* Multicast        */=0A=
+#define IS_TX_BP(X)          (((X) & (1<<ETHTX_bp_b))  >> ETHTX_bp_b ) =
   /* Broadcast        */=0A=
+#define IS_TX_UND_ERR(X)     (((X) & (1<<ETHTX_und_b)) >> ETHTX_und_b =
)   /* Transmit FIFO Underflow */=0A=
+#define IS_TX_OF_ERR(X)      (((X) & (1<<ETHTX_of_b))  >> ETHTX_of_b ) =
   /* Oversized frame  */=0A=
+#define IS_TX_ED_ERR(X)      (((X) & (1<<ETHTX_ed_b))  >> ETHTX_ed_b ) =
   /* Excessive deferral  */=0A=
+#define IS_TX_EC_ERR(X)      (((X) & (1<<ETHTX_ec_b))  >> ETHTX_ec_b)  =
   /* Excessive collisions  */=0A=
+#define IS_TX_LC_ERR(X)      (((X) & (1<<ETHTX_lc_b))  >> ETHTX_lc_b ) =
   /* Late Collision   */=0A=
+#define IS_TX_TD_ERR(X)      (((X) & (1<<ETHTX_td_b))  >> ETHTX_td_b ) =
   /* Transmit deferred*/=0A=
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<ETHTX_crc_b)) >> ETHTX_crc_b =
)   /* CRC Error        */=0A=
+#define IS_TX_LE_ERR(X)      (((X) & (1<<ETHTX_le_b))  >>  ETHTX_le_b =
)    /* Length Error     */=0A=
+=0A=
+#define TX_COLLISION_COUNT(X) (((X) & ETHTX_cc_m)>>ETHTX_cc_b)  /* =
Collision Count  */=0A=
+=0A=
+#define IS_RCV_ROK(X)        (((X) & (1<<ETHRX_rok_b)) >> ETHRX_rok_b) =
   /* Receive Okay     */=0A=
+#define IS_RCV_FM(X)         (((X) & (1<<ETHRX_fm_b))  >> ETHRX_fm_b)  =
   /* Is Filter Match  */=0A=
+#define IS_RCV_MP(X)         (((X) & (1<<ETHRX_mp_b))  >> ETHRX_mp_b)  =
   /* Is it MP         */=0A=
+#define IS_RCV_BP(X)         (((X) & (1<<ETHRX_bp_b))  >> ETHRX_bp_b)  =
   /* Is it BP         */=0A=
+#define IS_RCV_VLT(X)        (((X) & (1<<ETHRX_vlt_b)) >> ETHRX_vlt_b) =
   /* VLAN Tag Detect  */=0A=
+#define IS_RCV_CF(X)         (((X) & (1<<ETHRX_cf_b))  >> ETHRX_cf_b)  =
   /* Control Frame    */=0A=
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<ETHRX_ovr_b)) >> ETHRX_ovr_b) =
   /* Receive Overflow */=0A=
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<ETHRX_crc_b)) >> ETHRX_crc_b) =
   /* CRC Error        */=0A=
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<ETHRX_cv_b))  >> ETHRX_cv_b)  =
   /* Code Violation   */=0A=
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<ETHRX_db_b))  >> ETHRX_db_b)  =
   /* Dribble Bits     */=0A=
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<ETHRX_le_b))  >> ETHRX_le_b)  =
   /* Length error     */=0A=
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<ETHRX_lor_b)) >> ETHRX_lor_b) =
   /* Length Out of Range */=0A=
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<ETHRX_ces_b)) >> ETHRX_ces_b) =
 /* Preamble error   */=0A=
+#define RCVPKT_LENGTH(X)     (((X) & ETHRX_length_m) >> =
ETHRX_length_b)   /* Length of the received packet */=0A=
+=0A=
+#endif //__IDT_RC32365_ETH_V_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_gpio.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_gpio.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_gpio.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_gpio.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,175 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   RC32365/336 GPIO hardware abstraction.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ **********************************************************************=
****=0A=
+ */=0A=
+=0A=
+#ifndef	__IDT_RC32365_GPIO_H__=0A=
+#define	__IDT_RC32365_GPIO_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	GPIO0_PhysicalAddress	=3D 0x18048000,=0A=
+	GPIO_PhysicalAddress	=3D GPIO0_PhysicalAddress,	// Default=0A=
+	=0A=
+	GPIO0_VirtualAddress	=3D 0xb8048000,=0A=
+	GPIO_VirtualAddress	=3D GPIO0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32   gpiofunc;   /* GPIO Function Register=0A=
+			   * gpiofunc[x]=3D=3D0 bit =3D gpio=0A=
+			   * func[x]=3D=3D1  bit =3D altfunc=0A=
+			   */=0A=
+	u32   gpiocfg;    /* GPIO Configuration Register=0A=
+			   * gpiocfg[x]=3D=3D0 bit =3D input=0A=
+			   * gpiocfg[x]=3D=3D1 bit =3D output=0A=
+			   */=0A=
+	u32   gpiod;	    /* GPIO Data Register=0A=
+			     * gpiod[x] read/write gpio pinX status=0A=
+			     */=0A=
+	u32   gpioilevel; /* GPIO Interrupt Status Register=0A=
+			   * interrupt level (see gpioistat)=0A=
+			   */=0A=
+	u32   gpioistat;  /* Gpio Interrupt Status Register=0A=
+			   * istat[x] =3D (gpiod[x] =3D=3D level[x])=0A=
+			   * cleared in ISR (STICKY bits)=0A=
+			   */=0A=
+	u32   gpionmien;  /* GPIO Non-maskable Interrupt Enable Register =
*/=0A=
+} volatile * GPIO_t ;=0A=
+=0A=
+typedef enum=0A=
+{=0A=
+	GPIO_gpio_v	    =3D 0,		// gpiofunc use pin as GPIO.=0A=
+	GPIO_alt_v	    =3D 1,		// gpiofunc use pin as alt.=0A=
+	GPIO_input_v	    =3D 0,		// gpiocfg use pin as input.=0A=
+	GPIO_output_v	    =3D 1,		// gpiocfg use pin as output.=0A=
+	GPIO_pin0_b	    =3D 0,=0A=
+	GPIO_pin0_m	    =3D 0x00000001,=0A=
+	GPIO_pin1_b	    =3D 1,=0A=
+	GPIO_pin1_m	    =3D 0x00000002,=0A=
+	GPIO_pin2_b	    =3D 2,=0A=
+	GPIO_pin2_m	    =3D 0x00000004,=0A=
+	GPIO_pin3_b	    =3D 3,=0A=
+	GPIO_pin3_m	    =3D 0x00000008,=0A=
+	GPIO_pin4_b	    =3D 4,=0A=
+	GPIO_pin4_m	    =3D 0x00000010,=0A=
+	GPIO_pin5_b	    =3D 5,=0A=
+	GPIO_pin5_m	    =3D 0x00000020,=0A=
+	GPIO_pin6_b	    =3D 6,=0A=
+	GPIO_pin6_m	    =3D 0x00000040,=0A=
+	GPIO_pin7_b	    =3D 7,=0A=
+	GPIO_pin7_m	    =3D 0x00000080,=0A=
+	GPIO_pin8_b	    =3D 8,=0A=
+	GPIO_pin8_m	    =3D 0x00000100,=0A=
+	GPIO_pin9_b	    =3D 9,=0A=
+	GPIO_pin9_m	    =3D 0x00000200,=0A=
+	GPIO_pin10_b	    =3D 10,=0A=
+	GPIO_pin10_m	    =3D 0x00000400,=0A=
+	GPIO_pin11_b	    =3D 11,=0A=
+	GPIO_pin11_m	    =3D 0x00000800,=0A=
+	GPIO_pin12_b	    =3D 12,=0A=
+	GPIO_pin12_m	    =3D 0x00001000,=0A=
+	GPIO_pin13_b	    =3D 13,=0A=
+	GPIO_pin13_m	    =3D 0x00002000,=0A=
+	GPIO_pin14_b	    =3D 14,=0A=
+	GPIO_pin14_m	    =3D 0x00004000,=0A=
+	GPIO_pin15_b	    =3D 15,=0A=
+	GPIO_pin15_m	    =3D 0x00008000,=0A=
+	=0A=
+// Alternate function pins.  Corrsponding gpiofunc bit set to =
GPIO_alt_v.=0A=
+	=0A=
+	GPIO_u0sout_b	    =3D GPIO_pin0_b,		// UART 0 serial out.=0A=
+	GPIO_u0sout_m	    =3D GPIO_pin0_m,=0A=
+	GPIO_u0sout_cfg_v   =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_u0sinp_b	    =3D GPIO_pin1_b,			// UART 0 serial in.=0A=
+	GPIO_u0sinp_m	    =3D GPIO_pin1_m,=0A=
+	GPIO_u0sinp_cfg_v   =3D GPIO_input_v,=0A=
+	=0A=
+	GPIO_maddr22_b	    =3D GPIO_pin2_b, 	// M&P bus bit 22.=0A=
+	GPIO_maddr22_m	    =3D GPIO_pin2_m,=0A=
+	GPIO_maddr22_cfg_v  =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_maddr23_b	    =3D GPIO_pin3_b, 	// M&P bus bit 23.=0A=
+	GPIO_maddr23_m	    =3D GPIO_pin3_m,=0A=
+	GPIO_maddr23_cfg_v  =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_maddr24_b	    =3D GPIO_pin4_b, 	// M&P bus bit 24.=0A=
+	GPIO_maddr24_m	    =3D GPIO_pin4_m,=0A=
+	GPIO_maddr24_cfg_v  =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_maddr25_b	    =3D GPIO_pin5_b, 	// M&P bus bit 25.=0A=
+	GPIO_maddr25_m	    =3D GPIO_pin5_m,=0A=
+	GPIO_maddr25_cfg_v  =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_rngclk_b 	    =3D GPIO_pin6_b, 	// reserved.=0A=
+	GPIO_rngclk_m 	    =3D GPIO_pin6_m,=0A=
+	GPIO_rngclk_cfg_v   =3D GPIO_input_v,=0A=
+=0A=
+	GPIO_sdckenp_b 	    =3D GPIO_pin7_b, 	// reserved.=0A=
+	GPIO_sdckenp_m 	    =3D GPIO_pin7_m,=0A=
+	GPIO_sdckenp_cfg_v  =3D GPIO_output_v,=0A=
+=0A=
+	GPIO_cen1_b 	    =3D GPIO_pin8_b, 	// reserved.=0A=
+	GPIO_cen1_m 	    =3D GPIO_pin8_m,=0A=
+	GPIO_cen1_cfg_v	    =3D GPIO_output_v,=0A=
+=0A=
+	GPIO_cen2_b 	    =3D GPIO_pin9_b, 	// reserved.=0A=
+	GPIO_cen2_m 	    =3D GPIO_pin9_m,=0A=
+	GPIO_cen2_cfg_v	    =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_regn_b 	    =3D GPIO_pin10_b, 	// reserved.=0A=
+	GPIO_regn_m 	    =3D GPIO_pin10_m,=0A=
+	GPIO_regn_cfg_v	    =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_iordn_b 	    =3D GPIO_pin11_b, 	// reserved.=0A=
+	GPIO_iordn_m 	    =3D GPIO_pin11_m,=0A=
+	GPIO_iordn_cfg_v    =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_iowrn_b 	    =3D GPIO_pin12_b, 	// reserved.=0A=
+	GPIO_iowrn_m 	    =3D GPIO_pin12_m,=0A=
+	GPIO_iowrn_cfg_v    =3D GPIO_output_v,=0A=
+    =0A=
+	GPIO_pcireqn2_b	    =3D GPIO_pin13_b, 	// PCI messaging int.=0A=
+	GPIO_pcireqn2_m	    =3D GPIO_pin13_m,=0A=
+	GPIO_pcireqn2_cfg_v =3D GPIO_input_v,=0A=
+	=0A=
+	GPIO_pcigntn2_b	    =3D GPIO_pin14_b, 	// PCI messaging int.=0A=
+	GPIO_pcigntn2_m	    =3D GPIO_pin14_m,=0A=
+	GPIO_pcigntn2_cfg_v =3D GPIO_output_v,=0A=
+	=0A=
+	GPIO_pcimuintn_b    =3D GPIO_pin15_b, 	// PCI messaging int.=0A=
+	GPIO_pcimuintn_m    =3D GPIO_pin15_m,=0A=
+	GPIO_pcimuintn_cfg_v=3D GPIO_output_v,=0A=
+	=0A=
+} GPIO_DEFS_t;=0A=
+=0A=
+#endif //__IDT_RC32365_GPIO_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_gpio_v.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_gpio_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_gpio_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_gpio_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,84 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Routines to set/clear/toggle GPIO on RC32365=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+#ifndef	__IDT_RC32365_GPIO_V_H__=0A=
+#define	__IDT_RC32365_GPIO_V_H__=0A=
+=0A=
+=0A=
+#ifdef _LANGUAGE_ASSEMBLY=0A=
+#define SET_GPIO(pin) \=0A=
+	lui t5,0xb804 ; \=0A=
+	ori t5,t5,0x8000 ; \=0A=
+	lw  t4,8(t5) ; \=0A=
+	ori t4,t4,pin ; \=0A=
+	sw  t4,8(t5) ;=0A=
+=0A=
+#define CLEAR_GPIO(pin) \=0A=
+	lui t5,0xb804 ; \=0A=
+	ori t5,t5,0x8000 ; \=0A=
+	lw  t4,8(t5) ; \=0A=
+        lui t6,0xFFFF; \=0A=
+        ori t6,t6,0xFFFF; \=0A=
+	xori t6,t6,pin ; \=0A=
+        and  t4,t6 ; \=0A=
+	sw  t4,8(t5) ;=0A=
+=0A=
+#define TOGGLE_GPIO(pin) \=0A=
+	lui t5,0xb804 ; \=0A=
+	ori t5,t5,0x8000 ; \=0A=
+	lw  t4,8(t5) ; \=0A=
+	xori t4,t4,pin ; \=0A=
+	sw  t4,8(t5) ;=0A=
+=0A=
+#else // !_LANGUAGE_ASSEMBLY =0A=
+#include  <asm/rc32300/types.h> =0A=
+#include  <asm/rc32300/rc32365_gpio.h> =0A=
+#include  <asm/rc32300/rc32365.h>=0A=
+=0A=
+static inline void set_gpio(unsigned long pin)=0A=
+{=0A=
+  gpio->gpiod |=3D pin;=0A=
+}=0A=
+ =0A=
+static inline void clear_gpio(unsigned long pin)=0A=
+{=0A=
+  gpio->gpiod &=3D ~pin;=0A=
+}=0A=
+static inline void toggle_gpio(unsigned long pin)=0A=
+{=0A=
+  gpio->gpiod ^=3D pin;=0A=
+}=0A=
+#define SET_GPIO(pin) set_gpio(pin)=0A=
+#define CLEAR_GPIO(pin) clear_gpio(pin)=0A=
+#define TOGGLE_GPIO(pin) toggle_gpio(pin)=0A=
+#endif // _LANGUAGE_ASSEMBLY =0A=
+=0A=
+#endif //__IDT_RC32365_GPIO_V_H__=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365.h	2006-03-09 =
16:26:31.000000000 -0800=0A=
@@ -0,0 +1,154 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for IDT RC32365 CPU.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32365_H__=0A=
+#define __IDT_RC32365_H__=0A=
+=0A=
+extern unsigned int cedar_za;=0A=
+=0A=
+/* Base address of internal registers */=0A=
+#define RC32365_REG_BASE   0x18000000=0A=
+=0A=
+/* System ID Registers */=0A=
+#define CPU_SYSID          (RC32365_REG_BASE + 0x00018)=0A=
+#define CPU_DEVTYPE        (RC32365_REG_BASE + 0x0001c)=0A=
+=0A=
+/* Reset Controller */=0A=
+#define RESET_CNTL         (RC32365_REG_BASE + 0x08000)=0A=
+#define BOOT_VECTOR        (RC32365_REG_BASE + 0x08004)=0A=
+=0A=
+/* Device Controller */=0A=
+#define DEV0_BASE          (RC32365_REG_BASE + 0x10000)=0A=
+#define DEV0_MASK          (RC32365_REG_BASE + 0x10004)=0A=
+#define DEV0_CNTL          (RC32365_REG_BASE + 0x10008)=0A=
+#define DEV0_TIMING        (RC32365_REG_BASE + 0x1000c)=0A=
+#define DEV_REG_OFFSET     0x10=0A=
+=0A=
+/* SDRAM Controller */=0A=
+#define SDRAM0_BASE        (RC32365_REG_BASE + 0x18000)=0A=
+#define SDRAM0_MASK        (RC32365_REG_BASE + 0x18004)=0A=
+#define SDRAM1_BASE        (RC32365_REG_BASE + 0x18008)=0A=
+#define SDRAM1_MASK        (RC32365_REG_BASE + 0x1800c)=0A=
+#define SDRAM_CNTL         (RC32365_REG_BASE + 0x18010)=0A=
+=0A=
+/* Counters/Timers */=0A=
+#define TIMER0_COUNT       (RC32365_REG_BASE + 0x20000)=0A=
+#define TIMER0_COMPARE     (RC32365_REG_BASE + 0x20004)=0A=
+#define TIMER0_CNTL        (RC32365_REG_BASE + 0x20008)=0A=
+#define TIMER0_SELECT      (RC32365_REG_BASE + 0x2000c)=0A=
+#define TIMER_REG_OFFSET   0x10=0A=
+=0A=
+/* System Integrity */=0A=
+=0A=
+/* Interrupt Controller */=0A=
+#define IC_GROUP0_PEND     (RC32365_REG_BASE + 0x30000)=0A=
+#define IC_GROUP0_TEST     (RC32365_REG_BASE + 0x30004)=0A=
+#define IC_GROUP0_MASK     (RC32365_REG_BASE + 0x30008)=0A=
+#define IC_GROUP_OFFSET    0x0c=0A=
+=0A=
+#define NUM_INTR_GROUPS    5=0A=
+/*=0A=
+ * The IRQ mapping is as follows:=0A=
+ *=0A=
+ *    IRQ         Mapped To=0A=
+ *    ---     -------------------=0A=
+ *     0      SW0  (IP0) SW0 intr=0A=
+ *     1      SW1  (IP1) SW1 intr=0A=
+ *     -      Int0 (IP2) mapped to GROUP0_IRQ_BASE=0A=
+ *     -      Int1 (IP3) mapped to GROUP1_IRQ_BASE=0A=
+ *     -      Int2 (IP4) mapped to GROUP2_IRQ_BASE=0A=
+ *     -      Int3 (IP5) mapped to GROUP3_IRQ_BASE=0A=
+ *     -      Int4 (IP6) mapped to GROUP4_IRQ_BASE=0A=
+ *     7      Int5 (IP7) CP0 Timer=0A=
+ *=0A=
+ * IRQ's 8 and up are all mapped to Int0-4 (IP2-IP6), which=0A=
+ * internally on the RC32365 is routed to the Expansion=0A=
+ * Interrupt Controller.=0A=
+ */=0A=
+#define MIPS_CPU_TIMER_IRQ 7=0A=
+=0A=
+#define GROUP0_IRQ_BASE  8                      // Counter/Timers, =
UCW=0A=
+#define GROUP1_IRQ_BASE  (GROUP0_IRQ_BASE + 32) // DMA=0A=
+#define GROUP2_IRQ_BASE  (GROUP1_IRQ_BASE + 32) // RNG, SEC=0A=
+#define GROUP3_IRQ_BASE  (GROUP2_IRQ_BASE + 32) // Eth, PCI, UARTs=0A=
+#define GROUP4_IRQ_BASE  (GROUP3_IRQ_BASE + 32) // GPIO=0A=
+=0A=
+#define RC32365_NR_IRQS  (GROUP4_IRQ_BASE + 32)=0A=
+=0A=
+/* DMA - see rc32365_dma.h for full list of registers */=0A=
+=0A=
+#define RC32365_DMA_BASE (RC32365_REG_BASE + 0x38000)=0A=
+#define DMA_CHAN_OFFSET  0x14=0A=
+=0A=
+/* GPIO Controller */=0A=
+#define gpio              ((volatile GPIO_t) GPIO0_VirtualAddress)=0A=
+=0A=
+/* 16550 UARTs */=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32300_UART0_BASE (RC32365_REG_BASE + 0x50003)=0A=
+#else=0A=
+#define RC32300_UART0_BASE (RC32365_REG_BASE + 0x50000)=0A=
+#endif=0A=
+#define RC32300_UART0_IRQ  (GROUP3_IRQ_BASE + 0)=0A=
+=0A=
+/* Ethernet - see rc32365_eth.h for full list of registers */=0A=
+=0A=
+#define RC32365_ETH_BASE   (RC32365_REG_BASE + 0x58000)=0A=
+=0A=
+#define IDT_CLOCK_MULT     2=0A=
+=0A=
+/* FLASH (device 1) */=0A=
+#define FLASH_BASE         0x08000000=0A=
+#define FLASH_SIZE         0x00800000=0A=
+=0A=
+/* LCD 4-digit display (device 2) */=0A=
+#define LCD_DIGIT0         0x0C000003=0A=
+#define LCD_DIGIT1         0x0C000002=0A=
+#define LCD_DIGIT2         0x0C000001=0A=
+#define LCD_DIGIT3         0x0C000000=0A=
+=0A=
+/* RTC (DS1553) (device 2) */=0A=
+#define RTC_BASE           0x0c800000=0A=
+/* NVRAM */=0A=
+#define NVRAM_BASE         RTC_BASE=0A=
+#define NVRAM_ENVSIZE_OFF  4=0A=
+#define NVRAM_ENVSTART_OFF 32=0A=
+=0A=
+/* Interrupts routed on 79EB365 board */=0A=
+#define RC32365_PCI_INTA_IRQ (GROUP4_IRQ_BASE +  8)=0A=
+#define RC32365_PCI_INTB_IRQ (GROUP4_IRQ_BASE +  9)=0A=
+#define RC32365_PCI_INTC_IRQ (GROUP4_IRQ_BASE + 10)=0A=
+#define RC32365_PCI_INTD_IRQ (GROUP4_IRQ_BASE + 11)=0A=
+=0A=
+#define RAM_SIZE	   (32 * 1024 * 1024)=0A=
+=0A=
+#endif //__IDT_RC32365_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_pci.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_pci.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_pci.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_pci.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,509 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Datatype declaration for IDT 79EB365/336 PCI=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32365_PCI_H__=0A=
+#define __IDT_RC32365_PCI_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	PCI0_PhysicalAddress	=3D 0x18068000,=0A=
+	PCI_PhysicalAddress	=3D PCI0_PhysicalAddress,=0A=
+	=0A=
+	PCI0_VirtualAddress	=3D 0xb8068000,=0A=
+	PCI_VirtualAddress	=3D PCI0_VirtualAddress,=0A=
+} ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	PCI_LbaCount	=3D 4,		// Local base addresses.=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32	a ;		// Address.=0A=
+	u32	c ;		// Control.=0A=
+	u32	m ;		// mapping.=0A=
+} PCI_Map_s ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32		pcic ;=0A=
+	u32		pcis ;=0A=
+	u32		pcism ;=0A=
+	u32		pcicfga ;=0A=
+	u32		pcicfgd ;=0A=
+	PCI_Map_s	pcilba [PCI_LbaCount] ;=0A=
+	u32		pcidac ;=0A=
+	u32		pcidas ;=0A=
+	u32		pcidasm ;=0A=
+	u32		pcidad ;=0A=
+	u32		pcidma8c ;=0A=
+	u32		pcidma9c ;=0A=
+	u32		pcitc ;=0A=
+} volatile *PCI_t ;=0A=
+=0A=
+// PCI messaging unit.=0A=
+enum=0A=
+{=0A=
+	PCIM_Count	=3D 2,=0A=
+} ;=0A=
+typedef struct=0A=
+{=0A=
+	u32		pciim [PCIM_Count] ;=0A=
+	u32		pciom [PCIM_Count] ;=0A=
+	u32		pciid ;=0A=
+	u32		pciiic ;=0A=
+	u32		pciiim ;=0A=
+	u32		pciiod ;=0A=
+	u32		pciioic ;=0A=
+	u32		pciioim ;=0A=
+} volatile *PCIM_t ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIC_en_b	=3D 0,=0A=
+	PCIC_en_m	=3D 0x00000001,=0A=
+	PCIC_tnr_b	=3D 1,=0A=
+	PCIC_tnr_m	=3D 0x00000002,=0A=
+	PCIC_sce_b	=3D 2,=0A=
+	PCIC_sce_m	=3D 0x00000004,=0A=
+	PCIC_ien_b	=3D 3,=0A=
+	PCIC_ien_m	=3D 0x00000008,=0A=
+	PCIC_aaa_b	=3D 4,=0A=
+	PCIC_aaa_m	=3D 0x00000010,=0A=
+	PCIC_eap_b	=3D 5,=0A=
+	PCIC_eap_m	=3D 0x00000020,=0A=
+	PCIC_pcim_b	=3D 6,=0A=
+	PCIC_pcim_m	=3D 0x000001c0,=0A=
+		PCIC_pcim_disabled_v	=3D 0,=0A=
+		PCIC_pcim_tnr_v 	=3D 1,	// Satellite - target not ready=0A=
+		PCIC_pcim_suspend_v	=3D 2,	// Satellite - suspended CPU.=0A=
+		PCIC_pcim_extern_v	=3D 3,	// Host - external arbiter.=0A=
+		PCIC_pcim_fixed_v	=3D 4,	// Host - fixed priority arb.=0A=
+		PCIC_pcim_roundrobin_v	=3D 5,	// Host - round robin priority.=0A=
+		PCIC_pcim_reserved6_v	=3D 6,=0A=
+		PCIC_pcim_reserved7_v	=3D 7,=0A=
+	PCIC_igm_b	=3D 9,=0A=
+	PCIC_igm_m	=3D 0x00000200,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Status Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIS_eed_b	=3D 0,=0A=
+	PCIS_eed_m	=3D 0x00000001,=0A=
+	PCIS_wr_b	=3D 1,=0A=
+	PCIS_wr_m	=3D 0x00000002,=0A=
+	PCIS_nmi_b	=3D 2,=0A=
+	PCIS_nmi_m	=3D 0x00000004,=0A=
+	PCIS_ii_b	=3D 3,=0A=
+	PCIS_ii_m	=3D 0x00000008,=0A=
+	PCIS_cwe_b	=3D 4,=0A=
+	PCIS_cwe_m	=3D 0x00000010,=0A=
+	PCIS_cre_b	=3D 5,=0A=
+	PCIS_cre_m	=3D 0x00000020,=0A=
+	PCIS_mdpe_b	=3D 6,=0A=
+	PCIS_mdpe_m	=3D 0x00000040,=0A=
+	PCIS_sta_b	=3D 7,=0A=
+	PCIS_sta_m	=3D 0x00000080,=0A=
+	PCIS_rta_b	=3D 8,=0A=
+	PCIS_rta_m	=3D 0x00000100,=0A=
+	PCIS_rma_b	=3D 9,=0A=
+	PCIS_rma_m	=3D 0x00000200,=0A=
+	PCIS_sse_b	=3D 10,=0A=
+	PCIS_sse_m	=3D 0x00000400,=0A=
+	PCIS_ose_b	=3D 11,=0A=
+	PCIS_ose_m	=3D 0x00000800,=0A=
+	PCIS_pe_b	=3D 12,=0A=
+	PCIS_pe_m	=3D 0x00001000,=0A=
+	PCIS_tae_b	=3D 13,=0A=
+	PCIS_tae_m	=3D 0x00002000,=0A=
+	PCIS_rle_b	=3D 14,=0A=
+	PCIS_rle_m	=3D 0x00004000,=0A=
+	PCIS_bme_b	=3D 15,=0A=
+	PCIS_bme_m	=3D 0x00008000,=0A=
+	PCIS_prd_b	=3D 16,=0A=
+	PCIS_prd_m	=3D 0x00010000,=0A=
+	PCIS_rip_b	=3D 17,=0A=
+	PCIS_rip_m	=3D 0x00020000,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Status Mask Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCISM_eed_b		=3D 0,=0A=
+	PCISM_eed_m		=3D 0x00000001,=0A=
+	PCISM_wr_b		=3D 1,=0A=
+	PCISM_wr_m		=3D 0x00000002,=0A=
+	PCISM_nmi_b		=3D 2,=0A=
+	PCISM_nmi_m		=3D 0x00000004,=0A=
+	PCISM_ii_b		=3D 3,=0A=
+	PCISM_ii_m		=3D 0x00000008,=0A=
+	PCISM_cwe_b		=3D 4,=0A=
+	PCISM_cwe_m		=3D 0x00000010,=0A=
+	PCISM_cre_b		=3D 5,=0A=
+	PCISM_cre_m		=3D 0x00000020,=0A=
+	PCISM_mdpe_b		=3D 6,=0A=
+	PCISM_mdpe_m		=3D 0x00000040,=0A=
+	PCISM_sta_b		=3D 7,=0A=
+	PCISM_sta_m		=3D 0x00000080,=0A=
+	PCISM_rta_b		=3D 8,=0A=
+	PCISM_rta_m		=3D 0x00000100,=0A=
+	PCISM_rma_b		=3D 9,=0A=
+	PCISM_rma_m		=3D 0x00000200,=0A=
+	PCISM_sse_b		=3D 10,=0A=
+	PCISM_sse_m		=3D 0x00000400,=0A=
+	PCISM_ose_b		=3D 11,=0A=
+	PCISM_ose_m		=3D 0x00000800,=0A=
+	PCISM_pe_b		=3D 12,=0A=
+	PCISM_pe_m		=3D 0x00001000,=0A=
+	PCISM_tae_b		=3D 13,=0A=
+	PCISM_tae_m		=3D 0x00002000,=0A=
+	PCISM_rle_b		=3D 14,=0A=
+	PCISM_rle_m		=3D 0x00004000,=0A=
+	PCISM_bme_b		=3D 15,=0A=
+	PCISM_bme_m		=3D 0x00008000,=0A=
+	PCISM_prd_b		=3D 16,=0A=
+	PCISM_prd_m		=3D 0x00010000,=0A=
+	PCISM_rip_b		=3D 17,=0A=
+	PCISM_rip_m		=3D 0x00020000,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Configuration Address Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCICFGA_reg_b		=3D 2,=0A=
+	PCICFGA_reg_m		=3D 0x000000fc,=0A=
+	PCICFGA_reg_id_v	=3D 0x00>>2, //use PCFGID_=0A=
+	PCICFGA_reg_04_v	=3D 0x04>>2, //use PCFG04_=0A=
+	PCICFGA_reg_08_v	=3D 0x08>>2, //use PCFG08_=0A=
+	PCICFGA_reg_0C_v	=3D 0x0C>>2, //use PCFG0C_=0A=
+	PCICFGA_reg_pba0_v	=3D 0x10>>2, //use PCIPBA_=0A=
+	PCICFGA_reg_pba1_v	=3D 0x14>>2, //use PCIPBA_=0A=
+	PCICFGA_reg_pba2_v	=3D 0x18>>2, //use PCIPBA_=0A=
+	PCICFGA_reg_pba3_v	=3D 0x1c>>2, //use PCIPBA_=0A=
+	PCICFGA_reg_subsystem_v =3D 0x2c>>2, //use PCFGSS_=0A=
+	PCICFGA_reg_3C_v	=3D 0x3C>>2, //use PCFG3C_=0A=
+	PCICFGA_reg_pba0c_v	=3D 0x44>>2, //use PCIPBAC_=0A=
+	PCICFGA_reg_pba0m_v	=3D 0x48>>2,=0A=
+	PCICFGA_reg_pba1c_v	=3D 0x4c>>2, //use PCIPBAC_=0A=
+	PCICFGA_reg_pba1m_v	=3D 0x50>>2,=0A=
+	PCICFGA_reg_pba2c_v	=3D 0x54>>2, //use PCIPBAC_=0A=
+	PCICFGA_reg_pba2m_v	=3D 0x58>>2,=0A=
+	PCICFGA_reg_pba3c_v	=3D 0x5c>>2, //use PCIPBAC_=0A=
+	PCICFGA_reg_pba3m_v	=3D 0x60>>2,=0A=
+	PCICFGA_reg_pmgt_v	=3D 0x64>>2,=0A=
+	PCICFGA_func_b		=3D 8,=0A=
+	PCICFGA_func_m		=3D 0x00000700,=0A=
+	PCICFGA_dev_b		=3D 11,=0A=
+	PCICFGA_dev_m		=3D 0x0000f800,=0A=
+	PCICFGA_dev_internal_v	=3D 0,=0A=
+	PCICFGA_bus_b		=3D 16,=0A=
+	PCICFGA_bus_m		=3D 0x00ff0000,=0A=
+	PCICFGA_bus_type0_v	=3D 0,	//local bus=0A=
+	PCICFGA_en_b		=3D 31,		// read only=0A=
+	PCICFGA_en_m		=3D 0x80000000,=0A=
+} ;=0A=
+=0A=
+enum {=0A=
+	PCFGID_vendor_b 	=3D 0,=0A=
+	PCFGID_vendor_m 	=3D 0x0000ffff,=0A=
+	PCFGID_vendor_IDT_v		=3D 0x111d,=0A=
+	PCFGID_device_b 	=3D 16,=0A=
+	PCFGID_device_m 	=3D 0xffff0000,=0A=
+	PCFGID_device_Acaciade_v	=3D 0x0207,=0A=
+=0A=
+	PCFG04_command_ioena_b		=3D 1,=0A=
+	PCFG04_command_ioena_m		=3D 0x00000001,=0A=
+	PCFG04_command_memena_b 	=3D 2,=0A=
+	PCFG04_command_memena_m 	=3D 0x00000002,=0A=
+	PCFG04_command_bmena_b		=3D 3,=0A=
+	PCFG04_command_bmena_m		=3D 0x00000004,=0A=
+	PCFG04_command_mwinv_b		=3D 5,=0A=
+	PCFG04_command_mwinv_m		=3D 0x00000010,=0A=
+	PCFG04_command_parena_b 	=3D 7,=0A=
+	PCFG04_command_parena_m 	=3D 0x00000040,=0A=
+	PCFG04_command_serrena_b	=3D 9,=0A=
+	PCFG04_command_serrena_m	=3D 0x00000100,=0A=
+	PCFG04_command_fastbbena_b	=3D 10,=0A=
+	PCFG04_command_fastbbena_m	=3D 0x00000200,=0A=
+	PCFG04_status_b 		=3D 16,=0A=
+	PCFG04_status_m 		=3D 0xffff0000,=0A=
+	PCFG04_status_66MHz_b		=3D 21,	// 66 MHz enable=0A=
+	PCFG04_status_66MHz_m		=3D 0x00200000,=0A=
+	PCFG04_status_fbb_b		=3D 23,=0A=
+	PCFG04_status_fbb_m		=3D 0x00800000,=0A=
+	PCFG04_status_mdpe_b		=3D 24,=0A=
+	PCFG04_status_mdpe_m		=3D 0x01000000,=0A=
+	PCFG04_status_dst_b		=3D 25,=0A=
+	PCFG04_status_dst_m		=3D 0x06000000,=0A=
+	PCFG04_status_sta_b		=3D 27,=0A=
+	PCFG04_status_sta_m		=3D 0x08000000,=0A=
+	PCFG04_status_rta_b		=3D 28,=0A=
+	PCFG04_status_rta_m		=3D 0x10000000,=0A=
+	PCFG04_status_rma_b		=3D 29,=0A=
+	PCFG04_status_rma_m		=3D 0x20000000,=0A=
+	PCFG04_status_sse_b		=3D 30,=0A=
+	PCFG04_status_sse_m		=3D 0x40000000,=0A=
+	PCFG04_status_pe_b		=3D 31,=0A=
+	PCFG04_status_pe_m		=3D 0x40000000,=0A=
+=0A=
+	PCFG08_revId_b			=3D 0,=0A=
+	PCFG08_revId_m			=3D 0x000000ff,=0A=
+	PCFG08_classCode_b		=3D 0,=0A=
+	PCFG08_classCode_m		=3D 0xffffff00,=0A=
+	PCFG08_classCode_bridge_v	=3D 06,=0A=
+	PCFG08_classCode_proc_v 	=3D 0x0b3000, // processor-MIPS=0A=
+	PCFG0C_cacheline_b		=3D 0,=0A=
+	PCFG0C_cacheline_m		=3D 0x000000ff,=0A=
+	PCFG0C_masterLatency_b		=3D 8,=0A=
+	PCFG0C_masterLatency_m		=3D 0x0000ff00,=0A=
+	PCFG0C_headerType_b		=3D 16,=0A=
+	PCFG0C_headerType_m		=3D 0x00ff0000,=0A=
+	PCFG0C_bist_b			=3D 24,=0A=
+	PCFG0C_bist_m			=3D 0xff000000,=0A=
+=0A=
+	PCIPBA_msi_b			=3D 0,=0A=
+	PCIPBA_msi_m			=3D 0x00000001,=0A=
+	PCIPBA_p_b			=3D 3,=0A=
+	PCIPBA_p_m			=3D 0x00000004,=0A=
+	PCIPBA_baddr_b			=3D 8,=0A=
+	PCIPBA_baddr_m			=3D 0xffffff00,=0A=
+=0A=
+	PCFGSS_vendorId_b		=3D 0,=0A=
+	PCFGSS_vendorId_m		=3D 0x0000ffff,=0A=
+	PCFGSS_id_b			=3D 16,=0A=
+	PCFGSS_id_m			=3D 0xffff0000,=0A=
+=0A=
+	PCFG3C_interruptLine_b		=3D 0,=0A=
+	PCFG3C_interruptLine_m		=3D 0x000000ff,=0A=
+	PCFG3C_interruptPin_b		=3D 8,=0A=
+	PCFG3C_interruptPin_m		=3D 0x0000ff00,=0A=
+	PCFG3C_minGrant_b		=3D 16,=0A=
+	PCFG3C_minGrant_m		=3D 0x00ff0000,=0A=
+	PCFG3C_maxLat_b 		=3D 24,=0A=
+	PCFG3C_maxLat_m 		=3D 0xff000000,=0A=
+=0A=
+	PCIPBAC_msi_b			=3D 0,=0A=
+	PCIPBAC_msi_m			=3D 0x00000001,=0A=
+	PCIPBAC_p_b			=3D 1,=0A=
+	PCIPBAC_p_m			=3D 0x00000002,=0A=
+	PCIPBAC_size_b			=3D 2,=0A=
+	PCIPBAC_size_m			=3D 0x0000007c,=0A=
+	PCIPBAC_sb_b			=3D 7,=0A=
+	PCIPBAC_sb_m			=3D 0x00000080,=0A=
+	PCIPBAC_pp_b			=3D 8,=0A=
+	PCIPBAC_pp_m			=3D 0x00000100,=0A=
+	PCIPBAC_mr_b			=3D 9,=0A=
+	PCIPBAC_mr_m			=3D 0x00000600,=0A=
+	PCIPBAC_mr_read_v	=3D0,	//no prefetching=0A=
+	PCIPBAC_mr_readLine_v	=3D1,=0A=
+	PCIPBAC_mr_readMult_v	=3D2,=0A=
+	PCIPBAC_mrl_b			=3D 11,=0A=
+	PCIPBAC_mrl_m			=3D 0x00000800,=0A=
+	PCIPBAC_mrm_b			=3D 12,=0A=
+	PCIPBAC_mrm_m			=3D 0x00001000,=0A=
+	PCIPBAC_trp_b			=3D 13,=0A=
+	PCIPBAC_trp_m			=3D 0x00002000,=0A=
+=0A=
+	PCFG40_trdyTimeout_b		=3D 0,=0A=
+	PCFG40_trdyTimeout_m		=3D 0x000000ff,=0A=
+	PCFG40_retryLim_b		=3D 8,=0A=
+	PCFG40_retryLim_m		=3D 0x0000ff00,=0A=
+};=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address [0|1|2|3] Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBA_baddr_b		=3D 0,		// In PCI_t -> pcilba [] .a=0A=
+	PCILBA_baddr_m		=3D 0xffffff00,=0A=
+} ;=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBAC_msi_b		=3D 0,		// In pPci->pcilba[i].c=0A=
+	PCILBAC_msi_m		=3D 0x00000001,=0A=
+	PCILBAC_msi_mem_v	=3D 0,=0A=
+	PCILBAC_msi_io_v	=3D 1,=0A=
+	PCILBAC_size_b		=3D 2,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_size_m		=3D 0x0000007c,=0A=
+	PCILBAC_sb_b		=3D 7,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_sb_m		=3D 0x00000080,=0A=
+	PCILBAC_rt_b		=3D 8,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_rt_m		=3D 0x00000100,=0A=
+	PCILBAC_rt_noprefetch_v =3D 0, // mem read=0A=
+	PCILBAC_rt_prefetch_v	=3D 1, // mem readline=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address [0|1|2|3] Mapping Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBAM_maddr_b 	=3D 8,=0A=
+	PCILBAM_maddr_m 	=3D 0xffffff00,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Decoupled Access Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDAC_den_b		=3D 0,=0A=
+	PCIDAC_den_m		=3D 0x00000001,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Decoupled Access Status Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDAS_d_b	=3D 0,=0A=
+	PCIDAS_d_m	=3D 0x00000001,=0A=
+	PCIDAS_b_b	=3D 1,=0A=
+	PCIDAS_b_m	=3D 0x00000002,=0A=
+	PCIDAS_e_b	=3D 2,=0A=
+	PCIDAS_e_m	=3D 0x00000004,=0A=
+	PCIDAS_ofe_b	=3D 3,=0A=
+	PCIDAS_ofe_m	=3D 0x00000008,=0A=
+	PCIDAS_off_b	=3D 4,=0A=
+	PCIDAS_off_m	=3D 0x00000010,=0A=
+	PCIDAS_ife_b	=3D 5,=0A=
+	PCIDAS_ife_m	=3D 0x00000020,=0A=
+	PCIDAS_iff_b	=3D 6,=0A=
+	PCIDAS_iff_m	=3D 0x00000040,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI DMA Channel 8 Configuration Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIDMA8C_mbs_b	=3D 0,		// Maximum Burst Size.=0A=
+	PCIDMA8C_mbs_m	=3D 0x00000fff,	// { pcidma8c }=0A=
+	PCIDMA8C_our_b	=3D 12,		// Optimize Unaligned Burst Reads.=0A=
+	PCIDMA8C_our_m	=3D 0x00001000,	// { pcidma8c }=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI DMA Channel 9 Configuration Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIDMA9C_mbs_b	=3D 0,		// Maximum Burst Size.=0A=
+	PCIDMA9C_mbs_m	=3D 0x00000fff, // { pcidma9c }=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI to Memory(DMA Channel 8) AND Memory to PCI DMA(DMA Channel =
9)Descriptors=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDMAD_pt_b		=3D 22,		// in DEVCMD field (descriptor)=0A=
+	PCIDMAD_pt_m		=3D 0x00c00000,	// preferred transaction field=0A=
+	// These are for reads (DMA channel 8)=0A=
+	PCIDMAD_devcmd_mr_v	=3D 0,	//memory read=0A=
+	PCIDMAD_devcmd_mrl_v	=3D 1,	//memory read line=0A=
+	PCIDMAD_devcmd_mrm_v	=3D 2,	//memory read multiple=0A=
+	PCIDMAD_devcmd_ior_v	=3D 3,	//I/O read=0A=
+	// These are for writes (DMA channel 9)=0A=
+	PCIDMAD_devcmd_mw_v	=3D 0,	//memory write=0A=
+	PCIDMAD_devcmd_mwi_v	=3D 1,	//memory write invalidate=0A=
+	PCIDMAD_devcmd_iow_v	=3D 3,	//I/O write=0A=
+	=0A=
+	// Swap byte field applies to both DMA channel 8 and 9=0A=
+	PCIDMAD_sb_b		=3D 24,		// in DEVCMD field (descriptor)=0A=
+	PCIDMAD_sb_m		=3D 0x01000000,	// swap byte field=0A=
+} ;=0A=
+=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Target Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCITC_rtimer_b		=3D 0,		// In PCITC_t -> pcitc=0A=
+	PCITC_rtimer_m		=3D 0x000000ff,=0A=
+	PCITC_dtimer_b		=3D 8,		// In PCITC_t -> pcitc=0A=
+	PCITC_dtimer_m		=3D 0x0000ff00,=0A=
+	PCITC_rdr_b		=3D 18,		// In PCITC_t -> pcitc=0A=
+	PCITC_rdr_m		=3D 0x00040000,=0A=
+	PCITC_ddt_b		=3D 19,		// In PCITC_t -> pcitc=0A=
+	PCITC_ddt_m		=3D 0x00080000,=0A=
+} ;=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI messaging unit [applies to both inbound and outbound registers =
]=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIM_m0_b	=3D 0,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_m0_m	=3D 0x00000001,	// inbound or outbound message 0=0A=
+	PCIM_m1_b	=3D 1,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_m1_m	=3D 0x00000002,	// inbound or outbound message 1=0A=
+	PCIM_db_b	=3D 2,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_db_m	=3D 0x00000004,	// inbound or outbound doorbell=0A=
+};=0A=
+=0A=
+=0A=
+#endif	// __IDT_RC32365_PCI_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_pci_v.h =
idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_pci_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32300/rc32365_pci_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32300/rc32365_pci_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,210 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   PCI header values for IDT 79EB365/336                             =
                      =0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32365_PCI_V_H__=0A=
+#define __IDT_RC32365_PCI_V_H__=0A=
+=0A=
+=0A=
+#define PCI_MSG_VirtualAddress	0xB806C010=0A=
+#define rc32365_pci ((volatile PCI_t) PCI0_VirtualAddress)=0A=
+#define rc32365_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)=0A=
+=0A=
+#define PCIM_SHFT		0x6=0A=
+#define PCIM_BIT_LEN		0x7=0A=
+#define PCIM_H_EA		0x3=0A=
+#define PCIM_H_IA_FIX		0x4=0A=
+#define PCIM_H_IA_RR		0x5=0A=
+=0A=
+#define PCI_ADDR_START		0x50000000=0A=
+=0A=
+#define CPUTOPCI_MEM_WIN	0x02000000=0A=
+#define CPUTOPCI_IO_WIN		0x00100000=0A=
+#define PCILBA_SIZE_SHFT	2=0A=
+#define PCILBA_SIZE_MASK	0x1F=0A=
+#define SIZE_256MB		0x1C=0A=
+#define SIZE_128MB		0x1B=0A=
+#define SIZE_64MB               0x1A=0A=
+#define SIZE_32MB		0x19=0A=
+#define SIZE_16MB               0x18=0A=
+#define SIZE_4MB		0x16=0A=
+#define SIZE_2MB		0x15=0A=
+#define SIZE_1MB		0x14=0A=
+#define CEDAR_CONFIG0_ADDR	0x80000000=0A=
+#define CEDAR_CONFIG1_ADDR	0x80000004=0A=
+#define CEDAR_CONFIG2_ADDR	0x80000008=0A=
+#define CEDAR_CONFIG3_ADDR	0x8000000C=0A=
+#define CEDAR_CONFIG4_ADDR	0x80000010=0A=
+#define CEDAR_CONFIG5_ADDR	0x80000014=0A=
+#define CEDAR_CONFIG6_ADDR	0x80000018=0A=
+#define CEDAR_CONFIG7_ADDR	0x8000001C=0A=
+#define CEDAR_CONFIG8_ADDR	0x80000020=0A=
+#define CEDAR_CONFIG9_ADDR	0x80000024=0A=
+#define CEDAR_CONFIG10_ADDR	0x80000028=0A=
+#define CEDAR_CONFIG11_ADDR	0x8000002C=0A=
+#define CEDAR_CONFIG12_ADDR	0x80000030=0A=
+#define CEDAR_CONFIG13_ADDR	0x80000034=0A=
+#define CEDAR_CONFIG14_ADDR	0x80000038=0A=
+#define CEDAR_CONFIG15_ADDR	0x8000003C=0A=
+#define CEDAR_CONFIG16_ADDR	0x80000040=0A=
+#define CEDAR_CONFIG17_ADDR	0x80000044=0A=
+#define CEDAR_CONFIG18_ADDR	0x80000048=0A=
+#define CEDAR_CONFIG19_ADDR	0x8000004C=0A=
+#define CEDAR_CONFIG20_ADDR	0x80000050=0A=
+#define CEDAR_CONFIG21_ADDR	0x80000054=0A=
+#define CEDAR_CONFIG22_ADDR	0x80000058=0A=
+#define CEDAR_CONFIG23_ADDR	0x8000005C=0A=
+#define CEDAR_CONFIG24_ADDR	0x80000060=0A=
+#define CEDAR_CONFIG25_ADDR	0x80000064=0A=
+#define CEDAR_CMD 	       (PCFG04_command_ioena_m  | \=0A=
+				PCFG04_command_memena_m | \=0A=
+				PCFG04_command_bmena_m  | \=0A=
+				PCFG04_command_mwinv_m  | \=0A=
+				PCFG04_command_parena_m | \=0A=
+				PCFG04_command_serrena_m )=0A=
+=0A=
+#define CEDAR_STAT	       (PCFG04_status_mdpe_m | \=0A=
+				PCFG04_status_sta_m  | \=0A=
+				PCFG04_status_rta_m  | \=0A=
+				PCFG04_status_rma_m  | \=0A=
+				PCFG04_status_sse_m  | \=0A=
+				PCFG04_status_pe_m)=0A=
+=0A=
+#define CEDAR_CNFG1	      ((CEDAR_STAT << 16) | \=0A=
+                                CEDAR_CMD)=0A=
+=0A=
+#define CEDAR_REVID		0=0A=
+#define CEDAR_CLASS_CODE	0=0A=
+#define CEDAR_CNFG2	      ((CEDAR_CLASS_CODE << 8) | \=0A=
+				CEDAR_REVID)=0A=
+=0A=
+#define CEDAR_CACHE_LINE_SIZE	4=0A=
+#define CEDAR_MASTER_LAT	0x3c=0A=
+#define CEDAR_HEADER_TYPE	0=0A=
+#define CEDAR_BIST		0=0A=
+=0A=
+#define CEDAR_CNFG3           ((CEDAR_BIST        << 24) | \=0A=
+		               (CEDAR_HEADER_TYPE << 16) | \=0A=
+		               (CEDAR_MASTER_LAT  <<  8) | \=0A=
+		                CEDAR_CACHE_LINE_SIZE)=0A=
+=0A=
+#define CEDAR_BAR0	        0x00000008 /* 128 MB Memory */=0A=
+#define CEDAR_BAR1	        0x18800001 /* 1 MB IO */=0A=
+#define CEDAR_BAR2	        0x18000001 /* 2 MB IO window for Cedar=0A=
+				              internal Registers */=0A=
+#define CEDAR_BAR3	        0x48000008 /* Spare 128 MB Memory */=0A=
+=0A=
+#define CEDAR_CNFG4	        CEDAR_BAR0=0A=
+#define CEDAR_CNFG5             CEDAR_BAR1=0A=
+#define CEDAR_CNFG6 	        CEDAR_BAR2=0A=
+#define CEDAR_CNFG7	        CEDAR_BAR3=0A=
+=0A=
+#define CEDAR_SUBSYS_VENDOR_ID  0=0A=
+#define CEDAR_SUBSYSTEM_ID	0=0A=
+#define CEDAR_CNFG8		0=0A=
+#define CEDAR_CNFG9		0=0A=
+#define CEDAR_CNFG10		0=0A=
+#define CEDAR_CNFG11 	      ((CEDAR_SUBSYS_VENDOR_ID << 16) | \=0A=
+			        CEDAR_SUBSYSTEM_ID)=0A=
+#define CEDAR_INT_LINE		1=0A=
+#define CEDAR_INT_PIN		1=0A=
+#define CEDAR_MIN_GNT		8=0A=
+#define CEDAR_MAX_LAT		0x38=0A=
+#define CEDAR_CNFG12		0=0A=
+#define CEDAR_CNFG13 		0=0A=
+#define CEDAR_CNFG14		0=0A=
+#define CEDAR_CNFG15	      ((CEDAR_MAX_LAT << 24) | \=0A=
+			       (CEDAR_MIN_GNT << 16) | \=0A=
+			       (CEDAR_INT_PIN <<  8) | \=0A=
+			        CEDAR_INT_LINE)=0A=
+#define	CEDAR_RETRY_LIMIT	0x80=0A=
+#define CEDAR_TRDY_LIMIT	0x80=0A=
+#define CEDAR_CNFG16          ((CEDAR_RETRY_LIMIT << 8) | \=0A=
+			        CEDAR_TRDY_LIMIT)=0A=
+#define PCI_PBAxC_R		0x0=0A=
+#define PCI_PBAxC_RL		0x1=0A=
+#define PCI_PBAxC_RM		0x2=0A=
+#define SIZE_SHFT		2=0A=
+#ifdef __MIPSEB__=0A=
+#define CEDAR_PBA0C	       (((1 & 0x3) << PCIPBAC_mr_b) | \=0A=
+			        PCIPBAC_pp_m | \=0A=
+				PCIPBAC_sb_m | \=0A=
+			       (SIZE_128MB << SIZE_SHFT) | \=0A=
+			        PCIPBAC_p_m)=0A=
+#else=0A=
+=0A=
+#define CEDAR_PBA0C	       (((1 & 0x3) << PCIPBAC_mr_b) | \=0A=
+			        PCIPBAC_pp_m | \=0A=
+			       (SIZE_128MB << SIZE_SHFT) | \=0A=
+			        PCIPBAC_p_m)=0A=
+#endif=0A=
+#define CEDAR_CNFG17	        CEDAR_PBA0C=0A=
+#define CEDAR_PBA0M	        0x0=0A=
+#define CEDAR_CNFG18	        CEDAR_PBA0M=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define CEDAR_PBA1C	      ((SIZE_1MB << SIZE_SHFT) | \=0A=
+				PCIPBAC_sb_m | \=0A=
+			        PCIPBAC_msi_m)=0A=
+#else=0A=
+#define CEDAR_PBA1C	      ((SIZE_1MB << SIZE_SHFT) | \=0A=
+			        PCIPBAC_msi_m)=0A=
+#endif=0A=
+#define CEDAR_CNFG19	        CEDAR_PBA1C=0A=
+#define CEDAR_PBA1M	        0x0=0A=
+#define CEDAR_CNFG20	        CEDAR_PBA1M=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define CEDAR_PBA2C	      ((SIZE_2MB << SIZE_SHFT) |  \=0A=
+				PCIPBAC_sb_m | \=0A=
+			        PCIPBAC_msi_m)=0A=
+#else=0A=
+#define CEDAR_PBA2C	      ((SIZE_2MB << SIZE_SHFT) |  \=0A=
+			        PCIPBAC_msi_m)=0A=
+#endif=0A=
+=0A=
+#define CEDAR_CNFG21	        CEDAR_PBA2C=0A=
+#define CEDAR_PBA2M	        0x18000000=0A=
+#define CEDAR_CNFG22	        CEDAR_PBA2M=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define CEDAR_PBA3C	        PCIPBAC_sb_m=0A=
+#else=0A=
+#define CEDAR_PBA3C	        0 =0A=
+#endif=0A=
+=0A=
+#define CEDAR_CNFG23	        CEDAR_PBA3C=0A=
+#define CEDAR_PBA3M	        0=0A=
+#define CEDAR_CNFG24	        CEDAR_PBA3M=0A=
+=0A=
+#define	PCITC_DTIMER_VAL	8=0A=
+#define PCITC_RTIMER_VAL	0x10=0A=
+=0A=
+#endif //__IDT_RC32365_PCI_V_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_dma.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_dma.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_dma.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_dma.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,198 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   DMA register definition=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_DMA_H__=0A=
+#define __IDT_DMA_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMA0_PhysicalAddress	=3D 0x18040000,=0A=
+	DMA_PhysicalAddress	=3D DMA0_PhysicalAddress,		// Default=0A=
+=0A=
+	DMA0_VirtualAddress	=3D 0xb8040000,=0A=
+	DMA_VirtualAddress	=3D DMA0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA descriptor (in physical memory).=0A=
+ */=0A=
+=0A=
+typedef struct DMAD_s=0A=
+{=0A=
+	u32			control ;	// Control. use DMAD_*=0A=
+	u32			ca ;		// Current Address.=0A=
+	u32			devcs ; 	// Device control and status.=0A=
+	u32			link ;		// Next descriptor in chain.=0A=
+} volatile *DMAD_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMAD_size		=3D sizeof (struct DMAD_s),=0A=
+	DMAD_count_b		=3D 0,		// in DMAD_t -> control=0A=
+	DMAD_count_m		=3D 0x0003ffff,	// in DMAD_t -> control=0A=
+	DMAD_ds_b		=3D 20,		// in DMAD_t -> control=0A=
+	DMAD_ds_m		=3D 0x00300000,	// in DMAD_t -> control=0A=
+		DMAD_ds_ethRcv0_v	=3D 0,=0A=
+		DMAD_ds_ethXmt0_v	=3D 0,=0A=
+		DMAD_ds_memToFifo_v	=3D 0,=0A=
+		DMAD_ds_fifoToMem_v	=3D 0,=0A=
+		DMAD_ds_pciToMem_v	=3D 0,=0A=
+		DMAD_ds_memToPci_v	=3D 0,=0A=
+	=0A=
+	DMAD_devcmd_b		=3D 22,		// in DMAD_t -> control=0A=
+	DMAD_devcmd_m		=3D 0x01c00000,	// in DMAD_t -> control=0A=
+		DMAD_devcmd_byte_v	=3D 0,	//memory-to-memory=0A=
+		DMAD_devcmd_halfword_v	=3D 1,	//memory-to-memory=0A=
+		DMAD_devcmd_word_v	=3D 2,	//memory-to-memory=0A=
+		DMAD_devcmd_2words_v	=3D 3,	//memory-to-memory=0A=
+		DMAD_devcmd_4words_v	=3D 4,	//memory-to-memory=0A=
+		DMAD_devcmd_6words_v	=3D 5,	//memory-to-memory=0A=
+		DMAD_devcmd_8words_v	=3D 6,	//memory-to-memory=0A=
+		DMAD_devcmd_16words_v	=3D 7,	//memory-to-memory=0A=
+	DMAD_cof_b		=3D 25,		// chain on finished=0A=
+	DMAD_cof_m		=3D 0x02000000,	// =0A=
+	DMAD_cod_b		=3D 26,		// chain on done=0A=
+	DMAD_cod_m		=3D 0x04000000,	// =0A=
+	DMAD_iof_b		=3D 27,		// interrupt on finished=0A=
+	DMAD_iof_m		=3D 0x08000000,	// =0A=
+	DMAD_iod_b		=3D 28,		// interrupt on done=0A=
+	DMAD_iod_m		=3D 0x10000000,	// =0A=
+	DMAD_t_b		=3D 29,		// terminated=0A=
+	DMAD_t_m		=3D 0x20000000,	// =0A=
+	DMAD_d_b		=3D 30,		// done=0A=
+	DMAD_d_m		=3D 0x40000000,	// =0A=
+	DMAD_f_b		=3D 31,		// finished=0A=
+	DMAD_f_m		=3D 0x80000000,	// =0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA register (within Internal Register Map).=0A=
+ */=0A=
+=0A=
+struct DMA_Chan_s=0A=
+{=0A=
+	u32		dmac ;		// Control.=0A=
+	u32		dmas ;		// Status.	=0A=
+	u32		dmasm ; 	// Mask.=0A=
+	u32		dmadptr ;	// Descriptor pointer.=0A=
+	u32		dmandptr ;	// Next descriptor pointer.=0A=
+};=0A=
+=0A=
+typedef struct DMA_Chan_s volatile *DMA_Chan_t ;=0A=
+=0A=
+//DMA_Channels	  use DMACH_count instead=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMAC_run_b	=3D 0,		// =0A=
+	DMAC_run_m	=3D 0x00000001,	// =0A=
+	DMAC_dm_b	=3D 1,		// done mask=0A=
+	DMAC_dm_m	=3D 0x00000002,	// =0A=
+	DMAC_mode_b	=3D 2,		// =0A=
+	DMAC_mode_m	=3D 0x0000000c,	// =0A=
+		DMAC_mode_auto_v	=3D 0,=0A=
+		DMAC_mode_burst_v	=3D 1,=0A=
+		DMAC_mode_transfer_v	=3D 2, //usually used=0A=
+		DMAC_mode_reserved_v	=3D 3,=0A=
+	DMAC_a_b	=3D 4,		// =0A=
+	DMAC_a_m	=3D 0x00000010,	// =0A=
+=0A=
+	DMAS_f_b	=3D 0,		// finished (sticky) =0A=
+	DMAS_f_m	=3D 0x00000001,	//		     =0A=
+	DMAS_d_b	=3D 1,		// done (sticky)     =0A=
+	DMAS_d_m	=3D 0x00000002,	//		     =0A=
+	DMAS_c_b	=3D 2,		// chain (sticky)    =0A=
+	DMAS_c_m	=3D 0x00000004,	//		     =0A=
+	DMAS_e_b	=3D 3,		// error (sticky)    =0A=
+	DMAS_e_m	=3D 0x00000008,	//		     =0A=
+	DMAS_h_b	=3D 4,		// halt (sticky)     =0A=
+	DMAS_h_m	=3D 0x00000010,	//		     =0A=
+=0A=
+	DMASM_f_b	=3D 0,		// finished (1=3Dmask)=0A=
+	DMASM_f_m	=3D 0x00000001,	// =0A=
+	DMASM_d_b	=3D 1,		// done (1=3Dmask)=0A=
+	DMASM_d_m	=3D 0x00000002,	// =0A=
+	DMASM_c_b	=3D 2,		// chain (1=3Dmask)=0A=
+	DMASM_c_m	=3D 0x00000004,	// =0A=
+	DMASM_e_b	=3D 3,		// error (1=3Dmask)=0A=
+	DMASM_e_m	=3D 0x00000008,	// =0A=
+	DMASM_h_b	=3D 4,		// halt (1=3Dmask)=0A=
+	DMASM_h_m	=3D 0x00000010,	// =0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA channel definitions=0A=
+ */=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMACH_ethRcv0 =3D 0,=0A=
+	DMACH_ethXmt0 =3D 1,=0A=
+	DMACH_memToFifo =3D 2,=0A=
+	DMACH_fifoToMem =3D 3,=0A=
+	DMACH_pciToMem =3D 4,=0A=
+	DMACH_memToPci =3D 5,=0A=
+=0A=
+	DMACH_count //must be last=0A=
+};=0A=
+=0A=
+=0A=
+typedef struct DMAC_s=0A=
+{=0A=
+	struct DMA_Chan_s ch [DMACH_count] ; //use ch[DMACH_]=0A=
+} volatile *DMA_t ;=0A=
+=0A=
+=0A=
+/*=0A=
+ * External DMA parameters=0A=
+*/=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMADEVCMD_ts_b	=3D 0,		// ts field in devcmd=0A=
+	DMADEVCMD_ts_m	=3D 0x00000007,	// ts field in devcmd=0A=
+		DMADEVCMD_ts_byte_v	=3D 0,=0A=
+		DMADEVCMD_ts_halfword_v	=3D 1,=0A=
+		DMADEVCMD_ts_word_v	=3D 2,=0A=
+		DMADEVCMD_ts_2word_v	=3D 3,=0A=
+		DMADEVCMD_ts_4word_v	=3D 4,=0A=
+		DMADEVCMD_ts_6word_v	=3D 5,=0A=
+		DMADEVCMD_ts_8word_v	=3D 6,=0A=
+		DMADEVCMD_ts_16word_v	=3D 7=0A=
+};=0A=
+=0A=
+=0A=
+#endif	// __IDT_DMA_H__=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_dma_v.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_dma_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_dma_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_dma_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,81 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for DMA controller.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_DMA_V_H__=0A=
+#define __IDT_DMA_V_H__=0A=
+=0A=
+#include  <asm/idt-boards/rc32434/rc32434_dma.h> =0A=
+#include  <asm/idt-boards/rc32434/rc32434.h>=0A=
+=0A=
+#define DMA_CHAN_OFFSET  0x14=0A=
+#define IS_DMA_USED(X) (((X) & (DMAD_f_m | DMAD_d_m | DMAD_t_m)) !=3D =
0)=0A=
+#define DMA_COUNT(count)   \=0A=
+  ((count) & DMAD_count_m)=0A=
+=0A=
+#define DMA_HALT_TIMEOUT 500=0A=
+=0A=
+=0A=
+static inline int rc32434_halt_dma(DMA_Chan_t ch)=0A=
+{=0A=
+	int timeout=3D1;=0A=
+	if (rc32434_readl(&ch->dmac) & DMAC_run_m) {=0A=
+		rc32434_writel(0, &ch->dmac); =0A=
+		=0A=
+		for (timeout =3D DMA_HALT_TIMEOUT; timeout > 0; timeout--) {=0A=
+			if (rc32434_readl(&ch->dmas) & DMAS_h_m) {=0A=
+				rc32434_writel(0, &ch->dmas);  =0A=
+				break;=0A=
+			}=0A=
+		}=0A=
+=0A=
+	}=0A=
+	=0A=
+	return timeout ? 0 : 1;=0A=
+}=0A=
+=0A=
+static inline void rc32434_start_dma(DMA_Chan_t ch, u32 dma_addr)=0A=
+{=0A=
+	rc32434_writel(0, &ch->dmandptr); =0A=
+	rc32434_writel(dma_addr, &ch->dmadptr);=0A=
+}=0A=
+=0A=
+static inline void rc32434_chain_dma(DMA_Chan_t ch, u32 dma_addr)=0A=
+{=0A=
+	rc32434_writel(dma_addr, &ch->dmandptr);=0A=
+}=0A=
+=0A=
+#endif	// __IDT_DMA_V_H__=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_eth.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_eth.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_eth.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_eth.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,326 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Ethernet register definition=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef	__IDT_ETH_H__=0A=
+#define	__IDT_ETH_H__=0A=
+=0A=
+=0A=
+enum=0A=
+{=0A=
+	ETH0_PhysicalAddress	=3D 0x18060000,=0A=
+	ETH_PhysicalAddress	=3D ETH0_PhysicalAddress,		// Default=0A=
+=0A=
+	ETH0_VirtualAddress	=3D 0xb8060000,=0A=
+	ETH_VirtualAddress	=3D ETH0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32 ethintfc		;=0A=
+	u32 ethfifott		;=0A=
+	u32 etharc		;=0A=
+	u32 ethhash0		;=0A=
+	u32 ethhash1		;=0A=
+	u32 ethu0 [4]		;	// Reserved.	=0A=
+	u32 ethpfs		;=0A=
+	u32 ethmcp		;=0A=
+	u32 eth_u1 [10]		;	// Reserved.=0A=
+	u32 ethspare		;=0A=
+	u32 eth_u2 [42]		;	// Reserved. =0A=
+	u32 ethsal0		;=0A=
+	u32 ethsah0		;=0A=
+	u32 ethsal1		;=0A=
+	u32 ethsah1		;=0A=
+	u32 ethsal2		;=0A=
+	u32 ethsah2		;=0A=
+	u32 ethsal3		;=0A=
+	u32 ethsah3		;=0A=
+	u32 ethrbc		;=0A=
+	u32 ethrpc		;=0A=
+	u32 ethrupc		;=0A=
+	u32 ethrfc		;=0A=
+	u32 ethtbc		;=0A=
+	u32 ethgpf		;=0A=
+	u32 eth_u9 [50]		;	// Reserved.	=0A=
+	u32 ethmac1		;=0A=
+	u32 ethmac2		;=0A=
+	u32 ethipgt		;=0A=
+	u32 ethipgr		;=0A=
+	u32 ethclrt		;=0A=
+	u32 ethmaxf		;=0A=
+	u32 eth_u10		;	// Reserved.	=0A=
+	u32 ethmtest		;=0A=
+	u32 miimcfg		;=0A=
+	u32 miimcmd		;=0A=
+	u32 miimaddr		;=0A=
+	u32 miimwtd		;=0A=
+	u32 miimrdd		;=0A=
+	u32 miimind		;=0A=
+	u32 eth_u11		;	// Reserved.=0A=
+	u32 eth_u12		;	// Reserved.=0A=
+	u32 ethcfsa0		;=0A=
+	u32 ethcfsa1		;=0A=
+	u32 ethcfsa2		;=0A=
+} volatile *ETH_t;=0A=
+=0A=
+enum=0A=
+{=0A=
+	ETHINTFC_en_b		=3D 0,=0A=
+	ETHINTFC_en_m		=3D 0x00000001,=0A=
+	ETHINTFC_its_b		=3D 1,=0A=
+	ETHINTFC_its_m		=3D 0x00000002,=0A=
+	ETHINTFC_rip_b		=3D 2,=0A=
+	ETHINTFC_rip_m		=3D 0x00000004,=0A=
+	ETHINTFC_jam_b		=3D 3,=0A=
+	ETHINTFC_jam_m		=3D 0x00000008,=0A=
+	ETHINTFC_ovr_b		=3D 4,=0A=
+	ETHINTFC_ovr_m		=3D 0x00000010,=0A=
+	ETHINTFC_und_b		=3D 5,=0A=
+	ETHINTFC_und_m		=3D 0x00000020,=0A=
+=0A=
+	ETHFIFOTT_tth_b		=3D 0,=0A=
+	ETHFIFOTT_tth_m		=3D 0x0000007f,=0A=
+=0A=
+	ETHARC_pro_b		=3D 0,=0A=
+	ETHARC_pro_m		=3D 0x00000001,=0A=
+	ETHARC_am_b		=3D 1,=0A=
+	ETHARC_am_m		=3D 0x00000002,=0A=
+	ETHARC_afm_b		=3D 2,=0A=
+	ETHARC_afm_m		=3D 0x00000004,=0A=
+	ETHARC_ab_b		=3D 3,=0A=
+	ETHARC_ab_m		=3D 0x00000008,=0A=
+=0A=
+	ETHSAL_byte5_b		=3D 0,=0A=
+	ETHSAL_byte5_m		=3D 0x000000ff,=0A=
+	ETHSAL_byte4_b		=3D 8,=0A=
+	ETHSAL_byte4_m		=3D 0x0000ff00,=0A=
+	ETHSAL_byte3_b		=3D 16,=0A=
+	ETHSAL_byte3_m		=3D 0x00ff0000,=0A=
+	ETHSAL_byte2_b		=3D 24,=0A=
+	ETHSAL_byte2_m		=3D 0xff000000,=0A=
+=0A=
+	ETHSAH_byte1_b		=3D 0,=0A=
+	ETHSAH_byte1_m		=3D 0x000000ff,=0A=
+	ETHSAH_byte0_b		=3D 8,=0A=
+	ETHSAH_byte0_m		=3D 0x0000ff00,=0A=
+	=0A=
+	ETHGPF_ptv_b		=3D 0,=0A=
+	ETHGPF_ptv_m		=3D 0x0000ffff,=0A=
+=0A=
+	ETHPFS_pfd_b		=3D 0,=0A=
+	ETHPFS_pfd_m		=3D 0x00000001,=0A=
+=0A=
+	ETHCFSA0_cfsa4_b	=3D 0,=0A=
+	ETHCFSA0_cfsa4_m	=3D 0x000000ff,=0A=
+	ETHCFSA0_cfsa5_b	=3D 8,=0A=
+	ETHCFSA0_cfsa5_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHCFSA1_cfsa2_b	=3D 0,=0A=
+	ETHCFSA1_cfsa2_m	=3D 0x000000ff,=0A=
+	ETHCFSA1_cfsa3_b	=3D 8,=0A=
+	ETHCFSA1_cfsa3_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHCFSA2_cfsa0_b	=3D 0,=0A=
+	ETHCFSA2_cfsa0_m	=3D 0x000000ff,=0A=
+	ETHCFSA2_cfsa1_b	=3D 8,=0A=
+	ETHCFSA2_cfsa1_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHMAC1_re_b		=3D 0,=0A=
+	ETHMAC1_re_m		=3D 0x00000001,=0A=
+	ETHMAC1_paf_b		=3D 1,=0A=
+	ETHMAC1_paf_m		=3D 0x00000002,=0A=
+	ETHMAC1_rfc_b		=3D 2,=0A=
+	ETHMAC1_rfc_m		=3D 0x00000004,=0A=
+	ETHMAC1_tfc_b		=3D 3,=0A=
+	ETHMAC1_tfc_m		=3D 0x00000008,=0A=
+	ETHMAC1_lb_b		=3D 4,=0A=
+	ETHMAC1_lb_m		=3D 0x00000010,=0A=
+	ETHMAC1_mr_b		=3D 31,=0A=
+	ETHMAC1_mr_m		=3D 0x80000000,=0A=
+=0A=
+	ETHMAC2_fd_b		=3D 0,=0A=
+	ETHMAC2_fd_m		=3D 0x00000001,=0A=
+	ETHMAC2_flc_b		=3D 1,=0A=
+	ETHMAC2_flc_m		=3D 0x00000002,=0A=
+	ETHMAC2_hfe_b		=3D 2,=0A=
+	ETHMAC2_hfe_m		=3D 0x00000004,=0A=
+	ETHMAC2_dc_b		=3D 3,=0A=
+	ETHMAC2_dc_m		=3D 0x00000008,=0A=
+	ETHMAC2_cen_b		=3D 4,=0A=
+	ETHMAC2_cen_m		=3D 0x00000010,=0A=
+	ETHMAC2_pe_b		=3D 5,=0A=
+	ETHMAC2_pe_m		=3D 0x00000020,=0A=
+	ETHMAC2_vpe_b		=3D 6,=0A=
+	ETHMAC2_vpe_m		=3D 0x00000040,=0A=
+	ETHMAC2_ape_b		=3D 7,=0A=
+	ETHMAC2_ape_m		=3D 0x00000080,=0A=
+	ETHMAC2_ppe_b		=3D 8,=0A=
+	ETHMAC2_ppe_m		=3D 0x00000100,=0A=
+	ETHMAC2_lpe_b		=3D 9,=0A=
+	ETHMAC2_lpe_m		=3D 0x00000200,=0A=
+	ETHMAC2_nb_b		=3D 12,=0A=
+	ETHMAC2_nb_m		=3D 0x00001000,=0A=
+	ETHMAC2_bp_b		=3D 13,=0A=
+	ETHMAC2_bp_m		=3D 0x00002000,=0A=
+	ETHMAC2_ed_b		=3D 14,=0A=
+	ETHMAC2_ed_m		=3D 0x00004000,=0A=
+=0A=
+	ETHIPGT_ipgt_b		=3D 0,=0A=
+	ETHIPGT_ipgt_m		=3D 0x0000007f,=0A=
+=0A=
+	ETHIPGR_ipgr2_b		=3D 0,=0A=
+	ETHIPGR_ipgr2_m		=3D 0x0000007f,=0A=
+	ETHIPGR_ipgr1_b		=3D 8,=0A=
+	ETHIPGR_ipgr1_m		=3D 0x00007f00,=0A=
+=0A=
+	ETHCLRT_maxret_b	=3D 0,=0A=
+	ETHCLRT_maxret_m	=3D 0x0000000f,=0A=
+	ETHCLRT_colwin_b	=3D 8,=0A=
+	ETHCLRT_colwin_m	=3D 0x00003f00,=0A=
+=0A=
+	ETHMAXF_maxf_b		=3D 0,=0A=
+	ETHMAXF_maxf_m		=3D 0x0000ffff,=0A=
+=0A=
+	ETHMTEST_tb_b		=3D 2,=0A=
+	ETHMTEST_tb_m		=3D 0x00000004,=0A=
+=0A=
+	ETHMCP_div_b		=3D 0,=0A=
+	ETHMCP_div_m		=3D 0x000000ff,=0A=
+	=0A=
+	MIIMCFG_rsv_b		=3D 0,=0A=
+	MIIMCFG_rsv_m		=3D 0x0000000c,=0A=
+=0A=
+	MIIMCMD_rd_b		=3D 0,=0A=
+	MIIMCMD_rd_m		=3D 0x00000001,=0A=
+	MIIMCMD_scn_b		=3D 1,=0A=
+	MIIMCMD_scn_m		=3D 0x00000002,=0A=
+=0A=
+	MIIMADDR_regaddr_b	=3D 0,=0A=
+	MIIMADDR_regaddr_m	=3D 0x0000001f,=0A=
+	MIIMADDR_phyaddr_b	=3D 8,=0A=
+	MIIMADDR_phyaddr_m	=3D 0x00001f00,=0A=
+=0A=
+	MIIMWTD_wdata_b		=3D 0,=0A=
+	MIIMWTD_wdata_m		=3D 0x0000ffff,=0A=
+=0A=
+	MIIMRDD_rdata_b		=3D 0,=0A=
+	MIIMRDD_rdata_m		=3D 0x0000ffff,=0A=
+=0A=
+	MIIMIND_bsy_b		=3D 0,=0A=
+	MIIMIND_bsy_m		=3D 0x00000001,=0A=
+	MIIMIND_scn_b		=3D 1,=0A=
+	MIIMIND_scn_m		=3D 0x00000002,=0A=
+	MIIMIND_nv_b		=3D 2,=0A=
+	MIIMIND_nv_m		=3D 0x00000004,=0A=
+=0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * Values for the DEVCS field of the Ethernet DMA Rx and Tx =
descriptors.=0A=
+ */=0A=
+enum=0A=
+{=0A=
+	ETHRX_fd_b		=3D 0,=0A=
+	ETHRX_fd_m		=3D 0x00000001,=0A=
+	ETHRX_ld_b		=3D 1,=0A=
+	ETHRX_ld_m		=3D 0x00000002,=0A=
+	ETHRX_rok_b		=3D 2,=0A=
+	ETHRX_rok_m		=3D 0x00000004,=0A=
+	ETHRX_fm_b		=3D 3,=0A=
+	ETHRX_fm_m		=3D 0x00000008,=0A=
+	ETHRX_mp_b		=3D 4,=0A=
+	ETHRX_mp_m		=3D 0x00000010,=0A=
+	ETHRX_bp_b		=3D 5,=0A=
+	ETHRX_bp_m		=3D 0x00000020,=0A=
+	ETHRX_vlt_b		=3D 6,=0A=
+	ETHRX_vlt_m		=3D 0x00000040,=0A=
+	ETHRX_cf_b		=3D 7,=0A=
+	ETHRX_cf_m		=3D 0x00000080,=0A=
+	ETHRX_ovr_b		=3D 8,=0A=
+	ETHRX_ovr_m		=3D 0x00000100,=0A=
+	ETHRX_crc_b		=3D 9,=0A=
+	ETHRX_crc_m		=3D 0x00000200,=0A=
+	ETHRX_cv_b		=3D 10,=0A=
+	ETHRX_cv_m		=3D 0x00000400,=0A=
+	ETHRX_db_b		=3D 11,=0A=
+	ETHRX_db_m		=3D 0x00000800,=0A=
+	ETHRX_le_b		=3D 12,=0A=
+	ETHRX_le_m		=3D 0x00001000,=0A=
+	ETHRX_lor_b		=3D 13,=0A=
+	ETHRX_lor_m		=3D 0x00002000,=0A=
+	ETHRX_ces_b		=3D 14,=0A=
+	ETHRX_ces_m		=3D 0x00004000,=0A=
+	ETHRX_length_b		=3D 16,=0A=
+	ETHRX_length_m		=3D 0xffff0000,=0A=
+=0A=
+	ETHTX_fd_b		=3D 0,=0A=
+	ETHTX_fd_m		=3D 0x00000001,=0A=
+	ETHTX_ld_b		=3D 1,=0A=
+	ETHTX_ld_m		=3D 0x00000002,=0A=
+	ETHTX_oen_b		=3D 2,=0A=
+	ETHTX_oen_m		=3D 0x00000004,=0A=
+	ETHTX_pen_b		=3D 3,=0A=
+	ETHTX_pen_m		=3D 0x00000008,=0A=
+	ETHTX_cen_b		=3D 4,=0A=
+	ETHTX_cen_m		=3D 0x00000010,=0A=
+	ETHTX_hen_b		=3D 5,=0A=
+	ETHTX_hen_m		=3D 0x00000020,=0A=
+	ETHTX_tok_b		=3D 6,=0A=
+	ETHTX_tok_m		=3D 0x00000040,=0A=
+	ETHTX_mp_b		=3D 7,=0A=
+	ETHTX_mp_m		=3D 0x00000080,=0A=
+	ETHTX_bp_b		=3D 8,=0A=
+	ETHTX_bp_m		=3D 0x00000100,=0A=
+	ETHTX_und_b		=3D 9,=0A=
+	ETHTX_und_m		=3D 0x00000200,=0A=
+	ETHTX_of_b		=3D 10,=0A=
+	ETHTX_of_m		=3D 0x00000400,=0A=
+	ETHTX_ed_b		=3D 11,=0A=
+	ETHTX_ed_m		=3D 0x00000800,=0A=
+	ETHTX_ec_b		=3D 12,=0A=
+	ETHTX_ec_m		=3D 0x00001000,=0A=
+	ETHTX_lc_b		=3D 13,=0A=
+	ETHTX_lc_m		=3D 0x00002000,=0A=
+	ETHTX_td_b		=3D 14,=0A=
+	ETHTX_td_m		=3D 0x00004000,=0A=
+	ETHTX_crc_b		=3D 15,=0A=
+	ETHTX_crc_m		=3D 0x00008000,=0A=
+	ETHTX_le_b		=3D 16,=0A=
+	ETHTX_le_m		=3D 0x00010000,=0A=
+	ETHTX_cc_b		=3D 17,=0A=
+	ETHTX_cc_m		=3D 0x001E0000,=0A=
+} ;=0A=
+=0A=
+#endif	// __IDT_ETH_H__=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_eth_v.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_eth_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_eth_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_eth_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,70 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Ethernet register definition=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef	__IDT_ETH_V_H__=0A=
+#define	__IDT_ETH_V_H__=0A=
+=0A=
+#include  <asm/idt-boards/rc32434/rc32434_eth.h> =0A=
+=0A=
+#define IS_TX_TOK(X)         (((X) & (1<<ETHTX_tok_b)) >> ETHTX_tok_b =
)   /* Transmit Okay    */=0A=
+#define IS_TX_MP(X)          (((X) & (1<<ETHTX_mp_b))  >> ETHTX_mp_b ) =
   /* Multicast        */=0A=
+#define IS_TX_BP(X)          (((X) & (1<<ETHTX_bp_b))  >> ETHTX_bp_b ) =
   /* Broadcast        */=0A=
+#define IS_TX_UND_ERR(X)     (((X) & (1<<ETHTX_und_b)) >> ETHTX_und_b =
)   /* Transmit FIFO Underflow */=0A=
+#define IS_TX_OF_ERR(X)      (((X) & (1<<ETHTX_of_b))  >> ETHTX_of_b ) =
   /* Oversized frame  */=0A=
+#define IS_TX_ED_ERR(X)      (((X) & (1<<ETHTX_ed_b))  >> ETHTX_ed_b ) =
   /* Excessive deferral  */=0A=
+#define IS_TX_EC_ERR(X)      (((X) & (1<<ETHTX_ec_b))  >> ETHTX_ec_b)  =
   /* Excessive collisions  */=0A=
+#define IS_TX_LC_ERR(X)      (((X) & (1<<ETHTX_lc_b))  >> ETHTX_lc_b ) =
   /* Late Collision   */=0A=
+#define IS_TX_TD_ERR(X)      (((X) & (1<<ETHTX_td_b))  >> ETHTX_td_b ) =
   /* Transmit deferred*/=0A=
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<ETHTX_crc_b)) >> ETHTX_crc_b =
)   /* CRC Error        */=0A=
+#define IS_TX_LE_ERR(X)      (((X) & (1<<ETHTX_le_b))  >>  ETHTX_le_b =
)    /* Length Error     */=0A=
+=0A=
+#define TX_COLLISION_COUNT(X) (((X) & ETHTX_cc_m)>>ETHTX_cc_b)  /* =
Collision Count  */=0A=
+=0A=
+#define IS_RCV_ROK(X)        (((X) & (1<<ETHRX_rok_b)) >> ETHRX_rok_b) =
   /* Receive Okay     */=0A=
+#define IS_RCV_FM(X)         (((X) & (1<<ETHRX_fm_b))  >> ETHRX_fm_b)  =
   /* Is Filter Match  */=0A=
+#define IS_RCV_MP(X)         (((X) & (1<<ETHRX_mp_b))  >> ETHRX_mp_b)  =
   /* Is it MP         */=0A=
+#define IS_RCV_BP(X)         (((X) & (1<<ETHRX_bp_b))  >> ETHRX_bp_b)  =
   /* Is it BP         */=0A=
+#define IS_RCV_VLT(X)        (((X) & (1<<ETHRX_vlt_b)) >> ETHRX_vlt_b) =
   /* VLAN Tag Detect  */=0A=
+#define IS_RCV_CF(X)         (((X) & (1<<ETHRX_cf_b))  >> ETHRX_cf_b)  =
   /* Control Frame    */=0A=
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<ETHRX_ovr_b)) >> ETHRX_ovr_b) =
   /* Receive Overflow */=0A=
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<ETHRX_crc_b)) >> ETHRX_crc_b) =
   /* CRC Error        */=0A=
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<ETHRX_cv_b))  >> ETHRX_cv_b)  =
   /* Code Violation   */=0A=
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<ETHRX_db_b))  >> ETHRX_db_b)  =
   /* Dribble Bits     */=0A=
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<ETHRX_le_b))  >> ETHRX_le_b)  =
   /* Length error     */=0A=
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<ETHRX_lor_b)) >> ETHRX_lor_b) =
   /* Length Out of Range */=0A=
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<ETHRX_ces_b)) >> ETHRX_ces_b) =
 /* Preamble error   */=0A=
+#define RCVPKT_LENGTH(X)     (((X) & ETHRX_length_m) >> =
ETHRX_length_b)   /* Length of the received packet */=0A=
+#endif	// __IDT_ETH_V_H__=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_gpio.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_gpio.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_gpio.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_gpio.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,160 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   GPIO register definition=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_GPIO_H__=0A=
+#define __IDT_GPIO_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	GPIO0_PhysicalAddress	=3D 0x18050000,=0A=
+	GPIO_PhysicalAddress	=3D GPIO0_PhysicalAddress,	// Default=0A=
+=0A=
+	GPIO0_VirtualAddress	=3D 0xb8050000,=0A=
+	GPIO_VirtualAddress	=3D GPIO0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32   gpiofunc;   /* GPIO Function Register=0A=
+			   * gpiofunc[x]=3D=3D0 bit =3D gpio=0A=
+			   * func[x]=3D=3D1  bit =3D altfunc=0A=
+			   */=0A=
+	u32   gpiocfg;	  /* GPIO Configuration Register=0A=
+			   * gpiocfg[x]=3D=3D0 bit =3D input=0A=
+			   * gpiocfg[x]=3D=3D1 bit =3D output=0A=
+			   */=0A=
+	u32   gpiod;	  /* GPIO Data Register=0A=
+			   * gpiod[x] read/write gpio pinX status=0A=
+			   */=0A=
+	u32   gpioilevel; /* GPIO Interrupt Status Register=0A=
+			   * interrupt level (see gpioistat)=0A=
+			   */=0A=
+	u32   gpioistat;  /* Gpio Interrupt Status Register=0A=
+			   * istat[x] =3D (gpiod[x] =3D=3D level[x])=0A=
+			   * cleared in ISR (STICKY bits)=0A=
+			   */=0A=
+	u32   gpionmien;  /* GPIO Non-maskable Interrupt Enable Register =
*/=0A=
+} volatile * GPIO_t ;=0A=
+=0A=
+typedef enum=0A=
+{=0A=
+	GPIO_gpio_v		=3D 0,		// gpiofunc use pin as GPIO.=0A=
+	GPIO_alt_v		=3D 1,		// gpiofunc use pin as alt.=0A=
+	GPIO_input_v		=3D 0,		// gpiocfg use pin as input.=0A=
+	GPIO_output_v		=3D 1,		// gpiocfg use pin as output.=0A=
+	GPIO_pin0_b		=3D 0,=0A=
+	GPIO_pin0_m		=3D 0x00000001,=0A=
+	GPIO_pin1_b		=3D 1,=0A=
+	GPIO_pin1_m		=3D 0x00000002,=0A=
+	GPIO_pin2_b		=3D 2,=0A=
+	GPIO_pin2_m		=3D 0x00000004,=0A=
+	GPIO_pin3_b		=3D 3,=0A=
+	GPIO_pin3_m		=3D 0x00000008,=0A=
+	GPIO_pin4_b		=3D 4,=0A=
+	GPIO_pin4_m		=3D 0x00000010,=0A=
+	GPIO_pin5_b		=3D 5,=0A=
+	GPIO_pin5_m		=3D 0x00000020,=0A=
+	GPIO_pin6_b		=3D 6,=0A=
+	GPIO_pin6_m		=3D 0x00000040,=0A=
+	GPIO_pin7_b		=3D 7,=0A=
+	GPIO_pin7_m		=3D 0x00000080,=0A=
+	GPIO_pin8_b		=3D 8,=0A=
+	GPIO_pin8_m		=3D 0x00000100,=0A=
+	GPIO_pin9_b		=3D 9,=0A=
+	GPIO_pin9_m		=3D 0x00000200,=0A=
+	GPIO_pin10_b		=3D 10,=0A=
+	GPIO_pin10_m		=3D 0x00000400,=0A=
+	GPIO_pin11_b		=3D 11,=0A=
+	GPIO_pin11_m		=3D 0x00000800,=0A=
+	GPIO_pin12_b		=3D 12,=0A=
+	GPIO_pin12_m		=3D 0x00001000,=0A=
+	GPIO_pin13_b		=3D 13,=0A=
+	GPIO_pin13_m		=3D 0x00002000,=0A=
+=0A=
+// Alternate function pins.  Corrsponding gpiofunc bit set to =
GPIO_alt_v.=0A=
+=0A=
+	GPIO_u0sout_b		=3D GPIO_pin0_b,		// UART 0 serial out.=0A=
+	GPIO_u0sout_m		=3D GPIO_pin0_m,=0A=
+		GPIO_u0sout_cfg_v	=3D GPIO_output_v,=0A=
+	GPIO_u0sinp_b	=3D GPIO_pin1_b,			// UART 0 serial in.=0A=
+	GPIO_u0sinp_m	=3D GPIO_pin1_m,=0A=
+		GPIO_u0sinp_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_u0rtsn_b	=3D GPIO_pin2_b,			// UART 0 req. to send.=0A=
+	GPIO_u0rtsn_m	=3D GPIO_pin2_m,=0A=
+		GPIO_u0rtsn_cfg_v	=3D GPIO_output_v,=0A=
+	GPIO_u0ctsn_b	=3D GPIO_pin3_b,			// UART 0 clear to send.=0A=
+	GPIO_u0ctsn_m	=3D GPIO_pin3_m,=0A=
+		GPIO_u0ctsn_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_maddr22_b		=3D GPIO_pin4_b, 	// M&P bus bit 22.=0A=
+	GPIO_maddr22_m		=3D GPIO_pin4_m,=0A=
+		GPIO_maddr22_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_maddr23_b		=3D GPIO_pin5_b, 	// M&P bus bit 23.=0A=
+	GPIO_maddr23_m		=3D GPIO_pin5_m,=0A=
+		GPIO_maddr23_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_maddr24_b		=3D GPIO_pin6_b, 	// M&P bus bit 24.=0A=
+	GPIO_maddr24_m		=3D GPIO_pin6_m,=0A=
+		GPIO_maddr24_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_maddr25_b		=3D GPIO_pin7_b, 	// M&P bus bit 25.=0A=
+	GPIO_maddr25_m		=3D GPIO_pin7_m,=0A=
+		GPIO_maddr25_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_cpudmadebug_b 	=3D GPIO_pin8_b, 	// CPU or DMA debug pin=0A=
+	GPIO_cpudmadebug_m 	=3D GPIO_pin8_m,=0A=
+		GPIO_cpudmadebug_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_pcireq4_b 	=3D GPIO_pin9_b, 	// PCI Request 4=0A=
+	GPIO_pcireq4_m 	=3D GPIO_pin9_m,=0A=
+		GPIO_pcireq4_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_pcigrant4_b 	=3D GPIO_pin10_b, 	// PCI Grant 4=0A=
+	GPIO_pcigrant4_m 	=3D GPIO_pin10_m,=0A=
+		GPIO_pcigrant4_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_pcireq5_b 	=3D GPIO_pin11_b, 	// PCI Request 5=0A=
+	GPIO_pcireq5_m 	=3D GPIO_pin11_m,=0A=
+		GPIO_pcireq5_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_pcigrant5_b 	=3D GPIO_pin12_b, 	// PCI Grant 5=0A=
+	GPIO_pcigrant5_m 	=3D GPIO_pin12_m,=0A=
+		GPIO_pcigrant5_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_pcimuintn_b	=3D GPIO_pin13_b, 	// PCI messaging int.=0A=
+	GPIO_pcimuintn_m	=3D GPIO_pin13_m,=0A=
+		GPIO_pcimuintn_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+} GPIO_DEFS_t;=0A=
+=0A=
+#endif	// __IDT_GPIO_H__=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434.h	2006-03-09 =
16:26:31.000000000 -0800=0A=
@@ -0,0 +1,192 @@=0A=
+ =
/***********************************************************************=
***=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for IDT RC32434 CPU=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef _RC32434_H_=0A=
+#define _RC32434_H_=0A=
+=0A=
+#include <linux/config.h>=0A=
+#include <linux/delay.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/idt-boards/rc32434/rc32434_timer.h>=0A=
+=0A=
+#define RC32434_REG_BASE   0x18000000=0A=
+=0A=
+=0A=
+#define interrupt ((volatile INT_t ) INT0_VirtualAddress)=0A=
+#define idt_timer     ((volatile TIM_t)  TIM0_VirtualAddress)=0A=
+#define gpio	  ((volatile GPIO_t) GPIO0_VirtualAddress)=0A=
+=0A=
+#define IDT_CLOCK_MULT 2=0A=
+#define MIPS_CPU_TIMER_IRQ 7=0A=
+/* Interrupt Controller */=0A=
+#define IC_GROUP0_PEND     (RC32434_REG_BASE + 0x38000)=0A=
+#define IC_GROUP0_MASK     (RC32434_REG_BASE + 0x38008)=0A=
+#define IC_GROUP_OFFSET    0x0C=0A=
+#define RTC_BASE           0xBA001FF0=0A=
+=0A=
+#define NUM_INTR_GROUPS    5=0A=
+/* 16550 UARTs */=0A=
+=0A=
+#define GROUP0_IRQ_BASE 8		/* GRP2 IRQ numbers start here */=0A=
+#define GROUP1_IRQ_BASE (GROUP0_IRQ_BASE + 32) /* GRP3 IRQ numbers =
start here */=0A=
+#define GROUP2_IRQ_BASE (GROUP1_IRQ_BASE + 32) /* GRP4 IRQ numbers =
start here */=0A=
+#define GROUP3_IRQ_BASE (GROUP2_IRQ_BASE + 32)	/* GRP5 IRQ numbers =
start here */=0A=
+#define GROUP4_IRQ_BASE (GROUP3_IRQ_BASE + 32)=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58003)=0A=
+#define EB434_UART1_BASE   (0x19800003)=0A=
+#else=0A=
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58000)=0A=
+#define EB434_UART1_BASE   (0x19800000)=0A=
+#endif=0A=
+=0A=
+#define RC32434_UART0_IRQ  GROUP3_IRQ_BASE + 0=0A=
+#define EB434_UART1_IRQ    GROUP4_IRQ_BASE + 11=0A=
+=0A=
+#if 0=0A=
+#define local_readl(addr) __raw_readl(addr)=0A=
+#define local_writel(l,addr) __raw_writel(l,addr)=0A=
+#endif =0A=
+=0A=
+#define RC32434_NR_IRQS  (GROUP4_IRQ_BASE + 32)=0A=
+=0A=
+/* cpu pipeline flush */=0A=
+static inline void rc32434_sync(void)=0A=
+{=0A=
+        __asm__ volatile ("sync");=0A=
+}=0A=
+=0A=
+static inline void rc32434_sync_udelay(int us)=0A=
+{=0A=
+        __asm__ volatile ("sync");=0A=
+        udelay(us);=0A=
+}=0A=
+=0A=
+static inline void rc32434_sync_delay(int ms)=0A=
+{=0A=
+        __asm__ volatile ("sync");=0A=
+        mdelay(ms);=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+/*=0A=
+ * Macros to access internal RC32434 registers. No byte=0A=
+ * swapping should be done when accessing the internal=0A=
+ * registers.=0A=
+ */=0A=
+=0A=
+#define rc32434_readb __raw_readb=0A=
+#define rc32434_readw __raw_readw=0A=
+#define rc32434_readl __raw_readl=0A=
+=0A=
+#define rc32434_writeb __raw_writeb=0A=
+#define rc32434_writew __raw_writew=0A=
+#define rc32434_writel __raw_writel=0A=
+=0A=
+#if 0=0A=
+static inline u8 rc32434_readb(unsigned long pa)=0A=
+{=0A=
+	return *((volatile u8 *)KSEG1ADDR(pa));=0A=
+}=0A=
+static inline u16 rc32434_readw(unsigned long pa)=0A=
+{=0A=
+	return *((volatile u16 *)KSEG1ADDR(pa));=0A=
+}=0A=
+static inline u32 rc32434_readl(unsigned long pa)=0A=
+{=0A=
+	return *((volatile u32 *)KSEG1ADDR(pa));=0A=
+}=0A=
+static inline void rc32434_writeb(u8 val, unsigned long pa)=0A=
+{=0A=
+	*((volatile u8 *)KSEG1ADDR(pa)) =3D val;=0A=
+}=0A=
+static inline void rc32434_writew(u16 val, unsigned long pa)=0A=
+{=0A=
+	*((volatile u16 *)KSEG1ADDR(pa)) =3D val;=0A=
+}=0A=
+static inline void rc32434_writel(u32 val, unsigned long pa)=0A=
+{=0A=
+	*((volatile u32 *)KSEG1ADDR(pa)) =3D val;=0A=
+}=0A=
+=0A=
+#endif=0A=
+=0A=
+=0A=
+/*=0A=
+ * C access to CLZ and CLO instructions=0A=
+ * (count leading zeroes/ones).=0A=
+ */=0A=
+static inline int rc32434_clz(unsigned long val)=0A=
+{=0A=
+	int ret;=0A=
+        __asm__ volatile (=0A=
+		".set\tnoreorder\n\t"=0A=
+		".set\tnoat\n\t"=0A=
+		".set\tmips32r2\n\t"=0A=
+		"clz\t%0,%1\n\t"=0A=
+                ".set\tmips0\n\t"=0A=
+                ".set\tat\n\t"=0A=
+                ".set\treorder"=0A=
+                : "=3Dr" (ret)=0A=
+		: "r" (val));=0A=
+=0A=
+	return ret;=0A=
+}=0A=
+static inline int rc32434_clo(unsigned long val)=0A=
+{=0A=
+	int ret;=0A=
+        __asm__ volatile (=0A=
+		".set\tnoreorder\n\t"=0A=
+		".set\tnoat\n\t"=0A=
+		".set\tmips32r2\n\t"=0A=
+		"clo\t%0,%1\n\t"=0A=
+                ".set\tmips0\n\t"=0A=
+                ".set\tat\n\t"=0A=
+                ".set\treorder"=0A=
+                : "=3Dr" (ret)=0A=
+		: "r" (val));=0A=
+=0A=
+	return ret;=0A=
+}=0A=
+#endif /* _RC32434_H_ */=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_integ.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_integ.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_integ.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_integ.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,83 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   System Integrity register definition=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_INTEG_H__=0A=
+#define __IDT_INTEG_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	INTEG0_PhysicalAddress	=3D 0x18030000,=0A=
+	INTEG_PhysicalAddress	=3D INTEG0_PhysicalAddress,	// Default=0A=
+=0A=
+	INTEG0_VirtualAddress	=3D 0xB8030000,=0A=
+	INTEG_VirtualAddress	=3D INTEG0_VirtualAddress,	// Default=0A=
+} ;=0A=
+=0A=
+// if you are looking for CEA, try rst.h=0A=
+typedef struct=0A=
+{=0A=
+	u32 filler [0xc] ;		// 0x30 bytes unused.=0A=
+	u32 errcs ;			// sticky use ERRCS_=0A=
+	u32 wtcount ;			// Watchdog timer count reg.=0A=
+	u32 wtcompare ;			// Watchdog timer timeout value.=0A=
+	u32 wtc ;			// Watchdog timer control. use WTC_=0A=
+} volatile *INTEG_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	ERRCS_wto_b		=3D 0,		// In INTEG_t -> errcs=0A=
+	ERRCS_wto_m		=3D 0x00000001,=0A=
+	ERRCS_wne_b		=3D 1,		// In INTEG_t -> errcs=0A=
+	ERRCS_wne_m		=3D 0x00000002,=0A=
+	ERRCS_ucw_b		=3D 2,		// In INTEG_t -> errcs=0A=
+	ERRCS_ucw_m		=3D 0x00000004,=0A=
+	ERRCS_ucr_b		=3D 3,		// In INTEG_t -> errcs=0A=
+	ERRCS_ucr_m		=3D 0x00000008,=0A=
+	ERRCS_upw_b		=3D 4,		// In INTEG_t -> errcs=0A=
+	ERRCS_upw_m		=3D 0x00000010,=0A=
+	ERRCS_upr_b		=3D 5,		// In INTEG_t -> errcs=0A=
+	ERRCS_upr_m		=3D 0x00000020,=0A=
+	ERRCS_udw_b		=3D 6,		// In INTEG_t -> errcs=0A=
+	ERRCS_udw_m		=3D 0x00000040,=0A=
+	ERRCS_udr_b		=3D 7,		// In INTEG_t -> errcs=0A=
+	ERRCS_udr_m		=3D 0x00000080,=0A=
+	ERRCS_sae_b		=3D 8,		// In INTEG_t -> errcs=0A=
+	ERRCS_sae_m		=3D 0x00000100,=0A=
+	ERRCS_wre_b		=3D 9,		// In INTEG_t -> errcs=0A=
+	ERRCS_wre_m		=3D 0x00000200,=0A=
+=0A=
+	WTC_en_b		=3D 0,		// In INTEG_t -> wtc=0A=
+	WTC_en_m		=3D 0x00000001,=0A=
+	WTC_to_b		=3D 1,		// In INTEG_t -> wtc=0A=
+	WTC_to_m		=3D 0x00000002,=0A=
+} ;=0A=
+=0A=
+#endif	// __IDT_INTEG_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_int.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_int.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_int.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_int.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,166 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Interrupt Controller register definition.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_INT_H__=0A=
+#define __IDT_INT_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	INT0_PhysicalAddress	=3D 0x18038000,=0A=
+	INT_PhysicalAddress	=3D INT0_PhysicalAddress,		// Default=0A=
+=0A=
+	INT0_VirtualAddress	=3D 0xB8038000,=0A=
+	INT_VirtualAddress	=3D INT0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+struct INT_s=0A=
+{=0A=
+	u32		ipend ;		//Pending interrupts. use INT?_=0A=
+	u32		itest ;		//Test bits.		use INT?_=0A=
+	u32		imask ;		//Interrupt disabled when set. use INT?_=0A=
+} ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	IPEND2	=3D 0,			// HW 2 interrupt to core. use INT2_=0A=
+	IPEND3	=3D 1,			// HW 3 interrupt to core. use INT3_=0A=
+	IPEND4	=3D 2,			// HW 4 interrupt to core. use INT4_=0A=
+	IPEND5	=3D 3,			// HW 5 interrupt to core. use INT5_=0A=
+	IPEND6	=3D 4,			// HW 6 interrupt to core. use INT6_=0A=
+=0A=
+	IPEND_count,			// must be last (used in loops)=0A=
+	IPEND_min	=3D IPEND2	// min IPEND (used in loops)=0A=
+};=0A=
+=0A=
+typedef struct INTC_s=0A=
+{=0A=
+	struct INT_s	i [IPEND_count] ;// use i[IPEND?] =3D INT?_=0A=
+	u32		nmips ;		// use NMIPS_=0A=
+} volatile *INT_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	INT2_timer0_b			=3D 0,=0A=
+	INT2_timer0_m			=3D 0x00000001,=0A=
+	INT2_timer1_b			=3D 1,=0A=
+	INT2_timer1_m			=3D 0x00000002,=0A=
+	INT2_timer2_b			=3D 2,=0A=
+	INT2_timer2_m			=3D 0x00000004,=0A=
+	INT2_refresh_b			=3D 3,=0A=
+	INT2_refresh_m			=3D 0x00000008,=0A=
+	INT2_watchdogTimeout_b		=3D 4,=0A=
+	INT2_watchdogTimeout_m		=3D 0x00000010,=0A=
+	INT2_undecodedCpuWrite_b	=3D 5,=0A=
+	INT2_undecodedCpuWrite_m	=3D 0x00000020,=0A=
+	INT2_undecodedCpuRead_b		=3D 6,=0A=
+	INT2_undecodedCpuRead_m		=3D 0x00000040,=0A=
+	INT2_undecodedPciWrite_b	=3D 7,=0A=
+	INT2_undecodedPciWrite_m	=3D 0x00000080,=0A=
+	INT2_undecodedPciRead_b		=3D 8,=0A=
+	INT2_undecodedPciRead_m		=3D 0x00000100,=0A=
+	INT2_undecodedDmaWrite_b	=3D 9,=0A=
+	INT2_undecodedDmaWrite_m	=3D 0x00000200,=0A=
+	INT2_undecodedDmaRead_b		=3D 10,=0A=
+	INT2_undecodedDmaRead_m		=3D 0x00000400,=0A=
+	INT2_ipBusSlaveAckError_b	=3D 11,=0A=
+	INT2_ipBusSlaveAckError_m	=3D 0x00000800,=0A=
+=0A=
+	INT3_dmaChannel0_b		=3D 0,=0A=
+	INT3_dmaChannel0_m		=3D 0x00000001,=0A=
+	INT3_dmaChannel1_b		=3D 1,=0A=
+	INT3_dmaChannel1_m		=3D 0x00000002,=0A=
+	INT3_dmaChannel2_b		=3D 2,=0A=
+	INT3_dmaChannel2_m		=3D 0x00000004,=0A=
+	INT3_dmaChannel3_b		=3D 3,=0A=
+	INT3_dmaChannel3_m		=3D 0x00000008,=0A=
+	INT3_dmaChannel4_b		=3D 4,=0A=
+	INT3_dmaChannel4_m		=3D 0x00000010,=0A=
+	INT3_dmaChannel5_b		=3D 5,=0A=
+	INT3_dmaChannel5_m		=3D 0x00000020,=0A=
+=0A=
+	INT5_uartGeneral0_b		=3D 0,=0A=
+	INT5_uartGeneral0_m		=3D 0x00000001,=0A=
+	INT5_uartTxrdy0_b		=3D 1,=0A=
+	INT5_uartTxrdy0_m		=3D 0x00000002,=0A=
+	INT5_uartRxrdy0_b		=3D 2,=0A=
+	INT5_uartRxrdy0_m		=3D 0x00000004,=0A=
+	INT5_pci_b			=3D 3,=0A=
+	INT5_pci_m			=3D 0x00000008,=0A=
+	INT5_pciDecoupled_b		=3D 4,=0A=
+	INT5_pciDecoupled_m		=3D 0x00000010,=0A=
+	INT5_spi_b			=3D 5,=0A=
+	INT5_spi_m			=3D 0x00000020,=0A=
+	INT5_deviceDecoupled_b		=3D 6,=0A=
+	INT5_deviceDecoupled_m		=3D 0x00000040,=0A=
+	INT5_eth0Ovr_b			=3D 9,=0A=
+	INT5_eth0Ovr_m			=3D 0x00000200,=0A=
+	INT5_eth0Und_b			=3D 10,=0A=
+	INT5_eth0Und_m			=3D 0x00000400,=0A=
+	INT5_eth0Pfd_b			=3D 11,=0A=
+	INT5_eth0Pfd_m			=3D 0x00000800,=0A=
+	INT5_nvram_b			=3D 12,=0A=
+	INT5_nvram_m			=3D 0x00001000,=0A=
+=0A=
+	INT6_gpio0_b			=3D 0,=0A=
+	INT6_gpio0_m			=3D 0x00000001,=0A=
+	INT6_gpio1_b			=3D 1,=0A=
+	INT6_gpio1_m			=3D 0x00000002,=0A=
+	INT6_gpio2_b			=3D 2,=0A=
+	INT6_gpio2_m			=3D 0x00000004,=0A=
+	INT6_gpio3_b			=3D 3,=0A=
+	INT6_gpio3_m			=3D 0x00000008,=0A=
+	INT6_gpio4_b			=3D 4,=0A=
+	INT6_gpio4_m			=3D 0x00000010,=0A=
+	INT6_gpio5_b			=3D 5,=0A=
+	INT6_gpio5_m			=3D 0x00000020,=0A=
+	INT6_gpio6_b			=3D 6,=0A=
+	INT6_gpio6_m			=3D 0x00000040,=0A=
+	INT6_gpio7_b			=3D 7,=0A=
+	INT6_gpio7_m			=3D 0x00000080,=0A=
+	INT6_gpio8_b			=3D 8,=0A=
+	INT6_gpio8_m			=3D 0x00000100,=0A=
+	INT6_gpio9_b			=3D 9,=0A=
+	INT6_gpio9_m			=3D 0x00000200,=0A=
+	INT6_gpio10_b			=3D 10,=0A=
+	INT6_gpio10_m			=3D 0x00000400,=0A=
+	INT6_gpio11_b			=3D 11,=0A=
+	INT6_gpio11_m			=3D 0x00000800,=0A=
+	INT6_gpio12_b			=3D 12,=0A=
+	INT6_gpio12_m			=3D 0x00001000,=0A=
+	INT6_gpio13_b			=3D 13,=0A=
+	INT6_gpio13_m			=3D 0x00002000,=0A=
+=0A=
+	NMIPS_gpio_b			=3D 0,=0A=
+	NMIPS_gpio_m			=3D 0x00000001,=0A=
+} ;=0A=
+=0A=
+#endif	// __IDT_INT_H__=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_iparb.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_iparb.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_iparb.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_iparb.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,104 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   IP Arbiter register definitions=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_IPARB_H__=0A=
+#define __IDT_IPARB_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	IPARB0_PhysicalAddress	=3D 0x18048000,=0A=
+	IPARB_PhysicalAddress	=3D IPARB0_PhysicalAddress,	// Default=0A=
+=0A=
+	IPARB0_VirtualAddress	=3D 0xB8048000,=0A=
+	IPARB_VirtualAddress	=3D IPARB0_VirtualAddress,	// Default=0A=
+} ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	IPABMXC_ethernet0Receive	=3D 0,=0A=
+	IPABMXC_ethernet0Transmit	=3D 1,=0A=
+	IPABMXC_memoryToHoldFifo	=3D 2,=0A=
+	IPABMXC_holdFifoToMemory	=3D 3,=0A=
+	IPABMXC_pciToMemory		=3D 4,=0A=
+	IPABMXC_memoryToPci		=3D 5,=0A=
+	IPABMXC_pciTarget		=3D 6,=0A=
+	IPABMXC_pciTargetStart		=3D 7,=0A=
+	IPABMXC_cpuToIpBus		=3D 8,=0A=
+=0A=
+	IPABMXC_Count,				// Must be last in list !=0A=
+	IPABMXC_Min			=3D IPABMXC_ethernet0Receive,=0A=
+=0A=
+	IPAPXC_PriorityCount	=3D 4,		// 3-highest, 0-lowest.=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32	ipapc [IPAPXC_PriorityCount] ;	// ipapc[IPAPXC_] =3D IPAPC_=0A=
+	u32	ipabmc [IPABMXC_Count] ;	// ipabmc[IPABMXC_] =3D IPABMC_=0A=
+	u32	ipac ;				// use IPAC_=0A=
+	u32	ipaitcc;			// use IPAITCC_=0A=
+	u32	ipaspare ;=0A=
+} volatile * IPARB_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	IPAC_dp_b			=3D 0,=0A=
+	IPAC_dp_m			=3D 0x00000001,=0A=
+	IPAC_dep_b			=3D 1,=0A=
+	IPAC_dep_m			=3D 0x00000002,=0A=
+	IPAC_drm_b			=3D 2,=0A=
+	IPAC_drm_m			=3D 0x00000004,=0A=
+	IPAC_dwm_b			=3D 3,=0A=
+	IPAC_dwm_m			=3D 0x00000008,=0A=
+	IPAC_msk_b			=3D 4,=0A=
+	IPAC_msk_m			=3D 0x00000010,=0A=
+=0A=
+	IPAPC_ptc_b			=3D 0,=0A=
+	IPAPC_ptc_m			=3D 0x00003fff,=0A=
+	IPAPC_mf_b			=3D 14,=0A=
+	IPAPC_mf_m			=3D 0x00004000,=0A=
+	IPAPC_cptc_b			=3D 16,=0A=
+	IPAPC_cptc_m			=3D 0x3fff0000,=0A=
+=0A=
+	IPAITCC_itcc			=3D 0,=0A=
+	IPAITCC_itcc,			=3D 0x000001ff,=0A=
+=0A=
+	IPABMC_mtc_b			=3D 0,=0A=
+	IPABMC_mtc_m			=3D 0x00000fff,=0A=
+	IPABMC_p_b			=3D 12,=0A=
+	IPABMC_p_m			=3D 0x00003000,=0A=
+	IPABMC_msk_b			=3D 14,=0A=
+	IPABMC_msk_m			=3D 0x00004000,=0A=
+	IPABMC_cmtc_b			=3D 16,=0A=
+	IPABMC_cmtc_m			=3D 0x0fff0000,=0A=
+};=0A=
+=0A=
+#endif	// __IDT_IPARB_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_pci.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_pci.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_pci.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_pci.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,688 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   PCI register definitio=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_PCI_H__=0A=
+#define __IDT_PCI_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	PCI0_PhysicalAddress	=3D 0x18080000,=0A=
+	PCI_PhysicalAddress	=3D PCI0_PhysicalAddress,=0A=
+=0A=
+	PCI0_VirtualAddress	=3D 0xB8080000,=0A=
+	PCI_VirtualAddress	=3D PCI0_VirtualAddress,=0A=
+} ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	PCI_LbaCount	=3D 4,		// Local base addresses.=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32	a ;		// Address.=0A=
+	u32	c ;		// Control.=0A=
+	u32	m ;		// mapping.=0A=
+} PCI_Map_s ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32		pcic ;=0A=
+	u32		pcis ;=0A=
+	u32		pcism ;=0A=
+	u32		pcicfga ;=0A=
+	u32		pcicfgd ;=0A=
+	PCI_Map_s	pcilba [PCI_LbaCount] ;=0A=
+	u32		pcidac ;=0A=
+	u32		pcidas ;=0A=
+	u32		pcidasm ;=0A=
+	u32		pcidad ;=0A=
+	u32		pcidma8c ;=0A=
+	u32		pcidma9c ;=0A=
+	u32		pcitc ;=0A=
+} volatile *PCI_t ;=0A=
+=0A=
+// PCI messaging unit.=0A=
+enum=0A=
+{=0A=
+	PCIM_Count	=3D 2,=0A=
+} ;=0A=
+typedef struct=0A=
+{=0A=
+	u32		pciim [PCIM_Count] ;=0A=
+	u32		pciom [PCIM_Count] ;=0A=
+	u32		pciid ;=0A=
+	u32		pciiic ;=0A=
+	u32		pciiim ;=0A=
+	u32		pciiod ;=0A=
+	u32		pciioic ;=0A=
+	u32		pciioim ;=0A=
+} volatile *PCIM_t ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIC_en_b	=3D 0,=0A=
+	PCIC_en_m	=3D 0x00000001,=0A=
+	PCIC_tnr_b	=3D 1,=0A=
+	PCIC_tnr_m	=3D 0x00000002,=0A=
+	PCIC_sce_b	=3D 2,=0A=
+	PCIC_sce_m	=3D 0x00000004,=0A=
+	PCIC_ien_b	=3D 3,=0A=
+	PCIC_ien_m	=3D 0x00000008,=0A=
+	PCIC_aaa_b	=3D 4,=0A=
+	PCIC_aaa_m	=3D 0x00000010,=0A=
+	PCIC_eap_b	=3D 5,=0A=
+	PCIC_eap_m	=3D 0x00000020,=0A=
+	PCIC_pcim_b	=3D 6,=0A=
+	PCIC_pcim_m	=3D 0x000001c0,=0A=
+		PCIC_pcim_disabled_v	=3D 0,=0A=
+		PCIC_pcim_tnr_v 	=3D 1,	// Satellite - target not ready=0A=
+		PCIC_pcim_suspend_v	=3D 2,	// Satellite - suspended CPU.=0A=
+		PCIC_pcim_extern_v	=3D 3,	// Host - external arbiter.=0A=
+		PCIC_pcim_fixed_v	=3D 4,	// Host - fixed priority arb.=0A=
+		PCIC_pcim_roundrobin_v	=3D 5,	// Host - round robin priority.=0A=
+		PCIC_pcim_reserved6_v	=3D 6,=0A=
+		PCIC_pcim_reserved7_v	=3D 7,=0A=
+	PCIC_igm_b	=3D 9,=0A=
+	PCIC_igm_m	=3D 0x00000200,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Status Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIS_eed_b	=3D 0,=0A=
+	PCIS_eed_m	=3D 0x00000001,=0A=
+	PCIS_wr_b	=3D 1,=0A=
+	PCIS_wr_m	=3D 0x00000002,=0A=
+	PCIS_nmi_b	=3D 2,=0A=
+	PCIS_nmi_m	=3D 0x00000004,=0A=
+	PCIS_ii_b	=3D 3,=0A=
+	PCIS_ii_m	=3D 0x00000008,=0A=
+	PCIS_cwe_b	=3D 4,=0A=
+	PCIS_cwe_m	=3D 0x00000010,=0A=
+	PCIS_cre_b	=3D 5,=0A=
+	PCIS_cre_m	=3D 0x00000020,=0A=
+	PCIS_mdpe_b	=3D 6,=0A=
+	PCIS_mdpe_m	=3D 0x00000040,=0A=
+	PCIS_sta_b	=3D 7,=0A=
+	PCIS_sta_m	=3D 0x00000080,=0A=
+	PCIS_rta_b	=3D 8,=0A=
+	PCIS_rta_m	=3D 0x00000100,=0A=
+	PCIS_rma_b	=3D 9,=0A=
+	PCIS_rma_m	=3D 0x00000200,=0A=
+	PCIS_sse_b	=3D 10,=0A=
+	PCIS_sse_m	=3D 0x00000400,=0A=
+	PCIS_ose_b	=3D 11,=0A=
+	PCIS_ose_m	=3D 0x00000800,=0A=
+	PCIS_pe_b	=3D 12,=0A=
+	PCIS_pe_m	=3D 0x00001000,=0A=
+	PCIS_tae_b	=3D 13,=0A=
+	PCIS_tae_m	=3D 0x00002000,=0A=
+	PCIS_rle_b	=3D 14,=0A=
+	PCIS_rle_m	=3D 0x00004000,=0A=
+	PCIS_bme_b	=3D 15,=0A=
+	PCIS_bme_m	=3D 0x00008000,=0A=
+	PCIS_prd_b	=3D 16,=0A=
+	PCIS_prd_m	=3D 0x00010000,=0A=
+	PCIS_rip_b	=3D 17,=0A=
+	PCIS_rip_m	=3D 0x00020000,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Status Mask Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCISM_eed_b		=3D 0,=0A=
+	PCISM_eed_m		=3D 0x00000001,=0A=
+	PCISM_wr_b		=3D 1,=0A=
+	PCISM_wr_m		=3D 0x00000002,=0A=
+	PCISM_nmi_b		=3D 2,=0A=
+	PCISM_nmi_m		=3D 0x00000004,=0A=
+	PCISM_ii_b		=3D 3,=0A=
+	PCISM_ii_m		=3D 0x00000008,=0A=
+	PCISM_cwe_b		=3D 4,=0A=
+	PCISM_cwe_m		=3D 0x00000010,=0A=
+	PCISM_cre_b		=3D 5,=0A=
+	PCISM_cre_m		=3D 0x00000020,=0A=
+	PCISM_mdpe_b		=3D 6,=0A=
+	PCISM_mdpe_m		=3D 0x00000040,=0A=
+	PCISM_sta_b		=3D 7,=0A=
+	PCISM_sta_m		=3D 0x00000080,=0A=
+	PCISM_rta_b		=3D 8,=0A=
+	PCISM_rta_m		=3D 0x00000100,=0A=
+	PCISM_rma_b		=3D 9,=0A=
+	PCISM_rma_m		=3D 0x00000200,=0A=
+	PCISM_sse_b		=3D 10,=0A=
+	PCISM_sse_m		=3D 0x00000400,=0A=
+	PCISM_ose_b		=3D 11,=0A=
+	PCISM_ose_m		=3D 0x00000800,=0A=
+	PCISM_pe_b		=3D 12,=0A=
+	PCISM_pe_m		=3D 0x00001000,=0A=
+	PCISM_tae_b		=3D 13,=0A=
+	PCISM_tae_m		=3D 0x00002000,=0A=
+	PCISM_rle_b		=3D 14,=0A=
+	PCISM_rle_m		=3D 0x00004000,=0A=
+	PCISM_bme_b		=3D 15,=0A=
+	PCISM_bme_m		=3D 0x00008000,=0A=
+	PCISM_prd_b		=3D 16,=0A=
+	PCISM_prd_m		=3D 0x00010000,=0A=
+	PCISM_rip_b		=3D 17,=0A=
+	PCISM_rip_m		=3D 0x00020000,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Configuration Address Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCICFGA_reg_b		=3D 2,=0A=
+	PCICFGA_reg_m		=3D 0x000000fc,=0A=
+		PCICFGA_reg_id_v	=3D 0x00>>2, //use PCFGID_=0A=
+		PCICFGA_reg_04_v	=3D 0x04>>2, //use PCFG04_=0A=
+		PCICFGA_reg_08_v	=3D 0x08>>2, //use PCFG08_=0A=
+		PCICFGA_reg_0C_v	=3D 0x0C>>2, //use PCFG0C_=0A=
+		PCICFGA_reg_pba0_v	=3D 0x10>>2, //use PCIPBA_=0A=
+		PCICFGA_reg_pba1_v	=3D 0x14>>2, //use PCIPBA_=0A=
+		PCICFGA_reg_pba2_v	=3D 0x18>>2, //use PCIPBA_=0A=
+		PCICFGA_reg_pba3_v	=3D 0x1c>>2, //use PCIPBA_=0A=
+		PCICFGA_reg_subsystem_v =3D 0x2c>>2, //use PCFGSS_=0A=
+		PCICFGA_reg_3C_v	=3D 0x3C>>2, //use PCFG3C_=0A=
+		PCICFGA_reg_pba0c_v	=3D 0x44>>2, //use PCIPBAC_=0A=
+		PCICFGA_reg_pba0m_v	=3D 0x48>>2,=0A=
+		PCICFGA_reg_pba1c_v	=3D 0x4c>>2, //use PCIPBAC_=0A=
+		PCICFGA_reg_pba1m_v	=3D 0x50>>2,=0A=
+		PCICFGA_reg_pba2c_v	=3D 0x54>>2, //use PCIPBAC_=0A=
+		PCICFGA_reg_pba2m_v	=3D 0x58>>2,=0A=
+		PCICFGA_reg_pba3c_v	=3D 0x5c>>2, //use PCIPBAC_=0A=
+		PCICFGA_reg_pba3m_v	=3D 0x60>>2,=0A=
+		PCICFGA_reg_pmgt_v	=3D 0x64>>2,=0A=
+	PCICFGA_func_b		=3D 8,=0A=
+	PCICFGA_func_m		=3D 0x00000700,=0A=
+	PCICFGA_dev_b		=3D 11,=0A=
+	PCICFGA_dev_m		=3D 0x0000f800,=0A=
+		PCICFGA_dev_internal_v	=3D 0,=0A=
+	PCICFGA_bus_b		=3D 16,=0A=
+	PCICFGA_bus_m		=3D 0x00ff0000,=0A=
+		PCICFGA_bus_type0_v	=3D 0,	//local bus=0A=
+	PCICFGA_en_b		=3D 31,		// read only=0A=
+	PCICFGA_en_m		=3D 0x80000000,=0A=
+} ;=0A=
+=0A=
+enum {=0A=
+	PCFGID_vendor_b 	=3D 0,=0A=
+	PCFGID_vendor_m 	=3D 0x0000ffff,=0A=
+		PCFGID_vendor_IDT_v		=3D 0x111d,=0A=
+	PCFGID_device_b 	=3D 16,=0A=
+	PCFGID_device_m 	=3D 0xffff0000,=0A=
+		PCFGID_device_Korinade_v	=3D 0x0214,=0A=
+=0A=
+	PCFG04_command_ioena_b		=3D 1,=0A=
+	PCFG04_command_ioena_m		=3D 0x00000001,=0A=
+	PCFG04_command_memena_b 	=3D 2,=0A=
+	PCFG04_command_memena_m 	=3D 0x00000002,=0A=
+	PCFG04_command_bmena_b		=3D 3,=0A=
+	PCFG04_command_bmena_m		=3D 0x00000004,=0A=
+	PCFG04_command_mwinv_b		=3D 5,=0A=
+	PCFG04_command_mwinv_m		=3D 0x00000010,=0A=
+	PCFG04_command_parena_b 	=3D 7,=0A=
+	PCFG04_command_parena_m 	=3D 0x00000040,=0A=
+	PCFG04_command_serrena_b	=3D 9,=0A=
+	PCFG04_command_serrena_m	=3D 0x00000100,=0A=
+	PCFG04_command_fastbbena_b	=3D 10,=0A=
+	PCFG04_command_fastbbena_m	=3D 0x00000200,=0A=
+	PCFG04_status_b 		=3D 16,=0A=
+	PCFG04_status_m 		=3D 0xffff0000,=0A=
+	PCFG04_status_66MHz_b		=3D 21,	// 66 MHz enable=0A=
+	PCFG04_status_66MHz_m		=3D 0x00200000,=0A=
+	PCFG04_status_fbb_b		=3D 23,=0A=
+	PCFG04_status_fbb_m		=3D 0x00800000,=0A=
+	PCFG04_status_mdpe_b		=3D 24,=0A=
+	PCFG04_status_mdpe_m		=3D 0x01000000,=0A=
+	PCFG04_status_dst_b		=3D 25,=0A=
+	PCFG04_status_dst_m		=3D 0x06000000,=0A=
+	PCFG04_status_sta_b		=3D 27,=0A=
+	PCFG04_status_sta_m		=3D 0x08000000,=0A=
+	PCFG04_status_rta_b		=3D 28,=0A=
+	PCFG04_status_rta_m		=3D 0x10000000,=0A=
+	PCFG04_status_rma_b		=3D 29,=0A=
+	PCFG04_status_rma_m		=3D 0x20000000,=0A=
+	PCFG04_status_sse_b		=3D 30,=0A=
+	PCFG04_status_sse_m		=3D 0x40000000,=0A=
+	PCFG04_status_pe_b		=3D 31,=0A=
+	PCFG04_status_pe_m		=3D 0x40000000,=0A=
+=0A=
+	PCFG08_revId_b			=3D 0,=0A=
+	PCFG08_revId_m			=3D 0x000000ff,=0A=
+	PCFG08_classCode_b		=3D 0,=0A=
+	PCFG08_classCode_m		=3D 0xffffff00,=0A=
+		PCFG08_classCode_bridge_v	=3D 06,=0A=
+		PCFG08_classCode_proc_v 	=3D 0x0b3000, // processor-MIPS=0A=
+	PCFG0C_cacheline_b		=3D 0,=0A=
+	PCFG0C_cacheline_m		=3D 0x000000ff,=0A=
+	PCFG0C_masterLatency_b		=3D 8,=0A=
+	PCFG0C_masterLatency_m		=3D 0x0000ff00,=0A=
+	PCFG0C_headerType_b		=3D 16,=0A=
+	PCFG0C_headerType_m		=3D 0x00ff0000,=0A=
+	PCFG0C_bist_b			=3D 24,=0A=
+	PCFG0C_bist_m			=3D 0xff000000,=0A=
+=0A=
+	PCIPBA_msi_b			=3D 0,=0A=
+	PCIPBA_msi_m			=3D 0x00000001,=0A=
+	PCIPBA_p_b			=3D 3,=0A=
+	PCIPBA_p_m			=3D 0x00000004,=0A=
+	PCIPBA_baddr_b			=3D 8,=0A=
+	PCIPBA_baddr_m			=3D 0xffffff00,=0A=
+=0A=
+	PCFGSS_vendorId_b		=3D 0,=0A=
+	PCFGSS_vendorId_m		=3D 0x0000ffff,=0A=
+	PCFGSS_id_b			=3D 16,=0A=
+	PCFGSS_id_m			=3D 0xffff0000,=0A=
+=0A=
+	PCFG3C_interruptLine_b		=3D 0,=0A=
+	PCFG3C_interruptLine_m		=3D 0x000000ff,=0A=
+	PCFG3C_interruptPin_b		=3D 8,=0A=
+	PCFG3C_interruptPin_m		=3D 0x0000ff00,=0A=
+	PCFG3C_minGrant_b		=3D 16,=0A=
+	PCFG3C_minGrant_m		=3D 0x00ff0000,=0A=
+	PCFG3C_maxLat_b 		=3D 24,=0A=
+	PCFG3C_maxLat_m 		=3D 0xff000000,=0A=
+=0A=
+	PCIPBAC_msi_b			=3D 0,=0A=
+	PCIPBAC_msi_m			=3D 0x00000001,=0A=
+	PCIPBAC_p_b			=3D 1,=0A=
+	PCIPBAC_p_m			=3D 0x00000002,=0A=
+	PCIPBAC_size_b			=3D 2,=0A=
+	PCIPBAC_size_m			=3D 0x0000007c,=0A=
+	PCIPBAC_sb_b			=3D 7,=0A=
+	PCIPBAC_sb_m			=3D 0x00000080,=0A=
+	PCIPBAC_pp_b			=3D 8,=0A=
+	PCIPBAC_pp_m			=3D 0x00000100,=0A=
+	PCIPBAC_mr_b			=3D 9,=0A=
+	PCIPBAC_mr_m			=3D 0x00000600,=0A=
+		PCIPBAC_mr_read_v	=3D0,	//no prefetching=0A=
+		PCIPBAC_mr_readLine_v	=3D1,=0A=
+		PCIPBAC_mr_readMult_v	=3D2,=0A=
+	PCIPBAC_mrl_b			=3D 11,=0A=
+	PCIPBAC_mrl_m			=3D 0x00000800,=0A=
+	PCIPBAC_mrm_b			=3D 12,=0A=
+	PCIPBAC_mrm_m			=3D 0x00001000,=0A=
+	PCIPBAC_trp_b			=3D 13,=0A=
+	PCIPBAC_trp_m			=3D 0x00002000,=0A=
+=0A=
+	PCFG40_trdyTimeout_b		=3D 0,=0A=
+	PCFG40_trdyTimeout_m		=3D 0x000000ff,=0A=
+	PCFG40_retryLim_b		=3D 8,=0A=
+	PCFG40_retryLim_m		=3D 0x0000ff00,=0A=
+};=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address [0|1|2|3] Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBA_baddr_b		=3D 0,		// In PCI_t -> pcilba [] .a=0A=
+	PCILBA_baddr_m		=3D 0xffffff00,=0A=
+} ;=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBAC_msi_b		=3D 0,		// In pPci->pcilba[i].c=0A=
+	PCILBAC_msi_m		=3D 0x00000001,=0A=
+		PCILBAC_msi_mem_v	=3D 0,=0A=
+		PCILBAC_msi_io_v	=3D 1,=0A=
+	PCILBAC_size_b		=3D 2,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_size_m		=3D 0x0000007c,=0A=
+	PCILBAC_sb_b		=3D 7,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_sb_m		=3D 0x00000080,=0A=
+	PCILBAC_rt_b		=3D 8,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_rt_m		=3D 0x00000100,=0A=
+		PCILBAC_rt_noprefetch_v =3D 0, // mem read=0A=
+		PCILBAC_rt_prefetch_v	=3D 1, // mem readline=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address [0|1|2|3] Mapping Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBAM_maddr_b 	=3D 8,=0A=
+	PCILBAM_maddr_m 	=3D 0xffffff00,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Decoupled Access Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDAC_den_b		=3D 0,=0A=
+	PCIDAC_den_m		=3D 0x00000001,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Decoupled Access Status Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDAS_d_b	=3D 0,=0A=
+	PCIDAS_d_m	=3D 0x00000001,=0A=
+	PCIDAS_b_b	=3D 1,=0A=
+	PCIDAS_b_m	=3D 0x00000002,=0A=
+	PCIDAS_e_b	=3D 2,=0A=
+	PCIDAS_e_m	=3D 0x00000004,=0A=
+	PCIDAS_ofe_b	=3D 3,=0A=
+	PCIDAS_ofe_m	=3D 0x00000008,=0A=
+	PCIDAS_off_b	=3D 4,=0A=
+	PCIDAS_off_m	=3D 0x00000010,=0A=
+	PCIDAS_ife_b	=3D 5,=0A=
+	PCIDAS_ife_m	=3D 0x00000020,=0A=
+	PCIDAS_iff_b	=3D 6,=0A=
+	PCIDAS_iff_m	=3D 0x00000040,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI DMA Channel 8 Configuration Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIDMA8C_mbs_b	=3D 0,		// Maximum Burst Size.=0A=
+	PCIDMA8C_mbs_m	=3D 0x00000fff,	// { pcidma8c }=0A=
+	PCIDMA8C_our_b	=3D 12,		// Optimize Unaligned Burst Reads.=0A=
+	PCIDMA8C_our_m	=3D 0x00001000,	// { pcidma8c }=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI DMA Channel 9 Configuration Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIDMA9C_mbs_b	=3D 0,		// Maximum Burst Size.=0A=
+	PCIDMA9C_mbs_m	=3D 0x00000fff, // { pcidma9c }=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI to Memory(DMA Channel 8) AND Memory to PCI DMA(DMA Channel =
9)Descriptors=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDMAD_pt_b		=3D 22,		// in DEVCMD field (descriptor)=0A=
+	PCIDMAD_pt_m		=3D 0x00c00000,	// preferred transaction field=0A=
+		// These are for reads (DMA channel 8)=0A=
+		PCIDMAD_devcmd_mr_v	=3D 0,	//memory read=0A=
+		PCIDMAD_devcmd_mrl_v	=3D 1,	//memory read line=0A=
+		PCIDMAD_devcmd_mrm_v	=3D 2,	//memory read multiple=0A=
+		PCIDMAD_devcmd_ior_v	=3D 3,	//I/O read=0A=
+		// These are for writes (DMA channel 9)=0A=
+		PCIDMAD_devcmd_mw_v	=3D 0,	//memory write=0A=
+		PCIDMAD_devcmd_mwi_v	=3D 1,	//memory write invalidate=0A=
+		PCIDMAD_devcmd_iow_v	=3D 3,	//I/O write=0A=
+=0A=
+	// Swap byte field applies to both DMA channel 8 and 9=0A=
+	PCIDMAD_sb_b		=3D 24,		// in DEVCMD field (descriptor)=0A=
+	PCIDMAD_sb_m		=3D 0x01000000,	// swap byte field=0A=
+} ;=0A=
+=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Target Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCITC_rtimer_b		=3D 0,		// In PCITC_t -> pcitc=0A=
+	PCITC_rtimer_m		=3D 0x000000ff,=0A=
+	PCITC_dtimer_b		=3D 8,		// In PCITC_t -> pcitc=0A=
+	PCITC_dtimer_m		=3D 0x0000ff00,=0A=
+	PCITC_rdr_b		=3D 18,		// In PCITC_t -> pcitc=0A=
+	PCITC_rdr_m		=3D 0x00040000,=0A=
+	PCITC_ddt_b		=3D 19,		// In PCITC_t -> pcitc=0A=
+	PCITC_ddt_m		=3D 0x00080000,=0A=
+} ;=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI messaging unit [applies to both inbound and outbound registers =
]=0A=
+ *=0A=
+ **********************************************************************=
********/=0A=
+enum=0A=
+{=0A=
+	PCIM_m0_b	=3D 0,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_m0_m	=3D 0x00000001,	// inbound or outbound message 0=0A=
+	PCIM_m1_b	=3D 1,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_m1_m	=3D 0x00000002,	// inbound or outbound message 1=0A=
+	PCIM_db_b	=3D 2,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_db_m	=3D 0x00000004,	// inbound or outbound doorbell=0A=
+};=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+#define PCI_MSG_VirtualAddress	     0xB8088010=0A=
+#define rc32434_pci ((volatile PCI_t) PCI0_VirtualAddress)=0A=
+#define rc32434_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)=0A=
+=0A=
+#define PCIM_SHFT		0x6=0A=
+#define PCIM_BIT_LEN		0x7=0A=
+#define PCIM_H_EA		0x3=0A=
+#define PCIM_H_IA_FIX		0x4=0A=
+#define PCIM_H_IA_RR		0x5=0A=
+#if 0=0A=
+#define PCI_ADDR_START		0x13000000=0A=
+#endif=0A=
+=0A=
+#define PCI_ADDR_START		0x50000000=0A=
+=0A=
+#define CPUTOPCI_MEM_WIN	0x02000000=0A=
+#define CPUTOPCI_IO_WIN		0x00100000=0A=
+#define PCILBA_SIZE_SHFT	2=0A=
+#define PCILBA_SIZE_MASK	0x1F=0A=
+#define SIZE_256MB		0x1C=0A=
+#define SIZE_128MB		0x1B=0A=
+#define SIZE_64MB               0x1A=0A=
+#define SIZE_32MB		0x19=0A=
+#define SIZE_16MB               0x18=0A=
+#define SIZE_4MB		0x16=0A=
+#define SIZE_2MB		0x15=0A=
+#define SIZE_1MB		0x14=0A=
+#define KORINA_CONFIG0_ADDR	0x80000000=0A=
+#define KORINA_CONFIG1_ADDR	0x80000004=0A=
+#define KORINA_CONFIG2_ADDR	0x80000008=0A=
+#define KORINA_CONFIG3_ADDR	0x8000000C=0A=
+#define KORINA_CONFIG4_ADDR	0x80000010=0A=
+#define KORINA_CONFIG5_ADDR	0x80000014=0A=
+#define KORINA_CONFIG6_ADDR	0x80000018=0A=
+#define KORINA_CONFIG7_ADDR	0x8000001C=0A=
+#define KORINA_CONFIG8_ADDR	0x80000020=0A=
+#define KORINA_CONFIG9_ADDR	0x80000024=0A=
+#define KORINA_CONFIG10_ADDR	0x80000028=0A=
+#define KORINA_CONFIG11_ADDR	0x8000002C=0A=
+#define KORINA_CONFIG12_ADDR	0x80000030=0A=
+#define KORINA_CONFIG13_ADDR	0x80000034=0A=
+#define KORINA_CONFIG14_ADDR	0x80000038=0A=
+#define KORINA_CONFIG15_ADDR	0x8000003C=0A=
+#define KORINA_CONFIG16_ADDR	0x80000040=0A=
+#define KORINA_CONFIG17_ADDR	0x80000044=0A=
+#define KORINA_CONFIG18_ADDR	0x80000048=0A=
+#define KORINA_CONFIG19_ADDR	0x8000004C=0A=
+#define KORINA_CONFIG20_ADDR	0x80000050=0A=
+#define KORINA_CONFIG21_ADDR	0x80000054=0A=
+#define KORINA_CONFIG22_ADDR	0x80000058=0A=
+#define KORINA_CONFIG23_ADDR	0x8000005C=0A=
+#define KORINA_CONFIG24_ADDR	0x80000060=0A=
+#define KORINA_CONFIG25_ADDR	0x80000064=0A=
+#define KORINA_CMD 		(PCFG04_command_ioena_m | \=0A=
+				 PCFG04_command_memena_m | \=0A=
+				 PCFG04_command_bmena_m | \=0A=
+				 PCFG04_command_mwinv_m | \=0A=
+				 PCFG04_command_parena_m | \=0A=
+				 PCFG04_command_serrena_m )=0A=
+=0A=
+#define KORINA_STAT		(PCFG04_status_mdpe_m | \=0A=
+				 PCFG04_status_sta_m  | \=0A=
+				 PCFG04_status_rta_m  | \=0A=
+				 PCFG04_status_rma_m  | \=0A=
+				 PCFG04_status_sse_m  | \=0A=
+				 PCFG04_status_pe_m)=0A=
+=0A=
+#define KORINA_CNFG1		((KORINA_STAT<<16)|KORINA_CMD)=0A=
+=0A=
+#define KORINA_REVID		0=0A=
+#define KORINA_CLASS_CODE	0=0A=
+#define KORINA_CNFG2		((KORINA_CLASS_CODE<<8) | \=0A=
+				  KORINA_REVID)=0A=
+=0A=
+#define KORINA_CACHE_LINE_SIZE	4=0A=
+#define KORINA_MASTER_LAT	0x3c=0A=
+#define KORINA_HEADER_TYPE	0=0A=
+#define KORINA_BIST		0=0A=
+=0A=
+#define KORINA_CNFG3 ((KORINA_BIST << 24) | \=0A=
+		      (KORINA_HEADER_TYPE<<16) | \=0A=
+		      (KORINA_MASTER_LAT<<8) | \=0A=
+		      KORINA_CACHE_LINE_SIZE )=0A=
+=0A=
+#define KORINA_BAR0	0x00000008 /* 128 MB Memory */=0A=
+#define KORINA_BAR1	0x18800001 /* 1 MB IO */=0A=
+#define KORINA_BAR2	0x18000001 /* 2 MB IO window for Korina=0A=
+					internal Registers */=0A=
+#define KORINA_BAR3	0x48000008 /* Spare 128 MB Memory */=0A=
+=0A=
+#define KORINA_CNFG4	KORINA_BAR0=0A=
+#define KORINA_CNFG5    KORINA_BAR1=0A=
+#define KORINA_CNFG6 	KORINA_BAR2=0A=
+#define KORINA_CNFG7	KORINA_BAR3=0A=
+=0A=
+#define KORINA_SUBSYS_VENDOR_ID 0x011d=0A=
+#define KORINA_SUBSYSTEM_ID	0x0214=0A=
+#define KORINA_CNFG8		0=0A=
+#define KORINA_CNFG9		0=0A=
+#define KORINA_CNFG10		0=0A=
+#define KORINA_CNFG11 	((KORINA_SUBSYS_VENDOR_ID<<16) | \=0A=
+			  KORINA_SUBSYSTEM_ID)=0A=
+#define KORINA_INT_LINE		1=0A=
+#define KORINA_INT_PIN		1=0A=
+#define KORINA_MIN_GNT		8=0A=
+#define KORINA_MAX_LAT		0x38=0A=
+#define KORINA_CNFG12		0=0A=
+#define KORINA_CNFG13 		0=0A=
+#define KORINA_CNFG14		0=0A=
+#define KORINA_CNFG15	((KORINA_MAX_LAT<<24) | \=0A=
+			 (KORINA_MIN_GNT<<16) | \=0A=
+			 (KORINA_INT_PIN<<8)  | \=0A=
+			  KORINA_INT_LINE)=0A=
+#define	KORINA_RETRY_LIMIT	0x80=0A=
+#define KORINA_TRDY_LIMIT	0x80=0A=
+#define KORINA_CNFG16 ((KORINA_RETRY_LIMIT<<8) | \=0A=
+			KORINA_TRDY_LIMIT)=0A=
+#define PCI_PBAxC_R		0x0=0A=
+#define PCI_PBAxC_RL		0x1=0A=
+#define PCI_PBAxC_RM		0x2=0A=
+#define SIZE_SHFT		2=0A=
+=0A=
+#if defined(__MIPSEB__)=0A=
+#define KORINA_PBA0C	( PCIPBAC_mrl_m | PCIPBAC_sb_m | \=0A=
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \=0A=
+			  PCIPBAC_pp_m | \=0A=
+			  (SIZE_128MB<<SIZE_SHFT) | \=0A=
+			   PCIPBAC_p_m)=0A=
+#else=0A=
+#define KORINA_PBA0C	( PCIPBAC_mrl_m | \=0A=
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \=0A=
+			  PCIPBAC_pp_m | \=0A=
+			  (SIZE_128MB<<SIZE_SHFT) | \=0A=
+			   PCIPBAC_p_m)=0A=
+#endif=0A=
+#define KORINA_CNFG17	KORINA_PBA0C=0A=
+#define KORINA_PBA0M	0x0=0A=
+#define KORINA_CNFG18	KORINA_PBA0M=0A=
+=0A=
+#if defined(__MIPSEB__)=0A=
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | PCIPBAC_sb_m | \=0A=
+			  PCIPBAC_msi_m)=0A=
+#else=0A=
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | \=0A=
+			  PCIPBAC_msi_m)=0A=
+#endif=0A=
+#define KORINA_CNFG19	KORINA_PBA1C=0A=
+#define KORINA_PBA1M	0x0=0A=
+#define KORINA_CNFG20	KORINA_PBA1M=0A=
+=0A=
+#if defined(__MIPSEB__)=0A=
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | PCIPBAC_sb_m | \=0A=
+			  PCIPBAC_msi_m)=0A=
+#else=0A=
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | \=0A=
+			  PCIPBAC_msi_m)=0A=
+#endif=0A=
+#define KORINA_CNFG21	KORINA_PBA2C=0A=
+#define KORINA_PBA2M	0x18000000=0A=
+#define KORINA_CNFG22	KORINA_PBA2M=0A=
+#define KORINA_PBA3C	0=0A=
+#define KORINA_CNFG23	KORINA_PBA3C=0A=
+#define KORINA_PBA3M	0=0A=
+#define KORINA_CNFG24	KORINA_PBA3M=0A=
+=0A=
+=0A=
+=0A=
+#define	PCITC_DTIMER_VAL	8=0A=
+#define PCITC_RTIMER_VAL	0x10=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+#endif	// __IDT_PCI_H__=0A=
+=0A=
+=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_rst.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_rst.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_rst.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_rst.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,112 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Reset register definitions.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RST_H__=0A=
+#define __IDT_RST_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	RST0_PhysicalAddress	=3D 0x18000000,=0A=
+	RST_PhysicalAddress	=3D RST0_PhysicalAddress,		// Default=0A=
+=0A=
+	RST0_VirtualAddress	=3D 0xb8000000,=0A=
+	RST_VirtualAddress	=3D RST0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+typedef struct RST_s=0A=
+{=0A=
+	u32	filler [0x0006] ;=0A=
+	u32	sysid ;=0A=
+	u32	filler2 [0x2000-8] ;		// Pad out to offset 0x8000=0A=
+	u32	reset ;=0A=
+	u32	bcv ;=0A=
+	u32	cea ;=0A=
+} volatile * RST_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	SYSID_rev_b		=3D 0,=0A=
+	SYSID_rev_m		=3D 0x000000ff,=0A=
+	SYSID_imp_b		=3D 8,=0A=
+	SYSID_imp_m		=3D 0x000fff00,=0A=
+	SYSID_vendor_b		=3D 8,=0A=
+	SYSID_vendor_m		=3D 0xfff00000,=0A=
+=0A=
+	BCV_pll_b		=3D 0,=0A=
+	BCV_pll_m		=3D 0x0000000f,=0A=
+		BCV_pll_PLLBypass_v	=3D 0x0,	// PCLK=3D1*CLK.=0A=
+		BCV_pll_Mul3_v		=3D 0x1,	// PCLK=3D3*CLK.=0A=
+		BCV_pll_Mul4_v		=3D 0x2,	// PCLK=3D4*CLK.=0A=
+		BCV_pll_SlowMul5_v	=3D 0x3,	// PCLK=3D5*CLK.=0A=
+		BCV_pll_Mul5_v		=3D 0x4,	// PCLK=3D5*CLK.=0A=
+		BCV_pll_SlowMul6_v	=3D 0x5,	// PCLK=3D6*CLK.=0A=
+		BCV_pll_Mul6_v		=3D 0x6,	// PCLK=3D6*CLK.=0A=
+		BCV_pll_Mul8_v		=3D 0x7,	// PCLK=3D8*CLK.=0A=
+		BCV_pll_Mul10_v		=3D 0x8,	// PCLK=3D10*CLK.=0A=
+	        BCV_pll_Res9_v	        =3D 0x9,=0A=
+		BCV_pll_Res10_v	        =3D 0xa,=0A=
+		BCV_pll_Res11_v	        =3D 0xb,=0A=
+		BCV_pll_Res12_v	        =3D 0xc,=0A=
+		BCV_pll_Res13_v		=3D 0xd,=0A=
+		BCV_pll_Res14_v		=3D 0xe,=0A=
+		BCV_pll_Res15_v		=3D 0xf,=0A=
+	BCV_clkDiv_b		=3D 4,=0A=
+	BCV_clkDiv_m		=3D 0x00000030,=0A=
+		BCV_clkDiv_Div1_v	=3D 0x0,=0A=
+		BCV_clkDiv_Div2_v	=3D 0x1,=0A=
+		BCV_clkDiv_Div4_v	=3D 0x2,=0A=
+		BCV_clkDiv_Res3_v	=3D 0x3,=0A=
+	BCV_bigEndian_b		=3D 6,=0A=
+	BCV_bigEndian_m		=3D 0x00000040,=0A=
+	BCV_resetFast_b		=3D 7,=0A=
+	BCV_resetFast_m		=3D 0x00000080,=0A=
+	BCV_pciMode_b		=3D 8,=0A=
+	BCV_pciMode_m		=3D 0x00000700,=0A=
+		BCV_pciMode_disabled_v	=3D 0,	// PCI is disabled.=0A=
+		BCV_pciMode_tnr_v	=3D 1,	// satellite Target Not Ready.=0A=
+		BCV_pciMode_suspended_v	=3D 2,	// satellite with suspended CPU.=0A=
+		BCV_pciMode_external_v	=3D 3,	// host, external arbiter.=0A=
+		BCV_pciMode_fixed_v	=3D 4,	// host, fixed priority arbiter.=0A=
+		BCV_pciMode_roundRobin_v=3D 5,	// host, round robin arbiter.=0A=
+		BCV_pciMode_res6_v	=3D 6,=0A=
+		BCV_pciMode_res7_v	=3D 7,=0A=
+	BCV_watchDisable_b	=3D 11,=0A=
+	BCV_watchDisable_m	=3D 0x00000800,=0A=
+	BCV_res12_b		=3D 12,=0A=
+	BCV_res12_m		=3D 0x00001000,=0A=
+	BCV_res13_b		=3D 13,=0A=
+	BCV_res13_m		=3D 0x00002000,=0A=
+	BCV_res14_b		=3D 14,=0A=
+	BCV_res14_m		=3D 0x00004000,=0A=
+	BCV_res15_b		=3D 15,=0A=
+	BCV_res15_m		=3D 0x00008000,=0A=
+} ;=0A=
+#endif	// __IDT_RST_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_spi.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_spi.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_spi.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_spi.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,113 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Serial Peripheral Interface register definitions.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_SPI_H__=0A=
+#define __IDT_SPI_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	SPI0_PhysicalAddress	=3D 0x18070000,=0A=
+	SPI_PhysicalAddress	=3D SPI0_PhysicalAddress,=0A=
+=0A=
+	SPI0_VirtualAddress	=3D 0xB8070000,=0A=
+	SPI_VirtualAddress	=3D SPI0_VirtualAddress,=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32 spcp ;	// prescalar. 0=3Doff, * spiClk =3D =
sysClk/(2*(spcp+1)*SPR)=0A=
+	u32 spc ;	// spi control reg use SPC_=0A=
+	u32 sps ;	// spi status reg use SPS_=0A=
+	u32 spd ;	// spi data reg use SPD_=0A=
+	u32 siofunc ;	// serial IO function use SIOFUNC_=0A=
+	u32 siocfg ;	// serial IO config use SIOCFG_=0A=
+	u32 siod;	// serial IO data use SIOD_=0A=
+} volatile *SPI_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	SPCP_div_b	 =3D 0,	       =0A=
+	SPCP_div_m	 =3D 0x000000ff,=0A=
+	SPC_spr_b	=3D 0,	       =0A=
+	SPC_spr_m	=3D 0x00000003,=0A=
+	     SPC_spr_div2_v  =3D 0,=0A=
+	     SPC_spr_div4_v  =3D 1,=0A=
+	     SPC_spr_div16_v =3D 2,=0A=
+	     SPC_spr_div32_v =3D 3,=0A=
+	SPC_cpha_b	=3D 2,	       =0A=
+	SPC_cpha_m	=3D 0x00000004,=0A=
+	SPC_cpol_b	=3D 3,	       =0A=
+	SPC_cpol_m	=3D 0x00000008,=0A=
+	SPC_mstr_b	=3D 4,	       =0A=
+	SPC_mstr_m	=3D 0x00000010,=0A=
+	SPC_spe_b	=3D 6,	       =0A=
+	SPC_spe_m	=3D 0x00000040,=0A=
+	SPC_spie_b	=3D 7,	       =0A=
+	SPC_spie_m	=3D 0x00000080,=0A=
+=0A=
+	SPS_modf_b	=3D 4,	       =0A=
+	SPS_modf_m	=3D 0x00000010,=0A=
+	SPS_wcol_b	=3D 6,	       =0A=
+	SPS_wcol_m	=3D 0x00000040,=0A=
+	SPS_spif_b	=3D 7,	       =0A=
+	SPS_spif_m	=3D 0x00000070,=0A=
+=0A=
+	SPD_data_b	=3D 0,	       =0A=
+	SPD_data_m	=3D 0x000000ff,=0A=
+=0A=
+	SIOFUNC_sdo_b	    =3D 0,	   =0A=
+	SIOFUNC_sdo_m	    =3D 0x00000001,=0A=
+	SIOFUNC_sdi_b	    =3D 1,	   =0A=
+	SIOFUNC_sdi_m	    =3D 0x00000002,=0A=
+	SIOFUNC_sck_b	    =3D 2,	   =0A=
+	SIOFUNC_sck_m	    =3D 0x00000004,=0A=
+	SIOFUNC_pci_b	    =3D 3,	   =0A=
+	SIOFUNC_pci_m	    =3D 0x00000008,=0A=
+	=0A=
+	SIOCFG_sdo_b	   =3D 0, 	   =0A=
+	SIOCFG_sdo_m	   =3D 0x00000001,=0A=
+	SIOCFG_sdi_b	   =3D 1, 	   =0A=
+	SIOCFG_sdi_m	   =3D 0x00000002,=0A=
+	SIOCFG_sck_b	   =3D 2, 	   =0A=
+	SIOCFG_sck_m	   =3D 0x00000004,=0A=
+	SIOCFG_pci_b	   =3D 3, 	   =0A=
+	SIOCFG_pci_m	   =3D 0x00000008,=0A=
+	=0A=
+	SIOD_sdo_b	 =3D 0,		 =0A=
+	SIOD_sdo_m	 =3D 0x00000001,=0A=
+	SIOD_sdi_b	 =3D 1,		 =0A=
+	SIOD_sdi_m	 =3D 0x00000002,=0A=
+	SIOD_sck_b	 =3D 2,		 =0A=
+	SIOD_sck_m	 =3D 0x00000004,=0A=
+	SIOD_pci_b	 =3D 3,		 =0A=
+	SIOD_pci_m	 =3D 0x00000008,=0A=
+} ;=0A=
+#endif	// __IDT_SPI_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_timer.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_timer.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_timer.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_timer.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,84 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for timer registers=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_TIM_H__=0A=
+#define __IDT_TIM_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	TIM0_PhysicalAddress	=3D 0x18028000,=0A=
+	TIM_PhysicalAddress	=3D TIM0_PhysicalAddress,		// Default=0A=
+=0A=
+	TIM0_VirtualAddress	=3D 0xb8028000,=0A=
+	TIM_VirtualAddress	=3D TIM0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	TIM_Count =3D 3,=0A=
+} ;=0A=
+=0A=
+struct TIM_CNTR_s=0A=
+{=0A=
+  u32 count ;=0A=
+  u32 compare ;=0A=
+  u32 ctc ;	//use CTC_=0A=
+} ;=0A=
+=0A=
+typedef struct TIM_s=0A=
+{=0A=
+  struct TIM_CNTR_s	tim [TIM_Count] ;=0A=
+  u32			rcount ;	//use RCOUNT_=0A=
+  u32			rcompare ;	//use RCOMPARE_=0A=
+  u32			rtc ;		//use RTC_=0A=
+} volatile * TIM_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+  CTC_en_b	=3D 0,		=0A=
+  CTC_en_m	=3D 0x00000001,=0A=
+  CTC_to_b	=3D 1,		 =0A=
+  CTC_to_m	=3D 0x00000002,=0A=
+  =0A=
+  RCOUNT_count_b		=3D 0,	     =0A=
+  RCOUNT_count_m		=3D 0x0000ffff,=0A=
+  RCOMPARE_compare_b	=3D 0,	   =0A=
+  RCOMPARE_compare_m	=3D 0x0000ffff,=0A=
+  RTC_ce_b		=3D 0,		=0A=
+  RTC_ce_m		=3D 0x00000001,=0A=
+  RTC_to_b		=3D 1,		=0A=
+  RTC_to_m		=3D 0x00000002,=0A=
+  RTC_rqe_b		=3D 2,		=0A=
+  RTC_rqe_m		=3D 0x00000004,=0A=
+  =0A=
+} ;=0A=
+#endif	// __IDT_TIM_H__=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_uart.h =
idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_uart.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32434/rc32434_uart.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32434/rc32434_uart.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,182 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   UART register definitions=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_UART_H__=0A=
+#define __IDT_UART_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	UART0_PhysicalAddress	=3D 0x18058000,=0A=
+	UART_PhysicalAddress	=3D UART0_PhysicalAddress,	// Default=0A=
+=0A=
+	UART0_VirtualAddress	=3D 0xb8058000,=0A=
+	UART_VirtualAddress	=3D UART0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * Register definitions are in bytes so we can handle endian =
problems.=0A=
+ */=0A=
+=0A=
+typedef struct UART_s=0A=
+{=0A=
+	union=0A=
+	{=0A=
+		u32 const	uartrb ;	// 0x00 - DLAB=3D0, read.=0A=
+		u32		uartth ;	// 0x00 - DLAB=3D0, write.=0A=
+		u32		uartdll ;	// 0x00 - DLAB=3D1, read/write.=0A=
+	} ;=0A=
+=0A=
+	union=0A=
+	{=0A=
+		u32		uartie ;	// 0x04 - DLAB=3D0, read/write.=0A=
+		u32		uartdlh ;	// 0x04 - DLAB=3D1, read/write.=0A=
+	} ;=0A=
+	union=0A=
+	{=0A=
+		u32 const	uartii ;	// 0x08 - DLAB=3D0, read.=0A=
+		u32		uartfc ;	// 0x08 - DLAB=3D0, write.=0A=
+	} ;=0A=
+=0A=
+	u32		uartlc ;		// 0x0c=0A=
+	u32		uartmc ;		// 0x10=0A=
+	u32		uartls ;		// 0x14=0A=
+	u32		uartms ;		// 0x18=0A=
+	u32		uarts ;			// 0x1c=0A=
+} volatile *UART_t ;=0A=
+=0A=
+// Reset registers.=0A=
+typedef u32	volatile *UARTRR_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	UARTIE_rda_b	=3D 0,=0A=
+	UARTIE_rda_m	=3D 0x00000001,=0A=
+	UARTIE_the_b	=3D 1,=0A=
+	UARTIE_the_m	=3D 0x00000002,=0A=
+	UARTIE_rls_b	=3D 2,=0A=
+	UARTIE_rls_m	=3D 0x00000004,=0A=
+	UARTIE_ems_b	=3D 3,=0A=
+	UARTIE_ems_m	=3D 0x00000008,=0A=
+=0A=
+	UARTII_pi_b	=3D 0,=0A=
+	UARTII_pi_m	=3D 0x00000001,=0A=
+	UARTII_iid_b	=3D 1,=0A=
+	UARTII_iid_m	=3D 0x0000000e,=0A=
+		UARTII_iid_ms_v		=3D 0,	// Modem stat-CTS,DSR,RI or DCD.=0A=
+		UARTII_iid_thre_v	=3D 1,	// Trans. Holding Reg. empty.=0A=
+		UARTII_iid_rda_v	=3D 2,	// Receive data available=0A=
+		UARTII_iid_rls_v	=3D 3,	// Overrun, parity, etc, error.=0A=
+		UARTII_iid_res4_v	=3D 4,	// reserved.=0A=
+		UARTII_iid_res5_v	=3D 5,	// reserved.=0A=
+		UARTII_iid_cto_v	=3D 6,	// Character timeout.=0A=
+		UARTII_iid_res7_v	=3D 7,	// reserved.=0A=
+=0A=
+	UARTFC_en_b	=3D 0,=0A=
+	UARTFC_en_m	=3D 0x00000001,=0A=
+	UARTFC_rr_b	=3D 1,=0A=
+	UARTFC_rr_m	=3D 0x00000002,=0A=
+	UARTFC_tr_b	=3D 2,=0A=
+	UARTFC_tr_m	=3D 0x00000004,=0A=
+	UARTFC_dms_b	=3D 3,=0A=
+	UARTFC_dms_m	=3D 0x00000008,=0A=
+	UARTFC_rt_b	=3D 6,=0A=
+	UARTFC_rt_m	=3D 0x000000c0,=0A=
+		UARTFC_rt_1Byte_v	=3D 0,=0A=
+		UARTFC_rt_4Byte_v	=3D 1,=0A=
+		UARTFC_rt_8Byte_v	=3D 2,=0A=
+		UARTFC_rt_14Byte_v	=3D 3,=0A=
+=0A=
+	UARTLC_wls_b	=3D 0,=0A=
+	UARTLC_wls_m	=3D 0x00000003,=0A=
+		UARTLC_wls_5Bits_v	=3D 0,=0A=
+		UARTLC_wls_6Bits_v	=3D 1,=0A=
+		UARTLC_wls_7Bits_v	=3D 2,=0A=
+		UARTLC_wls_8Bits_v	=3D 3,=0A=
+	UARTLC_stb_b	=3D 2,=0A=
+	UARTLC_stb_m	=3D 0x00000004,=0A=
+	UARTLC_pen_b	=3D 3,=0A=
+	UARTLC_pen_m	=3D 0x00000008,=0A=
+	UARTLC_eps_b	=3D 4,=0A=
+	UARTLC_eps_m	=3D 0x00000010,=0A=
+	UARTLC_sp_b	=3D 5,=0A=
+	UARTLC_sp_m	=3D 0x00000020,=0A=
+	UARTLC_sb_b	=3D 6,=0A=
+	UARTLC_sb_m	=3D 0x00000040,=0A=
+	UARTLC_dlab_b	=3D 7,=0A=
+	UARTLC_dlab_m	=3D 0x00000080,=0A=
+=0A=
+	UARTMC_dtr_b	=3D 0,=0A=
+	UARTMC_dtr_m	=3D 0x00000001,=0A=
+	UARTMC_rts_b	=3D 1,=0A=
+	UARTMC_rts_m	=3D 0x00000002,=0A=
+	UARTMC_o1_b	=3D 2,=0A=
+	UARTMC_o1_m	=3D 0x00000004,=0A=
+	UARTMC_o2_b	=3D 3,=0A=
+	UARTMC_o2_m	=3D 0x00000008,=0A=
+	UARTMC_lp_b	=3D 4,=0A=
+	UARTMC_lp_m	=3D 0x00000010,=0A=
+=0A=
+	UARTLS_dr_b	=3D 0,=0A=
+	UARTLS_dr_m	=3D 0x00000001,=0A=
+	UARTLS_oe_b	=3D 1,=0A=
+	UARTLS_oe_m	=3D 0x00000002,=0A=
+	UARTLS_pe_b	=3D 2,=0A=
+	UARTLS_pe_m	=3D 0x00000004,=0A=
+	UARTLS_fe_b	=3D 3,=0A=
+	UARTLS_fe_m	=3D 0x00000008,=0A=
+	UARTLS_bi_b	=3D 4,=0A=
+	UARTLS_bi_m	=3D 0x00000010,=0A=
+	UARTLS_thr_b	=3D 5,=0A=
+	UARTLS_thr_m	=3D 0x00000020,=0A=
+	UARTLS_te_b	=3D 6,=0A=
+	UARTLS_te_m	=3D 0x00000040,=0A=
+	UARTLS_rfe_b	=3D 7,=0A=
+	UARTLS_rfe_m	=3D 0x00000080,=0A=
+=0A=
+	UARTMS_dcts_b	=3D 0,=0A=
+	UARTMS_dcts_m	=3D 0x00000001,=0A=
+	UARTMS_ddsr_b	=3D 1,=0A=
+	UARTMS_ddsr_m	=3D 0x00000002,=0A=
+	UARTMS_teri_b	=3D 2,=0A=
+	UARTMS_teri_m	=3D 0x00000004,=0A=
+	UARTMS_ddcd_b	=3D 3,=0A=
+	UARTMS_ddcd_m	=3D 0x00000008,=0A=
+	UARTMS_cts_b	=3D 4,=0A=
+	UARTMS_cts_m	=3D 0x00000010,=0A=
+	UARTMS_dsr_b	=3D 5,=0A=
+	UARTMS_dsr_m	=3D 0x00000020,=0A=
+	UARTMS_ri_b	=3D 6,=0A=
+	UARTMS_ri_m	=3D 0x00000040,=0A=
+	UARTMS_dcd_b	=3D 7,=0A=
+	UARTMS_dcd_m	=3D 0x00000080,=0A=
+} ;=0A=
+=0A=
+#endif	// __IDT_UART_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_dma.h =
idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_dma.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_dma.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_dma.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,224 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Register definitions for  IDT RC32438 DMA.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+#ifndef __IDT_RC32438_DMA_H__=0A=
+#define __IDT_RC32438_DMA_H__=0A=
+enum=0A=
+{=0A=
+	DMA0_PhysicalAddress	=3D 0x18040000,=0A=
+	DMA_PhysicalAddress	=3D DMA0_PhysicalAddress,		// Default=0A=
+=0A=
+	DMA0_VirtualAddress	=3D 0xb8040000,=0A=
+	DMA_VirtualAddress	=3D DMA0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA descriptor (in physical memory).=0A=
+ */=0A=
+=0A=
+typedef struct DMAD_s=0A=
+{=0A=
+	u32			control ;	// Control. use DMAD_*=0A=
+	u32			ca ;		// Current Address.=0A=
+	u32			devcs ; 	// Device control and status.=0A=
+	u32			link ;		// Next descriptor in chain.=0A=
+} volatile *DMAD_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMAD_size		=3D sizeof (struct DMAD_s),=0A=
+	DMAD_count_b		=3D 0,		// in DMAD_t -> control=0A=
+	DMAD_count_m		=3D 0x0003ffff,	// in DMAD_t -> control=0A=
+	DMAD_ds_b		=3D 20,		// in DMAD_t -> control=0A=
+	DMAD_ds_m		=3D 0x00300000,	// in DMAD_t -> control=0A=
+		DMAD_ds_extToMem0_v	=3D 0,=0A=
+		DMAD_ds_memToExt0_v	=3D 1,=0A=
+		DMAD_ds_extToMem1_v	=3D 0,=0A=
+		DMAD_ds_memToExt1_v	=3D 1,=0A=
+		DMAD_ds_ethRcv0_v	=3D 0,=0A=
+		DMAD_ds_ethXmt0_v	=3D 0,=0A=
+		DMAD_ds_ethRcv1_v	=3D 0,=0A=
+		DMAD_ds_ethXmt2_v	=3D 0,=0A=
+		DMAD_ds_memToFifo_v	=3D 0,=0A=
+		DMAD_ds_fifoToMem_v	=3D 0,=0A=
+		DMAD_ds_rng_de_v	   =3D 1,//randomNumberGenerator on LC/DE=0A=
+		DMAD_ds_pciToMem_v	=3D 0,=0A=
+		DMAD_ds_memToPci_v	=3D 0,=0A=
+		DMAD_ds_securityInput_v =3D 0,=0A=
+		DMAD_ds_securityOutput_v =3D 0,=0A=
+		DMAD_ds_rng_se_v	=3D 0,//randomNumberGenerator on SE=0A=
+	=0A=
+	DMAD_devcmd_b		=3D 22,		// in DMAD_t -> control=0A=
+	DMAD_devcmd_m		=3D 0x01c00000,	// in DMAD_t -> control=0A=
+		DMAD_devcmd_byte_v	=3D 0,	//memory-to-memory=0A=
+		DMAD_devcmd_halfword_v	=3D 1,	//memory-to-memory=0A=
+		DMAD_devcmd_word_v	=3D 2,	//memory-to-memory=0A=
+		DMAD_devcmd_2words_v	=3D 3,	//memory-to-memory=0A=
+		DMAD_devcmd_4words_v	=3D 4,	//memory-to-memory=0A=
+		DMAD_devcmd_6words_v	=3D 5,	//memory-to-memory=0A=
+		DMAD_devcmd_8words_v	=3D 6,	//memory-to-memory=0A=
+		DMAD_devcmd_16words_v	=3D 7,	//memory-to-memory=0A=
+	DMAD_cof_b		=3D 25,		// chain on finished=0A=
+	DMAD_cof_m		=3D 0x02000000,	// =0A=
+	DMAD_cod_b		=3D 26,		// chain on done=0A=
+	DMAD_cod_m		=3D 0x04000000,	// =0A=
+	DMAD_iof_b		=3D 27,		// interrupt on finished=0A=
+	DMAD_iof_m		=3D 0x08000000,	// =0A=
+	DMAD_iod_b		=3D 28,		// interrupt on done=0A=
+	DMAD_iod_m		=3D 0x10000000,	// =0A=
+	DMAD_t_b		=3D 29,		// terminated=0A=
+	DMAD_t_m		=3D 0x20000000,	// =0A=
+	DMAD_d_b		=3D 30,		// done=0A=
+	DMAD_d_m		=3D 0x40000000,	// =0A=
+	DMAD_f_b		=3D 31,		// finished=0A=
+	DMAD_f_m		=3D 0x80000000,	// =0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA register (within Internal Register Map).=0A=
+ */=0A=
+=0A=
+struct DMA_Chan_s=0A=
+{=0A=
+	u32		dmac ;		// Control.=0A=
+	u32		dmas ;		// Status.	=0A=
+	u32		dmasm ; 	// Mask.=0A=
+	u32		dmadptr ;	// Descriptor pointer.=0A=
+	u32		dmandptr ;	// Next descriptor pointer.=0A=
+};=0A=
+=0A=
+typedef struct DMA_Chan_s volatile *DMA_Chan_t ;=0A=
+=0A=
+//DMA_Channels	  use DMACH_count instead=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMAC_run_b	=3D 0,		// =0A=
+	DMAC_run_m	=3D 0x00000001,	// =0A=
+	DMAC_dm_b	=3D 1,		// done mask=0A=
+	DMAC_dm_m	=3D 0x00000002,	// =0A=
+	DMAC_mode_b	=3D 2,		// =0A=
+	DMAC_mode_m	=3D 0x0000000c,	// =0A=
+		DMAC_mode_auto_v	=3D 0,=0A=
+		DMAC_mode_burst_v	=3D 1,=0A=
+		DMAC_mode_transfer_v	=3D 2, //usually used=0A=
+		DMAC_mode_reserved_v	=3D 3,=0A=
+	DMAC_a_b	=3D 4,		// =0A=
+	DMAC_a_m	=3D 0x00000010,	// =0A=
+=0A=
+	DMAS_f_b	=3D 0,		// finished (sticky) =0A=
+	DMAS_f_m	=3D 0x00000001,	//		     =0A=
+	DMAS_d_b	=3D 1,		// done (sticky)     =0A=
+	DMAS_d_m	=3D 0x00000002,	//		     =0A=
+	DMAS_c_b	=3D 2,		// chain (sticky)    =0A=
+	DMAS_c_m	=3D 0x00000004,	//		     =0A=
+	DMAS_e_b	=3D 3,		// error (sticky)    =0A=
+	DMAS_e_m	=3D 0x00000008,	//		     =0A=
+	DMAS_h_b	=3D 4,		// halt (sticky)     =0A=
+	DMAS_h_m	=3D 0x00000010,	//		     =0A=
+=0A=
+	DMASM_f_b	=3D 0,		// finished (1=3Dmask)=0A=
+	DMASM_f_m	=3D 0x00000001,	// =0A=
+	DMASM_d_b	=3D 1,		// done (1=3Dmask)=0A=
+	DMASM_d_m	=3D 0x00000002,	// =0A=
+	DMASM_c_b	=3D 2,		// chain (1=3Dmask)=0A=
+	DMASM_c_m	=3D 0x00000004,	// =0A=
+	DMASM_e_b	=3D 3,		// error (1=3Dmask)=0A=
+	DMASM_e_m	=3D 0x00000008,	// =0A=
+	DMASM_h_b	=3D 4,		// halt (1=3Dmask)=0A=
+	DMASM_h_m	=3D 0x00000010,	// =0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * DMA channel definitions=0A=
+ */=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMACH_extToMem0 =3D 0,=0A=
+	DMACH_memToExt0 =3D 0,=0A=
+	DMACH_extToMem1 =3D 1,=0A=
+	DMACH_memToExt1 =3D 1,=0A=
+	DMACH_ethRcv0 =3D 2,=0A=
+	DMACH_ethXmt0 =3D 3,=0A=
+	DMACH_ethRcv1 =3D 4,=0A=
+	DMACH_ethXmt2 =3D 5,=0A=
+	DMACH_memToFifo =3D 6,=0A=
+	DMACH_fifoToMem =3D 7,=0A=
+	DMACH_rng_de =3D 7,//randomNumberGenerator on LC/DE=0A=
+	DMACH_pciToMem =3D 8,=0A=
+	DMACH_memToPci =3D 9,=0A=
+	DMACH_securityInput =3D 10,=0A=
+	DMACH_securityOutput =3D 11,=0A=
+	DMACH_rng_se =3D 12, //randomNumberGenerator on SE=0A=
+	=0A=
+	DMACH_count //must be last=0A=
+};=0A=
+=0A=
+=0A=
+typedef struct DMAC_s=0A=
+{=0A=
+	struct DMA_Chan_s ch [DMACH_count] ; //use ch[DMACH_]=0A=
+} volatile *DMA_t ;=0A=
+=0A=
+=0A=
+/*=0A=
+ * External DMA parameters=0A=
+*/=0A=
+=0A=
+enum=0A=
+{=0A=
+	DMADEVCMD_ts_b	=3D 0,		// ts field in devcmd=0A=
+	DMADEVCMD_ts_m	=3D 0x00000007,	// ts field in devcmd=0A=
+		DMADEVCMD_ts_byte_v	=3D 0,=0A=
+		DMADEVCMD_ts_halfword_v	=3D 1,=0A=
+		DMADEVCMD_ts_word_v	=3D 2,=0A=
+		DMADEVCMD_ts_2word_v	=3D 3,=0A=
+		DMADEVCMD_ts_4word_v	=3D 4,=0A=
+		DMADEVCMD_ts_6word_v	=3D 5,=0A=
+		DMADEVCMD_ts_8word_v	=3D 6,=0A=
+		DMADEVCMD_ts_16word_v	=3D 7=0A=
+};=0A=
+=0A=
+=0A=
+#if 1	// aws - Compatibility.=0A=
+#	define	EXTDMA_ts_b		DMADEVCMD_ts_b=0A=
+#	define	EXTDMA_ts_m		DMADEVCMD_ts_m=0A=
+#	define	EXTDMA_ts_byte_v	DMADEVCMD_ts_byte_v=0A=
+#	define	EXTDMA_ts_halfword_v	DMADEVCMD_ts_halfword_v=0A=
+#	define	EXTDMA_ts_word_v	DMADEVCMD_ts_word_v=0A=
+#	define	EXTDMA_ts_2word_v	DMADEVCMD_ts_2word_v=0A=
+#	define	EXTDMA_ts_4word_v	DMADEVCMD_ts_4word_v=0A=
+#	define	EXTDMA_ts_6word_v	DMADEVCMD_ts_6word_v=0A=
+#	define	EXTDMA_ts_8word_v	DMADEVCMD_ts_8word_v=0A=
+#	define	EXTDMA_ts_16word_v	DMADEVCMD_ts_16word_v=0A=
+#endif	// aws - Compatibility.=0A=
+=0A=
+#endif //__IDT_RC32438_DMA_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_dma_v.h =
idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_dma_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_dma_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_dma_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,76 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   DMA operations for IDT RC32438.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32438_DMA_V_H__=0A=
+#define __IDT_RC32438_DMA_V_H__=0A=
+#include  <asm/idt-boards/rc32438/rc32438_dma.h> =0A=
+=0A=
+#define DMA_CHAN_OFFSET  0x14=0A=
+#define IS_DMA_USED(X) (((X) & (DMAD_f_m | DMAD_d_m | DMAD_t_m)) !=3D =
0)=0A=
+#define DMA_COUNT(count)   \=0A=
+  ((count) & DMAD_count_m)=0A=
+=0A=
+#define DMA_HALT_TIMEOUT 500=0A=
+=0A=
+=0A=
+static inline int rc32438_halt_dma(DMA_Chan_t ch)=0A=
+{=0A=
+	int timeout=3D1;=0A=
+	if (rc32438_readl(&ch->dmac) & DMAC_run_m) {=0A=
+		rc32438_writel(0, &ch->dmac); =0A=
+		=0A=
+		for (timeout =3D DMA_HALT_TIMEOUT; timeout > 0; timeout--) {=0A=
+			if (rc32438_readl(&ch->dmas) & DMAS_h_m) {=0A=
+				rc32438_writel(0, &ch->dmas);  =0A=
+				break;=0A=
+			}=0A=
+		}=0A=
+=0A=
+	}=0A=
+	=0A=
+	return timeout ? 0 : 1;=0A=
+}=0A=
+=0A=
+=0A=
+=0A=
+=0A=
+static inline void rc32438_start_dma(DMA_Chan_t ch, u32 dma_addr)=0A=
+{=0A=
+	rc32438_writel(0, &ch->dmandptr); =0A=
+	rc32438_writel(dma_addr, &ch->dmadptr);=0A=
+}=0A=
+=0A=
+static inline void rc32438_chain_dma(DMA_Chan_t ch, u32 dma_addr)=0A=
+{=0A=
+	rc32438_writel(dma_addr, &ch->dmandptr);=0A=
+}=0A=
+#endif //__IDT_RC32438_DMA_V_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_eth.h =
idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_eth.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_eth.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_eth.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,321 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for IDT EB438 ethernet=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32438_ETH_H__=0A=
+#define __IDT_RC32438_ETH_H__=0A=
+enum=0A=
+{=0A=
+	ETH0_PhysicalAddress	=3D 0x18058000,=0A=
+	ETH_PhysicalAddress	=3D ETH0_PhysicalAddress,		// Default=0A=
+=0A=
+	ETH0_VirtualAddress	=3D 0xb8058000,=0A=
+	ETH_VirtualAddress	=3D ETH0_VirtualAddress,		// Default=0A=
+	ETH1_PhysicalAddress	=3D 0x18060000,=0A=
+	ETH1_VirtualAddress	=3D 0xb8060000,			// Default=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32 ethintfc		;=0A=
+	u32 ethfifott		;=0A=
+	u32 etharc		;=0A=
+	u32 ethhash0		;=0A=
+	u32 ethhash1		;=0A=
+	u32 ethu0 [4]		;	// Reserved.	=0A=
+	u32 ethpfs		;=0A=
+	u32 ethmcp		;=0A=
+	u32 eth_u1 [10]		;	// Reserved.=0A=
+	u32 ethspare		;=0A=
+	u32 eth_u2 [42]		;	// Reserved. =0A=
+	u32 ethsal0		;=0A=
+	u32 ethsah0		;=0A=
+	u32 ethsal1		;=0A=
+	u32 ethsah1		;=0A=
+	u32 ethsal2		;=0A=
+	u32 ethsah2		;=0A=
+	u32 ethsal3		;=0A=
+	u32 ethsah3		;=0A=
+	u32 ethrbc		;=0A=
+	u32 ethrpc		;=0A=
+	u32 ethrupc		;=0A=
+	u32 ethrfc		;=0A=
+	u32 ethtbc		;=0A=
+	u32 ethgpf		;=0A=
+	u32 eth_u9 [50]		;	// Reserved.	=0A=
+	u32 ethmac1		;=0A=
+	u32 ethmac2		;=0A=
+	u32 ethipgt		;=0A=
+	u32 ethipgr		;=0A=
+	u32 ethclrt		;=0A=
+	u32 ethmaxf		;=0A=
+	u32 eth_u10		;	// Reserved.	=0A=
+	u32 ethmtest		;=0A=
+	u32 miimcfg		;=0A=
+	u32 miimcmd		;=0A=
+	u32 miimaddr		;=0A=
+	u32 miimwtd		;=0A=
+	u32 miimrdd		;=0A=
+	u32 miimind		;=0A=
+	u32 eth_u11		;	// Reserved.=0A=
+	u32 eth_u12		;	// Reserved.=0A=
+	u32 ethcfsa0		;=0A=
+	u32 ethcfsa1		;=0A=
+	u32 ethcfsa2		;=0A=
+} volatile *ETH_t;=0A=
+=0A=
+enum=0A=
+{=0A=
+	ETHINTFC_en_b		=3D 0,=0A=
+	ETHINTFC_en_m		=3D 0x00000001,=0A=
+	ETHINTFC_its_b		=3D 1,=0A=
+	ETHINTFC_its_m		=3D 0x00000002,=0A=
+	ETHINTFC_rip_b		=3D 2,=0A=
+	ETHINTFC_rip_m		=3D 0x00000004,=0A=
+	ETHINTFC_jam_b		=3D 3,=0A=
+	ETHINTFC_jam_m		=3D 0x00000008,=0A=
+	ETHINTFC_ovr_b		=3D 4,=0A=
+	ETHINTFC_ovr_m		=3D 0x00000010,=0A=
+	ETHINTFC_und_b		=3D 5,=0A=
+	ETHINTFC_und_m		=3D 0x00000020,=0A=
+=0A=
+	ETHFIFOTT_tth_b		=3D 0,=0A=
+	ETHFIFOTT_tth_m		=3D 0x0000007f,=0A=
+=0A=
+	ETHARC_pro_b		=3D 0,=0A=
+	ETHARC_pro_m		=3D 0x00000001,=0A=
+	ETHARC_am_b		=3D 1,=0A=
+	ETHARC_am_m		=3D 0x00000002,=0A=
+	ETHARC_afm_b		=3D 2,=0A=
+	ETHARC_afm_m		=3D 0x00000004,=0A=
+	ETHARC_ab_b		=3D 3,=0A=
+	ETHARC_ab_m		=3D 0x00000008,=0A=
+=0A=
+	ETHSAL_byte5_b		=3D 0,=0A=
+	ETHSAL_byte5_m		=3D 0x000000ff,=0A=
+	ETHSAL_byte4_b		=3D 8,=0A=
+	ETHSAL_byte4_m		=3D 0x0000ff00,=0A=
+	ETHSAL_byte3_b		=3D 16,=0A=
+	ETHSAL_byte3_m		=3D 0x00ff0000,=0A=
+	ETHSAL_byte2_b		=3D 24,=0A=
+	ETHSAL_byte2_m		=3D 0xff000000,=0A=
+=0A=
+	ETHSAH_byte1_b		=3D 0,=0A=
+	ETHSAH_byte1_m		=3D 0x000000ff,=0A=
+	ETHSAH_byte0_b		=3D 8,=0A=
+	ETHSAH_byte0_m		=3D 0x0000ff00,=0A=
+	=0A=
+	ETHGPF_ptv_b		=3D 0,=0A=
+	ETHGPF_ptv_m		=3D 0x0000ffff,=0A=
+=0A=
+	ETHPFS_pfd_b		=3D 0,=0A=
+	ETHPFS_pfd_m		=3D 0x00000001,=0A=
+=0A=
+	ETHCFSA0_cfsa4_b	=3D 0,=0A=
+	ETHCFSA0_cfsa4_m	=3D 0x000000ff,=0A=
+	ETHCFSA0_cfsa5_b	=3D 8,=0A=
+	ETHCFSA0_cfsa5_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHCFSA1_cfsa2_b	=3D 0,=0A=
+	ETHCFSA1_cfsa2_m	=3D 0x000000ff,=0A=
+	ETHCFSA1_cfsa3_b	=3D 8,=0A=
+	ETHCFSA1_cfsa3_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHCFSA2_cfsa0_b	=3D 0,=0A=
+	ETHCFSA2_cfsa0_m	=3D 0x000000ff,=0A=
+	ETHCFSA2_cfsa1_b	=3D 8,=0A=
+	ETHCFSA2_cfsa1_m	=3D 0x0000ff00,=0A=
+=0A=
+	ETHMAC1_re_b		=3D 0,=0A=
+	ETHMAC1_re_m		=3D 0x00000001,=0A=
+	ETHMAC1_paf_b		=3D 1,=0A=
+	ETHMAC1_paf_m		=3D 0x00000002,=0A=
+	ETHMAC1_rfc_b		=3D 2,=0A=
+	ETHMAC1_rfc_m		=3D 0x00000004,=0A=
+	ETHMAC1_tfc_b		=3D 3,=0A=
+	ETHMAC1_tfc_m		=3D 0x00000008,=0A=
+	ETHMAC1_lb_b		=3D 4,=0A=
+	ETHMAC1_lb_m		=3D 0x00000010,=0A=
+	ETHMAC1_mr_b		=3D 31,=0A=
+	ETHMAC1_mr_m		=3D 0x80000000,=0A=
+=0A=
+	ETHMAC2_fd_b		=3D 0,=0A=
+	ETHMAC2_fd_m		=3D 0x00000001,=0A=
+	ETHMAC2_flc_b		=3D 1,=0A=
+	ETHMAC2_flc_m		=3D 0x00000002,=0A=
+	ETHMAC2_hfe_b		=3D 2,=0A=
+	ETHMAC2_hfe_m		=3D 0x00000004,=0A=
+	ETHMAC2_dc_b		=3D 3,=0A=
+	ETHMAC2_dc_m		=3D 0x00000008,=0A=
+	ETHMAC2_cen_b		=3D 4,=0A=
+	ETHMAC2_cen_m		=3D 0x00000010,=0A=
+	ETHMAC2_pe_b		=3D 5,=0A=
+	ETHMAC2_pe_m		=3D 0x00000020,=0A=
+	ETHMAC2_vpe_b		=3D 6,=0A=
+	ETHMAC2_vpe_m		=3D 0x00000040,=0A=
+	ETHMAC2_ape_b		=3D 7,=0A=
+	ETHMAC2_ape_m		=3D 0x00000080,=0A=
+	ETHMAC2_ppe_b		=3D 8,=0A=
+	ETHMAC2_ppe_m		=3D 0x00000100,=0A=
+	ETHMAC2_lpe_b		=3D 9,=0A=
+	ETHMAC2_lpe_m		=3D 0x00000200,=0A=
+	ETHMAC2_nb_b		=3D 12,=0A=
+	ETHMAC2_nb_m		=3D 0x00001000,=0A=
+	ETHMAC2_bp_b		=3D 13,=0A=
+	ETHMAC2_bp_m		=3D 0x00002000,=0A=
+	ETHMAC2_ed_b		=3D 14,=0A=
+	ETHMAC2_ed_m		=3D 0x00004000,=0A=
+=0A=
+	ETHIPGT_ipgt_b		=3D 0,=0A=
+	ETHIPGT_ipgt_m		=3D 0x0000007f,=0A=
+=0A=
+	ETHIPGR_ipgr2_b		=3D 0,=0A=
+	ETHIPGR_ipgr2_m		=3D 0x0000007f,=0A=
+	ETHIPGR_ipgr1_b		=3D 8,=0A=
+	ETHIPGR_ipgr1_m		=3D 0x00007f00,=0A=
+=0A=
+	ETHCLRT_maxret_b	=3D 0,=0A=
+	ETHCLRT_maxret_m	=3D 0x0000000f,=0A=
+	ETHCLRT_colwin_b	=3D 8,=0A=
+	ETHCLRT_colwin_m	=3D 0x00003f00,=0A=
+=0A=
+	ETHMAXF_maxf_b		=3D 0,=0A=
+	ETHMAXF_maxf_m		=3D 0x0000ffff,=0A=
+=0A=
+	ETHMTEST_tb_b		=3D 2,=0A=
+	ETHMTEST_tb_m		=3D 0x00000004,=0A=
+=0A=
+	ETHMCP_div_b		=3D 0,=0A=
+	ETHMCP_div_m		=3D 0x000000ff,=0A=
+	=0A=
+	MIIMCFG_rsv_b		=3D 0,=0A=
+	MIIMCFG_rsv_m		=3D 0x0000000c,=0A=
+=0A=
+	MIIMCMD_rd_b		=3D 0,=0A=
+	MIIMCMD_rd_m		=3D 0x00000001,=0A=
+	MIIMCMD_scn_b		=3D 1,=0A=
+	MIIMCMD_scn_m		=3D 0x00000002,=0A=
+=0A=
+	MIIMADDR_regaddr_b	=3D 0,=0A=
+	MIIMADDR_regaddr_m	=3D 0x0000001f,=0A=
+	MIIMADDR_phyaddr_b	=3D 8,=0A=
+	MIIMADDR_phyaddr_m	=3D 0x00001f00,=0A=
+=0A=
+	MIIMWTD_wdata_b		=3D 0,=0A=
+	MIIMWTD_wdata_m		=3D 0x0000ffff,=0A=
+=0A=
+	MIIMRDD_rdata_b		=3D 0,=0A=
+	MIIMRDD_rdata_m		=3D 0x0000ffff,=0A=
+=0A=
+	MIIMIND_bsy_b		=3D 0,=0A=
+	MIIMIND_bsy_m		=3D 0x00000001,=0A=
+	MIIMIND_scn_b		=3D 1,=0A=
+	MIIMIND_scn_m		=3D 0x00000002,=0A=
+	MIIMIND_nv_b		=3D 2,=0A=
+	MIIMIND_nv_m		=3D 0x00000004,=0A=
+=0A=
+} ;=0A=
+=0A=
+/*=0A=
+ * Values for the DEVCS field of the Ethernet DMA Rx and Tx =
descriptors.=0A=
+ */=0A=
+enum=0A=
+{=0A=
+	ETHRX_fd_b		=3D 0,=0A=
+	ETHRX_fd_m		=3D 0x00000001,=0A=
+	ETHRX_ld_b		=3D 1,=0A=
+	ETHRX_ld_m		=3D 0x00000002,=0A=
+	ETHRX_rok_b		=3D 2,=0A=
+	ETHRX_rok_m		=3D 0x00000004,=0A=
+	ETHRX_fm_b		=3D 3,=0A=
+	ETHRX_fm_m		=3D 0x00000008,=0A=
+	ETHRX_mp_b		=3D 4,=0A=
+	ETHRX_mp_m		=3D 0x00000010,=0A=
+	ETHRX_bp_b		=3D 5,=0A=
+	ETHRX_bp_m		=3D 0x00000020,=0A=
+	ETHRX_vlt_b		=3D 6,=0A=
+	ETHRX_vlt_m		=3D 0x00000040,=0A=
+	ETHRX_cf_b		=3D 7,=0A=
+	ETHRX_cf_m		=3D 0x00000080,=0A=
+	ETHRX_ovr_b		=3D 8,=0A=
+	ETHRX_ovr_m		=3D 0x00000100,=0A=
+	ETHRX_crc_b		=3D 9,=0A=
+	ETHRX_crc_m		=3D 0x00000200,=0A=
+	ETHRX_cv_b		=3D 10,=0A=
+	ETHRX_cv_m		=3D 0x00000400,=0A=
+	ETHRX_db_b		=3D 11,=0A=
+	ETHRX_db_m		=3D 0x00000800,=0A=
+	ETHRX_le_b		=3D 12,=0A=
+	ETHRX_le_m		=3D 0x00001000,=0A=
+	ETHRX_lor_b		=3D 13,=0A=
+	ETHRX_lor_m		=3D 0x00002000,=0A=
+	ETHRX_ces_b		=3D 14,=0A=
+	ETHRX_ces_m		=3D 0x00004000,=0A=
+	ETHRX_length_b		=3D 16,=0A=
+	ETHRX_length_m		=3D 0xffff0000,=0A=
+=0A=
+	ETHTX_fd_b		=3D 0,=0A=
+	ETHTX_fd_m		=3D 0x00000001,=0A=
+	ETHTX_ld_b		=3D 1,=0A=
+	ETHTX_ld_m		=3D 0x00000002,=0A=
+	ETHTX_oen_b		=3D 2,=0A=
+	ETHTX_oen_m		=3D 0x00000004,=0A=
+	ETHTX_pen_b		=3D 3,=0A=
+	ETHTX_pen_m		=3D 0x00000008,=0A=
+	ETHTX_cen_b		=3D 4,=0A=
+	ETHTX_cen_m		=3D 0x00000010,=0A=
+	ETHTX_hen_b		=3D 5,=0A=
+	ETHTX_hen_m		=3D 0x00000020,=0A=
+	ETHTX_tok_b		=3D 6,=0A=
+	ETHTX_tok_m		=3D 0x00000040,=0A=
+	ETHTX_mp_b		=3D 7,=0A=
+	ETHTX_mp_m		=3D 0x00000080,=0A=
+	ETHTX_bp_b		=3D 8,=0A=
+	ETHTX_bp_m		=3D 0x00000100,=0A=
+	ETHTX_und_b		=3D 9,=0A=
+	ETHTX_und_m		=3D 0x00000200,=0A=
+	ETHTX_of_b		=3D 10,=0A=
+	ETHTX_of_m		=3D 0x00000400,=0A=
+	ETHTX_ed_b		=3D 11,=0A=
+	ETHTX_ed_m		=3D 0x00000800,=0A=
+	ETHTX_ec_b		=3D 12,=0A=
+	ETHTX_ec_m		=3D 0x00001000,=0A=
+	ETHTX_lc_b		=3D 13,=0A=
+	ETHTX_lc_m		=3D 0x00002000,=0A=
+	ETHTX_td_b		=3D 14,=0A=
+	ETHTX_td_m		=3D 0x00004000,=0A=
+	ETHTX_crc_b		=3D 15,=0A=
+	ETHTX_crc_m		=3D 0x00008000,=0A=
+	ETHTX_le_b		=3D 16,=0A=
+	ETHTX_le_m		=3D 0x00010000,=0A=
+	ETHTX_cc_b		=3D 17,=0A=
+	ETHTX_cc_m		=3D 0x001E0000,=0A=
+} ;=0A=
+#endif //__IDT_RC32438_ETH_H__=0A=
diff -uNr linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_e=
th_v.h idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_eth_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_eth_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_eth_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,64 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   macros for IDT EB438 ethernet=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32438_ETH_V_H__=0A=
+#define __IDT_RC32438_ETH_V_H__=0A=
+#include  <asm/idt-boards/rc32438/rc32438_eth.h> =0A=
+=0A=
+#define IS_TX_TOK(X)         (((X) & (1<<ETHTX_tok_b)) >> ETHTX_tok_b =
)   /* Transmit Okay    */=0A=
+#define IS_TX_MP(X)          (((X) & (1<<ETHTX_mp_b))  >> ETHTX_mp_b ) =
   /* Multicast        */=0A=
+#define IS_TX_BP(X)          (((X) & (1<<ETHTX_bp_b))  >> ETHTX_bp_b ) =
   /* Broadcast        */=0A=
+#define IS_TX_UND_ERR(X)     (((X) & (1<<ETHTX_und_b)) >> ETHTX_und_b =
)   /* Transmit FIFO Underflow */=0A=
+#define IS_TX_OF_ERR(X)      (((X) & (1<<ETHTX_of_b))  >> ETHTX_of_b ) =
   /* Oversized frame  */=0A=
+#define IS_TX_ED_ERR(X)      (((X) & (1<<ETHTX_ed_b))  >> ETHTX_ed_b ) =
   /* Excessive deferral  */=0A=
+#define IS_TX_EC_ERR(X)      (((X) & (1<<ETHTX_ec_b))  >> ETHTX_ec_b)  =
   /* Excessive collisions  */=0A=
+#define IS_TX_LC_ERR(X)      (((X) & (1<<ETHTX_lc_b))  >> ETHTX_lc_b ) =
   /* Late Collision   */=0A=
+#define IS_TX_TD_ERR(X)      (((X) & (1<<ETHTX_td_b))  >> ETHTX_td_b ) =
   /* Transmit deferred*/=0A=
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<ETHTX_crc_b)) >> ETHTX_crc_b =
)   /* CRC Error        */=0A=
+#define IS_TX_LE_ERR(X)      (((X) & (1<<ETHTX_le_b))  >>  ETHTX_le_b =
)    /* Length Error     */=0A=
+=0A=
+#define TX_COLLISION_COUNT(X) (((X) & ETHTX_cc_m)>>ETHTX_cc_b)  /* =
Collision Count  */=0A=
+=0A=
+#define IS_RCV_ROK(X)        (((X) & (1<<ETHRX_rok_b)) >> ETHRX_rok_b) =
   /* Receive Okay     */=0A=
+#define IS_RCV_FM(X)         (((X) & (1<<ETHRX_fm_b))  >> ETHRX_fm_b)  =
   /* Is Filter Match  */=0A=
+#define IS_RCV_MP(X)         (((X) & (1<<ETHRX_mp_b))  >> ETHRX_mp_b)  =
   /* Is it MP         */=0A=
+#define IS_RCV_BP(X)         (((X) & (1<<ETHRX_bp_b))  >> ETHRX_bp_b)  =
   /* Is it BP         */=0A=
+#define IS_RCV_VLT(X)        (((X) & (1<<ETHRX_vlt_b)) >> ETHRX_vlt_b) =
   /* VLAN Tag Detect  */=0A=
+#define IS_RCV_CF(X)         (((X) & (1<<ETHRX_cf_b))  >> ETHRX_cf_b)  =
   /* Control Frame    */=0A=
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<ETHRX_ovr_b)) >> ETHRX_ovr_b) =
   /* Receive Overflow */=0A=
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<ETHRX_crc_b)) >> ETHRX_crc_b) =
   /* CRC Error        */=0A=
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<ETHRX_cv_b))  >> ETHRX_cv_b)  =
   /* Code Violation   */=0A=
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<ETHRX_db_b))  >> ETHRX_db_b)  =
   /* Dribble Bits     */=0A=
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<ETHRX_le_b))  >> ETHRX_le_b)  =
   /* Length error     */=0A=
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<ETHRX_lor_b)) >> ETHRX_lor_b) =
   /* Length Out of Range */=0A=
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<ETHRX_ces_b)) >> ETHRX_ces_b) =
 /* Preamble error   */=0A=
+#define RCVPKT_LENGTH(X)     (((X) & ETHRX_length_m) >> =
ETHRX_length_b)   /* Length of the received packet */=0A=
+=0A=
+#endif //__IDT_RC32438_ETH_V_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_gpio.h =
idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_gpio.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_gpio.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_gpio.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,249 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for IDT RC32438 GPIO.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+#ifndef __IDT_RC32438_GPIO_H__=0A=
+#define __IDT_RC32438_GPIO_H__ =0A=
+enum=0A=
+{=0A=
+	GPIO0_PhysicalAddress	=3D 0x18048000,=0A=
+	GPIO_PhysicalAddress	=3D GPIO0_PhysicalAddress,	// Default=0A=
+=0A=
+	GPIO0_VirtualAddress	=3D 0xb8048000,=0A=
+	GPIO_VirtualAddress	=3D GPIO0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32   gpiofunc;   /* GPIO Function Register=0A=
+			   * gpiofunc[x]=3D=3D0 bit =3D gpio=0A=
+			   * func[x]=3D=3D1  bit =3D altfunc=0A=
+			   */=0A=
+	u32   gpiocfg;	  /* GPIO Configuration Register=0A=
+			   * gpiocfg[x]=3D=3D0 bit =3D input=0A=
+			   * gpiocfg[x]=3D=3D1 bit =3D output=0A=
+			   */=0A=
+	u32   gpiod;	  /* GPIO Data Register=0A=
+			   * gpiod[x] read/write gpio pinX status=0A=
+			   */=0A=
+	u32   gpioilevel; /* GPIO Interrupt Status Register=0A=
+			   * interrupt level (see gpioistat)=0A=
+			   */=0A=
+	u32   gpioistat;  /* Gpio Interrupt Status Register=0A=
+			   * istat[x] =3D (gpiod[x] =3D=3D level[x])=0A=
+			   * cleared in ISR (STICKY bits)=0A=
+			   */=0A=
+	u32   gpionmien;  /* GPIO Non-maskable Interrupt Enable Register =
*/=0A=
+} volatile * GPIO_t ;=0A=
+=0A=
+typedef enum=0A=
+{=0A=
+	GPIO_gpio_v		=3D 0,		// gpiofunc use pin as GPIO.=0A=
+	GPIO_alt_v		=3D 1,		// gpiofunc use pin as alt.=0A=
+	GPIO_input_v		=3D 0,		// gpiocfg use pin as input.=0A=
+	GPIO_output_v		=3D 1,		// gpiocfg use pin as output.=0A=
+	GPIO_pin0_b		=3D 0,=0A=
+	GPIO_pin0_m		=3D 0x00000001,=0A=
+	GPIO_pin1_b		=3D 1,=0A=
+	GPIO_pin1_m		=3D 0x00000002,=0A=
+	GPIO_pin2_b		=3D 2,=0A=
+	GPIO_pin2_m		=3D 0x00000004,=0A=
+	GPIO_pin3_b		=3D 3,=0A=
+	GPIO_pin3_m		=3D 0x00000008,=0A=
+	GPIO_pin4_b		=3D 4,=0A=
+	GPIO_pin4_m		=3D 0x00000010,=0A=
+	GPIO_pin5_b		=3D 5,=0A=
+	GPIO_pin5_m		=3D 0x00000020,=0A=
+	GPIO_pin6_b		=3D 6,=0A=
+	GPIO_pin6_m		=3D 0x00000040,=0A=
+	GPIO_pin7_b		=3D 7,=0A=
+	GPIO_pin7_m		=3D 0x00000080,=0A=
+	GPIO_pin8_b		=3D 8,=0A=
+	GPIO_pin8_m		=3D 0x00000100,=0A=
+	GPIO_pin9_b		=3D 9,=0A=
+	GPIO_pin9_m		=3D 0x00000200,=0A=
+	GPIO_pin10_b		=3D 10,=0A=
+	GPIO_pin10_m		=3D 0x00000400,=0A=
+	GPIO_pin11_b		=3D 11,=0A=
+	GPIO_pin11_m		=3D 0x00000800,=0A=
+	GPIO_pin12_b		=3D 12,=0A=
+	GPIO_pin12_m		=3D 0x00001000,=0A=
+	GPIO_pin13_b		=3D 13,=0A=
+	GPIO_pin13_m		=3D 0x00002000,=0A=
+	GPIO_pin14_b		=3D 14,=0A=
+	GPIO_pin14_m		=3D 0x00004000,=0A=
+	GPIO_pin15_b		=3D 15,=0A=
+	GPIO_pin15_m		=3D 0x00008000,=0A=
+	GPIO_pin16_b		=3D 16,=0A=
+	GPIO_pin16_m		=3D 0x00010000,=0A=
+	GPIO_pin17_b		=3D 17,=0A=
+	GPIO_pin17_m		=3D 0x00020000,=0A=
+	GPIO_pin18_b		=3D 18,=0A=
+	GPIO_pin18_m		=3D 0x00040000,=0A=
+	GPIO_pin19_b		=3D 19,=0A=
+	GPIO_pin19_m		=3D 0x00080000,=0A=
+	GPIO_pin20_b		=3D 20,=0A=
+	GPIO_pin20_m		=3D 0x00100000,=0A=
+	GPIO_pin21_b		=3D 21,=0A=
+	GPIO_pin21_m		=3D 0x00200000,=0A=
+	GPIO_pin22_b		=3D 22,=0A=
+	GPIO_pin22_m		=3D 0x00400000,=0A=
+	GPIO_pin23_b		=3D 23,=0A=
+	GPIO_pin23_m		=3D 0x00800000,=0A=
+	GPIO_pin24_b		=3D 24,=0A=
+	GPIO_pin24_m		=3D 0x01000000,=0A=
+	GPIO_pin25_b		=3D 25,=0A=
+	GPIO_pin25_m		=3D 0x02000000,=0A=
+	GPIO_pin26_b		=3D 26,=0A=
+	GPIO_pin26_m		=3D 0x04000000,=0A=
+	GPIO_pin27_b		=3D 27,=0A=
+	GPIO_pin27_m		=3D 0x08000000,=0A=
+	GPIO_pin28_b		=3D 28,=0A=
+	GPIO_pin28_m		=3D 0x10000000,=0A=
+	GPIO_pin29_b		=3D 29,=0A=
+	GPIO_pin29_m		=3D 0x20000000,=0A=
+	GPIO_pin30_b		=3D 30,=0A=
+	GPIO_pin30_m		=3D 0x40000000,=0A=
+	GPIO_pin31_b		=3D 31,=0A=
+	GPIO_pin31_m		=3D 0x80000000,=0A=
+=0A=
+// Alternate function pins.  Corrsponding gpiofunc bit set to =
GPIO_alt_v.=0A=
+=0A=
+	GPIO_u0sout_b		=3D GPIO_pin0_b,		// UART 0 serial out.=0A=
+	GPIO_u0sout_m		=3D GPIO_pin0_m,=0A=
+		GPIO_u0sout_cfg_v	=3D GPIO_output_v,=0A=
+	GPIO_u0sinp_b	=3D GPIO_pin1_b,			// UART 0 serial in.=0A=
+	GPIO_u0sinp_m	=3D GPIO_pin1_m,=0A=
+		GPIO_u0sinp_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_u0rin_b	=3D GPIO_pin2_b,			// UART 0 ring indic.=0A=
+	GPIO_u0rin_m	=3D GPIO_pin2_m,=0A=
+		GPIO_u0rin_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_u0dcdn_b	=3D GPIO_pin3_b,			// UART 0 data carr.det.=0A=
+	GPIO_u0dcdn_m	=3D GPIO_pin3_m,=0A=
+		GPIO_u0dcdn_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_u0dtrn_b	=3D GPIO_pin4_b,			// UART 0 data term rdy.=0A=
+	GPIO_u0dtrn_m	=3D GPIO_pin4_m,=0A=
+		GPIO_u0dtrn_cfg_v	=3D GPIO_output_v,=0A=
+	GPIO_u0dsrn_b	=3D GPIO_pin5_b,			// UART 0 data set rdy.=0A=
+	GPIO_u0dsrn_m	=3D GPIO_pin5_m,=0A=
+		GPIO_u0dsrn_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_u0rtsn_b	=3D GPIO_pin6_b,			// UART 0 req. to send.=0A=
+	GPIO_u0rtsn_m	=3D GPIO_pin6_m,=0A=
+		GPIO_u0rtsn_cfg_v	=3D GPIO_output_v,=0A=
+	GPIO_u0ctsn_b	=3D GPIO_pin7_b,			// UART 0 clear to send.=0A=
+	GPIO_u0ctsn_m	=3D GPIO_pin7_m,=0A=
+		GPIO_u0ctsn_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_u1sout_b		=3D GPIO_pin8_b,		// UART 1 serial out.=0A=
+	GPIO_u1sout_m		=3D GPIO_pin8_m,=0A=
+		GPIO_u1sout_cfg_v	=3D GPIO_output_v,=0A=
+	GPIO_u1sinp_b		=3D GPIO_pin9_b,		// UART 1 serial in.=0A=
+	GPIO_u1sinp_m		=3D GPIO_pin9_m,=0A=
+		GPIO_u1sinp_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_u1dtrn_b		=3D GPIO_pin10_b, 	// UART 1 data term rdy.=0A=
+	GPIO_u1dtrn_m		=3D GPIO_pin10_m,=0A=
+		GPIO_u1dtrn_cfg_v	=3D GPIO_output_v,=0A=
+	GPIO_u1dsrn_b		=3D GPIO_pin11_b, 	// UART 1 data set rdy.=0A=
+	GPIO_u1dsrn_m		=3D GPIO_pin11_m,=0A=
+		GPIO_u1dsrn_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_u1rtsn_b		=3D GPIO_pin12_b, 	// UART 1 req. to send.=0A=
+	GPIO_u1rtsn_m		=3D GPIO_pin12_m,=0A=
+		GPIO_u1rtsn_cfg_v	=3D GPIO_output_v,=0A=
+	GPIO_u1ctsn_b		=3D GPIO_pin13_b, 	// UART 1 clear to send.=0A=
+	GPIO_u1ctsn_m		=3D GPIO_pin13_m,=0A=
+		GPIO_u1ctsn_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_dmareqn0_b 	=3D GPIO_pin14_b, 	// Ext. DMA 0 request=0A=
+	GPIO_dmareqn0_m 	=3D GPIO_pin14_m,=0A=
+		GPIO_dmareqn0_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_dmareqn1_b 	=3D GPIO_pin15_b, 	// Ext. DMA 1 request=0A=
+	GPIO_dmareqn1_m 	=3D GPIO_pin15_m,=0A=
+		GPIO_dmareqn1_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_dmadonen0_b	=3D GPIO_pin16_b, 	// Ext. DMA 0 done=0A=
+	GPIO_dmadonen0_m	=3D GPIO_pin16_m,=0A=
+		GPIO_dmadonen0_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_dmadonen1_b	=3D GPIO_pin17_b, 	// Ext. DMA 1 done=0A=
+	GPIO_dmadonen1_m	=3D GPIO_pin17_m,=0A=
+		GPIO_dmadonen1_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_dmafinn0_b 	=3D GPIO_pin18_b, 	// Ext. DMA 0 finished=0A=
+	GPIO_dmafinn0_m 	=3D GPIO_pin18_m,=0A=
+		GPIO_dmafinn0_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_dmafinn1_b 	=3D GPIO_pin19_b, 	// Ext. DMA 1 finished=0A=
+	GPIO_dmafinn1_m 	=3D GPIO_pin19_m,=0A=
+		GPIO_dmafinn1_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_maddr22_b		=3D GPIO_pin20_b, 	// M&P bus bit 22.=0A=
+	GPIO_maddr22_m		=3D GPIO_pin20_m,=0A=
+		GPIO_maddr22_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_maddr23_b		=3D GPIO_pin21_b, 	// M&P bus bit 23.=0A=
+	GPIO_maddr23_m		=3D GPIO_pin21_m,=0A=
+		GPIO_maddr23_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_maddr24_b		=3D GPIO_pin22_b, 	// M&P bus bit 24.=0A=
+	GPIO_maddr24_m		=3D GPIO_pin22_m,=0A=
+		GPIO_maddr24_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_maddr25_b		=3D GPIO_pin23_b, 	// M&P bus bit 25.=0A=
+	GPIO_maddr25_m		=3D GPIO_pin23_m,=0A=
+		GPIO_maddr25_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_afspare6_b 	=3D GPIO_pin24_b, 	// reserved.=0A=
+	GPIO_afspare6_m 	=3D GPIO_pin24_m,=0A=
+		GPIO_afspare6_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_afspare5_b 	=3D GPIO_pin25_b, 	// reserved.=0A=
+	GPIO_afspare5_m 	=3D GPIO_pin25_m,=0A=
+		GPIO_afspare5_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_afspare4_b 	=3D GPIO_pin26_b, 	// reserved.=0A=
+	GPIO_afspare4_m 	=3D GPIO_pin26_m,=0A=
+		GPIO_afspare4_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_afspare3_b 	=3D GPIO_pin27_b, 	// reserved.=0A=
+	GPIO_afspare3_m 	=3D GPIO_pin27_m,=0A=
+		GPIO_afspare3_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_afspare2_b 	=3D GPIO_pin28_b, 	// reserved.=0A=
+	GPIO_afspare2_m 	=3D GPIO_pin28_m,=0A=
+		GPIO_afspare2_cfg_v	=3D GPIO_input_v,=0A=
+	GPIO_afspare1_b 	=3D GPIO_pin29_b, 	// reserved.=0A=
+	GPIO_afspare1_m 	=3D GPIO_pin29_m,=0A=
+		GPIO_afspare1_cfg_v	=3D GPIO_input_v,=0A=
+=0A=
+	GPIO_pcimuintn_b	=3D GPIO_pin30_b, 	// PCI messaging int.=0A=
+	GPIO_pcimuintn_m	=3D GPIO_pin30_m,=0A=
+		GPIO_pcimuintn_cfg_v	=3D GPIO_output_v,=0A=
+=0A=
+	GPIO_rngclk_b		=3D GPIO_pin31_b, 	// RNG external clock=0A=
+	GPIO_rngclk_m		=3D GPIO_pin31_m,=0A=
+		GPIO_rncclk_cfg_v	=3D GPIO_input_v,=0A=
+} GPIO_DEFS_t;=0A=
+=0A=
+#endif //__IDT_RC32438_GPIO_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438.h =
idtlinux/include/asm-mips/idt-boards/rc32438/rc32438.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438.h	2006-03-09 =
16:26:31.000000000 -0800=0A=
@@ -0,0 +1,144 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for IDT RC32438 CPU.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __IDT_RC32438_H__=0A=
+#define  __IDT_RC32438_H__=0A=
+#include <linux/config.h>=0A=
+#include <linux/delay.h>=0A=
+#include <asm/io.h>=0A=
+#include <asm/idt-boards/rc32438/rc32438_timer.h>=0A=
+=0A=
+#define RC32438_REG_BASE   0x18000000=0A=
+=0A=
+#define interrupt ((volatile INT_t ) INT0_VirtualAddress)=0A=
+#define idttimer     ((volatile TIM_t)  TIM0_VirtualAddress)=0A=
+#define gpio	  ((volatile GPIO_t) GPIO0_VirtualAddress)=0A=
+=0A=
+#define IDT_CLOCK_MULT 2=0A=
+#define MIPS_CPU_TIMER_IRQ 7=0A=
+/* Interrupt Controller */=0A=
+#define IC_GROUP0_PEND     (RC32438_REG_BASE + 0x38000)=0A=
+#define IC_GROUP0_MASK     (RC32438_REG_BASE + 0x38008)=0A=
+#define IC_GROUP_OFFSET    0x0C=0A=
+#define RTC_BASE           0xAC0801FF0=0A=
+=0A=
+#define NUM_INTR_GROUPS    5=0A=
+/* 16550 UARTs */=0A=
+=0A=
+#define GROUP0_IRQ_BASE 8		/* GRP2 IRQ numbers start here */=0A=
+#define GROUP1_IRQ_BASE (GROUP0_IRQ_BASE + 32) /* GRP3 IRQ numbers =
start here */=0A=
+#define GROUP2_IRQ_BASE (GROUP1_IRQ_BASE + 32) /* GRP4 IRQ numbers =
start here */=0A=
+#define GROUP3_IRQ_BASE (GROUP2_IRQ_BASE + 32)	/* GRP5 IRQ numbers =
start here */=0A=
+#define GROUP4_IRQ_BASE (GROUP3_IRQ_BASE + 32)=0A=
+=0A=
+#ifdef __MIPSEB__=0A=
+#define RC32438_UART0_BASE (RC32438_REG_BASE + 0x50003)=0A=
+#define RC32438_UART1_BASE (RC32438_REG_BASE + 0x50023)=0A=
+#else=0A=
+#define RC32438_UART0_BASE (RC32438_REG_BASE + 0x50000)=0A=
+#define RC32438_UART1_BASE (RC32438_REG_BASE + 0x50020)=0A=
+#endif=0A=
+=0A=
+#define RC32438_UART0_IRQ  GROUP3_IRQ_BASE + 0=0A=
+#define RC32438_UART1_IRQ  GROUP3_IRQ_BASE + 3=0A=
+=0A=
+#define RC32438_NR_IRQS  (GROUP4_IRQ_BASE + 32)=0A=
+=0A=
+=0A=
+=0A=
+/* cpu pipeline flush */=0A=
+static inline void rc32438_sync(void)=0A=
+{=0A=
+        __asm__ volatile ("sync");=0A=
+}=0A=
+=0A=
+static inline void rc32438_sync_udelay(int us)=0A=
+{=0A=
+        __asm__ volatile ("sync");=0A=
+        udelay(us);=0A=
+}=0A=
+=0A=
+static inline void rc32438_sync_delay(int ms)=0A=
+{=0A=
+        __asm__ volatile ("sync");=0A=
+        mdelay(ms);=0A=
+}=0A=
+=0A=
+/*=0A=
+ * Macros to access internal RC32438 registers. No byte=0A=
+ * swapping should be done when accessing the internal=0A=
+ * registers.=0A=
+ */=0A=
+=0A=
+#define rc32438_readb __raw_readb=0A=
+#define rc32438_readw __raw_readw=0A=
+#define rc32438_readl __raw_readl=0A=
+=0A=
+#define rc32438_writeb __raw_writeb=0A=
+#define rc32438_writew __raw_writew=0A=
+#define rc32438_writel __raw_writel=0A=
+=0A=
+/*=0A=
+ * C access to CLZ and CLO instructions=0A=
+ * (count leading zeroes/ones).=0A=
+ */=0A=
+static inline int rc32438_clz(unsigned long val)=0A=
+{=0A=
+	int ret;=0A=
+        __asm__ volatile (=0A=
+		".set\tnoreorder\n\t"=0A=
+		".set\tnoat\n\t"=0A=
+		".set\tmips32\n\t"=0A=
+		"clz\t%0,%1\n\t"=0A=
+                ".set\tmips0\n\t"=0A=
+                ".set\tat\n\t"=0A=
+                ".set\treorder"=0A=
+                : "=3Dr" (ret)=0A=
+		: "r" (val));=0A=
+=0A=
+	return ret;=0A=
+}=0A=
+static inline int rc32438_clo(unsigned long val)=0A=
+{=0A=
+	int ret;=0A=
+        __asm__ volatile (=0A=
+		".set\tnoreorder\n\t"=0A=
+		".set\tnoat\n\t"=0A=
+		".set\tmips32\n\t"=0A=
+		"clo\t%0,%1\n\t"=0A=
+                ".set\tmips0\n\t"=0A=
+                ".set\tat\n\t"=0A=
+                ".set\treorder"=0A=
+                : "=3Dr" (ret)=0A=
+		: "r" (val));=0A=
+=0A=
+	return ret;=0A=
+}=0A=
+#endif //__IDT_RC32438_H__=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_pci.h =
idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_pci.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_pci.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_pci.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,502 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for IDT RC32438 PCI.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+enum=0A=
+{=0A=
+	PCI0_PhysicalAddress	=3D 0x18080000,=0A=
+	PCI_PhysicalAddress	=3D PCI0_PhysicalAddress,=0A=
+=0A=
+	PCI0_VirtualAddress	=3D 0xb8080000,=0A=
+	PCI_VirtualAddress	=3D PCI0_VirtualAddress,=0A=
+} ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	PCI_LbaCount	=3D 4,		// Local base addresses.=0A=
+} ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32	a ;		// Address.=0A=
+	u32	c ;		// Control.=0A=
+	u32	m ;		// mapping.=0A=
+} PCI_Map_s ;=0A=
+=0A=
+typedef struct=0A=
+{=0A=
+	u32		pcic ;=0A=
+	u32		pcis ;=0A=
+	u32		pcism ;=0A=
+	u32		pcicfga ;=0A=
+	u32		pcicfgd ;=0A=
+	PCI_Map_s	pcilba [PCI_LbaCount] ;=0A=
+	u32		pcidac ;=0A=
+	u32		pcidas ;=0A=
+	u32		pcidasm ;=0A=
+	u32		pcidad ;=0A=
+	u32		pcidma8c ;=0A=
+	u32		pcidma9c ;=0A=
+	u32		pcitc ;=0A=
+} volatile *PCI_t ;=0A=
+=0A=
+// PCI messaging unit.=0A=
+enum=0A=
+{=0A=
+	PCIM_Count	=3D 2,=0A=
+} ;=0A=
+typedef struct=0A=
+{=0A=
+	u32		pciim [PCIM_Count] ;=0A=
+	u32		pciom [PCIM_Count] ;=0A=
+	u32		pciid ;=0A=
+	u32		pciiic ;=0A=
+	u32		pciiim ;=0A=
+	u32		pciiod ;=0A=
+	u32		pciioic ;=0A=
+	u32		pciioim ;=0A=
+} volatile *PCIM_t ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIC_en_b	=3D 0,=0A=
+	PCIC_en_m	=3D 0x00000001,=0A=
+	PCIC_tnr_b	=3D 1,=0A=
+	PCIC_tnr_m	=3D 0x00000002,=0A=
+	PCIC_sce_b	=3D 2,=0A=
+	PCIC_sce_m	=3D 0x00000004,=0A=
+	PCIC_ien_b	=3D 3,=0A=
+	PCIC_ien_m	=3D 0x00000008,=0A=
+	PCIC_aaa_b	=3D 4,=0A=
+	PCIC_aaa_m	=3D 0x00000010,=0A=
+	PCIC_eap_b	=3D 5,=0A=
+	PCIC_eap_m	=3D 0x00000020,=0A=
+	PCIC_pcim_b	=3D 6,=0A=
+	PCIC_pcim_m	=3D 0x000001c0,=0A=
+		PCIC_pcim_disabled_v	=3D 0,=0A=
+		PCIC_pcim_tnr_v 	=3D 1,	// Satellite - target not ready=0A=
+		PCIC_pcim_suspend_v	=3D 2,	// Satellite - suspended CPU.=0A=
+		PCIC_pcim_extern_v	=3D 3,	// Host - external arbiter.=0A=
+		PCIC_pcim_fixed_v	=3D 4,	// Host - fixed priority arb.=0A=
+		PCIC_pcim_roundrobin_v	=3D 5,	// Host - round robin priority.=0A=
+		PCIC_pcim_reserved6_v	=3D 6,=0A=
+		PCIC_pcim_reserved7_v	=3D 7,=0A=
+	PCIC_igm_b	=3D 9,=0A=
+	PCIC_igm_m	=3D 0x00000200,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Status Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIS_eed_b	=3D 0,=0A=
+	PCIS_eed_m	=3D 0x00000001,=0A=
+	PCIS_wr_b	=3D 1,=0A=
+	PCIS_wr_m	=3D 0x00000002,=0A=
+	PCIS_nmi_b	=3D 2,=0A=
+	PCIS_nmi_m	=3D 0x00000004,=0A=
+	PCIS_ii_b	=3D 3,=0A=
+	PCIS_ii_m	=3D 0x00000008,=0A=
+	PCIS_cwe_b	=3D 4,=0A=
+	PCIS_cwe_m	=3D 0x00000010,=0A=
+	PCIS_cre_b	=3D 5,=0A=
+	PCIS_cre_m	=3D 0x00000020,=0A=
+	PCIS_mdpe_b	=3D 6,=0A=
+	PCIS_mdpe_m	=3D 0x00000040,=0A=
+	PCIS_sta_b	=3D 7,=0A=
+	PCIS_sta_m	=3D 0x00000080,=0A=
+	PCIS_rta_b	=3D 8,=0A=
+	PCIS_rta_m	=3D 0x00000100,=0A=
+	PCIS_rma_b	=3D 9,=0A=
+	PCIS_rma_m	=3D 0x00000200,=0A=
+	PCIS_sse_b	=3D 10,=0A=
+	PCIS_sse_m	=3D 0x00000400,=0A=
+	PCIS_ose_b	=3D 11,=0A=
+	PCIS_ose_m	=3D 0x00000800,=0A=
+	PCIS_pe_b	=3D 12,=0A=
+	PCIS_pe_m	=3D 0x00001000,=0A=
+	PCIS_tae_b	=3D 13,=0A=
+	PCIS_tae_m	=3D 0x00002000,=0A=
+	PCIS_rle_b	=3D 14,=0A=
+	PCIS_rle_m	=3D 0x00004000,=0A=
+	PCIS_bme_b	=3D 15,=0A=
+	PCIS_bme_m	=3D 0x00008000,=0A=
+	PCIS_prd_b	=3D 16,=0A=
+	PCIS_prd_m	=3D 0x00010000,=0A=
+	PCIS_rip_b	=3D 17,=0A=
+	PCIS_rip_m	=3D 0x00020000,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Status Mask Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCISM_eed_b		=3D 0,=0A=
+	PCISM_eed_m		=3D 0x00000001,=0A=
+	PCISM_wr_b		=3D 1,=0A=
+	PCISM_wr_m		=3D 0x00000002,=0A=
+	PCISM_nmi_b		=3D 2,=0A=
+	PCISM_nmi_m		=3D 0x00000004,=0A=
+	PCISM_ii_b		=3D 3,=0A=
+	PCISM_ii_m		=3D 0x00000008,=0A=
+	PCISM_cwe_b		=3D 4,=0A=
+	PCISM_cwe_m		=3D 0x00000010,=0A=
+	PCISM_cre_b		=3D 5,=0A=
+	PCISM_cre_m		=3D 0x00000020,=0A=
+	PCISM_mdpe_b		=3D 6,=0A=
+	PCISM_mdpe_m		=3D 0x00000040,=0A=
+	PCISM_sta_b		=3D 7,=0A=
+	PCISM_sta_m		=3D 0x00000080,=0A=
+	PCISM_rta_b		=3D 8,=0A=
+	PCISM_rta_m		=3D 0x00000100,=0A=
+	PCISM_rma_b		=3D 9,=0A=
+	PCISM_rma_m		=3D 0x00000200,=0A=
+	PCISM_sse_b		=3D 10,=0A=
+	PCISM_sse_m		=3D 0x00000400,=0A=
+	PCISM_ose_b		=3D 11,=0A=
+	PCISM_ose_m		=3D 0x00000800,=0A=
+	PCISM_pe_b		=3D 12,=0A=
+	PCISM_pe_m		=3D 0x00001000,=0A=
+	PCISM_tae_b		=3D 13,=0A=
+	PCISM_tae_m		=3D 0x00002000,=0A=
+	PCISM_rle_b		=3D 14,=0A=
+	PCISM_rle_m		=3D 0x00004000,=0A=
+	PCISM_bme_b		=3D 15,=0A=
+	PCISM_bme_m		=3D 0x00008000,=0A=
+	PCISM_prd_b		=3D 16,=0A=
+	PCISM_prd_m		=3D 0x00010000,=0A=
+	PCISM_rip_b		=3D 17,=0A=
+	PCISM_rip_m		=3D 0x00020000,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Configuration Address Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCICFGA_reg_b		=3D 2,=0A=
+	PCICFGA_reg_m		=3D 0x000000fc,=0A=
+		PCICFGA_reg_id_v	=3D 0x00>>2, //use PCFGID_=0A=
+		PCICFGA_reg_04_v	=3D 0x04>>2, //use PCFG04_=0A=
+		PCICFGA_reg_08_v	=3D 0x08>>2, //use PCFG08_=0A=
+		PCICFGA_reg_0C_v	=3D 0x0C>>2, //use PCFG0C_=0A=
+		PCICFGA_reg_pba0_v	=3D 0x10>>2, //use PCIPBA_=0A=
+		PCICFGA_reg_pba1_v	=3D 0x14>>2, //use PCIPBA_=0A=
+		PCICFGA_reg_pba2_v	=3D 0x18>>2, //use PCIPBA_=0A=
+		PCICFGA_reg_pba3_v	=3D 0x1c>>2, //use PCIPBA_=0A=
+		PCICFGA_reg_subsystem_v =3D 0x2c>>2, //use PCFGSS_=0A=
+		PCICFGA_reg_3C_v	=3D 0x3C>>2, //use PCFG3C_=0A=
+		PCICFGA_reg_pba0c_v	=3D 0x44>>2, //use PCIPBAC_=0A=
+		PCICFGA_reg_pba0m_v	=3D 0x48>>2,=0A=
+		PCICFGA_reg_pba1c_v	=3D 0x4c>>2, //use PCIPBAC_=0A=
+		PCICFGA_reg_pba1m_v	=3D 0x50>>2,=0A=
+		PCICFGA_reg_pba2c_v	=3D 0x54>>2, //use PCIPBAC_=0A=
+		PCICFGA_reg_pba2m_v	=3D 0x58>>2,=0A=
+		PCICFGA_reg_pba3c_v	=3D 0x5c>>2, //use PCIPBAC_=0A=
+		PCICFGA_reg_pba3m_v	=3D 0x60>>2,=0A=
+		PCICFGA_reg_pmgt_v	=3D 0x64>>2,=0A=
+	PCICFGA_func_b		=3D 8,=0A=
+	PCICFGA_func_m		=3D 0x00000700,=0A=
+	PCICFGA_dev_b		=3D 11,=0A=
+	PCICFGA_dev_m		=3D 0x0000f800,=0A=
+		PCICFGA_dev_internal_v	=3D 0,=0A=
+	PCICFGA_bus_b		=3D 16,=0A=
+	PCICFGA_bus_m		=3D 0x00ff0000,=0A=
+		PCICFGA_bus_type0_v	=3D 0,	//local bus=0A=
+	PCICFGA_en_b		=3D 31,		// read only=0A=
+	PCICFGA_en_m		=3D 0x80000000,=0A=
+} ;=0A=
+=0A=
+enum {=0A=
+	PCFGID_vendor_b 	=3D 0,=0A=
+	PCFGID_vendor_m 	=3D 0x0000ffff,=0A=
+		PCFGID_vendor_IDT_v		=3D 0x111d,=0A=
+	PCFGID_device_b 	=3D 16,=0A=
+	PCFGID_device_m 	=3D 0xffff0000,=0A=
+		PCFGID_device_Acaciade_v	=3D 0x0207,=0A=
+=0A=
+	PCFG04_command_ioena_b		=3D 1,=0A=
+	PCFG04_command_ioena_m		=3D 0x00000001,=0A=
+	PCFG04_command_memena_b 	=3D 2,=0A=
+	PCFG04_command_memena_m 	=3D 0x00000002,=0A=
+	PCFG04_command_bmena_b		=3D 3,=0A=
+	PCFG04_command_bmena_m		=3D 0x00000004,=0A=
+	PCFG04_command_mwinv_b		=3D 5,=0A=
+	PCFG04_command_mwinv_m		=3D 0x00000010,=0A=
+	PCFG04_command_parena_b 	=3D 7,=0A=
+	PCFG04_command_parena_m 	=3D 0x00000040,=0A=
+	PCFG04_command_serrena_b	=3D 9,=0A=
+	PCFG04_command_serrena_m	=3D 0x00000100,=0A=
+	PCFG04_command_fastbbena_b	=3D 10,=0A=
+	PCFG04_command_fastbbena_m	=3D 0x00000200,=0A=
+	PCFG04_status_b 		=3D 16,=0A=
+	PCFG04_status_m 		=3D 0xffff0000,=0A=
+	PCFG04_status_66MHz_b		=3D 21,	// 66 MHz enable=0A=
+	PCFG04_status_66MHz_m		=3D 0x00200000,=0A=
+	PCFG04_status_fbb_b		=3D 23,=0A=
+	PCFG04_status_fbb_m		=3D 0x00800000,=0A=
+	PCFG04_status_mdpe_b		=3D 24,=0A=
+	PCFG04_status_mdpe_m		=3D 0x01000000,=0A=
+	PCFG04_status_dst_b		=3D 25,=0A=
+	PCFG04_status_dst_m		=3D 0x06000000,=0A=
+	PCFG04_status_sta_b		=3D 27,=0A=
+	PCFG04_status_sta_m		=3D 0x08000000,=0A=
+	PCFG04_status_rta_b		=3D 28,=0A=
+	PCFG04_status_rta_m		=3D 0x10000000,=0A=
+	PCFG04_status_rma_b		=3D 29,=0A=
+	PCFG04_status_rma_m		=3D 0x20000000,=0A=
+	PCFG04_status_sse_b		=3D 30,=0A=
+	PCFG04_status_sse_m		=3D 0x40000000,=0A=
+	PCFG04_status_pe_b		=3D 31,=0A=
+	PCFG04_status_pe_m		=3D 0x40000000,=0A=
+=0A=
+	PCFG08_revId_b			=3D 0,=0A=
+	PCFG08_revId_m			=3D 0x000000ff,=0A=
+	PCFG08_classCode_b		=3D 0,=0A=
+	PCFG08_classCode_m		=3D 0xffffff00,=0A=
+		PCFG08_classCode_bridge_v	=3D 06,=0A=
+		PCFG08_classCode_proc_v 	=3D 0x0b3000, // processor-MIPS=0A=
+	PCFG0C_cacheline_b		=3D 0,=0A=
+	PCFG0C_cacheline_m		=3D 0x000000ff,=0A=
+	PCFG0C_masterLatency_b		=3D 8,=0A=
+	PCFG0C_masterLatency_m		=3D 0x0000ff00,=0A=
+	PCFG0C_headerType_b		=3D 16,=0A=
+	PCFG0C_headerType_m		=3D 0x00ff0000,=0A=
+	PCFG0C_bist_b			=3D 24,=0A=
+	PCFG0C_bist_m			=3D 0xff000000,=0A=
+=0A=
+	PCIPBA_msi_b			=3D 0,=0A=
+	PCIPBA_msi_m			=3D 0x00000001,=0A=
+	PCIPBA_p_b			=3D 3,=0A=
+	PCIPBA_p_m			=3D 0x00000004,=0A=
+	PCIPBA_baddr_b			=3D 8,=0A=
+	PCIPBA_baddr_m			=3D 0xffffff00,=0A=
+=0A=
+	PCFGSS_vendorId_b		=3D 0,=0A=
+	PCFGSS_vendorId_m		=3D 0x0000ffff,=0A=
+	PCFGSS_id_b			=3D 16,=0A=
+	PCFGSS_id_m			=3D 0xffff0000,=0A=
+=0A=
+	PCFG3C_interruptLine_b		=3D 0,=0A=
+	PCFG3C_interruptLine_m		=3D 0x000000ff,=0A=
+	PCFG3C_interruptPin_b		=3D 8,=0A=
+	PCFG3C_interruptPin_m		=3D 0x0000ff00,=0A=
+	PCFG3C_minGrant_b		=3D 16,=0A=
+	PCFG3C_minGrant_m		=3D 0x00ff0000,=0A=
+	PCFG3C_maxLat_b 		=3D 24,=0A=
+	PCFG3C_maxLat_m 		=3D 0xff000000,=0A=
+=0A=
+	PCIPBAC_msi_b			=3D 0,=0A=
+	PCIPBAC_msi_m			=3D 0x00000001,=0A=
+	PCIPBAC_p_b			=3D 1,=0A=
+	PCIPBAC_p_m			=3D 0x00000002,=0A=
+	PCIPBAC_size_b			=3D 2,=0A=
+	PCIPBAC_size_m			=3D 0x0000007c,=0A=
+	PCIPBAC_sb_b			=3D 7,=0A=
+	PCIPBAC_sb_m			=3D 0x00000080,=0A=
+	PCIPBAC_pp_b			=3D 8,=0A=
+	PCIPBAC_pp_m			=3D 0x00000100,=0A=
+	PCIPBAC_mr_b			=3D 9,=0A=
+	PCIPBAC_mr_m			=3D 0x00000600,=0A=
+		PCIPBAC_mr_read_v	=3D0,	//no prefetching=0A=
+		PCIPBAC_mr_readLine_v	=3D1,=0A=
+		PCIPBAC_mr_readMult_v	=3D2,=0A=
+	PCIPBAC_mrl_b			=3D 11,=0A=
+	PCIPBAC_mrl_m			=3D 0x00000800,=0A=
+	PCIPBAC_mrm_b			=3D 12,=0A=
+	PCIPBAC_mrm_m			=3D 0x00001000,=0A=
+	PCIPBAC_trp_b			=3D 13,=0A=
+	PCIPBAC_trp_m			=3D 0x00002000,=0A=
+=0A=
+	PCFG40_trdyTimeout_b		=3D 0,=0A=
+	PCFG40_trdyTimeout_m		=3D 0x000000ff,=0A=
+	PCFG40_retryLim_b		=3D 8,=0A=
+	PCFG40_retryLim_m		=3D 0x0000ff00,=0A=
+};=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address [0|1|2|3] Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBA_baddr_b		=3D 0,		// In PCI_t -> pcilba [] .a=0A=
+	PCILBA_baddr_m		=3D 0xffffff00,=0A=
+} ;=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBAC_msi_b		=3D 0,		// In pPci->pcilba[i].c=0A=
+	PCILBAC_msi_m		=3D 0x00000001,=0A=
+		PCILBAC_msi_mem_v	=3D 0,=0A=
+		PCILBAC_msi_io_v	=3D 1,=0A=
+	PCILBAC_size_b		=3D 2,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_size_m		=3D 0x0000007c,=0A=
+	PCILBAC_sb_b		=3D 7,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_sb_m		=3D 0x00000080,=0A=
+	PCILBAC_rt_b		=3D 8,	// In pPci->pcilba[i].c=0A=
+	PCILBAC_rt_m		=3D 0x00000100,=0A=
+		PCILBAC_rt_noprefetch_v =3D 0, // mem read=0A=
+		PCILBAC_rt_prefetch_v	=3D 1, // mem readline=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Local Base Address [0|1|2|3] Mapping Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCILBAM_maddr_b 	=3D 8,=0A=
+	PCILBAM_maddr_m 	=3D 0xffffff00,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Decoupled Access Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDAC_den_b		=3D 0,=0A=
+	PCIDAC_den_m		=3D 0x00000001,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Decoupled Access Status Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDAS_d_b	=3D 0,=0A=
+	PCIDAS_d_m	=3D 0x00000001,=0A=
+	PCIDAS_b_b	=3D 1,=0A=
+	PCIDAS_b_m	=3D 0x00000002,=0A=
+	PCIDAS_e_b	=3D 2,=0A=
+	PCIDAS_e_m	=3D 0x00000004,=0A=
+	PCIDAS_ofe_b	=3D 3,=0A=
+	PCIDAS_ofe_m	=3D 0x00000008,=0A=
+	PCIDAS_off_b	=3D 4,=0A=
+	PCIDAS_off_m	=3D 0x00000010,=0A=
+	PCIDAS_ife_b	=3D 5,=0A=
+	PCIDAS_ife_m	=3D 0x00000020,=0A=
+	PCIDAS_iff_b	=3D 6,=0A=
+	PCIDAS_iff_m	=3D 0x00000040,=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI DMA Channel 8 Configuration Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIDMA8C_mbs_b	=3D 0,		// Maximum Burst Size.=0A=
+	PCIDMA8C_mbs_m	=3D 0x00000fff,	// { pcidma8c }=0A=
+	PCIDMA8C_our_b	=3D 12,		// Optimize Unaligned Burst Reads.=0A=
+	PCIDMA8C_our_m	=3D 0x00001000,	// { pcidma8c }=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI DMA Channel 9 Configuration Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIDMA9C_mbs_b	=3D 0,		// Maximum Burst Size.=0A=
+	PCIDMA9C_mbs_m	=3D 0x00000fff, // { pcidma9c }=0A=
+} ;=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI to Memory(DMA Channel 8) AND Memory to PCI DMA(DMA Channel =
9)Descriptors=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum {=0A=
+	PCIDMAD_pt_b		=3D 22,		// in DEVCMD field (descriptor)=0A=
+	PCIDMAD_pt_m		=3D 0x00c00000,	// preferred transaction field=0A=
+		// These are for reads (DMA channel 8)=0A=
+		PCIDMAD_devcmd_mr_v	=3D 0,	//memory read=0A=
+		PCIDMAD_devcmd_mrl_v	=3D 1,	//memory read line=0A=
+		PCIDMAD_devcmd_mrm_v	=3D 2,	//memory read multiple=0A=
+		PCIDMAD_devcmd_ior_v	=3D 3,	//I/O read=0A=
+		// These are for writes (DMA channel 9)=0A=
+		PCIDMAD_devcmd_mw_v	=3D 0,	//memory write=0A=
+		PCIDMAD_devcmd_mwi_v	=3D 1,	//memory write invalidate=0A=
+		PCIDMAD_devcmd_iow_v	=3D 3,	//I/O write=0A=
+=0A=
+	// Swap byte field applies to both DMA channel 8 and 9=0A=
+	PCIDMAD_sb_b		=3D 24,		// in DEVCMD field (descriptor)=0A=
+	PCIDMAD_sb_m		=3D 0x01000000,	// swap byte field=0A=
+} ;=0A=
+=0A=
+=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI Target Control Register=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCITC_rtimer_b		=3D 0,		// In PCITC_t -> pcitc=0A=
+	PCITC_rtimer_m		=3D 0x000000ff,=0A=
+	PCITC_dtimer_b		=3D 8,		// In PCITC_t -> pcitc=0A=
+	PCITC_dtimer_m		=3D 0x0000ff00,=0A=
+	PCITC_rdr_b		=3D 18,		// In PCITC_t -> pcitc=0A=
+	PCITC_rdr_m		=3D 0x00040000,=0A=
+	PCITC_ddt_b		=3D 19,		// In PCITC_t -> pcitc=0A=
+	PCITC_ddt_m		=3D 0x00080000,=0A=
+} ;=0A=
+/**********************************************************************=
*********=0A=
+ *=0A=
+ * PCI messaging unit [applies to both inbound and outbound registers =
]=0A=
+ *=0A=
+ =
************************************************************************=
******/=0A=
+enum=0A=
+{=0A=
+	PCIM_m0_b	=3D 0,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_m0_m	=3D 0x00000001,	// inbound or outbound message 0=0A=
+	PCIM_m1_b	=3D 1,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_m1_m	=3D 0x00000002,	// inbound or outbound message 1=0A=
+	PCIM_db_b	=3D 2,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}=0A=
+	PCIM_db_m	=3D 0x00000004,	// inbound or outbound doorbell=0A=
+};=0A=
+=0A=
diff -uNr =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_pci_v.h =
idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_pci_v.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_pci_v.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_pci_v.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,183 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   Definitions for IDT RC32438 PCI setup.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#define PCI_MSG_VirtualAddress	     0xB8088010=0A=
+#define rc32438_pci ((volatile PCI_t) PCI0_VirtualAddress)=0A=
+#define rc32438_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)=0A=
+=0A=
+#define PCIM_SHFT		0x6=0A=
+#define PCIM_BIT_LEN		0x7=0A=
+#define PCIM_H_EA		0x3=0A=
+#define PCIM_H_IA_FIX		0x4=0A=
+#define PCIM_H_IA_RR		0x5=0A=
+=0A=
+#define PCI_ADDR_START		0x50000000=0A=
+=0A=
+#define CPUTOPCI_MEM_WIN	0x02000000=0A=
+#define CPUTOPCI_IO_WIN		0x00100000=0A=
+#define PCILBA_SIZE_SHFT	2=0A=
+#define PCILBA_SIZE_MASK	0x1F=0A=
+#define SIZE_256MB		0x1C=0A=
+#define SIZE_128MB		0x1B=0A=
+#define SIZE_64MB               0x1A=0A=
+#define SIZE_32MB		0x19=0A=
+#define SIZE_16MB               0x18=0A=
+#define SIZE_4MB		0x16=0A=
+#define SIZE_2MB		0x15=0A=
+#define SIZE_1MB		0x14=0A=
+#define ACACIA_CONFIG0_ADDR	0x80000000=0A=
+#define ACACIA_CONFIG1_ADDR	0x80000004=0A=
+#define ACACIA_CONFIG2_ADDR	0x80000008=0A=
+#define ACACIA_CONFIG3_ADDR	0x8000000C=0A=
+#define ACACIA_CONFIG4_ADDR	0x80000010=0A=
+#define ACACIA_CONFIG5_ADDR	0x80000014=0A=
+#define ACACIA_CONFIG6_ADDR	0x80000018=0A=
+#define ACACIA_CONFIG7_ADDR	0x8000001C=0A=
+#define ACACIA_CONFIG8_ADDR	0x80000020=0A=
+#define ACACIA_CONFIG9_ADDR	0x80000024=0A=
+#define ACACIA_CONFIG10_ADDR	0x80000028=0A=
+#define ACACIA_CONFIG11_ADDR	0x8000002C=0A=
+#define ACACIA_CONFIG12_ADDR	0x80000030=0A=
+#define ACACIA_CONFIG13_ADDR	0x80000034=0A=
+#define ACACIA_CONFIG14_ADDR	0x80000038=0A=
+#define ACACIA_CONFIG15_ADDR	0x8000003C=0A=
+#define ACACIA_CONFIG16_ADDR	0x80000040=0A=
+#define ACACIA_CONFIG17_ADDR	0x80000044=0A=
+#define ACACIA_CONFIG18_ADDR	0x80000048=0A=
+#define ACACIA_CONFIG19_ADDR	0x8000004C=0A=
+#define ACACIA_CONFIG20_ADDR	0x80000050=0A=
+#define ACACIA_CONFIG21_ADDR	0x80000054=0A=
+#define ACACIA_CONFIG22_ADDR	0x80000058=0A=
+#define ACACIA_CONFIG23_ADDR	0x8000005C=0A=
+#define ACACIA_CONFIG24_ADDR	0x80000060=0A=
+#define ACACIA_CONFIG25_ADDR	0x80000064=0A=
+#define ACACIA_CMD 		(PCFG04_command_ioena_m | \=0A=
+				 PCFG04_command_memena_m | \=0A=
+				 PCFG04_command_bmena_m | \=0A=
+				 PCFG04_command_mwinv_m | \=0A=
+				 PCFG04_command_parena_m | \=0A=
+				 PCFG04_command_serrena_m )=0A=
+=0A=
+#define ACACIA_STAT		(PCFG04_status_mdpe_m | \=0A=
+				 PCFG04_status_sta_m  | \=0A=
+				 PCFG04_status_rta_m  | \=0A=
+				 PCFG04_status_rma_m  | \=0A=
+				 PCFG04_status_sse_m  | \=0A=
+				 PCFG04_status_pe_m)=0A=
+=0A=
+#define ACACIA_CNFG1		((ACACIA_STAT<<16)|ACACIA_CMD)=0A=
+=0A=
+#define ACACIA_REVID		0=0A=
+#define ACACIA_CLASS_CODE	0=0A=
+#define ACACIA_CNFG2		((ACACIA_CLASS_CODE<<8) | \=0A=
+				  ACACIA_REVID)=0A=
+=0A=
+#define ACACIA_CACHE_LINE_SIZE	4=0A=
+#define ACACIA_MASTER_LAT	0x3c=0A=
+#define ACACIA_HEADER_TYPE	0=0A=
+#define ACACIA_BIST		0=0A=
+=0A=
+#define ACACIA_CNFG3 ((ACACIA_BIST << 24) | \=0A=
+		      (ACACIA_HEADER_TYPE<<16) | \=0A=
+		      (ACACIA_MASTER_LAT<<8) | \=0A=
+		      ACACIA_CACHE_LINE_SIZE )=0A=
+=0A=
+#define ACACIA_BAR0	0x00000008 /* 128 MB Memory */=0A=
+#define ACACIA_BAR1	0x18800001 /* 1 MB IO */=0A=
+#define ACACIA_BAR2	0x18000001 /* 2 MB IO window for Acacia=0A=
+					internal Registers */=0A=
+#define ACACIA_BAR3	0x48000008 /* Spare 128 MB Memory */=0A=
+=0A=
+#define ACACIA_CNFG4	ACACIA_BAR0=0A=
+#define ACACIA_CNFG5    ACACIA_BAR1=0A=
+#define ACACIA_CNFG6 	ACACIA_BAR2=0A=
+#define ACACIA_CNFG7	ACACIA_BAR3=0A=
+=0A=
+#define ACACIA_SUBSYS_VENDOR_ID 0=0A=
+#define ACACIA_SUBSYSTEM_ID	0=0A=
+#define ACACIA_CNFG8		0=0A=
+#define ACACIA_CNFG9		0=0A=
+#define ACACIA_CNFG10		0=0A=
+#define ACACIA_CNFG11 	((ACACIA_SUBSYS_VENDOR_ID<<16) | \=0A=
+			  ACACIA_SUBSYSTEM_ID)=0A=
+#define ACACIA_INT_LINE		1=0A=
+#define ACACIA_INT_PIN		1=0A=
+#define ACACIA_MIN_GNT		8=0A=
+#define ACACIA_MAX_LAT		0x38=0A=
+#define ACACIA_CNFG12		0=0A=
+#define ACACIA_CNFG13 		0=0A=
+#define ACACIA_CNFG14		0=0A=
+#define ACACIA_CNFG15	((ACACIA_MAX_LAT<<24) | \=0A=
+			 (ACACIA_MIN_GNT<<16) | \=0A=
+			 (ACACIA_INT_PIN<<8)  | \=0A=
+			  ACACIA_INT_LINE)=0A=
+#define	ACACIA_RETRY_LIMIT	0x80=0A=
+#define ACACIA_TRDY_LIMIT	0x80=0A=
+#define ACACIA_CNFG16 ((ACACIA_RETRY_LIMIT<<8) | \=0A=
+			ACACIA_TRDY_LIMIT)=0A=
+#define PCI_PBAxC_R		0x0=0A=
+#define PCI_PBAxC_RL		0x1=0A=
+#define PCI_PBAxC_RM		0x2=0A=
+#define SIZE_SHFT		2=0A=
+=0A=
+#define ACACIA_PBA0C	( PCIPBAC_mrl_m | PCIPBAC_sb_m | \=0A=
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \=0A=
+			  PCIPBAC_pp_m | \=0A=
+			  (SIZE_128MB<<SIZE_SHFT) | \=0A=
+			   PCIPBAC_p_m)=0A=
+=0A=
+#define ACACIA_CNFG17	ACACIA_PBA0C=0A=
+#define ACACIA_PBA0M	0x0=0A=
+#define ACACIA_CNFG18	ACACIA_PBA0M=0A=
+=0A=
+#define ACACIA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | PCIPBAC_sb_m | \=0A=
+			  PCIPBAC_msi_m)=0A=
+=0A=
+#define ACACIA_CNFG19	ACACIA_PBA1C=0A=
+#define ACACIA_PBA1M	0x0=0A=
+#define ACACIA_CNFG20	ACACIA_PBA1M=0A=
+=0A=
+#define ACACIA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | PCIPBAC_sb_m | \=0A=
+			  PCIPBAC_msi_m)=0A=
+=0A=
+#define ACACIA_CNFG21	ACACIA_PBA2C=0A=
+#define ACACIA_PBA2M	0x18000000=0A=
+#define ACACIA_CNFG22	ACACIA_PBA2M=0A=
+#define ACACIA_PBA3C	0=0A=
+#define ACACIA_CNFG23	ACACIA_PBA3C=0A=
+#define ACACIA_PBA3M	0=0A=
+#define ACACIA_CNFG24	ACACIA_PBA3M=0A=
+=0A=
+=0A=
+=0A=
+#define	PCITC_DTIMER_VAL	8=0A=
+#define PCITC_RTIMER_VAL	0x10=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_t=
imer.h idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_timer.h=0A=
--- =
linux-2.6.16-rc5/include/asm-mips/idt-boards/rc32438/rc32438_timer.h	=
1969-12-31 16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/idt-boards/rc32438/rc32438_timer.h	=
2006-03-09 16:26:31.000000000 -0800=0A=
@@ -0,0 +1,83 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *    Timer register definition IDT RC32438 CPU.=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+ =0A=
+#ifndef __IDT_RC32438_TIM_H__=0A=
+#define __IDT_RC32438_TIM_H__=0A=
+=0A=
+enum=0A=
+{=0A=
+	TIM0_PhysicalAddress	=3D 0x18028000,=0A=
+	TIM_PhysicalAddress	=3D TIM0_PhysicalAddress,		// Default=0A=
+=0A=
+	TIM0_VirtualAddress	=3D 0xb8028000,=0A=
+	TIM_VirtualAddress	=3D TIM0_VirtualAddress,		// Default=0A=
+} ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	TIM_Count =3D 3,=0A=
+} ;=0A=
+=0A=
+struct TIM_CNTR_s=0A=
+{=0A=
+	u32 count ;=0A=
+	u32 compare ;=0A=
+	u32 ctc ;	//use CTC_=0A=
+} ;=0A=
+=0A=
+typedef struct TIM_s=0A=
+{=0A=
+	struct TIM_CNTR_s	tim [TIM_Count] ;=0A=
+	u32			rcount ;	//use RCOUNT_=0A=
+	u32			rcompare ;	//use RCOMPARE_=0A=
+	u32			rtc ;		//use RTC_=0A=
+} volatile * TIM_t ;=0A=
+=0A=
+enum=0A=
+{=0A=
+	CTC_en_b	=3D 0,		=0A=
+	CTC_en_m	=3D 0x00000001,=0A=
+	CTC_to_b	=3D 1,		 =0A=
+	CTC_to_m	=3D 0x00000002,=0A=
+=0A=
+	RCOUNT_count_b		=3D 0,	     =0A=
+	RCOUNT_count_m		=3D 0x0000ffff,=0A=
+	RCOMPARE_compare_b	=3D 0,	   =0A=
+	RCOMPARE_compare_m	=3D 0x0000ffff,=0A=
+	RTC_ce_b		=3D 0,		=0A=
+	RTC_ce_m		=3D 0x00000001,=0A=
+	RTC_to_b		=3D 1,		=0A=
+	RTC_to_m		=3D 0x00000002,=0A=
+	RTC_rqe_b		=3D 2,		=0A=
+	RTC_rqe_m		=3D 0x00000004,=0A=
+				 =0A=
+} ;=0A=
+#endif	//__IDT_RC32438_TIM_H__=0A=
+=0A=
diff -uNr linux-2.6.16-rc5/include/asm-mips/mach-idt/irq.h =
idtlinux/include/asm-mips/mach-idt/irq.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/mach-idt/irq.h	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/mach-idt/irq.h	2006-03-09 =
16:26:31.000000000 -0800=0A=
@@ -0,0 +1,60 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   NR_IRQS for IDT boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __ASM_MACH_IDT_IRQ_H__=0A=
+#define __ASM_MACH_IDT_IRQ_H__=0A=
+#include <linux/config.h>=0A=
+=0A=
+#ifdef CONFIG_IDT_EB365=0A=
+#include <asm/idt-boards/rc32300/rc32365.h>=0A=
+#define NR_IRQS RC32365_NR_IRQS=0A=
+#endif=0A=
+=0A=
+#ifdef CONFIG_IDT_EB434=0A=
+#include <asm/idt-boards/rc32434/rc32434.h>=0A=
+#define NR_IRQS RC32434_NR_IRQS=0A=
+#endif=0A=
+=0A=
+#ifdef CONFIG_IDT_EB438=0A=
+#include <asm/idt-boards/rc32438/rc32438.h>=0A=
+#define NR_IRQS RC32438_NR_IRQS=0A=
+#endif=0A=
+=0A=
+#ifdef CONFIG_IDT_S334=0A=
+#include <asm/idt-boards/rc32300/rc32334.h>=0A=
+#define NR_IRQS RC32334_NR_IRQS=0A=
+#endif=0A=
+=0A=
+#ifdef CONFIG_IDT_EB355=0A=
+#include <asm/idt-boards/rc32300/rc32355.h>=0A=
+#define NR_IRQS RC32355_NR_IRQS=0A=
+#endif=0A=
+=0A=
+#endif //__ASM_MACH_IDT_IRQ_H__=0A=
diff -uNr linux-2.6.16-rc5/include/asm-mips/mach-idt/param.h =
idtlinux/include/asm-mips/mach-idt/param.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/mach-idt/param.h	1969-12-31 =
16:00:00.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/mach-idt/param.h	2006-03-09 =
16:26:31.000000000 -0800=0A=
@@ -0,0 +1,41 @@=0A=
+/**********************************************************************=
****=0A=
+ *=0A=
+ *  BRIEF MODULE DESCRIPTION=0A=
+ *   HZ for IDT boards=0A=
+ *=0A=
+ *  Copyright 2006 IDT Inc. (rischelp@idt.com)=0A=
+ *         =0A=
+ *  This program is free software; you can redistribute  it and/or =
modify it=0A=
+ *  under  the terms of  the GNU General  Public License as published =
by the=0A=
+ *  Free Software Foundation;  either version 2 of the  License, or =
(at your=0A=
+ *  option) any later version.=0A=
+ *=0A=
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR =
IMPLIED=0A=
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED =
WARRANTIES OF=0A=
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE =
DISCLAIMED.  IN=0A=
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, =
INDIRECT,=0A=
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES =
(INCLUDING, BUT=0A=
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; =
LOSS OF=0A=
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED =
AND ON=0A=
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, =
OR TORT=0A=
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE =
USE OF=0A=
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH =
DAMAGE.=0A=
+ *=0A=
+ *  You should have received a copy of the  GNU General Public License =
along=0A=
+ *  with this program; if not, write  to the Free Software Foundation, =
Inc.,=0A=
+ *  675 Mass Ave, Cambridge, MA 02139, USA.=0A=
+ *=0A=
+ *=0A=
+ =
************************************************************************=
**=0A=
+ */=0A=
+=0A=
+#ifndef __ASM_MACH_IDT_PARAM_H=0A=
+#define __ASM_MACH_IDT_PARAM_H=0A=
+#include <linux/config.h>=0A=
+#ifdef CONFIG_IDT_EB438=0A=
+#define HZ		1000=0A=
+#else=0A=
+#define HZ		100=0A=
+#endif=0A=
+=0A=
+#endif /* __ASM_MACH_IDT_PARAM_H */=0A=
diff -uNr linux-2.6.16-rc5/include/asm-mips/module.h =
idtlinux/include/asm-mips/module.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/module.h	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/module.h	2006-03-09 16:26:31.000000000 =
-0800=0A=
@@ -113,6 +113,8 @@=0A=
 #define MODULE_PROC_FAMILY "RM9000 "=0A=
 #elif defined CONFIG_CPU_SB1=0A=
 #define MODULE_PROC_FAMILY "SB1 "=0A=
+#elif defined CONFIG_CPU_RC32300=0A=
+#define MODULE_PROC_FAMILY "R4X00"=0A=
 #else=0A=
 #error MODULE_PROC_FAMILY undefined for your processor =
configuration=0A=
 #endif=0A=
diff -uNr linux-2.6.16-rc5/include/asm-mips/serial.h =
idtlinux/include/asm-mips/serial.h=0A=
--- linux-2.6.16-rc5/include/asm-mips/serial.h	2006-02-27 =
02:56:56.000000000 -0800=0A=
+++ idtlinux/include/asm-mips/serial.h	2006-03-09 16:26:31.000000000 =
-0800=0A=
@@ -238,6 +238,14 @@=0A=
 #define IP32_SERIAL_PORT_DEFNS=0A=
 #endif /* CONFIG_SGI_IP32 */=0A=
 =0A=
+#if defined(CONFIG_IDT_EB438) || defined(CONFIG_IDT_EB365) || =
defined(CONFIG_IDT_EB434) || defined(CONFIG_IDT_S334) || =
defined(CONFIG_IDT_EB355)=0A=
+#define IDT_SERIAL_PORT_DEFNS \=0A=
+        {},{},=0A=
+#else=0A=
+#define IDT_SERIAL_PORT_DEFNS=0A=
+#endif=0A=
+=0A=
+=0A=
 #define SERIAL_PORT_DFNS				\=0A=
 	DDB5477_SERIAL_PORT_DEFNS			\=0A=
 	EV96100_SERIAL_PORT_DEFNS			\=0A=
diff -uNr linux-2.6.16-rc5/MAINTAINERS idtlinux/MAINTAINERS=0A=
--- linux-2.6.16-rc5/MAINTAINERS	2006-02-27 02:56:56.000000000 -0800=0A=
+++ idtlinux/MAINTAINERS	2006-03-09 16:26:34.000000000 -0800=0A=
@@ -1232,6 +1232,13 @@=0A=
 L:	linux-kernel@vger.kernel.org=0A=
 S:	Maintained=0A=
 =0A=
+IDT INTERPRISE INTEGRATED COMMUNICATION PROCESSOR SUPPORT=0A=
+P:      Rakesh Tiwari=0A=
+M:      rischelp@idt.com=0A=
+L:	rischelp@idt.com=0A=
+W:	http://www.idt.com/?catID=3D58532=0A=
+S:	Supported=0A=
+=0A=
 IDE/ATAPI TAPE DRIVERS=0A=
 P:	Gadi Oxman=0A=
 M:	Gadi Oxman <gadio@netvision.net.il>=0A=

------_=_NextPart_000_01C643DF.3058CF34--

Received: with ECARTIS (v1.0.0; list linux-mips); Wed, 29 Apr 2009 19:40:54 +0100 (BST)
Received: from n7b.bullet.mail.ac4.yahoo.com ([76.13.13.77]:26757 "HELO
	n7b.bullet.mail.ac4.yahoo.com" rhost-flags-OK-OK-OK-OK)
	by ftp.linux-mips.org with SMTP id S20024608AbZD2Skt (ORCPT
	<rfc822;linux-mips@linux-mips.org>); Wed, 29 Apr 2009 19:40:49 +0100
Received: from [76.13.13.26] by n7.bullet.mail.ac4.yahoo.com with NNFMP; 29 Apr 2009 18:40:41 -0000
Received: from [76.13.10.178] by t3.bullet.mail.ac4.yahoo.com with NNFMP; 29 Apr 2009 18:40:41 -0000
Received: from [127.0.0.1] by omp119.mail.ac4.yahoo.com with NNFMP; 29 Apr 2009 18:40:41 -0000
X-Yahoo-Newman-Property: ymail-3
X-Yahoo-Newman-Id: 192913.68843.bm@omp119.mail.ac4.yahoo.com
Received: (qmail 50303 invoked by uid 60001); 29 Apr 2009 18:40:39 -0000
DKIM-Signature:	v=1; a=rsa-sha256; c=relaxed/relaxed; d=yahoo.com; s=s1024; t=1241030439; bh=+qWMepY4CyuP1vP8upaMpR7DGXK7UGJ1yE4lwRzh7tE=; h=Message-ID:X-YMail-OSG:Received:X-Mailer:Date:From:Reply-To:Subject:To:MIME-Version:Content-Type; b=Nl4EYBK/yP25K0LDlLoJ5xqHLdeR9j2cNiZZRawH/kS/fE8mNM49lDccp9YLTVBNaj+mr2xAXIaLmDQRBNQiM3D0rC6zrmAaz0wY4/jft+c+OVWUPWu1lQhBcCka9Zoan5CG05ZT4sOIC0v/3XYE524f3VEiLH+OZ4gQPVVgdRw=
DomainKey-Signature: a=rsa-sha1; q=dns; c=nofws;
  s=s1024; d=yahoo.com;
  h=Message-ID:X-YMail-OSG:Received:X-Mailer:Date:From:Reply-To:Subject:To:MIME-Version:Content-Type;
  b=iIF0+6YhWU7id4PQoFbHsbcBTKbnkATaIoJsZdLTyTShPoGup6CEQSMIpbHsQlTo3RZFjhu1/Ws31895EKtllaPkg0pO5p+yZvhYXprWEnk+BneJvM2ex0y0Gv3BbqCeoFT0JvmLk38vne6ImxsID64+Jnr18+zSg/+yeNCMyoA=;
Message-ID: <607257.50141.qm@web59815.mail.ac4.yahoo.com>
X-YMail-OSG: GB9L12sVM1nsJ_HDm5ekc5bvPy4eDjKeUj7un8z_e4fffhhgNE28FlxvDnp1TUiKkOEG8j_dx5FMSl_SA1Hz0avToWi4fYcBB_sT3QaAKRIO.Z99._.B8ShPjWP6Di55ChCh3dEgrvLVGPscl_mZ4neJndo1iL4iUse.2C6xyYZJdU..ITOLJTwbP3yka.MeBWWbO6DUbZehzuA0ui63gd27edA7TGYyXGDb1ve_uNyQV_zXJrgQltwWfU3IDKR9rg86qEiEa2hOe8d.IHp287evsNmnETZtI.JHloRWBbNXPXqB04DhrWcN4LTdDmnIML2aMjUsUFiscKMljIGhTUCSBD2y4gGfDh7gCBx6yu_aiN6ARKhxuxeZ8vzo
Received: from [91.196.252.17] by web59815.mail.ac4.yahoo.com via HTTP; Wed, 29 Apr 2009 11:40:39 PDT
X-Mailer: YahooMailWebService/0.7.289.1
Date:	Wed, 29 Apr 2009 11:40:39 -0700 (PDT)
From:	Andrew Randrianasulu <randrik_a@yahoo.com>
Reply-To: randrik_a@yahoo.com
Subject: Re: SGI O2 gbe/crm patch
To:	linux-mips@linux-mips.org
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Return-Path: <randrik_a@yahoo.com>
X-Envelope-To: <"|/home/ecartis/ecartis -s linux-mips"> (uid 0)
X-Orcpt: rfc822;linux-mips@linux-mips.org
Original-Recipient: rfc822;linux-mips@linux-mips.org
X-archive-position: 22547
X-ecartis-version: Ecartis v1.0.0
Sender: linux-mips-bounce@linux-mips.org
Errors-to: linux-mips-bounce@linux-mips.org
X-original-sender: randrik_a@yahoo.com
Precedence: bulk
X-list: linux-mips



--- On Wed, 4/29/09, Andrew Randrianasulu <randrik_a@yahoo.com> wrote:

> From: Andrew Randrianasulu <randrik_a@yahoo.com>
> Subject: Re: SGI O2 gbe/crm patch
> To: "David Daney" <ddaney@caviumnetworks.com>
> Date: Wednesday, April 29, 2009, 6:21 PM
> --- On Wed, 4/29/09, David Daney
> <ddaney@caviumnetworks.com> wrote:
> 
> > From: David Daney <ddaney@caviumnetworks.com>
> > Subject: Re: SGI O2 gbe/crm patch
> > To: "Andrew Randrianasulu"
> <randrik_a@yahoo.com>
> > Cc: linux-mips@linux-mips.org
> > Date: Wednesday, April 29, 2009, 6:07 PM
> > Andrew Randrianasulu wrote:
> > 
> > [...]
> > >
> >
> ZGlmZiAtLWdpdCBhL2RyaXZlcnMvdmlkZW8vZ2JlZmIuYyBiL2RyaXZlcnMv
> > >
> >
> dmlkZW8vZ2JlZmIuYwppbmRleCBmZTViNTE5Li5lZDczMmE4IDEwMDY0NAot
> > >
> >
> LS0gYS9kcml2ZXJzL3ZpZGVvL2diZWZiLmMKKysrIGIvZHJpdmVycy92aWRl
> > [...]
> > 
> > I can't read that.
> > 
> > Please send patches as outlined here:
> >
> http://www.linux-mips.org/git?p=linux.git;a=blob;f=Documentation/SubmittingPatches;h=f309d3c6221c3699a0c0b97fbe689faed09e4d2f;hb=07057d15cd9cd1ccc8d1cafd286c871694d8483c
> > 
> Sorry ... same patch in plain text  (i hope)
> 

----------

diff --git a/drivers/video/gbefb.c b/drivers/video/gbefb.c
index fe5b519..ed732a8 100644
--- a/drivers/video/gbefb.c
+++ b/drivers/video/gbefb.c
@@ -193,7 +193,7 @@ static int flat_panel_enabled = 0;
 static void gbe_reset(void)
 {
 	/* Turn on dotclock PLL */
-	gbe->ctrlstat = 0x300aa000;
+	gbe->sgi_gbe_first.ctrlstat = 0x300aa000;
 }
 
 
@@ -213,7 +213,7 @@ void gbe_turn_off(void)
 	gbe_turned_on = 0;
 
 	/* check if pixel counter is on */
-	val = gbe->vt_xy;
+	val = gbe->sgi_gbe_vt.vt_xy;
 	if (GET_GBE_FIELD(VT_XY, FREEZE, val) == 1)
 		return;
 
@@ -254,11 +254,11 @@ void gbe_turn_off(void)
 		printk(KERN_ERR "gbefb: turn off DMA timed out\n");
 
 	/* wait for vpixen_off */
-	val = gbe->vt_vpixen;
+	val = gbe->sgi_gbe_vt.vt_vpixen;
 	vpixen_off = GET_GBE_FIELD(VT_VPIXEN, VPIXEN_OFF, val);
 
 	for (i = 0; i < 100000; i++) {
-		val = gbe->vt_xy;
+		val = gbe->sgi_gbe_vt.vt_xy;
 		x = GET_GBE_FIELD(VT_XY, X, val);
 		y = GET_GBE_FIELD(VT_XY, Y, val);
 		if (y < vpixen_off)
@@ -269,7 +269,7 @@ void gbe_turn_off(void)
 		printk(KERN_ERR
 		       "gbefb: wait for vpixen_off timed out\n");
 	for (i = 0; i < 10000; i++) {
-		val = gbe->vt_xy;
+		val = gbe->sgi_gbe_vt.vt_xy;
 		x = GET_GBE_FIELD(VT_XY, X, val);
 		y = GET_GBE_FIELD(VT_XY, Y, val);
 		if (y > vpixen_off)
@@ -282,10 +282,10 @@ void gbe_turn_off(void)
 	/* turn off pixel counter */
 	val = 0;
 	SET_GBE_FIELD(VT_XY, FREEZE, val, 1);
-	gbe->vt_xy = val;
+	gbe->sgi_gbe_vt.vt_xy = val;
 	udelay(10000);
 	for (i = 0; i < 10000; i++) {
-		val = gbe->vt_xy;
+		val = gbe->sgi_gbe_vt.vt_xy;
 		if (GET_GBE_FIELD(VT_XY, FREEZE, val) != 1)
 			udelay(10);
 		else
@@ -295,12 +295,12 @@ void gbe_turn_off(void)
 		printk(KERN_ERR "gbefb: turn off pixel clock timed out\n");
 
 	/* turn off dot clock */
-	val = gbe->dotclock;
+	val = gbe->sgi_gbe_first.dotclock;
 	SET_GBE_FIELD(DOTCLK, RUN, val, 0);
-	gbe->dotclock = val;
+	gbe->sgi_gbe_first.dotclock = val;
 	udelay(10000);
 	for (i = 0; i < 10000; i++) {
-		val = gbe->dotclock;
+		val = gbe->sgi_gbe_first.dotclock;
 		if (GET_GBE_FIELD(DOTCLK, RUN, val))
 			udelay(10);
 		else
@@ -326,18 +326,18 @@ static void gbe_turn_on(void)
 	 * code hangs Visual Workstations
 	 */
 	if (gbe_revision < 2) {
-		val = gbe->vt_xy;
+		val = gbe->sgi_gbe_vt.vt_xy;
 		if (GET_GBE_FIELD(VT_XY, FREEZE, val) == 0)
 			return;
 	}
 
 	/* turn on dot clock */
-	val = gbe->dotclock;
+	val = gbe->sgi_gbe_first.dotclock;
 	SET_GBE_FIELD(DOTCLK, RUN, val, 1);
-	gbe->dotclock = val;
+	gbe->sgi_gbe_first.dotclock = val;
 	udelay(10000);
 	for (i = 0; i < 10000; i++) {
-		val = gbe->dotclock;
+		val = gbe->sgi_gbe_first.dotclock;
 		if (GET_GBE_FIELD(DOTCLK, RUN, val) != 1)
 			udelay(10);
 		else
@@ -349,10 +349,10 @@ static void gbe_turn_on(void)
 	/* turn on pixel counter */
 	val = 0;
 	SET_GBE_FIELD(VT_XY, FREEZE, val, 0);
-	gbe->vt_xy = val;
+	gbe->sgi_gbe_vt.vt_xy = val;
 	udelay(10000);
 	for (i = 0; i < 10000; i++) {
-		val = gbe->vt_xy;
+		val = gbe->sgi_gbe_vt.vt_xy;
 		if (GET_GBE_FIELD(VT_XY, FREEZE, val))
 			udelay(10);
 		else
@@ -428,7 +428,7 @@ static void gbefb_setup_flatpanel(struct gbe_timing_info *timing)
 		(timing->flags & FB_SYNC_HOR_HIGH_ACT) ? 0 : 1);
 	SET_GBE_FIELD(VT_FLAGS, VDRV_INVERT, outputVal,
 		(timing->flags & FB_SYNC_VERT_HIGH_ACT) ? 0 : 1);
-	gbe->vt_flags = outputVal;
+	gbe->sgi_gbe_vt.vt_flags = outputVal;
 
 	/* Turn on the flat panel */
 	fp_wid = 1600;
@@ -442,14 +442,14 @@ static void gbefb_setup_flatpanel(struct gbe_timing_info *timing)
 	outputVal = 0;
 	SET_GBE_FIELD(FP_DE, ON, outputVal, fp_vbs);
 	SET_GBE_FIELD(FP_DE, OFF, outputVal, fp_vbe);
-	gbe->fp_de = outputVal;
+	gbe->sgi_gbe_vt.fp_de = outputVal;
 	outputVal = 0;
 	SET_GBE_FIELD(FP_HDRV, OFF, outputVal, fp_wid);
-	gbe->fp_hdrv = outputVal;
+	gbe->sgi_gbe_vt.fp_hdrv = outputVal;
 	outputVal = 0;
 	SET_GBE_FIELD(FP_VDRV, ON, outputVal, 1);
 	SET_GBE_FIELD(FP_VDRV, OFF, outputVal, fp_hgt + 1);
-	gbe->fp_vdrv = outputVal;
+	gbe->sgi_gbe_vt.fp_vdrv = outputVal;
 }
 
 struct gbe_pll_info {
@@ -550,44 +550,44 @@ static void gbe_set_timing_info(struct gbe_timing_info *timing)
 	SET_GBE_FIELD(DOTCLK, N, val, timing->pll_n - 1);
 	SET_GBE_FIELD(DOTCLK, P, val, timing->pll_p);
 	SET_GBE_FIELD(DOTCLK, RUN, val, 0);	/* do not start yet */
-	gbe->dotclock = val;
+	gbe->sgi_gbe_first.dotclock = val;
 	udelay(10000);
 
 	/* setup pixel counter */
 	val = 0;
 	SET_GBE_FIELD(VT_XYMAX, MAXX, val, timing->htotal);
 	SET_GBE_FIELD(VT_XYMAX, MAXY, val, timing->vtotal);
-	gbe->vt_xymax = val;
+	gbe->sgi_gbe_vt.vt_xymax = val;
 
 	/* setup video timing signals */
 	val = 0;
 	SET_GBE_FIELD(VT_VSYNC, VSYNC_ON, val, timing->vsync_start);
 	SET_GBE_FIELD(VT_VSYNC, VSYNC_OFF, val, timing->vsync_end);
-	gbe->vt_vsync = val;
+	gbe->sgi_gbe_vt.vt_vsync = val;
 	val = 0;
 	SET_GBE_FIELD(VT_HSYNC, HSYNC_ON, val, timing->hsync_start);
 	SET_GBE_FIELD(VT_HSYNC, HSYNC_OFF, val, timing->hsync_end);
-	gbe->vt_hsync = val;
+	gbe->sgi_gbe_vt.vt_hsync = val;
 	val = 0;
 	SET_GBE_FIELD(VT_VBLANK, VBLANK_ON, val, timing->vblank_start);
 	SET_GBE_FIELD(VT_VBLANK, VBLANK_OFF, val, timing->vblank_end);
-	gbe->vt_vblank = val;
+	gbe->sgi_gbe_vt.vt_vblank = val;
 	val = 0;
 	SET_GBE_FIELD(VT_HBLANK, HBLANK_ON, val,
 		      timing->hblank_start - 5);
 	SET_GBE_FIELD(VT_HBLANK, HBLANK_OFF, val,
 		      timing->hblank_end - 3);
-	gbe->vt_hblank = val;
+	gbe->sgi_gbe_vt.vt_hblank = val;
 
 	/* setup internal timing signals */
 	val = 0;
 	SET_GBE_FIELD(VT_VCMAP, VCMAP_ON, val, timing->vblank_start);
 	SET_GBE_FIELD(VT_VCMAP, VCMAP_OFF, val, timing->vblank_end);
-	gbe->vt_vcmap = val;
+	gbe->sgi_gbe_vt.vt_vcmap = val;
 	val = 0;
 	SET_GBE_FIELD(VT_HCMAP, HCMAP_ON, val, timing->hblank_start);
 	SET_GBE_FIELD(VT_HCMAP, HCMAP_OFF, val, timing->hblank_end);
-	gbe->vt_hcmap = val;
+	gbe->sgi_gbe_vt.vt_hcmap = val;
 
 	val = 0;
 	temp = timing->vblank_start - timing->vblank_end - 1;
@@ -631,17 +631,17 @@ static void gbe_set_timing_info(struct gbe_timing_info *timing)
 	SET_GBE_FIELD(VT_HPIXEN, HPIXEN_OFF, val,
 		      ((temp + timing->width -
 			GBE_PIXEN_MAGIC_OFF) % timing->htotal));
-	gbe->vt_hpixen = val;
+	gbe->sgi_gbe_vt.vt_hpixen = val;
 
 	val = 0;
 	SET_GBE_FIELD(VT_VPIXEN, VPIXEN_ON, val, timing->vblank_end);
 	SET_GBE_FIELD(VT_VPIXEN, VPIXEN_OFF, val, timing->vblank_start);
-	gbe->vt_vpixen = val;
+	gbe->sgi_gbe_vt.vt_vpixen = val;
 
 	/* turn off sync on green */
 	val = 0;
 	SET_GBE_FIELD(VT_FLAGS, SYNC_LOW, val, 1);
-	gbe->vt_flags = val;
+	gbe->sgi_gbe_vt.vt_flags = val;
 }
 
 /*
@@ -693,8 +693,8 @@ static int gbefb_set_par(struct fb_info *info)
 		gbe->mode_regs[i] = val;
 
 	/* Initialize interrupts */
-	gbe->vt_intr01 = 0xffffffff;
-	gbe->vt_intr23 = 0xffffffff;
+	gbe->sgi_gbe_vt.vt_intr01 = 0xffffffff;
+	gbe->sgi_gbe_vt.vt_intr23 = 0xffffffff;
 
 	/* HACK:
 	   The GBE hardware uses a tiled memory to screen mapping. Tiles are
@@ -1159,7 +1159,7 @@ static int __init gbefb_probe(struct platform_device *p_dev)
 		ret = -ENXIO;
 		goto out_release_mem_region;
 	}
-	gbe_revision = gbe->ctrlstat & 15;
+	gbe_revision = gbe->sgi_gbe_first.ctrlstat & 15;
 
 	gbe_tiles.cpu =
 		dma_alloc_coherent(NULL, GBE_TLB_SIZE * sizeof(uint16_t),
diff --git a/include/video/gbe.h b/include/video/gbe.h
index ad51028..a777aea 100644
--- a/include/video/gbe.h
+++ b/include/video/gbe.h
@@ -10,6 +10,7 @@
 #ifndef __GBE_H__
 #define __GBE_H__
 
+#if 0
 struct sgi_gbe {
 	volatile uint32_t ctrlstat;	/* general control */
 	volatile uint32_t dotclock;	/* dot clock PLL control */
@@ -80,6 +81,276 @@ struct sgi_gbe {
 	volatile uint32_t vc_8;	/* video capture crtl 8 */
 };
 
+#endif /* old struct */
+
+struct sgi_gbe_first {
+	volatile uint32_t ctrlstat;	/* general control */
+	volatile uint32_t dotclock;	/* dot clock PLL control */
+	volatile uint32_t i2c;		/* crt I2C control */
+	volatile uint32_t sysclk;	/* system clock PLL control */
+	volatile uint32_t i2cfp;	/* flat panel I2C control */
+	volatile uint32_t id;		/* device id/chip revision */
+	volatile uint32_t config;       /* power on configuration [1] */
+	volatile uint32_t bist;         /* internal bist status [1] */
+	uint32_t _pad0[0x000800/4 - 8];
+};
+
+struct sgi_crm_de {
+	volatile uint32_t crm_de_run;	/* OR this to a register address in 
+					 * order to start a command */
+	uint32_t _pad0[0x0017fc/4];
+	/* uint32_t _pad0[0x010000/4 - 8]; */
+	volatile uint32_t crm_mode_src;		/* DE src */
+	uint32_t _pad1[0x000004/4];
+	volatile uint32_t crm_mode_dst;		/* DE dst */
+	uint32_t _pad2[0x000004/4];
+	volatile uint32_t crm_clip_mode;	/* DE clipmode */
+	uint32_t _pad3[0x000004/4];
+	volatile uint32_t crm_draw_mode;	/* DE draw mode */
+	uint32_t _pad4[0x000004/4];
+	volatile uint32_t crm_src_mask0;	/* src mask 0 */
+	uint32_t _pad5[0x000004/4];
+	volatile uint32_t crm_src_mask1;	/* src mask 1 */
+	uint32_t _pad6[0x000004/4];
+	volatile uint32_t crm_src_mask2;	/* src mask 2 */
+	uint32_t _pad7[0x000004/4];
+	volatile uint32_t crm_src_mask3;	/* src mask 3 */
+	uint32_t _pad8[0x000004/4];
+	volatile uint32_t crm_src_mask4;	/* src mask 4 */
+	uint32_t _pad9[0x000004/4];
+	volatile uint32_t crm_de_scissor;	/* DE scissor reg */
+	uint32_t _pad10[0x000004/4];
+	volatile uint32_t crm_de_winoffset_src;	/* x in upper, y in lower 16 bit */
+	uint32_t _pad11[0x000004/4];
+	volatile uint32_t crm_de_winoffset_dst;	/* DE window offset destination */
+	uint32_t _pad12[0x000004/4];
+	volatile uint32_t crm_de_primitive;	/* DE primitive control reg */
+	uint32_t _pad13[0x00000c/4];
+	volatile uint32_t crm_de_x_vertex_0;	/* x vert 0 */
+	volatile uint32_t crm_de_x_vertex_1;	/* x vert 1 */
+	volatile uint32_t crm_de_x_vertex_2;	/* x vert 2 */
+	uint32_t _pad14[0x000004/4];
+	volatile uint32_t crm_de_gl_vertex_0_x;
+	volatile uint32_t crm_de_gl_vertex_0_y;
+	volatile uint32_t crm_de_gl_vertex_1_x;
+	volatile uint32_t crm_de_gl_vertex_1_y;
+	volatile uint32_t crm_de_gl_vertex_2_x;
+	volatile uint32_t crm_de_gl_vertex_2_y;
+	uint32_t _pad15[0x000008/4];
+	volatile uint32_t crm_de_xfer_addr_src;
+	volatile uint32_t crm_de_xfer_strd_src;
+	volatile uint32_t crm_de_xfer_step_x;
+	volatile uint32_t crm_de_xfer_step_y;
+	volatile uint32_t crm_de_xfer_addr_dst;
+	volatile uint32_t crm_de_xfer_strd_dst;
+	uint32_t _pad16[0x000008/4];
+	volatile uint32_t crm_de_stipple_mode;	/* DE stipple mode reg */
+	volatile uint32_t crm_de_stipple_pat;	/* DE stipple pattern */
+	uint32_t _pad17[0x000008/4];
+	volatile uint32_t crm_de_fg;
+	uint32_t _pad18[0x000004/4];
+	volatile uint32_t crm_de_bg;
+	uint32_t _pad19[0x000004/4];
+};
+
+struct sgi_crm_shading {
+	volatile uint32_t crm_de_shade_r0;	/* Shade reg, r0 */
+	volatile uint32_t crm_de_shade_g0;	/* Shade reg, g0 */
+	volatile uint32_t crm_de_shade_b0;	/* Shade reg, b0 */
+	volatile uint32_t crm_de_shade_a0;	/* Shade reg, a0 */
+	volatile uint32_t crm_de_shade_dr_dx;
+	volatile uint32_t crm_de_shade_dg_dx;
+	volatile uint32_t crm_de_shade_dr_dy;
+	volatile uint32_t crm_de_shade_dg_dy;
+	volatile uint32_t crm_de_shade_db_dx;
+	volatile uint32_t crm_de_shade_da_dx;
+	volatile uint32_t crm_de_shade_db_dy;
+	volatile uint32_t crm_de_shade_da_dy;
+};
+struct sgi_crm_texturing {
+	volatile uint32_t crm_de_texture_mode;	/* texture mode reg */
+	uint32_t _pad0[0x000004/4];
+	volatile uint32_t crm_de_texture_format;	/* texture format */
+	uint32_t _pad1[0x000004/4];
+	volatile uint32_t crm_de_texture_sq0;
+	uint32_t _pad2[0x000004/4];
+	volatile uint32_t crm_de_texture_tq0;
+	uint32_t _pad3[0x000004/4];
+	volatile uint32_t crm_de_texture_q0;
+	volatile uint32_t crm_de_texture_st_shift;
+	volatile uint32_t crm_de_texture_dsq_dx;
+	uint32_t _pad4[0x000004/4];
+	volatile uint32_t crm_de_texture_dsq_dy;
+	uint32_t _pad5[0x000004/4];
+	volatile uint32_t crm_de_texture_dtq_dx;
+	uint32_t _pad6[0x000004/4];
+	volatile uint32_t crm_de_texture_dtq_dy;
+	uint32_t _pad7[0x000004/4];
+	volatile uint32_t crm_de_texture_dq_dx;
+	volatile uint32_t crm_de_texture_dq_dy;
+	volatile uint32_t crm_de_texture_border_colour;
+	uint32_t _pad8[0x000004/4];
+	volatile uint32_t crm_de_texture_env_colour;
+	uint32_t _pad9[0x000004/4];
+};
+struct sgi_crm_fog {
+	volatile uint32_t crm_de_fog_colur;
+	uint32_t _pad0[0x000004/4];
+	volatile uint32_t crm_de_fog_f0;
+	uint32_t _pad1[0x000004/4];
+	volatile uint32_t crm_de_fog_df_dx;
+	uint32_t _pad2[0x000004/4];
+	volatile uint32_t crm_de_fog_df_dy;
+	uint32_t _pad3[0x000004/4];
+};
+struct sgi_crm_aa {
+	volatile uint32_t crm_de_aa_line;	/* aa reg */
+	volatile uint32_t crm_de_aa_cov;
+};
+
+struct sgi_crm_alpha {
+	volatile uint32_t crm_de_alpha_test;
+	uint32_t _pad0[0x000004/4];
+	volatile uint32_t crm_de_alpha_colour;	/* constant colour for alpha */
+	uint32_t _pad1[0x000004/4];
+	volatile uint32_t crm_de_alpha_func;	/* blend function */
+	uint32_t _pad2[0x000004/4];
+};
+struct sgi_crm_rop {
+	volatile uint32_t crm_de_rop;		/* raster op */
+	uint32_t _pad0[0x000004/4];
+	volatile uint32_t crm_de_plane_mask;
+	uint32_t _pad1[0x000004/4];
+};
+struct sgi_crm_depth_stencil {
+	volatile uint32_t crm_de_depth_func;
+	uint32_t _pad0[0x000004/4];
+	volatile uint32_t crm_de_depth_z0;
+	uint32_t _pad1[0x000004/4];
+	volatile uint32_t crm_de_depth_dz_dx;
+	uint32_t _pad2[0x000004/4];
+	volatile uint32_t crm_de_depth_dz_dy;
+	uint32_t _pad3[0x000004/4];
+	volatile uint32_t crm_de_stencil_mode;
+	uint32_t _pad4[0x000004/4];
+	volatile uint32_t crm_de_stencil_mask;
+	uint32_t _pad5[0x000004/4];
+	volatile uint32_t crm_de_null;
+	uint32_t _pad6[0x000004/4];
+	volatile uint32_t crm_de_flush;
+	uint32_t _pad7[0x000e04/4];
+};
+
+struct sgi_crm_mte {
+	volatile uint32_t crm_mte_mode;		/* MTE mode */
+	uint32_t _pad0[0x000004/4];
+	volatile uint32_t crm_mte_byte_mask;
+	uint32_t _pad1[0x000004/4];
+	volatile uint32_t crm_mte_stipple_mask;
+	uint32_t _pad2[0x000004/4];
+	volatile uint32_t crm_mte_bg;
+	uint32_t _pad3[0x000004/4];
+	volatile uint32_t crm_mte_src0;		/* start */
+	uint32_t _pad4[0x000004/4];
+	volatile uint32_t crm_mte_src1;		/* end */
+	uint32_t _pad5[0x000004/4];
+	volatile uint32_t crm_mte_dst0;		/* start */
+	uint32_t _pad6[0x000004/4];
+	volatile uint32_t crm_mte_dst1;		/* end */
+	uint32_t _pad7[0x000004/4];
+	volatile uint32_t crm_mte_src_y_step;
+	uint32_t _pad8[0x000004/4];
+	volatile uint32_t crm_mte_dst_y_step;
+	uint32_t _pad9[0x000024/4];
+	volatile uint32_t crm_mte_null;
+	uint32_t _pad10[0x000004/4];
+	volatile uint32_t crm_mte_flush;
+	uint32_t _pad11[0x000f84/4];
+	volatile uint32_t crm_de_status;
+	uint32_t _pad12[0x00bffc/4];	
+};
+
+struct sgi_gbe_vt {
+	volatile uint32_t vt_xy;	/* current dot coords */
+	volatile uint32_t vt_xymax;	/* maximum dot coords */
+	volatile uint32_t vt_vsync;	/* vsync on/off */
+	volatile uint32_t vt_hsync;	/* hsync on/off */
+	volatile uint32_t vt_vblank;	/* vblank on/off */
+	volatile uint32_t vt_hblank;	/* hblank on/off */
+	volatile uint32_t vt_flags;	/* polarity of vt signals */
+	volatile uint32_t vt_f2rf_lock;	/* f2rf & framelck y coord */
+	volatile uint32_t vt_intr01;	/* intr 0,1 y coords */
+	volatile uint32_t vt_intr23;	/* intr 2,3 y coords */
+	volatile uint32_t fp_hdrv;	/* flat panel hdrv on/off */
+	volatile uint32_t fp_vdrv;	/* flat panel vdrv on/off */
+	volatile uint32_t fp_de;	/* flat panel de on/off */
+	volatile uint32_t vt_hpixen;	/* intrnl horiz pixel on/off */
+	volatile uint32_t vt_vpixen;	/* intrnl vert pixel on/off */
+	volatile uint32_t vt_hcmap;	/* cmap write (horiz) */
+	volatile uint32_t vt_vcmap;	/* cmap write (vert) */
+};
+
+struct sgi_gbe_vc {
+	volatile uint32_t vc_0;	/* video capture crtl 0 */
+	volatile uint32_t vc_1;	/* video capture crtl 1 */
+	volatile uint32_t vc_2;	/* video capture crtl 2 */
+	volatile uint32_t vc_3;	/* video capture crtl 3 */
+	volatile uint32_t vc_4;	/* video capture crtl 4 */
+	volatile uint32_t vc_5;	/* video capture crtl 5 */
+	volatile uint32_t vc_6;	/* video capture crtl 6 */
+	volatile uint32_t vc_7;	/* video capture crtl 7 */
+	volatile uint32_t vc_8;	/* video capture crtl 8 */
+};
+
+struct sgi_gbe {
+	struct sgi_gbe_first sgi_gbe_first;
+	struct sgi_crm_de sgi_crm_de;
+	struct sgi_crm_shading sgi_crm_shading;
+	struct sgi_crm_texturing sgi_crm_texturing;
+	struct sgi_crm_fog sgi_crm_fog;
+	struct sgi_crm_aa sgi_crm_aa;
+	struct sgi_crm_alpha sgi_crm_alpha;
+	struct sgi_crm_rop sgi_crm_rop;
+	struct sgi_crm_depth_stencil sgi_crm_depth_stencil;
+	struct sgi_crm_mte sgi_crm_mte;
+	struct sgi_gbe_vt sgi_gbe_vt;
+	volatile uint32_t did_start_xy;	/* eol/f did/xy reset val */
+	volatile uint32_t crs_start_xy;	/* eol/f crs/xy reset val */
+	volatile uint32_t vc_start_xy;	/* eol/f vc/xy reset val */
+	uint32_t _pad0[0xffb0/4];
+	volatile uint32_t ovr_width_tile;/*overlay plane ctrl 0 */
+	volatile uint32_t ovr_inhwctrl;	/* overlay plane ctrl 1 */
+	volatile uint32_t ovr_control;	/* overlay plane ctrl 1 */
+	uint32_t _pad1[0xfff4/4];
+	volatile uint32_t frm_size_tile;/* normal plane ctrl 0 */
+	volatile uint32_t frm_size_pixel;/*normal plane ctrl 1 */
+	volatile uint32_t frm_inhwctrl;	/* normal plane ctrl 2 */
+	volatile uint32_t frm_control;	/* normal plane ctrl 3 */
+	uint32_t _pad2[0xfff0/4];
+	volatile uint32_t did_inhwctrl;	/* DID control */
+	volatile uint32_t did_control;	/* DID shadow */
+	uint32_t _pad3[0x7ff8/4];
+	volatile uint32_t mode_regs[32];/* WID table */
+	uint32_t _pad4[0x7f80/4];
+	volatile uint32_t cmap[6144];	/* color map */
+	uint32_t _pad5[0x2000/4];
+	volatile uint32_t cm_fifo;	/* color map fifo status */
+	uint32_t _pad6[0x7ffc/4];
+	volatile uint32_t gmap[256];	/* gamma map */
+	uint32_t _pad7[0x7c00/4];
+	volatile uint32_t gmap10[1024];	/* gamma map */
+	uint32_t _pad8[0x7000/4];
+	volatile uint32_t crs_pos;	/* cusror control 0 */
+	volatile uint32_t crs_ctl;	/* cusror control 1 */
+	volatile uint32_t crs_cmap[3];	/* crs cmap */
+	uint32_t _pad9[0x7fec/4];
+	volatile uint32_t crs_glyph[64];/* crs glyph */
+	uint32_t _pad10[0x7f00/4];
+	struct sgi_gbe_vc sgi_gbe_vc;
+};
+
+
+
 #define MASK(msb, lsb)		\
 	( (((u32)1<<((msb)-(lsb)+1))-1) << (lsb) )
 #define GET(v, msb, lsb)	\
---------------

Sorry, i send it directly (and only) to David first.


      

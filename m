Received: with ECARTIS (v1.0.0; list linux-mips); Fri, 15 Jan 2010 07:43:57 +0100 (CET)
Received: from cantor2.suse.de ([195.135.220.15]:59361 "EHLO mx2.suse.de"
        rhost-flags-OK-OK-OK-OK) by eddie.linux-mips.org with ESMTP
        id S1491141Ab0AOGnv (ORCPT <rfc822;linux-mips@linux-mips.org>);
        Fri, 15 Jan 2010 07:43:51 +0100
Received: from relay2.suse.de (charybdis-ext.suse.de [195.135.221.2])
        by mx2.suse.de (Postfix) with ESMTP id AA26379727;
        Fri, 15 Jan 2010 07:43:46 +0100 (CET)
Date:   Fri, 15 Jan 2010 07:43:45 +0100
Message-ID: <s5hvdf3lvfi.wl%tiwai@suse.de>
From:   Takashi Iwai <tiwai@suse.de>
To:     Benjamin Herrenschmidt <benh@kernel.crashing.org>
Cc:     Andreas Mohr <andi@lisas.de>, alsa-devel@alsa-project.org,
        Ralf Baechle <ralf@linux-mips.org>,
        Wu Zhangjin <wuzhangjin@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        linux-mips@linux-mips.org, Kumar Gala <galak@gate.crashing.org>,
        Becky Bruce <beckyb@kernel.crashing.org>
Subject: Re: [PATCH 0/5] PCM mmap (temporary) fixes for non-coherent architectures
In-Reply-To: <1263526082.724.395.camel@pasglop>
References: <1259248388-20095-1-git-send-email-tiwai@suse.de>
        <20100101193130.GA21510@rhlx01.hs-esslingen.de>
        <s5haawj7qlv.wl%tiwai@suse.de>
        <s5hljg24bl7.wl%tiwai@suse.de>
        <1263526082.724.395.camel@pasglop>
User-Agent: Wanderlust/2.15.6 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.7 Emacs/23.1
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
X-archive-position: 25592
X-ecartis-version: Ecartis v1.0.0
Sender: linux-mips-bounce@linux-mips.org
Errors-to: linux-mips-bounce@linux-mips.org
X-original-sender: tiwai@suse.de
Precedence: bulk
X-list: linux-mips
Return-Path: <linux-mips-bounce@linux-mips.org>
X-Keywords:                 
X-UID: 10012

At Fri, 15 Jan 2010 14:28:02 +1100,
Benjamin Herrenschmidt wrote:
> 
> 
> > A quick patch below (totally untested!) might do that.
> > It's passing the device struct blindly, so not sure whether this would
> > actually work for all dma_alloc_coherent().
> 
> On archs that have dma_ops such as powerpc (but I think x86 too
> nowadays) you cannot use the USB device for dma_* operations. You need
> to get up to the host controller device...

Yep, I don't think this being a proper fix, too.

> It -might- be worth looking at adding code to the USB stack to propagate
> the parent device dma_ops down to USB devices... hard to tell.

Or we may simply need to drop the mmap support on such architectures...


thanks,

Takashi

> 
> Cheers,
> Ben.
> 
> > 
> > Takashi
> > 
> > ---
> > diff --git a/sound/usb/usbaudio.c b/sound/usb/usbaudio.c
> > index 9edef46..6c82026 100644
> > --- a/sound/usb/usbaudio.c
> > +++ b/sound/usb/usbaudio.c
> > @@ -734,7 +734,7 @@ static void snd_complete_sync_urb(struct urb *urb)
> >  	}
> >  }
> >  
> > -
> > +#ifdef USBAUDIO_VMALLOC_BUFFER
> >  /* get the physical page pointer at the given offset */
> >  static struct page *snd_pcm_get_vmalloc_page(struct snd_pcm_substream *subs,
> >  					     unsigned long offset)
> > @@ -769,6 +769,24 @@ static int snd_pcm_free_vmalloc_buffer(struct snd_pcm_substream *subs)
> >  	return 0;
> >  }
> >  
> > +#define preallocate_buffer(chip, pcm, stream) /* NOP */
> > +
> > +#else
> > +#define snd_pcm_get_vmalloc_page	NULL
> > +#define snd_pcm_alloc_vmalloc_buffer	snd_pcm_lib_malloc_pages
> > +#define snd_pcm_free_vmalloc_buffer	snd_pcm_lib_free_pages
> > +
> > +static int preallocate_buffer(struct snd_usb_audio *chip, struct snd_pcm *pcm,
> > +			      int stream)
> > +{
> > +	struct snd_pcm_substream *subs = pcm->streams[stream].substream;
> > +	if (!subs)
> > +		return 0;
> > +	return snd_pcm_lib_preallocate_pages(subs, SNDRV_DMA_TYPE_DEV,
> > +					     chip->card->dev,
> > +					     1024 * 64, 1024 * 1024);
> > +}
> > +#endif
> >  
> >  /*
> >   * unlink active urbs.
> > @@ -2328,6 +2346,7 @@ static int add_audio_endpoint(struct snd_usb_audio *chip, int stream, struct aud
> >  		err = snd_pcm_new_stream(as->pcm, stream, 1);
> >  		if (err < 0)
> >  			return err;
> > +		preallocate_buffer(chip, as->pcm, stream);
> >  		init_substream(as, stream, fp);
> >  		return 0;
> >  	}
> > @@ -2356,6 +2375,7 @@ static int add_audio_endpoint(struct snd_usb_audio *chip, int stream, struct aud
> >  	else
> >  		strcpy(pcm->name, "USB Audio");
> >  
> > +	preallocate_buffer(chip, pcm, stream);
> >  	init_substream(as, stream, fp);
> >  
> >  	list_add(&as->list, &chip->pcm_list);
> 
> 
